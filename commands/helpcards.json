{
    "abs": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/abs\">abs</a></h1><p class=\"summary\">Returns the absolute value of the argument.</p><div class=\"usage\"><code>int abs(int n)</code></div><div class=\"usage\"><code>float abs(float n)</code></div><div class=\"usage\"><code>&lt;vector&gt; abs(&lt;vector&gt; v)</code></div><p>Returns the absolute (positive) equivalent of the number. For vectors, this is done per-component.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">if (abs(n) &gt; 1) {</code><code class=\"codeline\">        // n is greater than 1 or less than -1</code><code class=\"codeline\">    }</code></div><div class=\"codeblock\"><code class=\"codeline\">vector v = {1.0, -0.5, 1.1}</code><code class=\"codeline\">    if (abs(v) &gt; 1.0) {</code><code class=\"codeline\">        // vector is greater than unit scale</code><code class=\"codeline\">    }</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sign\">sign</a></div></body>",
    "abspath": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/abspath\">abspath</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the full path of a file.</p><div class=\"usage\"> <code>string abspath(string relpath)</code></div><p>Returns the supplied path converted to an absolute path. Relative paths\nare treated as relative to Houdini\u2019s current working directory. If the\nsupplied path is already absolute, the path is returned unchanged. The file\ndoes not need to exist.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/relpath\">relpath</a></div></body>",
    "accessframe": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/accessframe\">accessframe</a></h1><p class=\"summary\">Tells the COP manager that you need access to the given frame.</p><span class=\"padder\"><span class=\"pillow\">cop</span></span><div class=\"usage\"> <code>void accessframe(int frame)</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/nodes/cop2/tima\">cop2/tima</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/nodes/cop2/timefilter\">cop2/timefilter</a></div></body>",
    "acos": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/acos\">acos</a></h1><p class=\"summary\">Returns the inverse cosine of the argument.</p><div class=\"usage\"> <code>float acos(float v)</code></div><p>Returns the inverse cosine of <code>n</code>, where <code>n</code> is in radians. The return value is in the range 0 to \u03c0.</p><div class=\"usage\"> <code>vector2 acos(vector2 v)</code></div><div class=\"usage\"> <code>vector4 acos(vector4 v)</code></div><div class=\"usage\"> <code>vector acos(vector v)</code></div><p>Returns a new vector with <code>acos</code> applied to each component.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cos\">cos</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sin\">sin</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tan\">tan</a></div></body>",
    "addattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addattrib\">addattrib</a></h1><p class=\"summary\">Adds an attribute to a geometry.</p><p>If you know the class of attribute you want to add ahead of time, using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/adddetailattrib\">adddetailattrib</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addprimattrib\">addprimattrib</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addpointattrib\">addpointattrib</a>, or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addvertexattrib\">addvertexattrib</a> may be faster.</p><div class=\"usage\"> <code>int addattrib(int geohandle, string attribclass, string name, &lt;type&gt; defvalue)</code></div><div class=\"usage\"> <code>int addattrib(int geohandle, string attribclass, string name, &lt;type&gt; defvalue[])</code></div><div class=\"argument\"><code>name</code></div><p>The name of the attribute to create.</p><div class=\"argument\"><code>defvalue</code></div><p>The default value for the attribute and determines the type of attribute to create.  String and array attributes cannot have defaults, so only the type is used in those cases.</p><h2>Returns</h2><p><code>geohandle</code> on success, or <code>-1</code> on failure.</p><div class=\"related\">If an attribute of the same name already exists, the function will try to convert it to the new type.</div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/adddetailattrib\">adddetailattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addprimattrib\">addprimattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addpointattrib\">addpointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addvertexattrib\">addvertexattrib</a></div></body>",
    "addattribute": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addattribute\">addattribute</a></h1><span class=\"padder\"><span class=\"pillow\">sop</span></span><h2>Warning</h2><p>This function has been deprecated. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addattrib\">addattrib</a> or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setattrib\">setattrib</a> instead.</p></body>",
    "adddetailattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/adddetailattrib\">adddetailattrib</a></h1><p class=\"summary\">Adds a detail attribute to a geometry.</p><p>If you don\u2019t know the class of attribute until runtime, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addattrib\">addattrib</a>.</p><div class=\"usage\"> <code>int adddetailattrib(int geohandle, string name, &lt;type&gt; defvalue)</code></div><div class=\"usage\"> <code>int adddetailattrib(int geohandle, string name, &lt;type&gt; defvalue[])</code></div><p>Adds a detail attribute to the given geometry.</p><div class=\"usage\"> <code>int adddetailattrib(int geohandle, string name, &lt;type&gt; defvalue, string typeinfo)</code></div><div class=\"usage\"> <code>int adddetailattrib(int geohandle, string name, &lt;type&gt; defvalue[], string typeinfo)</code></div><p>Adds a detail attribute with the given transformation info. See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribtypeinfo\">attribtypeinfo</a> for more details.</p><div class=\"argument\"><code>name</code></div><p>The name of the attribute to create.</p><div class=\"argument\"><code>defvalue</code></div><p>The default value for the attribute and determines the type of attribute to create.  String and array attributes cannot have defaults, so only the type is used in those cases.</p><h2>Returns</h2><p><code>geohandle</code> on success, or <code>-1</code> on failure.</p><div class=\"related\">If an attribute of the same name already exists, the function will try to convert it to the new type.</div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addattrib\">addattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addprimattrib\">addprimattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addpointattrib\">addpointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addvertexattrib\">addvertexattrib</a></div></body>",
    "addgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addgroup\">addgroup</a></h1><span class=\"padder\"><span class=\"pillow\">sop</span></span><h2>Warning</h2><p>This function has been deprecated. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setattrib\">setattrib</a> instead.</p></body>",
    "addpoint": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addpoint\">addpoint</a></h1><p class=\"summary\">Adds a point to the geometry.</p><div class=\"usage\"> <code>int addpoint(int geohandle, int point_number)</code></div><p>Creates a new point with all the attributes and group memberships of the point with the given point number.</p><div class=\"usage\"> <code>int addpoint(int geohandle, vector pos)</code></div><p>Creates a new point with the given position.</p><h2>Returns</h2><p>A point number for the created point, or <code>-1</code> if the point could not be created.</p><p>You can use the return value with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointattrib\">setpointattrib</a> to set attributes on the new point, however it may not be the final number of the point.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addvertex\">addvertex</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addprim\">addprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepoint\">removepoint</a></div></body>",
    "addpointattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addpointattrib\">addpointattrib</a></h1><p class=\"summary\">Adds a point attribute to a geometry.</p><p>If you don\u2019t know the class of attribute until runtime, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addattrib\">addattrib</a>.</p><div class=\"usage\"> <code>int addpointattrib(int geohandle, string name, &lt;type&gt; defvalue)</code></div><div class=\"usage\"> <code>int addpointattrib(int geohandle, string name, &lt;type&gt; defvalue[])</code></div><p>Adds a point attribute to the given geometry.</p><div class=\"usage\"> <code>int addpointattrib(int geohandle, string name, &lt;type&gt; defvalue, string typeinfo)</code></div><div class=\"usage\"> <code>int addpointattrib(int geohandle, string name, &lt;type&gt; defvalue[], string typeinfo)</code></div><p>Adds a point attribute with the given transformation info. See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribtypeinfo\">attribtypeinfo</a> for more details.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addattrib\">addattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/adddetailattrib\">adddetailattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addprimattrib\">addprimattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addvertexattrib\">addvertexattrib</a></div></body>",
    "addprim": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addprim\">addprim</a></h1><p class=\"summary\">Adds a primitive to the geometry.</p><div class=\"usage\"> <code>int addprim(int geohandle, string type)</code></div><p>Create a polygon or polyline without any points. You can then add vertices to the primitive with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addvertex\">addvertex</a>.</p><p>Make sure to add at least one vertex to the created primitive. While we attempt to make sure Houdini\u2019s code can deal with empty polygons, it\u2019s possible they could cause strange results or failures.</p><div class=\"usage\"> <code>int addprim(int geohandle, string type, int pt0)</code></div><div class=\"usage\"> <code>int addprim(int geohandle, string type, int pt0, int pt1)</code></div><div class=\"usage\"> <code>int addprim(int geohandle, string type, int pt0, int pt1, int pt2)</code></div><div class=\"usage\"> <code>int addprim(int geohandle, string type, int pt0, int pt1, int pt2, int pt3)</code></div><div class=\"usage\"> <code>int addprim(int geohandle, string type, int pt0, int pt1, int pt2, int pt3, int pt4, int pt5, int pt6, int pt7)</code></div><p>Create a primitive using points specified by point numbers.</p><div class=\"usage\"> <code>int addprim(int geohandle, string type, int points[])</code></div><p>Create a primitive using points specified in an array of point numbers.</p><div class=\"usage\"> <code>void addprim(int &amp;prim_num, int geohandle, string type, int pt0, int &amp;vertices[])</code></div><div class=\"usage\"> <code>void addprim(int &amp;prim_num, int geohandle, string type, int pt0, int pt1, int &amp;vertices[])</code></div><div class=\"usage\"> <code>void addprim(int &amp;prim_num, int geohandle, string type, int pt0, int pt1, int pt2, int &amp;vertices[])</code></div><div class=\"usage\"> <code>void addprim(int &amp;prim_num, int geohandle, string type, int pt0, int pt1, int pt2, int pt3, int &amp;vertices[])</code></div><div class=\"usage\"> <code>void addprim(int &amp;prim_num, int geohandle, string type, int pt0, int pt1, int pt2, int pt3, int pt4, int pt5, int pt6, int pt7, int &amp;vertices[])</code></div><div class=\"usage\"> <code>void addprim(int &amp;prim_num, int geohandle, string type, int points[], int &amp;vertices[])</code></div><p>These signatures fill the given <code>vertices</code> array with the new primitive\u2019s vertex numbers corresponding to the given points. You can use these numbers with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setvertexattrib\">setvertexattrib</a> to set attributes on the vertices, however they may not be the final numbers of the vertices.</p><p>If the primitive was created, but any points were invalid, the corresponding vertex numbers in the array will be <code>-1</code>.</p><p>These signatures overwrite the <code>primnum</code> variable with the new primitive number instead of returning it.</p><div class=\"argument\"><code>type</code></div><p>One of the following strings:</p><span><code>\"poly\"</code> </span><p>Closed polygon. Can use 0 or more points.</p><span><code>\"polyline\"</code> </span><p>Open polygon. Can use 0 or more points.</p><span><code>\"tet\"</code> </span><p>Tetrahedron primitive.  A triangular pyramid.  Requires exactly 4 points.  You cannot add vertices to this primitive.</p><span>hex </span><p>Hexahedron primitive.  A distorted cube.  Requires eactly 8 points.  You cannot add vertices to this primitive.</p><span><code>\"sphere\"</code>, <code>\"circle\"</code>, <code>\"tube\"</code>, <code>\"metaball\"</code>, <code>\"metasquad\"</code> </span><p>Sphere, circle, tube, metaball, or metasuperquadric primitive.  The radius and shape are controled by transform primitive intrinsics.  Require exactly 1 point. You cannot add vertices to these primitives.</p><span><code>\"AlembicRef\"</code>, <code>\"PackedDisk\"</code> </span><p>Packed Alembic or packed disk primitive.  Require exactly 1 point. You cannot add vertices to these primitives.</p><h2>Returns</h2><p>A primitive number for the created primitive, or <code>-1</code> if the point could not be created.</p><p>You can use the return value with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setprimattrib\">setprimattrib</a> to set attributes on the new point, however it may not be the final number of the point.</p><p>You can set a primitive\u2019s transforms using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setprimintrinsic\">setprimintrinsic</a>, for example:</p><div class=\"codeblock\"><code class=\"codeline\">matrix3 transform_value = {{0, 0, 0}, {0, 0, 0}, {1, 1, 1}};</code><code class=\"codeline\">setprimintrinsic(geoself(), \"transform\", prim, transform_value);</code></div><p>You can also set Alembic and packed primitive intrinsics, for example:</p><div class=\"codeblock\"><code class=\"codeline\">setprimintrinsic(geoself(), \"unexpandedfilename\", prim, \"test.bgeo\");`</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addvertex\">addvertex</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addpoint\">addpoint</a></div></body>",
    "addprimattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addprimattrib\">addprimattrib</a></h1><p class=\"summary\">Adds a primitive attribute to a geometry.</p><p>If you don\u2019t know the class of attribute until runtime, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addattrib\">addattrib</a>.</p><div class=\"usage\"> <code>int addprimattrib(int geohandle, string name, &lt;type&gt; defvalue)</code></div><div class=\"usage\"> <code>int addprimattrib(int geohandle, string name, &lt;type&gt; defvalue[])</code></div><p>Adds a primitive attribute to the given geometry.</p><div class=\"usage\"> <code>int addprimattrib(int geohandle, string name, &lt;type&gt; defvalue, string typeinfo)</code></div><div class=\"usage\"> <code>int addprimattrib(int geohandle, string name, &lt;type&gt; defvalue[], string typeinfo)</code></div><p>Adds a primitive attribute with the given transformation info. See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribtypeinfo\">attribtypeinfo</a> for more details.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addattrib\">addattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/adddetailattrib\">adddetailattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addpointattrib\">addpointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addvertexattrib\">addvertexattrib</a></div></body>",
    "addvariablename": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addvariablename\">addvariablename</a></h1><p class=\"summary\">Adds a mapping for an attribute to a local variable.</p><div class=\"usage\"> <code>void addvariablename(string aname, string vname)</code></div><p>In contexts with current geometry, this adds a mapping to the geometry.</p><div class=\"usage\"> <code>int addvariablename(int geohandle, string aname, string vname)</code></div><p>Adds the mapping to the given geometry. Returns the <code>geohandle</code> on success.</p><p>Adds the mapping of the attribute <code>aname</code> to the local variable <code>vname</code>. In\nSOPs that support this, you will then have the\nlocal variable <code>$<code class=\"var\">vname</code></code> referencing the attribute <code class=\"var\">aname</code>. This\nemulates the behavior of the <a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/attribcreate\">AttribCreate SOP</a>.</p></body>",
    "addvertex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addvertex\">addvertex</a></h1><p class=\"summary\">Adds a vertex to a primitive in a geometry.</p><div class=\"usage\"> <code>int addvertex(int geohandle, int prim_num, int point_num)</code></div><div class=\"argument\"><code>prim_num</code></div><p>The primitive number to add the vertex to.</p><div class=\"argument\"><code>point_num</code></div><p>The point number to wire the new vertex to.</p><h2>Returns</h2><p>Returns a <em>linear</em> vertex index, or <code>-1</code> if the vertex could not be added. You can use this number with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setvertexattrib\">setvertexattrib</a> to set attributes on the new vertex, however this number may not be the final vertex index.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addprim\">addprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addpoint\">addpoint</a></div></body>",
    "addvertexattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addvertexattrib\">addvertexattrib</a></h1><p class=\"summary\">Adds a vertex attribute to a geometry.</p><p>If you don\u2019t know the class of attribute until runtime, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addattrib\">addattrib</a>.</p><div class=\"usage\"> <code>int addvertexattrib(int geohandle, string name, &lt;type&gt; defvalue)</code></div><div class=\"usage\"> <code>int addvertexattrib(int geohandle, string name, &lt;type&gt; defvalue[])</code></div><p>Adds a vertex attribute to the given geometry.</p><div class=\"usage\"> <code>int addvertexattrib(int geohandle, string name, &lt;type&gt; defvalue, string typeinfo)</code></div><div class=\"usage\"> <code>int addvertexattrib(int geohandle, string name, &lt;type&gt; defvalue[], string typeinfo)</code></div><p>Adds a vertex attribute with the given transformation info. See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribtypeinfo\">attribtypeinfo</a> for more details.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addattrib\">addattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/adddetailattrib\">adddetailattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addprimattrib\">addprimattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addpointattrib\">addpointattrib</a></div></body>",
    "addvisualizer": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addvisualizer\">addvisualizer</a></h1><p class=\"summary\">Appends to a geometry\u2019s visualizer detail attribute.</p><p>This function creates the <code>visualizer</code> detail string array attribute if it doesn\u2019t exist, then appends the given visualizer string to it. If the visualizer string already exists in the array, the function does not add it again.</p><div class=\"usage\"> <code>int addvisualizer(int geohandle, string op_url)</code></div><div class=\"argument\"><code>op_url</code></div><p>A string in the form<code>\"op:/path/to/node\"</code>. The geometry will use that node\u2019s visualizers.</p><div class=\"related\">Houdini looks up the visualizers by the <code>op:</code> reference, so changes to the visualizers on the referenced nodes will be reflected in the visualization of the geometry.</div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/adddetailattrib\">adddetailattrib</a></div></body>",
    "agentaddclip": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentaddclip\">agentaddclip</a></h1><p class=\"summary\">Add a clip into an agent\u2019s definition.</p><div class=\"usage\"> <code>int agentaddclip(int geohandle, int prim, string clipname, string clippath, int keepref)</code></div><p>This function adds a <code>.clip</code> or <code>.bclip</code> file saved from a CHOP (or generated\nby an <a href=\"https://www.sidefx.com/docs/houdini/nodes/out/agent\">out/agent</a> ROP) to the definition of the given agent primitive.\nClips in an agent definition contains transform animation for driving the\nagent\u2019s skeleton.</p><p>The channels within the clip should of the form <code>transform_name:channel_name</code>\nwhere _transform_name_ is a string matching the values returned by\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformnames\">agenttransformnames</a> and _channel_name_ is one of <code>tx</code>, <code>ty</code>, <code>tz</code>, <code>rx</code>,\n<code>ry</code>, <code>rz</code>, <code>sx</code>, <code>sy</code>, or <code>sz</code>. The channels starting with <code>t</code> denote\ntranslation, <code>r</code> denote rotation, and <code>s</code> denote scale. The resulting\ntransforms will be treated as <em>local</em> transforms, such as those returned by\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransform\">agentlocaltransform</a> (ie. they are relative to the corresponding parent\ntransform in the agent\u2019s skeleton).</p><div class=\"argument\"><code>prim</code></div><p>The primitive number of the agent primitive whose definition is to be\n    modified.</p><div class=\"argument\"><code>clipname</code></div><p>The name to identify the clip. All clips in an agent definition must have\n    unique names.</p><div class=\"argument\"><code>clippath</code></div><p>The filename of the <code>.clip</code> or <code>.bclip</code> file saved from a CHOP or generated\n    by the <a href=\"https://www.sidefx.com/docs/houdini/nodes/out/agent\">out/agent</a> ROP. Use <code>op:full_path_to_chop</code> to directly refer\n    to a CHOP in the scene.</p><div class=\"argument\"><code>keepref</code></div><p>When <code>clippath</code> refers to a filename on disk, this boolean flag indicates\n    whether the external reference should be maintained when the geometry will\n    be saved. If the reference is maintained, then the original source of the\n    clip needs to be available when the saved geometry is used. Otherwise, a\n    copy of the clip will be inlined when saving out the geometry so that the\n    original clip is no longer needed.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransform\">agentlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransforms\">agentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigparent\">agentrigparent</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformnames\">agenttransformnames</a></div></body>",
    "agentchannelcount": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelcount\">agentchannelcount</a></h1><p class=\"summary\">Returns the number of channels in an agent primitive\u2019s rig.</p><div class=\"usage\"> <code>int agentchannelcount(&lt;geometry&gt;, int prim)</code></div><p>Returns <code>-1</code> if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelvalue\">agentchannelvalue</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelvalues\">agentchannelvalues</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfindchannel\">agentrigfindchannel</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformcount\">agenttransformcount</a></div></body>",
    "agentchannelnames": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelnames\">agentchannelnames</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the names of the channels in an agent primitive\u2019s rig.</p><div class=\"usage\"> <code>string[] agentchannelnames(&lt;geometry&gt;, int prim)</code></div><p>Returns an empty array if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipchannel\">agentclipchannel</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelvalue\">agentchannelvalue</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelvalues\">agentchannelvalues</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfindchannel\">agentrigfindchannel</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentchannelvalue\">setagentchannelvalue</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentchannelvalues\">setagentchannelvalues</a></div></body>",
    "agentchannelvalue": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelvalue\">agentchannelvalue</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the current value of an agent primitive\u2019s channel.</p><div class=\"usage\"> <code>float agentchannelvalue(&lt;geometry&gt;, int prim, int channel)</code></div><p>Returns zero if <code>prim</code> is out of range, <code>prim</code> is not an agent primitive, or <code>channel</code> is out of range.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>channel</code></div><p>Index of a channel in the agent\u2019s rig.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipchannel\">agentclipchannel</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelnames\">agentchannelnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelvalues\">agentchannelvalues</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfindchannel\">agentrigfindchannel</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentchannelvalue\">setagentchannelvalue</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentchannelvalues\">setagentchannelvalues</a></div></body>",
    "agentchannelvalues": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelvalues\">agentchannelvalues</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the current values of an agent primitive\u2019s channels.</p><div class=\"usage\"> <code>float[] agentchannelvalues(&lt;geometry&gt;, int prim)</code></div><p>If only a single channel value is needed, using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelvalue\">agentchannelvalue</a> instead can be significantly faster.</p><p>Returns an empty array if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipchannel\">agentclipchannel</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelnames\">agentchannelnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelvalue\">agentchannelvalue</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfindchannel\">agentrigfindchannel</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentchannelvalue\">setagentchannelvalue</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentchannelvalues\">setagentchannelvalues</a></div></body>",
    "agentclipcatalog": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">agentclipcatalog</a></h1><p class=\"summary\">Returns all of the animation clips that have been loaded for an agent primitive.</p><div class=\"usage\"> <code>string[] agentclipcatalog(&lt;geometry&gt;, int prim)</code></div><p>Returns an empty array if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplength\">agentcliplength</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipnames\">agentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplelocal\">agentclipsamplelocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsampleworld\">agentclipsampleworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptimes\">agentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipweights\">agentclipweights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipnames\">setagentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcliptimes\">setagentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipweights\">setagentclipweights</a></div></body>",
    "agentclipchannel": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipchannel\">agentclipchannel</a></h1><p class=\"summary\">Finds the index of a channel in an agent\u2019s animation clip.</p><div class=\"usage\"> <code>int agentclipchannel(&lt;geometry&gt;, int prim, string clipname, string channel)</code></div><div class=\"usage\"> <code>int agentclipchannel(&lt;geometry&gt;, int prim, int clipindex, string channel)</code></div><p>Returns the index of a channel in the specified animation clip.\nReturns -1 if <code>clipname</code> is not one of the agent\u2019s <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">animation clips</a>,  <code>prim</code> is out of range, <code>prim</code> is not an agent primitive, or <code>channel</code> does not exist.</p><p>For sampling the clip\u2019s transform channels, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfind\">agentrigfind</a> and either <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplelocal\">agentclipsamplelocal</a> or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsampleworld\">agentclipsampleworld</a>.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>clipname</code></div><p>The name of the animation clip.</p><div class=\"argument\"><code>channel</code></div><p>Name of a channel in the animation clip.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">agentclipcatalog</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipnames\">agentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsample\">agentclipsample</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindclip\">agentfindclip</a></div></body>",
    "agentclipchannelnames": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipchannelnames\">agentclipchannelnames</a></h1><p class=\"summary\">Returns the names of the channels in an agent\u2019s animation clip.</p><div class=\"usage\"> <code>string[] agentclipchannelnames(&lt;geometry&gt;, int prim, string clipname)</code></div><div class=\"usage\"> <code>string[] agentclipchannelnames(&lt;geometry&gt;, int prim, int clipindex)</code></div><p>Returns an empty array if <code>clipname</code> is not one of the agent\u2019s <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">animation clips</a>,  <code>prim</code> is out of range, or <code>prim</code> is not an agent primitive.</p><p>For a list of the agent\u2019s transforms, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformnames\">agenttransformnames</a>.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>clipname</code></div><p>The name of the animation clip.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">agentclipcatalog</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipchannel\">agentclipchannel</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsample\">agentclipsample</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindclip\">agentfindclip</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformnames\">agenttransformnames</a></div></body>",
    "agentcliplayerblend": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplayerblend\">agentcliplayerblend</a></h1><p class=\"summary\">Blends values according to an agent\u2019s animation layers.</p><div class=\"usage\"> <code>float agentcliplayerblend(float values[], float value_weights[], int value_layer_ids[], int layer_blend_modes[], float layer_weights[], int layer_parent_ids[])</code></div><div class=\"usage\"> <code>matrix agentcliplayerblend(matrix values[], float value_weights[], int value_layer_ids[], int layer_blend_modes[], float layer_weights[], int layer_parent_ids[])</code></div><p>This function blends the input values according to the blend tree described by the other parameters (the same format used for <a href=\"https://www.sidefx.com/docs/houdini/crowds/agents#currentclips\">layering agent clips</a>).\nThis can be useful for blending custom values that correspond to each of an agent\u2019s assigned clips.</p><div class=\"argument\"><code>values</code></div><p>A list of the input values to blend.</p><div class=\"argument\"><code>value_weights</code></div><p>A list of blend weights for the input values.</p><div class=\"argument\"><code>value_layer_ids</code></div><p>A list containing the layer that each value is an input for.</p><div class=\"argument\"><code>layer_blend_modes</code></div><p>A list of blend modes for each layer. The available blend modes are defined in <code>$HH/vex/include/crowd_cliplayers.h</code>.</p><div class=\"argument\"><code>layer_weights</code></div><p>A list of blend weights for each layer. The blend weight is not used for the topmost layer.</p><div class=\"argument\"><code>layer_parent_ids</code></div><p>A list containing the parent layer for each layer (or -1 for the topmost layer). This specifies a tree of animation layers.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclips\">setagentclips</a></div></body>",
    "agentcliplength": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplength\">agentcliplength</a></h1><p class=\"summary\">Returns the length (in seconds) of an agent\u2019s animation clip.</p><div class=\"usage\"> <code>float agentcliplength(&lt;geometry&gt;, int prim, string clipname)</code></div><div class=\"usage\"> <code>float agentcliplength(&lt;geometry&gt;, int prim, int clipindex)</code></div><p>Returns <code>0</code> if <code>prim</code> is out of range or is not an agent primitive, or if <code>clipname</code> is not one of the agent\u2019s <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">animation clips</a>.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>clipname</code></div><p>The name of the animation clip.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">agentclipcatalog</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipnames\">agentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplelocal\">agentclipsamplelocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplerate\">agentclipsamplerate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsampleworld\">agentclipsampleworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipstarttime\">agentclipstarttime</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptimes\">agentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipweights\">agentclipweights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindclip\">agentfindclip</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipnames\">setagentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcliptimes\">setagentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipweights\">setagentclipweights</a></div></body>",
    "agentclipnames": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipnames\">agentclipnames</a></h1><p class=\"summary\">Returns an agent primitive\u2019s current animation clips.</p><div class=\"usage\"> <code>string[] agentclipnames(&lt;geometry&gt;, int prim)</code></div><p>Returns an empty array if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">agentclipcatalog</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplength\">agentcliplength</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplelocal\">agentclipsamplelocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsampleworld\">agentclipsampleworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptimes\">agentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipweights\">agentclipweights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransforms\">agentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipnames\">setagentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcliptimes\">setagentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipweights\">setagentclipweights</a></div></body>",
    "agentclipsample": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsample\">agentclipsample</a></h1><p class=\"summary\">Samples a channel of an agent\u2019s clip at a specific time.</p><div class=\"usage\"> <code>float agentclipsample(&lt;geometry&gt;, int prim, string clipname, float time, int channel_index)</code></div><div class=\"usage\"> <code>float agentclipsample(&lt;geometry&gt;, int prim, string clipname, float time, string channel)</code></div><div class=\"usage\"> <code>float agentclipsample(&lt;geometry&gt;, int prim, int clipindex, float time, int channel_index)</code></div><div class=\"usage\"> <code>float agentclipsample(&lt;geometry&gt;, int prim, int clipindex, float time, string channel)</code></div><p>Evaluates the clip at the given time and returns the value of the specified channel.\nReturns zero if <code>clipname</code> is not one of the agent\u2019s <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">animation clips</a>,  <code>prim</code> is out of range, <code>prim</code> is not an agent primitive, <code>channel_index</code> is out of range, or <code>channel</code> does not exist.</p><p>For sampling the clip\u2019s transform channels, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplelocal\">agentclipsamplelocal</a> or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsampleworld\">agentclipsampleworld</a> instead.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>clipname</code></div><p>The name of the animation clip.</p><div class=\"argument\"><code>time</code></div><p>The time (in seconds) to evaluate the clip at. If this time is greater than the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplength\">clip\u2019s length</a>, it will be wrapped around.</p><div class=\"argument\"><code>channel_index</code></div><p>Index of a channel in the animation clip, as returned by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipchannel\">agentclipchannel</a>.</p><div class=\"argument\"><code>channel</code></div><p>Name of a channel in the animation clip.</p><h2>Examples</h2><p>Sample a channel of the walk clip after 1.2 seconds.</p><div class=\"codeblock\"><code class=\"codeline\">float value = agentclipsample(0, @primnum, \"walk\", 1.2, \"latch_leftfoot\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">agentclipcatalog</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipchannel\">agentclipchannel</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipnames\">agentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplength\">agentcliplength</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplelocal\">agentclipsamplelocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplerate\">agentclipsamplerate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsampleworld\">agentclipsampleworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptimes\">agentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipweights\">agentclipweights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindclip\">agentfindclip</a></div></body>",
    "agentclipsamplelocal": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplelocal\">agentclipsamplelocal</a></h1><p class=\"summary\">Samples an agent\u2019s animation clip at a specific time.</p><div class=\"usage\"> <code>matrix[] agentclipsamplelocal(&lt;geometry&gt;, int prim, string clipname, float time)</code></div><div class=\"usage\"> <code>matrix[] agentclipsamplelocal(&lt;geometry&gt;, int prim, int clipindex, float time)</code></div><div class=\"usage\"> <code>matrix   agentclipsamplelocal(&lt;geometry&gt;, int prim, string clipname, float time, int transform)</code></div><div class=\"usage\"> <code>matrix   agentclipsamplelocal(&lt;geometry&gt;, int prim, int clipindex, float time, int transform)</code></div><p>Evaluates the clip at the given time and returns the local transforms of the agent\u2019s rig.\nReturns an empty array if <code>clipname</code> is not one of the agent\u2019s <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">animation clips</a>,  <code>prim</code> is out of range, <code>prim</code> is not an agent primitive, or <code>transform</code> is <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformcount\">out of range</a>.\nThe <code>matrix</code> signature is more efficient than the <code>matrix[]</code> signature for sampling a single transform.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>clipname</code></div><p>The name of the animation clip.</p><div class=\"argument\"><code>time</code></div><p>The time (in seconds) to evaluate the clip at. If this time is greater than the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplength\">clip\u2019s length</a>, it will be wrapped around.</p><div class=\"argument\"><code>transform</code></div><p>Index of a transform in the agent\u2019s rig.</p><h2>Examples</h2><p>Sample the local transforms of the walk clip after 1.2 seconds.</p><div class=\"codeblock\"><code class=\"codeline\">matrix xforms[] = agentclipsamplelocal(0, @primnum, \"agent1_clip.walk\", 1.2);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">agentclipcatalog</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipnames\">agentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplength\">agentcliplength</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsampleworld\">agentclipsampleworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptimes\">agentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipweights\">agentclipweights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindclip\">agentfindclip</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformcount\">agenttransformcount</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtoworld\">agenttransformtoworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipnames\">setagentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcliptimes\">setagentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipweights\">setagentclipweights</a></div></body>",
    "agentclipsamplerate": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplerate\">agentclipsamplerate</a></h1><p class=\"summary\">Returns the sample rate of an agent\u2019s animation clip.</p><div class=\"usage\"> <code>float agentclipsamplerate(&lt;geometry&gt;, int prim, string clipname)</code></div><div class=\"usage\"> <code>float agentclipsamplerate(&lt;geometry&gt;, int prim, int clipindex)</code></div><p>Returns <code>0</code> if <code>prim</code> is out of range or is not an agent primitive, or if <code>clipname</code> is not one of the agent\u2019s <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">animation clips</a>.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>clipname</code></div><p>The name of the animation clip.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">agentclipcatalog</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplength\">agentcliplength</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipnames\">agentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplelocal\">agentclipsamplelocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsampleworld\">agentclipsampleworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipstarttime\">agentclipstarttime</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptimes\">agentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipweights\">agentclipweights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindclip\">agentfindclip</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipnames\">setagentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcliptimes\">setagentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipweights\">setagentclipweights</a></div></body>",
    "agentclipsampleworld": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsampleworld\">agentclipsampleworld</a></h1><p class=\"summary\">Samples an agent\u2019s animation clip at a specific time.</p><div class=\"usage\"> <code>matrix[] agentclipsampleworld(&lt;geometry&gt;, int prim, string clipname, float time)</code></div><div class=\"usage\"> <code>matrix[] agentclipsampleworld(&lt;geometry&gt;, int prim, int clipindex, float time)</code></div><div class=\"usage\"> <code>matrix   agentclipsampleworld(&lt;geometry&gt;, int prim, string clipname, float time, int transform)</code></div><div class=\"usage\"> <code>matrix   agentclipsampleworld(&lt;geometry&gt;, int prim, int clipindex, float time, int transform)</code></div><p>Evaluates the clip at the given time and returns the world transforms of the agent\u2019s rig.\nReturns an empty array if <code>clipname</code> is not one of the agent\u2019s <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">animation clips</a>,  <code>prim</code> is out of range, <code>prim</code> is not an agent primitive, or <code>transform</code> is <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformcount\">out of range</a>.\nThe <code>matrix</code> signature is more efficient than the <code>matrix[]</code> signature for sampling a single transform.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>clipname</code></div><p>The name of the animation clip.</p><div class=\"argument\"><code>time</code></div><p>The time (in seconds) to evaluate the clip at. If this time is greater than the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplength\">clip\u2019s length</a>, it will be wrapped around.</p><div class=\"argument\"><code>transform</code></div><p>Index of a transform in the agent\u2019s rig.</p><h2>Examples</h2><p>Sample the world transforms of the walk clip after 1.2 seconds.</p><div class=\"codeblock\"><code class=\"codeline\">matrix xforms[] = agentclipsampleworld(0, @primnum, \"agent1_clip.walk\", 1.2);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">agentclipcatalog</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipnames\">agentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplength\">agentcliplength</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplelocal\">agentclipsamplelocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptimes\">agentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipweights\">agentclipweights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindclip\">agentfindclip</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformcount\">agenttransformcount</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtoworld\">agenttransformtoworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipnames\">setagentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcliptimes\">setagentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipweights\">setagentclipweights</a></div></body>",
    "agentclipstarttime": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipstarttime\">agentclipstarttime</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the start time (in seconds) of an agent\u2019s animation clip.</p><div class=\"usage\"> <code>float agentclipstarttime(&lt;geometry&gt;, int prim, string clipname)</code></div><div class=\"usage\"> <code>float agentclipstarttime(&lt;geometry&gt;, int prim, int clipindex)</code></div><p>Returns <code>0</code> if <code>prim</code> is out of range or is not an agent primitive, or if <code>clipname</code> is not one of the agent\u2019s <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">animation clips</a>.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>clipname</code></div><p>The name of the animation clip.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">agentclipcatalog</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplength\">agentcliplength</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipnames\">agentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplelocal\">agentclipsamplelocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplerate\">agentclipsamplerate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsampleworld\">agentclipsampleworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptimes\">agentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipweights\">agentclipweights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindclip\">agentfindclip</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipnames\">setagentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcliptimes\">setagentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipweights\">setagentclipweights</a></div></body>",
    "agentcliptimes": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptimes\">agentcliptimes</a></h1><p class=\"summary\">Returns the current times for an agent primitive\u2019s animation clips.</p><div class=\"usage\"> <code>float[] agentcliptimes(&lt;geometry&gt;, int prim)</code></div><p>Returns an empty array if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">agentclipcatalog</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplength\">agentcliplength</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipnames\">agentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplelocal\">agentclipsamplelocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsampleworld\">agentclipsampleworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipweights\">agentclipweights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipnames\">setagentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcliptimes\">setagentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipweights\">setagentclipweights</a></div></body>",
    "agentcliptransformgroups": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptransformgroups\">agentcliptransformgroups</a></h1><p class=\"summary\">Returns the transform groups for an agent primitive\u2019s current animation clips.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/crowds/agents#xformgroups\">Transform Groups</a> for more information.</p><div class=\"usage\"> <code>string[] agentcliptransformgroups(&lt;geometry&gt;, int prim)</code></div><p>Returns an empty array if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformgroupmember\">agenttransformgroupmember</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformgroups\">agenttransformgroups</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/hom/hou/AgentTransformGroup\">hou.AgentTransformGroup</a></div></body>",
    "agentclipweights": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipweights\">agentclipweights</a></h1><p class=\"summary\">Returns the blend weights for an agent primitive\u2019s animation clips.</p><div class=\"usage\"> <code>float[] agentclipweights(&lt;geometry&gt;, int prim)</code></div><p>Returns an empty array if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">agentclipcatalog</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplength\">agentcliplength</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipnames\">agentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplelocal\">agentclipsamplelocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsampleworld\">agentclipsampleworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptimes\">agentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipnames\">setagentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcliptimes\">setagentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipweights\">setagentclipweights</a></div></body>",
    "agentcollisionlayer": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcollisionlayer\">agentcollisionlayer</a></h1><p class=\"summary\">Returns the name of the collision layer of an agent primitive.</p><h2>Warning</h2><p>This function has been deprecated. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcollisionlayers\">agentcollisionlayers</a> instead.</p><div class=\"usage\"> <code>string agentcollisionlayer(&lt;geometry&gt;, int prim)</code></div><p>Returns an empty string if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcurrentlayer\">agentcurrentlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayerbindings\">agentlayerbindings</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayers\">agentlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayershapes\">agentlayershapes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcollisionlayer\">setagentcollisionlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcurrentlayer\">setagentcurrentlayer</a></div></body>",
    "agentcollisionlayers": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcollisionlayers\">agentcollisionlayers</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Returns the names of an agent primitive\u2019s collision layers.</p><div class=\"usage\"> <code>string[] agentcollisionlayers(&lt;geometry&gt;, int prim)</code></div><p>Returns an empty array if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcurrentlayers\">agentcurrentlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayerbindings\">agentlayerbindings</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayers\">agentlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayershapes\">agentlayershapes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcollisionlayers\">setagentcollisionlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcurrentlayers\">setagentcurrentlayers</a></div></body>",
    "agentcurrentlayer": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcurrentlayer\">agentcurrentlayer</a></h1><p class=\"summary\">Returns the name of the current layer of an agent primitive.</p><h2>Warning</h2><p>This function has been deprecated. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcurrentlayers\">agentcurrentlayers</a> instead.</p><div class=\"usage\"> <code>string agentcurrentlayer(&lt;geometry&gt;, int prim)</code></div><p>Returns an empty string if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcollisionlayer\">agentcollisionlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayerbindings\">agentlayerbindings</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayers\">agentlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayershapes\">agentlayershapes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcollisionlayer\">setagentcollisionlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcurrentlayer\">setagentcurrentlayer</a></div></body>",
    "agentcurrentlayers": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcurrentlayers\">agentcurrentlayers</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Returns the names of an agent primitive\u2019s current layers.</p><div class=\"usage\"> <code>string[] agentcurrentlayers(&lt;geometry&gt;, int prim)</code></div><p>Returns an empty array if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcollisionlayers\">agentcollisionlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayerbindings\">agentlayerbindings</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayers\">agentlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayershapes\">agentlayershapes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcollisionlayers\">setagentcollisionlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcurrentlayers\">setagentcurrentlayers</a></div></body>",
    "agentfindclip": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindclip\">agentfindclip</a></h1><p class=\"summary\">Finds the index of a clip in an agent\u2019s definition.</p><div class=\"usage\"> <code>int agentfindclip(&lt;geometry&gt;, int prim, string clipname)</code></div><p>Returns the index of a clip in the agent\u2019s definition.\nReturns -1 if <code>prim</code> is out of range, <code>prim</code> is not an agent primitive, or the clip does not exist.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>clipname</code></div><p>Name of a clip in the agent\u2019s definition.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">agentclipcatalog</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipchannel\">agentclipchannel</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipchannelnames\">agentclipchannelnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplength\">agentcliplength</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsample\">agentclipsample</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplelocal\">agentclipsamplelocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplerate\">agentclipsamplerate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsampleworld\">agentclipsampleworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipstarttime\">agentclipstarttime</a></div></body>",
    "agentfindlayer": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindlayer\">agentfindlayer</a></h1><p class=\"summary\">Finds the index of a layer in an agent\u2019s definition.</p><div class=\"usage\"> <code>int agentfindlayer(&lt;geometry&gt;, int prim, string layername)</code></div><p>Returns the index of a layer in the agent\u2019s definition.\nReturns -1 if <code>prim</code> is out of range, <code>prim</code> is not an agent primitive, or the layer does not exist.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>layername</code></div><p>Name of a layer in the agent\u2019s definition.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayerbindings\">agentlayerbindings</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayers\">agentlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayershapes\">agentlayershapes</a></div></body>",
    "agentfindtransformgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindtransformgroup\">agentfindtransformgroup</a></h1><p class=\"summary\">Finds the index of a transform group in an agent\u2019s definition.</p><div class=\"usage\"> <code>int agentfindtransformgroup(&lt;geometry&gt;, int prim, string transformgroup)</code></div><p>Returns the index of a transform group in the agent\u2019s definition.\nReturns -1 if <code>prim</code> is out of range, <code>prim</code> is not an agent primitive, or the transform group does not exist.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>transformgroup</code></div><p>Name of a transform group in the agent\u2019s definition.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformgroupmember\">agenttransformgroupmember</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformgroups\">agenttransformgroups</a></div></body>",
    "agentlayerbindings": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayerbindings\">agentlayerbindings</a></h1><p class=\"summary\">Returns the transform that each shape in an agent\u2019s layer is bound to.</p><div class=\"usage\"> <code>int[] agentlayerbindings(&lt;geometry&gt;, int prim, string layername, string shapetype)</code></div><div class=\"usage\"> <code>int[] agentlayerbindings(&lt;geometry&gt;, int prim, int layerindex, string shapetype)</code></div><p>Returns an empty array if <code>layername</code> is not one of the agent\u2019s <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayers\">layers</a>, <code>shapetype</code> is invalid, <code>prim</code> is out of range, or <code>prim</code> is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>layername</code></div><p>The name of one of the agent\u2019s layers.</p><div class=\"argument\"><code>layerindex</code></div><p>Index of a layer in the agent\u2019s definition.\n    A layer\u2019s index can be obtained via <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindlayer\">agentfindlayer</a>.</p><div class=\"argument\"><code>shapetype</code></div><p>Whether to inspect <code>\"static\"</code>, <code>\"deforming\"</code>, or <code>\"all\"</code> shapes from the specified layer.</p><h2>Examples</h2><p>Find the current world transform of each static shape in the collision layer.</p><div class=\"codeblock\"><code class=\"codeline\">string layer = agentcollisionlayer(0, @primnum);</code><code class=\"codeline\">int[] bindings = agentlayerbindings(0, @primnum, layer, \"static\");</code><code class=\"codeline\">matrix xforms[] = agentworldtransforms(0, @primnum);</code><code class=\"codeline\"></code><code class=\"codeline\">foreach (int idx; bindings) {</code><code class=\"codeline\">matrix xform = xforms[idx];</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcollisionlayer\">agentcollisionlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcurrentlayer\">agentcurrentlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindlayer\">agentfindlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayers\">agentlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayershapes\">agentlayershapes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcollisionlayer\">setagentcollisionlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcurrentlayer\">setagentcurrentlayer</a></div></body>",
    "agentlayers": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayers\">agentlayers</a></h1><p class=\"summary\">Returns all of the layers that have been loaded for an agent primitive.</p><div class=\"usage\"> <code>string[] agentlayers(&lt;geometry&gt;, int prim)</code></div><p>Returns an empty array if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcollisionlayer\">agentcollisionlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcurrentlayer\">agentcurrentlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayerbindings\">agentlayerbindings</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayershapes\">agentlayershapes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcollisionlayer\">setagentcollisionlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcurrentlayer\">setagentcurrentlayer</a></div></body>",
    "agentlayershapes": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayershapes\">agentlayershapes</a></h1><p class=\"summary\">Returns the names of the shapes referenced by an agent primitive\u2019s layer.</p><div class=\"usage\"> <code>string[] agentlayershapes(&lt;geometry&gt;, int prim, string layername, string shapetype)</code></div><div class=\"usage\"> <code>string[] agentlayershapes(&lt;geometry&gt;, int prim, int layerindex, string shapetype)</code></div><p>Returns the names of all shapes that are referenced by the layer and satisfy the <code>shapetype</code> filter.</p><div class=\"usage\"> <code>string[] agentlayershapes(&lt;geometry&gt;, int prim, string layername, int transform)</code></div><div class=\"usage\"> <code>string[] agentlayershapes(&lt;geometry&gt;, int prim, int layerindex, int transform)</code></div><p>Returns the names of all shapes that are referenced by the layer and are bound to the specified transform.</p><p>Returns an empty array if <code>layername</code> is not one of the agent\u2019s <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayers\">layers</a>, <code>shapetype</code> is invalid, <code>transform</code> is out of range, <code>prim</code> is out of range, or <code>prim</code> is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>layername</code></div><p>The name of one of the agent\u2019s layers.</p><div class=\"argument\"><code>layerindex</code></div><p>Index of a layer in the agent\u2019s definition.\n    A layer\u2019s index can be obtained via <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindlayer\">agentfindlayer</a>.</p><div class=\"argument\"><code>shapetype</code></div><p>Whether to inspect <code>\"static\"</code>, <code>\"deforming\"</code>, or <code>\"all\"</code> shapes from the specified layer.</p><div class=\"argument\"><code>transform</code></div><p>Index of a transform in the agent\u2019s rig.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcollisionlayer\">agentcollisionlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcurrentlayer\">agentcurrentlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindlayer\">agentfindlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayerbindings\">agentlayerbindings</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayers\">agentlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcollisionlayer\">setagentcollisionlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcurrentlayer\">setagentcurrentlayer</a></div></body>",
    "agentlocaltransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransform\">agentlocaltransform</a></h1><p class=\"summary\">Returns the current local space transform of an agent primitive\u2019s bone.</p><div class=\"usage\"> <code>matrix agentlocaltransform(&lt;geometry&gt;, int prim, int transform)</code></div><p>Returns an identity matrix if <code>transform</code> is <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformcount\">out of range</a>, <code>prim</code> is out of range, or <code>prim</code> is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>transform</code></div><p>Index of a transform in the agent\u2019s rig.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransforms\">agentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrestlocaltransform\">agentrestlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrestworldtransform\">agentrestworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtolocal\">agenttransformtolocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtoworld\">agenttransformtoworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransform\">agentworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransform\">setagentlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransforms\">setagentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransform\">setagentworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransforms\">setagentworldtransforms</a></div></body>",
    "agentlocaltransforms": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransforms\">agentlocaltransforms</a></h1><p class=\"summary\">Returns the current local space transforms of an agent primitive.</p><div class=\"usage\"> <code>matrix[] agentlocaltransforms(&lt;geometry&gt;, int prim)</code></div><p>If only a single transform is needed, using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransform\">agentlocaltransform</a> instead can be significantly faster.</p><p>Returns an empty array if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransform\">agentlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtolocal\">agenttransformtolocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtoworld\">agenttransformtoworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransform\">agentworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransform\">setagentlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransforms\">setagentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransform\">setagentworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransforms\">setagentworldtransforms</a></div></body>",
    "agentmetadata": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentmetadata\">agentmetadata</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Returns the agent definition\u2019s metadata dictionary.</p><div class=\"usage\"> <code>dict agentmetadata(&lt;geometry&gt;, int prim)</code></div><p>Returns the shared <a href=\"https://www.sidefx.com/docs/houdini/crowds/agents#metadata\">metadata dictionary</a> from the agent\u2019s definition.\nReturns an empty dictionary if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigchildren\">agentrigchildren</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfind\">agentrigfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigparent\">agentrigparent</a></div></body>",
    "agentrestlocaltransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrestlocaltransform\">agentrestlocaltransform</a></h1><p class=\"summary\">Returns the local space rest transform for an agent primitive\u2019s joint.</p><div class=\"usage\"> <code>matrix agentrestlocaltransform(&lt;geometry&gt;, int prim, int transform)</code></div><p>Returns an identity matrix if <code>transform</code> is <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformcount\">out of range</a>, <code>prim</code> is out of range, or <code>prim</code> is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>transform</code></div><p>Index of a transform in the agent\u2019s rig.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransforms\">agentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransform\">agentlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrestworldtransform\">agentrestworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtolocal\">agenttransformtolocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtoworld\">agenttransformtoworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransform\">agentworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransform\">setagentlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransforms\">setagentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransform\">setagentworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransforms\">setagentworldtransforms</a></div></body>",
    "agentrestworldtransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrestworldtransform\">agentrestworldtransform</a></h1><p class=\"summary\">Returns the world space rest transform for an agent primitive\u2019s joint.</p><div class=\"usage\"> <code>matrix agentrestworldtransform(&lt;geometry&gt;, int prim, int transform)</code></div><p>Returns an identity matrix if <code>transform</code> is <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformcount\">out of range</a>, <code>prim</code> is out of range, or <code>prim</code> is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>transform</code></div><p>Index of a transform in the agent\u2019s rig.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransforms\">agentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransform\">agentlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrestlocaltransform\">agentrestlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtolocal\">agenttransformtolocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtoworld\">agenttransformtoworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransform\">agentworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransform\">setagentlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransforms\">setagentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransform\">setagentworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransforms\">setagentworldtransforms</a></div></body>",
    "agentrigchildren": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigchildren\">agentrigchildren</a></h1><p class=\"summary\">Returns the child transforms of a transform in an agent primitive\u2019s rig.</p><div class=\"usage\"> <code>int[] agentrigchildren(&lt;geometry&gt;, int prim, int transform)</code></div><p>Returns a list of the direct children of the given transform.</p><p>Returns an empty array if <code>transform</code> is <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformcount\">out of range</a>, <code>prim</code> is out of range, or <code>prim</code> is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>transform</code></div><p>Index of a transform in the agent\u2019s rig.</p><h2>Examples</h2><p>Visit all of the children of a given transform.</p><div class=\"codeblock\"><code class=\"codeline\">int[] queue = { transform };</code><code class=\"codeline\"></code><code class=\"codeline\">while (len(queue) &gt; 0) {</code><code class=\"codeline\">int i = removeindex(queue, 0);</code><code class=\"codeline\">printf(\"%d\\n\", i);</code><code class=\"codeline\"></code><code class=\"codeline\">foreach (int child; agentrigchildren(0, @primnum, i))</code><code class=\"codeline\">push(queue, child);</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransforms\">agentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfind\">agentrigfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigparent\">agentrigparent</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformcount\">agenttransformcount</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtolocal\">agenttransformtolocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtoworld\">agenttransformtoworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></div></body>",
    "agentrigfind": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfind\">agentrigfind</a></h1><p class=\"summary\">Finds the index of a transform in an agent primitive\u2019s rig.</p><div class=\"usage\"> <code>int agentrigfind(&lt;geometry&gt;, int prim, string transformname)</code></div><p>Returns <code>-1</code> if <code>transformname</code> was not found in the rig, <code>prim</code> is out of range, or <code>prim</code> is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>transformname</code></div><p>The name of a transform in the agent\u2019s rig.</p><h2>Examples</h2><p>Find the current local transform of a given bone.</p><div class=\"codeblock\"><code class=\"codeline\">int idx = agentrigfind(0, @primnum, \"Hips\");</code><code class=\"codeline\">if (idx &gt;= 0) {</code><code class=\"codeline\">matrix local_xforms[] = agentlocaltransforms(0, @primnum);</code><code class=\"codeline\">matrix xform = local_xforms[idx];</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigchildren\">agentrigchildren</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigparent\">agentrigparent</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformcount\">agenttransformcount</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformnames\">agenttransformnames</a></div></body>",
    "agentrigfindchannel": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfindchannel\">agentrigfindchannel</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Finds the index of a channel in an agent primitive\u2019s rig.</p><div class=\"usage\"> <code>int agentrigfindchannel(&lt;geometry&gt;, int prim, string channelname)</code></div><p>Returns <code>-1</code> if <code>channelname</code> was not found in the rig, <code>prim</code> is out of range, or <code>prim</code> is not an agent primitive.\nThis index can be used to access an agent\u2019s current channel value using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelvalue\">agentchannelvalue</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentchannelvalue\">setagentchannelvalue</a>, or to sample the channel value from any clip using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsample\">agentclipsample</a>.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>channelname</code></div><p>The name of a channel in the agent\u2019s rig.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipchannel\">agentclipchannel</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelnames\">agentchannelnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelvalue\">agentchannelvalue</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelvalues\">agentchannelvalues</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentchannelvalue\">setagentchannelvalue</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentchannelvalues\">setagentchannelvalues</a></div></body>",
    "agentrigparent": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigparent\">agentrigparent</a></h1><p class=\"summary\">Returns the parent transform of a transform in an agent primitive\u2019s rig.</p><div class=\"usage\"> <code>int agentrigparent(&lt;geometry&gt;, int prim, int transform)</code></div><p>Returns <code>-1</code> if <code>transform</code> is a root of the transform hierarchy, <code>transform</code> is <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformcount\">out of range</a>, <code>prim</code> is out of range, or <code>prim</code> is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>transform</code></div><p>Index of a transform in the agent\u2019s rig.</p><h2>Examples</h2><p>Find the world transform of the rig\u2019s root, beginning from a given bone.</p><div class=\"codeblock\"><code class=\"codeline\">int root;</code><code class=\"codeline\">while (true) {</code><code class=\"codeline\">int parent = agentrigparent(0, @primnum, transform);</code><code class=\"codeline\"></code><code class=\"codeline\">if (parent &lt; 0)</code><code class=\"codeline\">{</code><code class=\"codeline\">root = transform;</code><code class=\"codeline\">break;</code><code class=\"codeline\">}</code><code class=\"codeline\">else</code><code class=\"codeline\">transform = parent;</code><code class=\"codeline\">}</code><code class=\"codeline\"></code><code class=\"codeline\">matrix root_xform = agentworldtransform(0, @primnum, root);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransform\">agentlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransforms\">agentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigchildren\">agentrigchildren</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfind\">agentrigfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformcount\">agenttransformcount</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtolocal\">agenttransformtolocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtoworld\">agenttransformtoworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransform\">agentworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></div></body>",
    "agentsolvefbik": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentsolvefbik\">agentsolvefbik</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Applies a full-body inverse kinematics algorithm to an agent\u2019s skeleton.</p><div class=\"usage\"> <code>int agentsolvefbik(&lt;geometry&gt;, int outgeo, int prim, int targets[], matrix targetxforms[], int xformgroup, int iters)</code></div><div class=\"usage\"> <code>int agentsolvefbik(&lt;geometry&gt;, int outgeo, int prim, int targets[], matrix targetxforms[], int xformgroup, int iters, float tolerance, int pinroot)</code></div><div class=\"usage\"> <code>int agentsolvefbik(&lt;geometry&gt;, int outgeo, int prim, int targets[], matrix targetxforms[], int xformgroup, int iters, float tolerance, int pinroot, float targetweights[], int targetpriorities[], int targetdepths[])</code></div><div class=\"usage\"> <code>int agentsolvefbik(&lt;geometry&gt;, int outgeo, int prim, int targets[], matrix targetxforms[], int xformgroup, int iters, float tolerance, int pinroot, float targetweights[], int targetpriorities[], int targetdepths[], int targettypes[], matrix targetoffsets[])</code></div><div class=\"usage\"> <code>int agentsolvefbik(&lt;geometry&gt;, int outgeo, int prim, int targets[], matrix targetxforms[], int xformgroup, int iters, float tolerance, int pinroot, float targetweights[], int targetpriorities[], int targetdepths[], string goalxformattrib, string constrainedxformattrib, string jointlimitsattrib)</code></div><div class=\"usage\"> <code>int agentsolvefbik(&lt;geometry&gt;, int outgeo, int prim, int targets[], matrix targetxforms[], int xformgroup, int iters, float tolerance, int pinroot, float targetweights[], int targetpriorities[], int targetdepths[], int targettypes[], matrix targetoffsets[], string goalxformattrib, string constrainedxformattrib, string jointlimitsattrib)</code></div><p>Returns <code>-1</code> if <code>prim</code> is out of range or is not an agent primitive, or targets and targetxforms are not the same length.</p><p>If agent_jointgoalxforms, agent_jointconstrainedxforms, and agent_jointlimits attributes are present on the agent, as produced by the <a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/agentconfigurejoints\">Agent Configure Joints SOP</a>, then they will be interpreted as joint limits to use while solving.</p><div class=\"argument\"><code>outgeo</code></div><p>Handle to the geometry to write to. <code>geoself()</code> can be used to get a handle to the current geometry.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number of the agent primitive.</p><div class=\"argument\"><code>targets</code></div><p>A list of the transform indexes of the end effectors in the agent.</p><div class=\"argument\"><code>targetxforms</code></div><p>A list of the target world transforms for the end effectors, in the same order as <code>targets</code>.</p><div class=\"argument\"><code>xformgroup</code></div><p>The index of a transform group, which specifies the joints to be used for the IK solver (all transforms not in the transform group will be ignored).\n    <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindtransformgroup\">agentfindtransformgroup</a> can be used to look up a transform group by name, and a value of -1 indicates that all the transforms in the agent should be included.\n    It\u2019s recommended to use a transform group that includes only transforms that correspond to the agent\u2019s bone structure.</p><div class=\"argument\"><code>iters</code></div><p>The maximum number of iterations to perform.\n    The solver may terminate early if the <code>tolerance</code> parameter is used.</p><div class=\"argument\"><code>tolerance</code></div><p>The tolerance to use when checking for convergence, defaults to 1e-5.\n    If positions converge to within this tolerance, the algorithm will stop.\n    If 0, the solver will always perform exactly <code>iters</code> iterations.</p><div class=\"argument\"><code>pinroot</code></div><p>Whether to pin the root to its start position, instead of allowing it to translate.\n    This can be useful when, for example, solving a subset of an agent\u2019s skeleton.\n    Defaults to 0 (off).</p><div class=\"argument\"><code>targetweights</code></div><p>A list containing the weight of each end effector, in the same order as <code>targets</code>.\n    For joints with multiple children, the normalized weights will be used to determine their position - this means that a target with a higher weight than other targets will be more likely to be reached.\n    The default weight is 1.0.</p><div class=\"argument\"><code>targetpriorities</code></div><p>A list containing the priority level of each end effector, in the same order as <code>targets</code>.\n    Targets from a lower priority level will not influence targets with higher priority.\n    For example, priority levels can be used to ensure that the targets for the feet are always satisfied, while still controlling the relative weights of the upper body targets.\n    The default priority is 0 (i.e. all targets are equal priority).</p><div class=\"argument\"><code>targetdepths</code></div><p>For each end effector, specifies how many joints above it in the chain can be adjusted to achieve the target transform.\n    A negative depth can be used to specify that all joints above the target are affected.\n    The default depth is -1.</p><div class=\"argument\"><code>targettypes</code></div><p>A list containing the target type for each end effector, in the same order as <code>targets</code>.\n    The target type can be used to specify how the end effector matches the position or orientation of its target transform (from <code>targetxforms</code>).\n    A value of <code>0</code> indicates a position-only target, <code>1</code> indicates an orientation-only target, and <code>2</code> matches both position and orientation (default).</p><div class=\"argument\"><code>targetoffsets</code></div><p>A list containing an additional local space transform for each end effector, in the same order as <code>targets</code>.\n    This transform is combined with the end effector\u2019s joint transform to produce the transform that the solver attempts to align with the target transform.\n    This can be used to place the target at an offset from the joint (for example, at the end of a bone).</p><div class=\"argument\"><code>goalxformattrib</code></div><p>An optional parameter specifying an alternative attribute to use instead of agent_jointgoalxforms.</p><div class=\"argument\"><code>constraintedxformattrib</code></div><p>An optional parameter specifying an alternative attribute to use instead of agent_jointconstrainedxforms.</p><div class=\"argument\"><code>jointlimitsattrib</code></div><p>An optional parameter specifying an alternative attribute to use instead of agent_jointlimits.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvefbik\">solvefbik</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransform\">agentworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfind\">agentrigfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigparent\">agentrigparent</a></div></body>",
    "agenttransformcount": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformcount\">agenttransformcount</a></h1><p class=\"summary\">Returns the number of transforms in an agent primitive\u2019s rig.</p><div class=\"usage\"> <code>int agenttransformcount(&lt;geometry&gt;, int prim)</code></div><p>Returns <code>-1</code> if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransforms\">agentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigchildren\">agentrigchildren</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfind\">agentrigfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigparent\">agentrigparent</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtolocal\">agenttransformtolocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtoworld\">agenttransformtoworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></div></body>",
    "agenttransformgroupmember": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformgroupmember\">agenttransformgroupmember</a></h1><p class=\"summary\">Returns whether a transform is a member of the specified transform group.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/crowds/agents#xformgroups\">Transform Groups</a> for more information.</p><div class=\"usage\"> <code>int agenttransformgroupmember(&lt;geometry&gt;, int prim, string transformgroup, int transform)</code></div><div class=\"usage\"> <code>int agenttransformgroupmember(&lt;geometry&gt;, int prim, int transformgroupidx, int transform)</code></div><p>Returns a non-zero value if the transform is a member of the specified transform group, and zero otherwise.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>transformgroup</code></div><p>Name of a transform group in the agent\u2019s definition.</p><div class=\"argument\"><code>transformgroupidx</code></div><p>Index of a transform group in the agent\u2019s definition.\n    A transform group\u2019s index can be obtained via <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindtransformgroup\">agentfindtransformgroup</a>.</p><div class=\"argument\"><code>transform</code></div><p>Index of a transform in the agent\u2019s rig.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptransformgroups\">agentcliptransformgroups</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindtransformgroup\">agentfindtransformgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfind\">agentrigfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformgroups\">agenttransformgroups</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformgroupmemberchannel\">agenttransformgroupmemberchannel</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/hom/hou/AgentTransformGroup\">hou.AgentTransformGroup</a></div></body>",
    "agenttransformgroupmemberchannel": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformgroupmemberchannel\">agenttransformgroupmemberchannel</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns whether a channel is a member of the specified transform group.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/crowds/agents#xformgroups\">Transform Groups</a> for more information.</p><div class=\"usage\"> <code>int agenttransformgroupmemberchannel(&lt;geometry&gt;, int prim, int transformgroupidx, int channel)</code></div><p>Returns a non-zero value if the channel is a member of the specified transform group, and zero otherwise.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>transformgroupidx</code></div><p>Index of a transform group in the agent\u2019s definition.\n    A transform group\u2019s index can be obtained via <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindtransformgroup\">agentfindtransformgroup</a>.</p><div class=\"argument\"><code>channel</code></div><p>Index of a channel in the agent\u2019s rig.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptransformgroups\">agentcliptransformgroups</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindtransformgroup\">agentfindtransformgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfind\">agentrigfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformgroups\">agenttransformgroups</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformgroupmember\">agenttransformgroupmember</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/hom/hou/AgentTransformGroup\">hou.AgentTransformGroup</a></div></body>",
    "agenttransformgroups": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformgroups\">agenttransformgroups</a></h1><p class=\"summary\">Returns the names of the transform groups in an agent\u2019s definition.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/crowds/agents#xformgroups\">Transform Groups</a> for more information.</p><div class=\"usage\"> <code>string[] agenttransformgroups(&lt;geometry&gt;, int prim)</code></div><p>Returns an empty array if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptransformgroups\">agentcliptransformgroups</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindtransformgroup\">agentfindtransformgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformgroupmember\">agenttransformgroupmember</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/hom/hou/AgentTransformGroup\">hou.AgentTransformGroup</a></div></body>",
    "agenttransformgroupweight": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformgroupweight\">agenttransformgroupweight</a></h1><p class=\"summary\">Returns the weight of a member of the specified transform group.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/crowds/agents#xformgroups\">Transform Groups</a> for more information.</p><div class=\"usage\"> <code>float agenttransformgroupweight(&lt;geometry&gt;, int prim, int transformgroup, int transform)</code></div><p>Returns the transform\u2019s weight if it is a member of the specified transform group, and zero otherwise.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>transformgroup</code></div><p>Index of a transform group in the agent\u2019s definition.\n    A transform group\u2019s index can be obtained via <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindtransformgroup\">agentfindtransformgroup</a>.</p><div class=\"argument\"><code>transform</code></div><p>Index of a transform in the agent\u2019s rig.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptransformgroups\">agentcliptransformgroups</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindtransformgroup\">agentfindtransformgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfind\">agentrigfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformgroups\">agenttransformgroups</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/hom/hou/AgentTransformGroup\">hou.AgentTransformGroup</a></div></body>",
    "agenttransformnames": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformnames\">agenttransformnames</a></h1><p class=\"summary\">Returns the name of each transform in an agent primitive\u2019s rig.</p><div class=\"usage\"> <code>string[] agenttransformnames(&lt;geometry&gt;, int prim)</code></div><p>Returns an empty array if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfind\">agentrigfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformcount\">agenttransformcount</a></div></body>",
    "agenttransformtolocal": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtolocal\">agenttransformtolocal</a></h1><p class=\"summary\">Converts transforms from world space to local space for an agent primitive.</p><div class=\"usage\"> <code>int agenttransformtolocal(&lt;geometry&gt;, int prim, matrix &amp;transforms[])</code></div><p>Returns <code>-1</code> if <code>len(transforms)</code> does not match the number of transforms in the agent\u2019s rig, <code>prim</code> is out of range, or <code>prim</code> is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>transforms</code></div><p>The transforms to convert from world space to local space.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransforms\">agentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtoworld\">agenttransformtoworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransforms\">setagentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransforms\">setagentworldtransforms</a></div></body>",
    "agenttransformtoworld": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtoworld\">agenttransformtoworld</a></h1><p class=\"summary\">Converts transforms from local space to world space for an agent primitive.</p><div class=\"usage\"> <code>int agenttransformtoworld(&lt;geometry&gt;, int prim, matrix &amp;transforms[])</code></div><p>Returns <code>-1</code> if <code>len(transforms)</code> does not match the number of transforms in the agent\u2019s rig, <code>prim</code> is out of range, or <code>prim</code> is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>transforms</code></div><p>The transforms to convert from local space to world space.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransforms\">agentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtolocal\">agenttransformtolocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransforms\">setagentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransforms\">setagentworldtransforms</a></div></body>",
    "agentworldtransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransform\">agentworldtransform</a></h1><p class=\"summary\">Returns the current world space transform of an agent primitive\u2019s bone.</p><div class=\"usage\"> <code>matrix agentworldtransform(&lt;geometry&gt;, int prim, int transform)</code></div><p>Returns an identity matrix if <code>transform</code> is <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformcount\">out of range</a>, <code>prim</code> is out of range, or <code>prim</code> is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>transform</code></div><p>Index of a transform in the agent\u2019s rig.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransform\">agentlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransforms\">agentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrestlocaltransform\">agentrestlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrestworldtransform\">agentrestworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtolocal\">agenttransformtolocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtoworld\">agenttransformtoworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransform\">setagentlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransforms\">setagentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransform\">setagentworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransforms\">setagentworldtransforms</a></div></body>",
    "agentworldtransforms": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></h1><p class=\"summary\">Returns the current world space transforms of an agent primitive.</p><div class=\"usage\"> <code>matrix[] agentworldtransforms(&lt;geometry&gt;, int prim)</code></div><p>If only a single transform is needed, using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransform\">agentworldtransform</a> instead can be significantly faster.</p><p>Returns an empty array if <code>prim</code> is out of range or is not an agent primitive.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransform\">agentlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransforms\">agentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtolocal\">agenttransformtolocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtoworld\">agenttransformtoworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransform\">agentworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransform\">setagentlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransforms\">setagentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransform\">setagentworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransforms\">setagentworldtransforms</a></div></body>",
    "albedo": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/albedo\">albedo</a></h1><p class=\"summary\">Returns the albedo (percentage of reflected light) for a bsdf given the outgoing light direction.</p><div class=\"usage\"> <code>vector albedo(bsdf b, ...)</code></div><div class=\"usage\"> <code>vector albedo(bsdf b, int mask, ...)</code></div><div class=\"usage\"> <code>vector albedo(bsdf b, vector viewer, ...)</code></div><div class=\"usage\"> <code>vector albedo(bsdf b, vector viewer, int mask, ...)</code></div><div class=\"argument\"><code>viewer</code></div><p>Vector toward viewer.</p><div class=\"argument\"><code>mask</code></div><p>A bitmask composed from values representing different shading components.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/bouncemask\">bouncemask</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/eval_bsdf\">eval_bsdf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_bsdf\">sample_bsdf</a></div></body>",
    "alphaname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/alphaname\">alphaname</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the default name of the alpha plane (as it appears in the\ncompositor preferences).</p><div class=\"usage\"> <code>string alphaname()</code></div><p>Returns the default name of the alpha plane (as it appears in the\ncompositor preferences). Using this instead of hardcoding the default\nmakes your code more portable. Default is A.</p></body>",
    "ambient": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ambient\">ambient</a></h1><span class=\"padder\"><span class=\"pillow\">displace</span></span><span class=\"padder\"><span class=\"pillow\">fog</span></span><span class=\"padder\"><span class=\"pillow\">surface</span></span><p class=\"summary\">Returns the color of ambient light in the scene.</p><div class=\"usage\"> <code>vector ambient( ... )</code></div><p>Returns the color of ambient light in the scene.</p></body>",
    "anoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/anoise\">anoise</a></h1><p class=\"summary\">Generates alligator noise.</p><div class=\"usage\"> <code>float anoise(vector pos)</code></div><div class=\"usage\"> <code>vector anoise(vector pos)</code></div><div class=\"usage\"> <code>float anoise(vector pos, int turbulence, float rough, float atten)</code></div><div class=\"usage\"> <code>vector anoise(vector pos, int turbulence, float rough, float atten)</code></div><div class=\"usage\"> <code>float anoise(vector pos, int periodX, int periodY, int periodZ)</code></div><div class=\"usage\"> <code>vector anoise(vector pos, int periodX, int periodY, int periodZ)</code></div><div class=\"usage\"> <code>float anoise(vector pos, int periodX, int periodY, int periodZ, int turbulence, float rough, float atten)</code></div><div class=\"usage\"> <code>vector anoise(vector pos, int periodX, int periodY, int periodZ, int turbulence, float rough, float atten)</code></div><p>These functions generate alligator noise, a type of cellular noise similar to\nWorley noise (<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wnoise\">wnoise</a>). It is currently not possible to simulate alligator noise\nusing the Worley functions, but it\u2019s possible to get a very similar look.</p><p>The bounds on the noise are roughly (0, 1). This function only supports 3D noise.</p><h2>Related</h2></body>",
    "append": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/append\">append</a></h1><p class=\"summary\">Adds an item to an array or string.</p><div class=\"usage\"> <code>void append(string &amp;array; string value)</code></div><p>Appends the second string to the first.</p><div class=\"usage\"> <code>void append(&lt;type&gt; &amp;array[]; &lt;type&gt; value)</code></div><p>Appends the given value to the end of the array. Increases the size of <code>array</code> by 1. This is the same as <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/push\">push(array, value)</a>.</p><div class=\"usage\"> <code>void append(&lt;type&gt; &amp;array[]; &lt;type&gt; values[])</code></div><p>Concatenates the values from the <code>values</code> array to the end of <code>array</code>. Increases the size of <code>array</code> by <code>len(values)</code>. This is the same as <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/push\">push(array, values)</a>.</p><h2>Tip</h2><p>You can set an individual item in an array using <code>array[n] = x</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/len\">len</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/push\">push</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/resize\">resize</a></div></body>",
    "area": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/area\">area</a></h1><p class=\"summary\">Returns the area of the micropolygon containing a variable such as P.</p><div class=\"usage\"> <code>float area(vector p, ...)</code></div><p>This is a more accurate and convenient method to get the micropolygon area\nthan multiplying the length of <code>Du(P)</code> by the length of <code>Dv(P)</code>.\nThis function is typically used to get the shading area in pixels.</p><h2>Note</h2><p>This function works because VEX knows that the variable <code>P</code>\n    has derivatives (<code>dPdu</code> and <code>dPdv</code>). Passing a literal vector\n    instead of a special variables such as <code>P</code> will return <code>0</code> since\n    VEX will not be able to access the derivatives.</p><h2>Examples</h2><p>Return the area of the current micro-polygon in camera space:</p><div class=\"codeblock\"><code class=\"codeline\">area(P)</code></div><p>Return the area of the current micro-polygon in NDC space:</p><div class=\"codeblock\"><code class=\"codeline\">area(transform(\"ndc\", P))</code></div><p>Returns <code>0</code>, since the argument is not a variable VEX knows the derivatives for:</p><div class=\"codeblock\"><code class=\"codeline\">area({0.1, 2.3, 4.5})</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volume\">volume</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Du\">Du</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dv\">Dv</a></div></body>",
    "argsort": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/argsort\">argsort</a></h1><p class=\"summary\">Returns the indices of a sorted version of an array.</p><div class=\"usage\"> <code>int [] argsort(&lt;type&gt; value[])</code></div><p>Returns a list of indices that, if applied to the given array, will give a sorted sequence in increasing order.  </p><p>This lets sort an array by some property of the items in the array rather than by the values themselves.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">cvex main()</code><code class=\"codeline\">    {</code><code class=\"codeline\">        // Given an array of strings...</code><code class=\"codeline\">        string colors[] = {\"Red\", \"Green\", \"Blue\", \"Orange\", \"Violet\", \"Indigo\"};</code><code class=\"codeline\"></code><code class=\"codeline\">        // Create an array with the corresponding lengths</code><code class=\"codeline\">        int[] lengths = {};</code><code class=\"codeline\">        foreach (string name; colors) {</code><code class=\"codeline\">            push(lengths, len(name));</code><code class=\"codeline\">        }</code><code class=\"codeline\"></code><code class=\"codeline\">        // Sort the lengths and return an array containing the new ordering</code><code class=\"codeline\">        int[] ordering = argsort(lengths);</code><code class=\"codeline\"></code><code class=\"codeline\">        // Get the array of color names but sorted by name length</code><code class=\"codeline\">        string colors_by_len[] = reorder(colors, ordering);</code><code class=\"codeline\"></code><code class=\"codeline\">        printf(\"%s\\n\", colors_by_len);</code><code class=\"codeline\">    }</code><code class=\"codeline\">    </code><code class=\"codeline\">    // Prints {Red, Blue, Green, Orange, Violet, Indigo}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/reorder\">reorder</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sort\">sort</a></div></body>",
    "array": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/array\">array</a></h1><p class=\"summary\">Efficiently creates an array from its arguments.</p><div class=\"usage\"> <code>&lt;type&gt;[] array(...)</code></div><p>Returns an array of items of the given type.</p><p>You should use function-style casting to ensure the array members have the\ncorrect type:</p><div class=\"codeblock\"><code class=\"codeline\">vector v[] = vector[](array( 1, {1,2,3}, 3, s, t, Cl, P, N));</code><code class=\"codeline\">float  f[] = float[](array(1, 2, s, t, length(P-L), length(N)));</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/len\">len</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/resize\">resize</a></div></body>",
    "ashikhmin": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ashikhmin\">ashikhmin</a></h1><p class=\"summary\">Returns a specular BSDF using the Ashikhmin shading model.</p><div class=\"usage\"> <code>bsdf ashikhmin(float exponentx, float exponenty, vector framex, vector framey, ...)</code></div><div class=\"usage\"> <code>bsdf ashikhmin(vector nml, float exponentx, float exponenty, vector framex, vector framey, ...)</code></div><p><a href=\"https://www.sidefx.com/docs/houdini/images/rendering/ashikhmin1.png\">/images/rendering/ashikhmin1.png</a>\n<a href=\"https://www.sidefx.com/docs/houdini/images/rendering/ashikhmin2.png\">/images/rendering/ashikhmin2.png</a></p><p>An anisotropic <code>bsdf</code> similar to <code>phong()</code> but with independent controls for the highlight size along 2 tangent vectors.</p><div class=\"argument\"><code>exponentx</code></div><p>Phong exponent along the <code>framex</code> vector.</p><div class=\"argument\"><code>exponenty</code></div><p>Phong exponent along the <code>framey</code> vector.</p><div class=\"argument\"><code>framex</code></div><p>Highlight X direction.</p><div class=\"argument\"><code>framey</code></div><p>Highlight Y direction.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phong\">phong</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phonglobe\">phonglobe</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "asin": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/asin\">asin</a></h1><p class=\"summary\">Returns the inverse sine of the argument.</p><div class=\"usage\"> <code>float asin(float n)</code></div><p>The inverse sine of <code>n</code>, where <code>n</code> is in radians. The return value is in the range -\u03c0/2 to \u03c0/2.</p><div class=\"usage\"> <code>vector2 asin(vector2 n)</code></div><div class=\"usage\"> <code>vector asin(vector n)</code></div><div class=\"usage\"> <code>vector4 asin(vector4 n)</code></div><p>Returns a new vector with <code>asin()</code> applied to all components.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sin\">sin</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cos\">cos</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tan\">tan</a></div></body>",
    "assert_enabled": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/assert_enabled\">assert_enabled</a></h1><p class=\"summary\">Returns 1 if the VEX assertions are enabled (see HOUDINI_VEX_ASSERT) or 0 if assertions are disabled. Used the implement the assert macro.</p><div class=\"usage\"> <code>int assert_enabled()</code></div><p>Returns 1 if the environment variable <code>HOUDINI_VEX_ASSERT</code> is set or 0 if the variable isn\u2019t set.</p><p>The <code>assert()</code> macro uses this function to only execute assertions when <code>HOUDINI_VEX_ASSERT</code> is set:</p><div class=\"codeblock\"><code class=\"codeline\">#define assert(EXPR)    \\</code><code class=\"codeline\">    if (assert_enabled()) { \\</code><code class=\"codeline\">        if (!(EXPR)) print_once(sprintf('VEX Assertion Failed %s:%d - (%s)\\n', \\</code><code class=\"codeline\">                __FILE__, __LINE__, #EXPR)); \\</code><code class=\"codeline\">    }</code></div><p>You could use this function to write your own assert macro (for example, you might write a macro that used your studio\u2019s logging infrastructure).</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/assertions\">using assertions in VEX</a> for more information.</p></body>",
    "assign": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/assign\">assign</a></h1><p class=\"summary\">An efficient way of extracting the components of a vector or matrix into float variables.</p><div class=\"usage\"> <code>void assign(float &amp;c1, float &amp;c2, vector2 source)</code></div><div class=\"usage\"> <code>void assign(float &amp;c1, float &amp;c2, float &amp;c3, vector source)</code></div><div class=\"usage\"> <code>void assign(float &amp;c1, float &amp;c2, float &amp;c3, float &amp;c4, vector4 source)</code></div><div class=\"usage\"> <code>void assign(float &amp;c1, float &amp;c2, float &amp;c3, float &amp;c4, matrix2 source)</code></div><div class=\"usage\"> <code>void assign(float &amp;c1, float &amp;c2, float &amp;c3, float &amp;c4, float &amp;c5, float &amp;c6, float &amp;c7, float &amp;c8, float &amp;c9, matrix3 source)</code></div><div class=\"usage\"> <code>void assign(float &amp;c1, float &amp;c2, float &amp;c3, float &amp;c4, float &amp;c5, float &amp;c6, float &amp;c7, float &amp;c8, float &amp;c9, float &amp;c10, float &amp;c11, float &amp;c12, float &amp;c13, float &amp;c14, float &amp;c15, float &amp;c16, matrix source)</code></div><p>This function overwrites the float variables with the components from the final vector or matrix argument.</p></body>",
    "atan": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/atan\">atan</a></h1><p class=\"summary\">Returns the inverse tangent of the argument.</p><div class=\"usage\"> <code>float atan(float n)</code></div><p>Returns the inverse tangent of <code>n</code>, where <code>n</code> is in radians. The return value is in the range -\u03c0/2 to \u03c0/2.</p><div class=\"usage\"> <code>float atan(float y, float x)</code></div><p>Alias for <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/atan2\">atan2</a>.</p><div class=\"usage\"> <code>&lt;vector&gt; atan(&lt;vector&gt; v)</code></div><p>Returns a new vector with <code>atan()</code> applied to each component.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/atan2\">atan2</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tan\">tan</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sin\">sin</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cos\">cos</a></div></body>",
    "atan2": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/atan2\">atan2</a></h1><p class=\"summary\">Returns the inverse tangent of y/x.</p><div class=\"usage\"> <code>float atan2(float y, float x)</code></div><p>Returns the principal value of the inverse tangent of y/x, using the signs\nof the two arguments to determine the quadrant of the result. The return value\nis in the range -\u03c0 to \u03c0.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/atan\">atan</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tan\">tan</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sin\">sin</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cos\">cos</a></div></body>",
    "atof": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/atof\">atof</a></h1><p class=\"summary\">Converts a string to a float.</p><div class=\"usage\"> <code>float atof(string str)</code></div><p>Converts a string to a floating point value.</p><div class=\"related\">This function ignores whitespace around the number.</div><div class=\"related\">Returns <code>0.0</code> if the string does not contain a number.</div><div class=\"related\">The string can contain exponential notation (for example <code>\"1.25e+5\"</code>).</div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/atoi\">atoi</a></div></body>",
    "atoi": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/atoi\">atoi</a></h1><p class=\"summary\">Converts a string to an integer.</p><div class=\"usage\"> <code>int atoi(string str)</code></div><div class=\"usage\"> <code>int atoi(string str, int base)</code></div><p>Converts the string argument to an integer value. If a base between 2 and 36 inclusive is supplied, the string is converted in base <code>base</code>.</p><div class=\"related\">This function ignores whitespace around the number.</div><div class=\"related\">Returns <code>0</code> if the string does not contain a number, or if an invalid base is specified.</div><div class=\"related\">The string can contain exponential notation (for example <code>\"1.25e+5\"</code>).</div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/atof\">atof</a></div></body>",
    "atten": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/atten\">atten</a></h1><p class=\"summary\">Computes attenuated falloff.</p><div class=\"usage\"> <code>float atten(float attenuation, float distance)</code></div><p>Computes attenuated falloff. This is equivalent to <code> <code class=\"var\">attenuation</code> /\n(<code class=\"var\">attenuation</code> + <code class=\"var\">distance</code>)</code>.</p></body>",
    "attrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attrib\">attrib</a></h1><p class=\"summary\">Reads the value of an attribute from geometry.</p><div class=\"usage\"> <code>&lt;type&gt; attrib(&lt;geometry&gt;, string attribclass, string name, int elemnum)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] attrib(&lt;geometry&gt;, string attribclass, string name, int elemnum)</code></div><p>This general form lets you specify the attribute class at run-time. This can be useful for writing general code that can work on different classes.\n    If you know the class of attribute you want to read ahead of time, using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/detail\">detail</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prim\">prim</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/point\">point</a>, or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertex\">vertex</a> may be faster.</p><div class=\"argument\"><code>name</code></div><p>The name of the attribute, group, or intrinsic to read from.</p><div class=\"argument\"><code>elemnum</code></div><p>Which element (e.g. point number, primitive number, vertex number) to read from. Ignored for detail attributes.  You can use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexindex\">vertexindex</a> to convert a primitive/point pair into a vertex number.</p><h2>Returns</h2><p>Zero/empty value if the attribute does not exist. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getattrib\">getattrib</a> if you want to check whether the attribute existed.</p></body>",
    "attribclass": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribclass\">attribclass</a></h1><p class=\"summary\">Returns the class of a geometry attribute.</p><div class=\"usage\"> <code>string attribclass(&lt;geometry&gt;, string attribute_name)</code></div><div class=\"argument\"><code>attribute_name</code></div><p>The name of the attribute to read.</p><p>If attributes with the same name exist at multiple levels, returns the <em>lowest level</em> at which the attribute exists. For example, if there is a primitive attribute <code>foo</code> and a vertex attribute <code>foo</code>, <code>attribclass(0, \"foo\")</code> will return <code>\"vertex\"</code>.</p><h2>Returns</h2><p>A string describing the class (<code>\"detail\"</code>, <code>\"prim\"</code>, <code>\"point\"</code>, or <code>\"vertex\"</code>) of the given attribute. If the attribute does not exist, returns an empty string (<code>\"\"</code>).</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addattrib\">addattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attrib\">attrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getattrib\">getattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribtype\">attribtype</a></div></body>",
    "attribdataid": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribdataid\">attribdataid</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Returns the data id of a geometry attribute.</p><div class=\"usage\"><code>int [] attribdataid(&lt;geometry&gt;, string attribclass, string attribute_name)</code></div><p>Returns the data id corresponding to an attribute.  Data ids can\n    be used for advanced forms of caching.  If the data id of an attribute\n    is the same as you've seen before, you can assume the attribute\n    contains the same data it did before.  This allows acceleration\n    structures to only be built when necessary.</p><p>The length and contents of the array are not defined, and no assumptions\n    should be made about the layout.  The result will vary from run\n    to run of Houdini, so only exact equality should be used.</p><div class=\"argument\"><code>In addition to the normal attribute classes, an additional\n    attribute class of meta is supported.  This has the additional\n    data ids of</code></div><div class=\"argument\"><code>topology</code></div><p>The overall wiring of vertices, points and primitives.\n            This will change if any points are rewired or vertices\n            added.</p><div class=\"argument\"><code>primitivelist</code></div><p>This data id changes if the contents of the primitive\n            change at all.</p><div class=\"argument\"><code>detail</code></div><p>This data id tracks the entire geometry as a whole.  If\n            it is unchanged, no changes occurred in the geometry.</p><h2>Returns</h2><p>An integer array indicating the data id of the attribute.</p></body>",
    "attribsize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribsize\">attribsize</a></h1><p class=\"summary\">Returns the size of a geometry attribute.</p><p>If you know the attribute class ahead of time, using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/detailattribsize\">detailattribsize</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primattribsize\">primattribsize</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointattribsize\">pointattribsize</a>, or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexattribsize\">vertexattribsize</a> may be faster.</p><div class=\"usage\"> <code>int attribsize(&lt;geometry&gt;, string attribclass, string attribute_name)</code></div><h2>Returns</h2><p>The size of an attribute\u2019s <em>type</em>.</p><div class=\"related\">For a vector type, this is the number of components.</div><div class=\"related\">For an integer, float, or string, this returns <code>1</code>.</div><div class=\"related\">For an array attribute, this returns the size of the tuples in the array. The tuple size is controlled by the <strong>Size</strong> parameter on the <a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/attribcreate\">Attribute Create node</a>.</div><p>If the attribute does not exist, returns <code>0</code>.</p><div class=\"related\">This function works with the attribute\u2019s <em>type</em>. It does not return the size of an attribute <em>value</em>. You can\u2019t use this function to get the length of a string or array value.</div><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the size of the position attribute of \"defgeo.bgeo\"</code><code class=\"codeline\">int size = attribsize(\"defgeo.bgeo\", \"point\", \"P\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addattrib\">addattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attrib\">attrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getattrib\">getattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribtype\">attribtype</a></div></body>",
    "attribtype": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribtype\">attribtype</a></h1><p class=\"summary\">Returns the type of a geometry attribute.</p><p>If you know the attribute class ahead of time, using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/detailattribtype\">detailattribtype</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primattribtype\">primattribtype</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointattribtype\">pointattribtype</a>, or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexattribtype\">vertexattribtype</a> may be faster.</p><div class=\"usage\"> <code>int attribtype(&lt;geometry&gt;, string attribclass, string attribute_name)</code></div><h2>Returns</h2><p>A numeric code indicating the attribute type:</p><span><code>-1</code> </span><p>Attribute not found, or unknown type.</p><span><code>0</code> </span><p>Integer</p><span><code>1</code> </span><p>Float or vector</p><span><code>2</code> </span><p>String</p><span><code>3</code> </span><p>Array of integers (or integer tuples)</p><span><code>4</code> </span><p>Array of floats (or float tuples)</p><span><code>5</code> </span><p>Array of strings.</p><span><code>6</code> </span><p>Dictionary</p><span><code>7</code> </span><p>Array of Dictionaries</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the type of the position attribute of \"defgeo.bgeo\"</code><code class=\"codeline\">int type = attribtype(\"defgeo.bgeo\", \"point\", \"P\");</code></div><h2>Related</h2><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addattrib\">addattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attrib\">attrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getattrib\">getattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribsize\">attribsize</a></div></body>",
    "attribtypeinfo": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribtypeinfo\">attribtypeinfo</a></h1><p class=\"summary\">Returns the transformation metadata of a geometry attribute.</p><div class=\"usage\"><code>string attribtypeinfo(&lt;geometry&gt;, string attribclass, string attribute_name)</code></div><p>This general form lets you specify the attribute class at run-time. This can be useful for writing general code that can work on different classes.\n    If you know the attribute class ahead of time, using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/detailattribtypeinfo\">detailattribtypeinfo</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primattribtypeinfo\">primattribtypeinfo</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointattribtypeinfo\">pointattribtypeinfo</a>, or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexattribtypeinfo\">vertexattribtypeinfo</a> may be faster.</p><h2>Returns</h2><p>A string indicating the metadata for a given geometry attribute, or the empty string (<code>\"\"</code>) if the attribute does not exist.</p></body>",
    "avg": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/avg\">avg</a></h1><p class=\"summary\">Returns the average value of the input(s)</p><div class=\"usage\"> <code>int avg(int a)</code></div><div class=\"usage\"> <code>float avg(float a)</code></div><p>Returns <code>a</code>.</p><div class=\"usage\"> <code>float avg(float a, float b, ...)</code></div><p>Returns the average of the arguments.</p><div class=\"usage\"> <code>float avg(vector2 v)</code></div><div class=\"usage\"> <code>float avg(vector v)</code></div><div class=\"usage\"> <code>float avg(vector4 v)</code></div><p>Returns the average of the values in the components of <code>v</code>.</p><div class=\"usage\"> <code>vector2 avg(vector2 a, vector2 b, ...)</code></div><div class=\"usage\"> <code>vector avg(vector a, vector b, ...)</code></div><div class=\"usage\"> <code>vector4 avg(vector4 a, vector4 b, ...)</code></div><p>Returns a new vector where each component is the average of the corresponding components in the arguments.</p><div class=\"usage\"> <code>&lt;type&gt; avg(&lt;type&gt; arr[])</code></div><p>Returns the average of the values in the array.</p></body>",
    "binput": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/binput\">binput</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Samples a 2\u00d72 pixel block around the given UV position, and bilinearly interpolates these pixels.</p><div class=\"usage\"> <code>vector binput(int u, int v, ...)</code></div><div class=\"usage\"> <code>vector4 binput(int u, int v, ...)</code></div><div class=\"usage\"> <code>vector binput(float u, float v, ...)</code></div><div class=\"usage\"> <code>vector4 binput(float u, float v, ...)</code></div><p>Sample from the currently cooking plane on input 0 at the current frame.</p><div class=\"usage\"> <code>float binput(int comp, int u, int v, ...)</code></div><div class=\"usage\"> <code>float binput(int comp, float u, float v, ...)</code></div><p>Sample one component from the given component index of the currently cooking plane on input 0 at the current frame.</p><div class=\"usage\"> <code>vector binput(int opinput, int plane, int u, int v, ...)</code></div><div class=\"usage\"> <code>vector4 binput(int opinput, int plane, int u, int v, ...)</code></div><div class=\"usage\"> <code>vector binput(int opinput, int plane, float u, float v, ...)</code></div><div class=\"usage\"> <code>vector4 binput(int opinput, int plane, float u, float v, ...)</code></div><p>Sample from the given input/plane at the current frame.</p><div class=\"usage\"> <code>float binput(int opinput, int plane, int comp, int u, int v, ...)</code></div><div class=\"usage\"> <code>float binput(int opinput, int plane, int comp, float u, float v, ...)</code></div><p>Sample one component from the given input/plane/component at the current frame.</p><div class=\"usage\"> <code>float binput(int opinput, int plane, int array_index, int comp, int u, int v, int frame, ...)</code></div><div class=\"usage\"> <code>float binput(int opinput, int plane, int array_index, int comp, float u, float v, int frame, ...)</code></div><p>Sample one component from the given input/plane/component at the given frame.</p><div class=\"usage\"> <code>vector binput(int opinput, int plane, int array_index, int u, int v, int frame, ...)</code></div><div class=\"usage\"> <code>vector4 binput(int opinput, int plane, int array_index, int u, int v, int frame, ...)</code></div><div class=\"usage\"> <code>vector binput(int opinput, int plane, int array_index, float u, float v, int frame, ...)</code></div><div class=\"usage\"> <code>vector4 binput(int opinput, int plane, int array_index, float u, float v, int frame, ...)</code></div><p>Sample from the given input/plane/component at the given frame.</p><div class=\"argument\"><code>opinput</code></div><p>The input number to read the pixels from. Versions that don\u2019t specify this always use the first input (0).</p><div class=\"argument\"><code>plane</code></div><p>The index of a plane in the input.\n    Versions that don\u2019t specify this always use the currently cooking plane.</p><div class=\"argument\"><code>array_index</code></div><p>For use if the plane has array values. Generally, just pass <code>0</code> here.</p><div class=\"argument\"><code>comp</code></div><p>The index of a component within the plane. For example, 0 for red, 1 for green, 2 for blue in an RGB plane.\n    The versions that return vectors do not take this argument and return all components at once.</p><div class=\"argument\"><code><code>u</code>, <code>v</code></code></div><p>If you give floating point UVs, the values are interpreted as unit (0-1) values. For example, <code>0.5, 0.5</code> would be the center of the image.\n    If you give integer UVs, the values are in pixels, ranging from <code>0,0</code> to <code>XRES-1, YRES-1</code>.</p><div class=\"argument\"><code>frame</code></div><p>Frame number to sample at.\n    Versions that don\u2019t specify this always use the current frame.</p><h2>Returns</h2><p>A float, vector or vector4 value. If the channel does not exist, returns 0.\n    Whenever possible, use the vector versions rather than reading individual components separately.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/cop_sample_suite\">COP pixel sampling functions</a> for more information.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/cop_sample_suite\">/vex/cop_sample_suite</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cinput\">cinput</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/finput\">finput</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ninput\">ninput</a></div></body>",
    "blackbody": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/blackbody\">blackbody</a></h1><p class=\"summary\">Compute the color value of an incandescent black body.</p><div class=\"usage\"> <code>vector blackbody(float temperature, float luminance)</code></div><p>Given a temperature, in Kelvin, and a luminance value, computes the\ncolor of an incandescent black body as CIE XYZ tristimulus values.</p><p>The computation uses a fast approximation, which is valid for\ntemperature values between 1666K and 25000K. Values outside of this\nrange are clamped to the nearest valid in-range value.</p><p>The returned value can be converted to linear sRGB values using\nthe <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xyztorgb\">xyztorgb</a> function.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xyztorgb\">xyztorgb</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/blackbody\">blackbody</a></div></body>",
    "blinn": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/blinn\">blinn</a></h1><p class=\"summary\">Returns a Blinn BSDF or computes Blinn shading.</p><div class=\"usage\"> <code>bsdf blinn(float exponent, ...)</code></div><div class=\"usage\"> <code>bsdf blinn(vector nml, float exponent, ...)</code></div><p>Returns a Blinn BSDF.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">writing a PBR shader</a> for information on BSDFs.</p><div class=\"usage\"> <code>vector blinn(vector nml, vector V, float roughness, ...)</code></div><p>Computes Blinn shading.</p><div class=\"argument\"><code>nml</code></div><p>The normal of the surface to use for evaluate.</p><div class=\"argument\"><code>V</code></div><p>The incidence vector.</p><div class=\"argument\"><code>exponent</code></div><p>The exponent value. The higher the value, the tighter the specular lobe.</p><p>Each of the functions can also take an optional light mask.</p><p><a href=\"https://www.sidefx.com/docs/houdini/images/rendering/blinn.png\">/images/rendering/blinn.png</a></p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phong\">phong</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wireblinn\">wireblinn</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/matchvex_blinn\">matchvex_blinn</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "blinnBRDF": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/blinnBRDF\">blinnBRDF</a></h1><div class=\"usage\"> <code>float blinnBRDF(vector L, vector N, vector V, float rough)</code></div><p><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/specularBRDF\">specularBRDF</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phongBRDF\">phongBRDF</a>, <code>blinnBRDF</code>,\nand <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/diffuseBRDF\">diffuseBRDF</a> return the computed BRDF for the\ndifferent lighting models used in VEX shading. You can use them in\ncustom <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a> loops to replicate the lighting models of the\ncorresponding VEX lighting functions.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/specularBRDF\">specularBRDF</a> for some example code.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/specularBRDF\">specularBRDF</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phongBRDF\">phongBRDF</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/diffuseBRDF\">diffuseBRDF</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a></div></body>",
    "bouncelabel": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/bouncelabel\">bouncelabel</a></h1><div class=\"usage\"> <code>string bouncelabel(int mask)</code></div><p>Returns the label associated with the given bounce mask.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/bouncemask\">bouncemask</a></div></body>",
    "bouncemask": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/bouncemask\">bouncemask</a></h1><div class=\"usage\"> <code>int bouncemask(string labels)</code></div><div class=\"argument\"><code>labels</code></div><p>A label or space-separated list of labels.</p><h2>Returns</h2><p>A bitmask that matches any of the labels.</p><p>Mantra tags different types of rays using shading component <em>labels</em>, such as diffuse, reflect, refract, volume, and sss. A custom BSDF can also specify its own labels in addition to existing ones (see <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cvex_bsdf\">cvex_bsdf</a> for more information).</p><p>Some VEX functions take or return a <em>component bitmask</em>, which specifies a combination of one or more of these labels using the bits of an integer.</p><p>To get the bit value associated with a label, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/bouncemask\">bouncemask</a>, for example <code>bouncemask(\"diffuse\")</code>. To get a mask that matches multiple labels, use a space-separated list:</p><div class=\"codeblock\"><code class=\"codeline\">reflect_or_refract = bouncemask(\"reflect refract\")</code></div><p>To construct a bitmask that matches all labels, use <code>bouncemask(\"all\")</code>. To match no labels, use <code>0</code>.</p><p>When you get a bitmask as a return value, you can check if it matches a certain label using <code>&amp;</code>. For example:</p><div class=\"codeblock\"><code class=\"codeline\">mask = getbounces(mybsdf)</code><code class=\"codeline\">if (mask &amp; bouncemask(\"reflect\")) {</code><code class=\"codeline\">    ...</code><code class=\"codeline\">}</code></div><p>(As an alternative to basic uses of <code>bouncemask()</code>, you can <code>#import \"pbr.h\"</code> and work with the constants <code>PBR_DIFFUSE_MASK</code>, <code>PBR_REFLECT_MASK</code>, <code>PBR_REFRACT_MASK</code>, <code>PBR_VOLUME_MASK</code>, <code>PBR_SSS_MASK</code>, as well as <code>PBR_ALL_MASK</code> and <code>PBR_NO_MASK</code>. You can combine the constants using <code>|</code>, for example <code>reflect_or_refract = PBR_REFLECT_MASK | PBR_REFRACT_MASK</code>.)</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbounces\">getbounces</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nbouncetypes\">nbouncetypes</a></div></body>",
    "bumpmap": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/bumpmap\">bumpmap</a></h1><h2>Warning</h2><p>This function is deprecated. Use <code>Du(texture()), Dv(texture())</code> instead.\n    See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Du\">Du</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dv\">Dv</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texture\">texture</a>.</p></body>",
    "bumpmapA": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/bumpmapA\">bumpmapA</a></h1><h2>Warning</h2><p>This function is deprecated. Use <code>Du(texture()), Dv(texture())</code> instead.\n    See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Du\">Du</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dv\">Dv</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texture\">texture</a>.</p></body>",
    "bumpmapB": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/bumpmapB\">bumpmapB</a></h1><h2>Warning</h2><p>This function is deprecated. Use <code>Du(texture()), Dv(texture())</code> instead.\n    See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Du\">Du</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dv\">Dv</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texture\">texture</a>.</p></body>",
    "bumpmapG": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/bumpmapG\">bumpmapG</a></h1><h2>Warning</h2><p>This function is deprecated. Use <code>Du(texture()), Dv(texture())</code> instead.\n    See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Du\">Du</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dv\">Dv</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texture\">texture</a>.</p></body>",
    "bumpmapL": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/bumpmapL\">bumpmapL</a></h1><h2>Warning</h2><p>This function is deprecated. Use <code>Du(texture()), Dv(texture())</code> instead.\n    See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Du\">Du</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dv\">Dv</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texture\">texture</a>.</p></body>",
    "bumpmapR": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/bumpmapR\">bumpmapR</a></h1><h2>Warning</h2><p>This function is deprecated. Use <code>Du(texture()), Dv(texture())</code> instead.\n    See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Du\">Du</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dv\">Dv</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texture\">texture</a>.</p></body>",
    "bumpname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/bumpname\">bumpname</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the default name of the bump plane (as it appears in the\ncompositor preferences).</p><div class=\"usage\"> <code>string bumpname()</code></div><p>Returns the default name of the bump plane (as it appears in the\ncompositor preferences). Using this instead of hardcoding the default\nmakes your code more portable. Default is B.</p></body>",
    "cbrt": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cbrt\">cbrt</a></h1><p class=\"summary\">Returns the cube root of the argument.</p><div class=\"usage\"> <code>float cbrt(float n)</code></div><p>Returns the cube-root of <code>n</code>.</p><div class=\"usage\"> <code>vector2 cbrt(vector2 v)</code></div><div class=\"usage\"> <code>vector cbrt(vector v )</code></div><div class=\"usage\"> <code>vector4 cbrt(vector4 v )</code></div><p>Returns a new vector where each component is the cube-root of the corresponding component in <code>v</code>.</p></body>",
    "ceil": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ceil\">ceil</a></h1><p class=\"summary\">Returns the smallest integer greater than or equal to the argument.</p><div class=\"usage\"> <code>float ceil(float n)</code></div><div class=\"usage\"> <code>&lt;vector&gt; ceil(&lt;vector&gt; v)</code></div><p>Returns the smallest integer greater than or equal to <code>n</code>. For vectors, this is done per-component.</p></body>",
    "ch": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch\">ch</a></h1><p class=\"summary\">Evaluates a channel (or parameter) and return its value.</p><div class=\"usage\"> <code>float ch(string channel)</code></div><div class=\"usage\"> <code>float ch(string channel, float time_in_sec)</code></div><div class=\"usage\"> <code>string ch(string channel)</code></div><div class=\"usage\"> <code>string ch(string channel, float time_in_sec)</code></div><div class=\"usage\"> <code>string ch(string channel, float time_in_sec)</code></div><div class=\"usage\"> <code>float ch(int op_id, int parm_index, int vector_index)</code></div><div class=\"usage\"> <code>float ch(int op_id, int parm_index, int vector_index, float time_in_sec)</code></div><p>Evaluates a channel (or parameter) and return its value. The time is specified in <em>seconds</em>, not in frames. If you don\u2019t specify the time, the function returns the value at the current time.</p><p>Houdini includes several functions to evaluate channels/parameters of different types.</p><div class=\"related\">To get a float or string without needing to know the parameter type, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch\">ch</a>.</div><div class=\"related\">To get a float, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chf\">chf</a>.</div><div class=\"related\">To get a string, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chs\">chs</a>.</div><div class=\"related\">For integer parameters, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chi\">chi</a></div><div class=\"related\">For matrix type parameters, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch3\">ch3</a> or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch4\">ch4</a>.</div><div class=\"related\">For a ramp parameter, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chramp\">chramp</a> or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chrampderiv\">chrampderiv</a>.</div><div class=\"related\">Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chid\">chid</a> to get an <code>op_id</code>, <code>parm_index</code> and <code>vector_index</code> to evaluate the channel without having to do string resolution.</div><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the X transform of the box1 SOP at 1.5s into the animation</code><code class=\"codeline\">float tx = ch(\"/obj/geo1/box1/tx\", 1.5)</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attrib\">attrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chf\">chf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chs\">chs</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chi\">chi</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chv\">chv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch3\">ch3</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch4\">ch4</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chramp\">chramp</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chid\">chid</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opid\">opid</a></div></body>",
    "ch2": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch2\">ch2</a></h1><p class=\"summary\">Evaluates a channel (or parameter) and return its value.</p><div class=\"usage\"> <code>matrix2 ch2(string channel)</code></div><div class=\"usage\"> <code>matrix2 ch2(string channel, float time)</code></div><p>If the node parameter referenced by <code>channel</code> is a matrix type, the base parameter name\ncan be used to return the all components as a matrix.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch\">ch</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chf\">chf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chs\">chs</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chi\">chi</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chu\">chu</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chv\">chv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chp\">chp</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch3\">ch3</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch4\">ch4</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chramp\">chramp</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chrampderiv\">chrampderiv</a></div></body>",
    "ch3": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch3\">ch3</a></h1><p class=\"summary\">Evaluates a channel (or parameter) and return its value.</p><div class=\"usage\"> <code>matrix3 ch3(string channel)</code></div><div class=\"usage\"> <code>matrix3 ch3(string channel, float time)</code></div><p>If the node parameter referenced by <code>channel</code> is a matrix type, the base parameter name\ncan be used to return the all components as a matrix.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch\">ch</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chf\">chf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chs\">chs</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chi\">chi</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chu\">chu</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chv\">chv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch4\">ch4</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chramp\">chramp</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chrampderiv\">chrampderiv</a></div></body>",
    "ch4": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch4\">ch4</a></h1><p class=\"summary\">Evaluates a channel (or parameter) and return its value.</p><div class=\"usage\"> <code>matrix ch4(string channel)</code></div><div class=\"usage\"> <code>matrix ch4(string channel, float time)</code></div><p>If the node parameter referenced by <code>channel</code> is a matrix type, the base parameter name\ncan be used to return the all components as a matrix.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch\">ch</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chf\">chf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chs\">chs</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chi\">chi</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chv\">chv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch3\">ch3</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chramp\">chramp</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chrampderiv\">chrampderiv</a></div></body>",
    "chadd": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chadd\">chadd</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Adds new channels to a CHOP node.</p><div class=\"usage\"> <code>int chadd(string channel_names)</code></div><div class=\"usage\"> <code>int chadd(string channel_names[])</code></div><p>This function adds new channels to a CHOP node. It works only when iterating over Clip, Channel or Samples, not when iterating over ChannelSample. You can\u2019t control the default channel values when adding channels using this function. You need to add another <code>Channel Wrangle</code> and compute the channel data inside it.</p><p>Returns 1 on success, 0 otherwise.</p><div class=\"argument\"><code><code>channel_names</code></code></div><p>The names of the attributes to add. Can be an array or a space separated list of channel names.</p></body>",
    "chattr": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chattr\">chattr</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Reads from a CHOP attribute.</p><div class=\"usage\"> <code>&lt;type&gt; chattr( string attrname; int &amp;success )</code></div><div class=\"usage\"> <code>&lt;type&gt; chattr( int opinput; string attrname; int &amp;success )</code></div><p>Get the value of a clip-level attribute.\n    The version without <code>opinput</code> assumes the first input (0).</p><div class=\"usage\"> <code>&lt;type&gt; chattr( string attrname; int channel; int &amp;success )</code></div><div class=\"usage\"> <code>&lt;type&gt; chattr( int opinput; string attrname; int channel; int &amp;success )</code></div><p>Get the value of a channel-level attribute.\n    The version without <code>opinput</code> assumes the first input (0).</p><div class=\"usage\"> <code>&lt;type&gt; chattr( string attrname; int channel; int sample; int &amp;success )</code></div><div class=\"usage\"> <code>&lt;type&gt; chattr( int opinput; string attrname; int channel; int sample; int &amp;success )</code></div><p>Get the value of an attribute.\n    The function guesses the attribute class from the other arguments.\n    The version without <code>opinput</code> assumes the first input (0).</p><div class=\"usage\"> <code>&lt;type&gt; chattr( string attrclass; string attrname; int channel; int sample; int &amp;success )</code></div><div class=\"usage\"> <code>&lt;type&gt; chattr( int opinput, string attribclass, string attrname, int channel, int sample, int &amp;success)</code></div><p>Get the value of an attribute of a specific class.\n    The version without <code>opinput</code> assumes the first input (0).</p><p>CHOP attributes store metadata on clips, channels, samples, or channel/sample pairs.</p><p>This function reads the value of a CHOP attribute. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chsetattr\">chsetattr</a> to set CHOP attributes.</p><div class=\"argument\"><code>attribclass</code></div><p>The level of the attribute:</p><div class=\"argument\"><code><code>\"clip\"</code></code></div><p>An attribute on a whole clip.</p><div class=\"argument\"><code><code>\"channel\"</code></code></div><p>An attribute on a whole channel.</p><div class=\"argument\"><code><code>\"sample\"</code></code></div><p>An attribute on a sample (across all channels).</p><div class=\"argument\"><code><code>\"channelsample\"</code></code></div><p>An attribute on a specific channel/sample pair.</p><div class=\"argument\"><code><code>\"\"</code></code></div><p>Pass an empty string to have the function figure out the class based on the other arguments.</p><p>Signatures that don\u2019t have this parameter act the same as if you passed the empty string.</p><div class=\"argument\"><code>attrname</code></div><p>The name of the attribute to read.</p><div class=\"argument\"><code>channel</code></div><p>When reading a <code>channel</code> or <code>channelsample</code> attribute, this is the index of the channel.\n    If you are reading a <code>clip</code> or <code>sample</code> attribute, use <code>-1</code> here.</p><div class=\"argument\"><code>sample</code></div><p>When reading a <code>sample</code> or <code>channelsample</code> attribute, this is the sample number.\n    If you are reading a <code>clip</code> or <code>channel</code> attribute, use <code>-1</code> here.</p><div class=\"argument\"><code>success</code></div><p>If the given attribute exists and can be read, the function sets this variable to <code>1</code>. Otherwise, it sets this variable to <code>0</code>.</p><h2>Returns</h2><p>The value of the attribute.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int success = 0</code><code class=\"codeline\">    int input = 0;</code><code class=\"codeline\">    string attrname = \"export\";</code><code class=\"codeline\">    string attrclass = \"channel\";</code><code class=\"codeline\">    int channel = 0; // Or use C global variable for current channel index.</code><code class=\"codeline\">    int sample = -1; // Or use I global variable for current sample index.</code><code class=\"codeline\">    string s = chattr(input, attrname, attrclass, channel, sample, success )</code><code class=\"codeline\">    if (success) {</code><code class=\"codeline\">        // Do something with s</code><code class=\"codeline\">        printf(\"s=%s\\n\", s);</code><code class=\"codeline\">    } else {</code><code class=\"codeline\">        // Couldn't read attribute, usually because an attribute with that</code><code class=\"codeline\">        // name doesn't exist</code><code class=\"codeline\">    }</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chsetattr\">chsetattr</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chattrnames\">chattrnames</a></div></body>",
    "chattrnames": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chattrnames\">chattrnames</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Reads CHOP attribute names of a given attribute class from a CHOP input.</p><div class=\"usage\"> <code>string[] chattrnames(int opinput, string attribclass)</code></div><div class=\"usage\"> <code>string[] chattrnames(string attrclass)</code></div><p>Returns all the CHOP attribute names of a given attribute class from a CHOP input.</p><p>CHOP attributes store metadata on clips, channels, samples, or channel/sample pairs.</p><div class=\"argument\"><code>attribclass</code></div><p>The level of the attribute:</p><div class=\"argument\"><code><code>\"clip\"</code></code></div><p>An attribute on a whole clip.</p><div class=\"argument\"><code><code>\"channel\"</code></code></div><p>An attribute on a whole channel.</p><div class=\"argument\"><code><code>\"sample\"</code></code></div><p>An attribute on a sample (across all channels).</p><div class=\"argument\"><code><code>\"channelsample\"</code></code></div><p>An attribute on a specific channel/sample pair.</p><div class=\"argument\"><code><code>\"\"</code></code></div><p>Pass an empty string to have the function figure out the class based on the other arguments.</p><h2>Returns</h2><p>The attribute names as a string array.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chattr\">chattr</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chsetattr\">chsetattr</a></div></body>",
    "chdict": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chdict\">chdict</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Evaluates a key-value dictionary parameter and return its value.</p><div class=\"usage\"> <code>dict chdict(string channel)</code></div><p>Evaluates a key value dictionary parameter and return its value.</p></body>",
    "chend": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chend\">chend</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Returns the sample number of the last sample in a given CHOP input.</p><div class=\"usage\"> <code>int chend(int opinput=0)</code></div><p>Returns the index of the last sample in the channel data in the given CHOP input.</p><p>To get the end frame, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chendf\">chendf</a>. To get the end time in seconds, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chendt\">chendt</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chendf\">chendf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chendt\">chendt</a></div></body>",
    "chendf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chendf\">chendf</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Returns the frame corresponding to the last sample of the input specified.</p><div class=\"usage\"> <code>float chendf(int opinput=0)</code></div><p>Returns the frame number corresponding to the last sample of the given CHOP input.</p><p>To get the end sample number, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chend\">chend</a>. To get the end time in seconds, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chendt\">chendt</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chend\">chend</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chendt\">chendt</a></div></body>",
    "chendt": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chendt\">chendt</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Returns the time corresponding to the last sample of the input\nspecified.</p><div class=\"usage\"> <code>float chendt(int opinput=0)</code></div><p>Returns the time (in seconds) corresponding to the last sample in the given CHOP input.</p><p>To get the end sample number, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chend\">chend</a>. To get the end frame, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chendf\">chendf</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chend\">chend</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chendf\">chendf</a></div></body>",
    "chexpr": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chexpr\">chexpr</a></h1><p class=\"summary\">Evaluates a channel with a new segment expression.</p><div class=\"usage\"> <code>float chexpr(string channel, string new_expr_function)</code></div><p>Evaluates a channel with a new segment expression and return its value.</p><p>This can be used to extract in and out segment values, slopes and acceleration using channel expression local variables like $IT, $OT, $IV, $OV.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chexprf\">chexprf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chexprt\">chexprt</a></div></body>",
    "chexprf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chexprf\">chexprf</a></h1><p class=\"summary\">Evaluates a channel with a new segment expression at a given frame.</p><div class=\"usage\"> <code>float chexprf(string channel, string new_expr_function, float frame)</code></div><p>Evaluates a channel with a new segment expression at a given frame and return its value.</p><p>This can be used to extract in and out segment values, slopes and acceleration using channel expression local variables like $IT, $OT, $IV, $OV.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chexpr\">chexpr</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chexprt\">chexprt</a></div></body>",
    "chexprt": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chexprt\">chexprt</a></h1><p class=\"summary\">Evaluates a channel with a new segment expression at a given time.</p><div class=\"usage\"> <code>float chexprt(string channel, string new_expr_function, float time_in_seconds)</code></div><p>Evaluates a channel with a new segment expression at a given time and return its value.</p><p>This can be used to extract in and out segment values, slopes and acceleration using channel expression local variables like $IT, $OT, $IV, $OV.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chexpr\">chexpr</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chexprf\">chexprf</a></div></body>",
    "chf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chf\">chf</a></h1><p class=\"summary\">Evaluates a channel (or parameter) and return its value.</p><div class=\"usage\"> <code>float chf(string channel)</code></div><div class=\"usage\"> <code>float chf(string channel, float time_in_sec)</code></div><div class=\"usage\"> <code>float chf(int op_id, int parm_index, int vector_index)</code></div><div class=\"usage\"> <code>float chf(int op_id, int parm_index, int vector_index, float time_in_sec)</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch\">ch</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chs\">chs</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chi\">chi</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chv\">chv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch3\">ch3</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch4\">ch4</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chramp\">chramp</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chrampderiv\">chrampderiv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chid\">chid</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opid\">opid</a></div></body>",
    "chi": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chi\">chi</a></h1><p class=\"summary\">Evaluates a channel (or parameter) and return its value.</p><div class=\"usage\"> <code>int chi(string channel)</code></div><div class=\"usage\"> <code>int chi(string channel, float time)</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch\">ch</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chf\">chf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chv\">chv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chs\">chs</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch3\">ch3</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch4\">ch4</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chramp\">chramp</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chrampderiv\">chrampderiv</a></div></body>",
    "chiang": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chiang\">chiang</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Returns a chiang BSDF.</p><div class=\"usage\"> <code>bsdf chiang(vector nn, vector tanV, float R_v, float R_s, float TT_v, float TT_s, float TRT_v, float TRT_s, float shift, vector absorption_coeff, float ior, ...)</code></div><p>Creates a BSDF for computation of the physically based hair \n        model described in paper A Practical and Controllable Hair \n        and Fur Model for Production Path Tracing by Chiang et al.</p><p>Suitable only for curve geometry.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">writing a PBR shader</a> for information on BSDFs.</p><div class=\"argument\"><code>nn</code></div><p>bumped/shading normal</p><div class=\"argument\"><code>tanV</code></div><p>tangent vector along V</p><div class=\"argument\"><code>R_v</code></div><p>Longitudinal roughness value v for lobe R (section 4.1 of the paper)</p><div class=\"argument\"><code>R_s</code></div><p>Azimuthal roughness value s for lobe R (section 4.1 of the paper)</p><div class=\"argument\"><code>TT_v</code></div><p>Longitudinal roughness value v for lobe TT (section 4.1 of the paper)</p><div class=\"argument\"><code>TT_s</code></div><p>Azimuthal roughness value s for lobe TT (section 4.1 of the paper)</p><div class=\"argument\"><code>TRT_v</code></div><p>Longitudinal roughness value v for lobe TRT (section 4.1 of the paper)</p><div class=\"argument\"><code>TRT_s</code></div><p>Azimuthal roughness value s for lobe TRT (section 4.1 of the paper)</p><div class=\"argument\"><code>shift</code></div><p>Represents the cuticle angle, which affects the position of the specular highlight.  Input range of -1 to 1 is internally mapped to -90 to 90 (eg meaning 3-degrees would be 3/90 = 0.03333)</p><div class=\"argument\"><code>absorption_coeff</code></div><p>The absorption coefficient (section 4.2 of the paper)</p><div class=\"argument\"><code>ior</code></div><p>Index of refraction (eg 1.55)</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "chid": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chid\">chid</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Resolves a channel string (or parameter) and return op_id, parm_index and vector_index.</p><div class=\"usage\"> <code>void chid(string channel_path, int &amp;op_id, int &amp;parm_index, int &amp;vector_index )</code></div><div class=\"usage\"> <code>void chid(string op_path, string channel_name, int &amp;op_id, int &amp;parm_index, int &amp;vector_index )</code></div><div class=\"usage\"> <code>int chid(int op_id, int parm_index, int vector_index )</code></div><p>Resolves a channel given by a channel path or operator path and returns</p><p>its corresponding operator id, parameter id and vector_index through output\narguments. Return -1 values on failure. You can also use the last overloaded\nfunction that doesn\u2019t take a channel_path to test for validity of the keys.\nReturns 1 if the ids are valid, otherwise returns 0.</p><p>The operator id and parameter indices can change when reloading the scene or when adding spare parameters to a node.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch\">ch</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chf\">chf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chs\">chs</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chi\">chi</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chv\">chv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch3\">ch3</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch4\">ch4</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chramp\">chramp</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chrampderiv\">chrampderiv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opid\">opid</a></div></body>",
    "chindex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chindex\">chindex</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Returns the channel index from a input given a channel name.</p><div class=\"usage\"> <code>int chindex(int opinput, string name)</code></div><div class=\"usage\"> <code>int chindex(string name)</code></div><div class=\"usage\"> <code>int[] chindex(string names[])</code></div><p>Returns the channel index from a input given a channel name or -1 on failure.</p><div class=\"argument\"><code><code>opinput</code></code></div><p>CHOP Input index or -1 if omitted.</p><div class=\"argument\"><code>name</code></div><p>Channel name to lookup.</p><div class=\"argument\"><code>names</code></div><p>Array of Channel names to lookup.</p></body>",
    "chinput": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chinput\">chinput</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Returns the value of a channel at the specified sample.</p><div class=\"usage\"> <code>&lt;type&gt; chinput(int channel_index, int|float sample)</code></div><div class=\"usage\"> <code>&lt;type&gt; chinput(int opinput, int channel_index, int|float sample)</code></div><p>Read a sample from the channel at the given index.\n    The version without <code>opinput</code> assumes the first input (0).</p><div class=\"usage\"> <code>&lt;type&gt; chinput(string channel_name, int|float sample)</code></div><div class=\"usage\"> <code>&lt;type&gt; chinput(int opinput, string channel_name, int|float sample)</code></div><p>Read a sample from the channel with the given name.\n    The version without <code>opinput</code> assumes the first input (0).</p><div class=\"usage\"> <code>int chinput(int channel_index, int|float sample, vector &amp;t, vector &amp;r, vector &amp;s)</code></div><div class=\"usage\"> <code>int chinput(int opinput, int channel_index, int|float sample, vector &amp;t, vector &amp;r, vector &amp;s)</code></div><p>Read samples from the 9 channels starting at the given index.\n    The samples are returned in the 3 vector output arguments.\n    Returns 1 on success or 0 on failure.\n    The version without <code>opinput</code> assumes the first input (0).</p><div class=\"usage\"> <code>int chinput(string channel_name, int|float sample, vector &amp;t, vector &amp;r, vector &amp;s)</code></div><div class=\"usage\"> <code>int chinput(int opinput, string channel_name, int|float sample, vector &amp;t, vector &amp;r, vector &amp;s)</code></div><p>Read samples from the 9 channels starting at the given channel name.\n    The samples are returned in the 3 vector output arguments.\n    Returns 1 on success or 0 on failure.\n    The version without <code>opinput</code> assumes the first input (0).</p><div class=\"argument\"><code>sample</code></div><p>If this is fractional, the value is linearly interpolated from the\n    two nearest points.</p><h2>Returns</h2><p>The value of a channel at the specified sample in an input. </p></body>",
    "chinputlimits": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chinputlimits\">chinputlimits</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Computes the minimum and maximum value of samples in an input channel.</p><div class=\"usage\"> <code>int chinputlimits(int opinput, int channel, float &amp;channel_min, float &amp;channel_max)</code></div><div class=\"argument\"><code><code>opinput</code></code></div><p>CHOP Input index or -1 if omitted.</p><div class=\"argument\"><code><code>channel_min</code></code></div><p>Computed minimum channel value;</p><div class=\"argument\"><code><code>channel_max</code></code></div><p>Computed maximum channel value;</p><h2>Returns</h2><p>Returns 1 on success or 0 on failure.</p></body>",
    "chname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chname\">chname</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Returns the name of a numbered channel.</p><h2>COPs</h2><div class=\"usage\"> <code>string chname(int plane_index, int chindex)</code></div><p>Returns the name of the channel on the plane (for example, <code>\"r\"</code>, or <code>\"x\"</code>).</p><h2>CHOPs</h2><div class=\"usage\"> <code>string chname(int channel_index)</code></div><div class=\"usage\"> <code>string chname(int opinput, int channel_index)</code></div><p>Returns the name of the channel, for example <code>\"tx\"</code>.\n    To get a list of all channel names, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chnames\">chnames</a>.</p></body>",
    "chnames": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chnames\">chnames</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Returns all the CHOP channel names of a given CHOP input.</p><div class=\"usage\"> <code>string[] chnames()</code></div><p>Uses <code>-1</code> as the <code>opinput</code>.</p><div class=\"usage\"> <code>string[] chnames(int opinput)</code></div><p>Returns an array of channel names in the given input.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chname\">chname</a></div></body>",
    "chnumchan": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chnumchan\">chnumchan</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Returns the number of channels in the input specified.</p><div class=\"usage\"> <code>int chnumchan()</code></div><p>Uses <code>-1</code> for <code>opinput</code></p><div class=\"usage\"> <code>int chnumchan(int opinput)</code></div><p>Returns the number of channels in the input specified.</p></body>",
    "chop": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chop\">chop</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Returns the value of a CHOP channel at the specified sample.</p><div class=\"usage\"> <code>float chop(string filename, int|string channel, int|float sample)</code></div><div class=\"usage\"> <code>vector2 chop(string filename, int|string channel, int|float sample)</code></div><div class=\"usage\"> <code>vector chop(string filename, int|string channel, int|float sample)</code></div><div class=\"usage\"> <code>vector4 chop(string filename, int|string channel, int|float sample)</code></div><div class=\"usage\"> <code>matrix chop(string filename, int|string channel, int|float sample)</code></div><p>Read a sample from the channel at the given index.</p><div class=\"argument\"><code>filename</code></div><p>The CHOP node path to query using the op: syntax.\n    Doesn\u2019t support reading directly from CHOP files yet.</p><div class=\"argument\"><code>channel</code></div><p>The channel index or channel name to query.</p><div class=\"argument\"><code>sample</code></div><p>If this is fractional, the value is linearly interpolated from the\n    two nearest points.</p><h2>Returns</h2><p>The value of a channel at the specified sample in a CHOP node. </p></body>",
    "choplocal": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/choplocal\">choplocal</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Returns the value of a CHOP local transform channel at the specified sample.</p><div class=\"usage\"> <code>matrix choplocal(string filename, int|string channel, int|float sample)</code></div><p>Read a sample from the local transform channel at the given index.</p><div class=\"argument\"><code>filename</code></div><p>The CHOP node path to query using the op: syntax.\n    Doesn\u2019t support reading directly from CHOP files yet.</p><div class=\"argument\"><code>channel</code></div><p>The channel index or channel name to query.</p><div class=\"argument\"><code>sample</code></div><p>If this is fractional, the value is linearly interpolated from the\n    two nearest points.</p><h2>Returns</h2><p>The value of a channel at the specified sample in a CHOP node. </p></body>",
    "choplocalt": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/choplocalt\">choplocalt</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Returns the value of a CHOP local transform channel at the specified sample and evaluation time.</p><div class=\"usage\"> <code>matrix choplocalt(string filename, int|string channel, int|float sample, float time)</code></div><p>Read a sample from the local transform channel at the given index.</p><div class=\"argument\"><code>filename</code></div><p>The CHOP node path to query using the op: syntax.\n    Doesn\u2019t support reading directly from CHOP files yet.</p><div class=\"argument\"><code>channel</code></div><p>The channel index or channel name to query.</p><div class=\"argument\"><code>sample</code></div><p>If this is fractional, the value is linearly interpolated from the\n    two nearest points.</p><div class=\"argument\"><code>time</code></div><p>Time in seconds when the CHOP node needs to be evaluated.</p><h2>Returns</h2><p>The value of a channel at the specified sample in a CHOP node.</p></body>",
    "chopt": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chopt\">chopt</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Returns the value of a CHOP channel at the specified sample and evaluation time.</p><div class=\"usage\"> <code>float chopt(string filename, int|string channel, int|float sample, float time)</code></div><div class=\"usage\"> <code>vector2 chopt(string filename, int|string channel, int|float sample, float time)</code></div><div class=\"usage\"> <code>vector chopt(string filename, int|string channel, int|float sample, float time)</code></div><div class=\"usage\"> <code>vector4 chopt(string filename, int|string channel, int|float sample, float time)</code></div><div class=\"usage\"> <code>matrix chopt(string filename, int|string channel, int|float sample, float time)</code></div><p>Read a sample from the channel at the given index.</p><div class=\"argument\"><code>filename</code></div><p>The CHOP node path to query using the op: syntax.\n    Doesn\u2019t support reading directly from CHOP files yet.</p><div class=\"argument\"><code>channel</code></div><p>The channel index or channel name to query.</p><div class=\"argument\"><code>sample</code></div><p>If this is fractional, the value is linearly interpolated from the\n    two nearest points.</p><div class=\"argument\"><code>time</code></div><p>Time in seconds when the CHOP node needs to be evaluated.</p><h2>Returns</h2><p>The value of a channel at the specified sample in a CHOP node. </p></body>",
    "chp": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chp\">chp</a></h1><p class=\"summary\">Evaluates a channel (or parameter) and return its value.</p><div class=\"usage\"> <code>vector4 chp(string channel)</code></div><div class=\"usage\"> <code>vector4 chp(string channel, float time)</code></div><p>Evaluates a channel (or parameter) and return its value.</p><p>If the parameter is a vector parameter, the base parameter name\ncan be used to return the all components as a vector.</p><p>The time is specified in seconds, not in frames.</p></body>",
    "chr": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chr\">chr</a></h1><p class=\"summary\">Converts an unicode codepoint to a UTF8 string.</p><div class=\"usage\"> <code>string chr(int value)</code></div><p>Returns a string encoding the giving unicode codepoint as a UTF8 value.  For\nvalues less than 128, this is a one-byte string of that value.  Higher values\nwill produce multiple byte strings.</p><p>If the given code point isn\u2019t a valid codepoint, an empty string is returned.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ord\">ord</a></div></body>",
    "chramp": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chramp\">chramp</a></h1><p class=\"summary\">Evaluates a ramp parameter and return its value.</p><div class=\"usage\"> <code>float chramp(string channel, float ramppos)</code></div><div class=\"usage\"> <code>float chramp(string channel, float ramppos, float time)</code></div><div class=\"usage\"> <code>vector chramp(string channel, float ramppos)</code></div><div class=\"usage\"> <code>vector chramp(string channel, float ramppos, float time)</code></div><p>Evaluates a ramp parameter and return its value.</p><p>The ramppos is where on the ramp to evaluate.  The ramppos is clamped to the range <a href=\"https://www.sidefx.com/docs/houdini0,1\">0,1</a>.</p><p>The time parameter can be used if the ramp is animated to evaluate\nat other than the current time.</p></body>",
    "chrampderiv": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chrampderiv\">chrampderiv</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Evaluates the derivative of a parm parameter with respect to position.</p><div class=\"usage\"> <code>float chrampderiv(string channel, float ramppos)</code></div><div class=\"usage\"> <code>float chrampderiv(string channel, float ramppos, float time)</code></div><div class=\"usage\"> <code>vector chrampderiv(string channel, float ramppos)</code></div><div class=\"usage\"> <code>vector chrampderiv(string channel, float ramppos, float time)</code></div><p>Evaluates the derivative of a parm parameter with respect to position.</p><p>The ramppos is where on the ramp to evaluate.  The ramppos is clamped to the range <a href=\"https://www.sidefx.com/docs/houdini0,1\">0,1</a></p><p>The time parameter can be used if the ramp is animated to evaluate\nat other than the current time.\nNote that this does not take a derivative with respect to time.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chramp\">chramp</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch\">ch</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chf\">chf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chi\">chi</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chv\">chv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chs\">chs</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch3\">ch3</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch4\">ch4</a></div></body>",
    "chrate": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chrate\">chrate</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Returns the sample rate of the input specified.</p><div class=\"usage\"> <code>float chrate()</code></div><p>Uses <code>-1</code> as the <code>opinput</code>.</p><div class=\"usage\"> <code>float chrate(int opinput)</code></div><p>Returns the sample rate of the given input.</p></body>",
    "chreadbuf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chreadbuf\">chreadbuf</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Returns the value of CHOP context temporary buffer at the specified index.</p><div class=\"usage\"> <code>float chreadbuf(int index)</code></div><p>Returns the value of a CHOP context temporary buffer at the specified index.</p></body>",
    "chremove": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chremove\">chremove</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Removes channels from a CHOP node.</p><div class=\"usage\"> <code>int chremove(int channel_index)</code></div><div class=\"usage\"> <code>int chremove(int channel_indices[])</code></div><div class=\"usage\"> <code>int chremove(string channel_name)</code></div><div class=\"usage\"> <code>int chremove(string channel_names[])</code></div><p>This function removes  channels from a CHOP node. It works only when iterating over Clip, Channel or Samples, not when iterating over ChannelSample.</p><p>Returns 1 if all channels were removed or 0 otherwise. </p><div class=\"argument\"><code><code>channel_index</code></code></div><p>The channel index to remove.</p><div class=\"argument\"><code><code>channel_indices</code></code></div><p>The array of channel indices to remove.</p><div class=\"argument\"><code><code>channel_name</code></code></div><p>The channel name to remove.</p><div class=\"argument\"><code><code>channel_names</code></code></div><p>The array of channel names to remove.</p></body>",
    "chremoveattr": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chremoveattr\">chremoveattr</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Removes a CHOP attribute.</p><div class=\"usage\"> <code>int chremoveattr(string attrclass, string attrname)</code></div><div class=\"usage\"> <code>int chremoveattr(string attrclass, string attrnames[])</code></div><div class=\"usage\"> <code>int chremoveattr(string attrname)</code></div><div class=\"usage\"> <code>int chremoveattr(string attrnames[])</code></div><p>This function removes CHOP attribute.</p><div class=\"argument\"><code><code>attrname</code></code></div><p>The name of the attribute to remove.</p><div class=\"argument\"><code><code>attrnames</code></code></div><p>The names of the attributes to remove.</p><h2>Returns</h2><p>Returns <code>1</code> if the operation succeeded, or <code>0</code> otherwise.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chattr\">chattr</a></div></body>",
    "chrename": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chrename\">chrename</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Renames a CHOP channel.</p><div class=\"usage\"> <code>int chrename(int channel_index, string new_name)</code></div><div class=\"usage\"> <code>int chrename(string channel_name, string new_name)</code></div><p>This function renames a CHOP channel . It works only when iterating over Clip, Channel or Samples, not when iterating over ChannelSample.</p><p>Returns 1 if channel was renamed or 0 otherwise.</p><div class=\"argument\"><code><code>channel_index</code></code></div><p>The channel index to rename.</p><div class=\"argument\"><code><code>channel_name</code></code></div><p>The channel to rename.</p><div class=\"argument\"><code><code>new_name</code></code></div><p>The new name.</p></body>",
    "chresizebuf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chresizebuf\">chresizebuf</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Resize the CHOP context temporary buffer</p><div class=\"usage\"> <code>int chresizebuf(int size)</code></div><p>Resizes the CHOP context temporary buffer.\nReturn 1 if the resize succeeded, 0 otherwise.</p></body>",
    "chs": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chs\">chs</a></h1><p class=\"summary\">Evaluates a channel (or parameter) and return its value.</p><div class=\"usage\"> <code>string chs(string channel)</code></div><div class=\"usage\"> <code>string chs(string channel, float time)</code></div><p>Evaluates a channel (or parameter) and return its value.</p><p>The time is specified in seconds, not in frames.</p></body>",
    "chsetattr": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chsetattr\">chsetattr</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Sets the value of a CHOP attribute.</p><div class=\"usage\"> <code>int chsetattr(string attrclass, string attrname, int channel, int sample, &lt;type&gt; value)</code></div><p>Sets the attribute to the given value in the current CHOP.</p><div class=\"usage\"> <code>int chsetattr(string attrname, int channel, int sample, &lt;type&gt; value)</code></div><p>This version assumes the attribute class argument to be <code>\"\"</code> (guess the class from the other arguments).</p><p>This function sets the value of a CHOP attribute. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chattr\">chattr</a> to read CHOP attributes.</p><div class=\"argument\"><code>attrname</code></div><p>The name of the attribute to write.</p><div class=\"argument\"><code>value</code></div><p>The new attribute value. The type of the argment determines the type of the attribute.</p><h2>Returns</h2><p>Returns <code>1</code> if the write succeeded, or <code>0</code> otherwise.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chattr\">chattr</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chattrnames\">chattrnames</a></div></body>",
    "chsetlength": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chsetlength\">chsetlength</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Sets the length of the CHOP channel data.</p><div class=\"usage\"> <code>int chsetlength(int clip_length)</code></div><p>Sets the length of the channel data.</p></body>",
    "chsetrate": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chsetrate\">chsetrate</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Sets the sampling rate of the CHOP channel data.</p><div class=\"usage\"> <code>int chsetrate(int clip_rate)</code></div><div class=\"usage\"> <code>int chsetrate(float clip_rate)</code></div><p>Sets the sampling rate of the channel data.</p></body>",
    "chsetstart": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chsetstart\">chsetstart</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Sets the CHOP start sample in the channel data.</p><div class=\"usage\"> <code>int chsetstart(int start)</code></div><div class=\"usage\"> <code>int chsetstart(float start)</code></div><p>Sets the index of the first sample in the channel data.</p></body>",
    "chsop": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chsop\">chsop</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Evaluates an operator path parameter and return the path to the operator.</p><div class=\"usage\"> <code>string chsop(string channel)</code></div><div class=\"usage\"> <code>string chsop(string channel, float time)</code></div><p>Evaluates an operator path parameter and return the path to the operator.</p><p>The time is specified in seconds, not in frames.</p></body>",
    "chsraw": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chsraw\">chsraw</a></h1><p class=\"summary\">Returns the raw string channel (or parameter).</p><div class=\"usage\"> <code>string chsraw(string channel)</code></div><p>Returns the raw expression value of the channel without actually evaluating the contents of the channel.</p></body>",
    "chstart": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chstart\">chstart</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Returns the start sample of the input specified.</p><div class=\"usage\"> <code>int chstart()</code></div><p>Uses <code>-1</code> as the <code>opinput</code>.</p><div class=\"usage\"> <code>int chstart(int opinput)</code></div><p>Returns the index of the first sample in the channel data in the given CHOP input.</p><p>To get the start frame, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chstartf\">chstartf</a>. To get the start time in seconds, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chstartt\">chstartt</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chstartf\">chstartf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chstartt\">chstartt</a></div></body>",
    "chstartf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chstartf\">chstartf</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Returns the frame corresponding to the first sample of the input\nspecified.</p><div class=\"usage\"> <code>float chstartf()</code></div><p>Uses <code>-1</code> as the <code>opinput</code>.</p><div class=\"usage\"> <code>float chstartf(int opinput)</code></div><p>Returns the frame corresponding to the first sample of the given CHOP input.</p><p>To get the first sample number, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chstart\">chstart</a>. To get the start time in seconds, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chstartt\">chstartt</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chstart\">chstart</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chstartt\">chstartt</a></div></body>",
    "chstartt": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chstartt\">chstartt</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Returns the time corresponding to the first sample of the input\nspecified.</p><div class=\"usage\"> <code>float chstartt()</code></div><p>Uses <code>-1</code> as the <code>opinput</code>.</p><div class=\"usage\"> <code>float chstartt(int opinput)</code></div><p>Returns the time (in seconds) corresponding to the first sample of the given CHOP input.</p><p>To get the start sample number, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chstart\">chstart</a>. To get the start sample frame number, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chstartf\">chstartf</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chstart\">chstart</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chstartf\">chstartf</a></div></body>",
    "chu": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chu\">chu</a></h1><p class=\"summary\">Evaluates a channel or parameter, and return its value.</p><div class=\"usage\"> <code>vector2 chu(string channel)</code></div><div class=\"usage\"> <code>vector2 chu(string channel, float time)</code></div><p>Evaluates a channel or parameter, and return its value.</p><p>If the parameter is a vector parameter, the base parameter name\ncan be used to return the all components as a vector.</p><p>The time is specified in seconds, not in frames.</p></body>",
    "chv": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chv\">chv</a></h1><p class=\"summary\">Evaluates a channel or parameter, and return its value.</p><div class=\"usage\"> <code>vector chv(string channel)</code></div><div class=\"usage\"> <code>vector chv(string channel, float time)</code></div><div class=\"usage\"> <code>vector chv(int opid, int pid)</code></div><div class=\"usage\"> <code>vector chv(int opid, int pid, float time)</code></div><p>Evaluates a channel or parameter, and return its value.</p><p>If the parameter is a vector parameter, the base parameter name\ncan be used to return the all components as a vector.</p><p>The time is specified in seconds, not in frames.</p></body>",
    "chwritebuf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chwritebuf\">chwritebuf</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Writes a value of CHOP context temporary buffer at the specified index.</p><div class=\"usage\"> <code>int chwritebuf(int index, float value)</code></div><div class=\"usage\"> <code>int chwritebuf(int index, vector t, vector r, vector s)</code></div><p>Writes a value of a CHOP context temporary buffer at the specified index.\nReturn 1 if the write succeeded, 0 otherwise.</p></body>",
    "cinput": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cinput\">cinput</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Samples the exact (unfiltered) pixel color at the given coordinates.</p><div class=\"usage\"> <code>vector cinput(int u, int v, ...)</code></div><div class=\"usage\"> <code>vector4 cinput(int u, int v, ...)</code></div><div class=\"usage\"> <code>vector cinput(float u, float v, ...)</code></div><div class=\"usage\"> <code>vector4 cinput(float u, float v, ...)</code></div><div class=\"usage\"> <code>float cinput(int component, int u, int v, ...)</code></div><div class=\"usage\"> <code>float cinput(int component, float u, float v, ...)</code></div><div class=\"usage\"> <code>vector cinput(int opinput, int planeindex, int u, int v, ...)</code></div><div class=\"usage\"> <code>vector4 cinput(int opinput, int planeindex, int u, int v, ...)</code></div><div class=\"usage\"> <code>vector cinput(int opinput, int planeindex, float u, float v, ...)</code></div><div class=\"usage\"> <code>vector4 cinput(int opinput, int planeindex, float u, float v, ...)</code></div><div class=\"usage\"> <code>float cinput(int opinput, int planeindex, int component, int u, int v, ...)</code></div><div class=\"usage\"> <code>float cinput(int opinput, int planeindex, int component, float u, float v, ...)</code></div><div class=\"usage\"> <code>vector cinput(int opinput, int planeindex, int arrayindex, int u, int v, int frame, ...)</code></div><div class=\"usage\"> <code>vector4 cinput(int opinput, int planeindex, int arrayindex, int u, int v, int frame, ...)</code></div><div class=\"usage\"> <code>vector cinput(int opinput, int planeindex, int arrayindex, float u, float v, int frame, ...)</code></div><div class=\"usage\"> <code>vector4 cinput(int opinput, int planeindex, int arrayindex, float u, float v, int frame, ...)</code></div><div class=\"usage\"> <code>float cinput(int opinput, int planeindex, int arrayindex, int component, int u, int v, int frame, ...)</code></div><div class=\"usage\"> <code>float cinput(int opinput, int planeindex, int arrayindex, int component, float u, float v, int frame, ...)</code></div><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/cop_sample_suite\">COP pixel sampling functions</a> for more information.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/cop_sample_suite\">/vex/cop_sample_suite</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/binput\">binput</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/finput\">finput</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ninput\">ninput</a></div></body>",
    "ckspline": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ckspline\">ckspline</a></h1><p class=\"summary\">Samples a Catmull-Rom (Cardinal) spline defined by position/value keys.</p><p>To specify the curve using uniformly spaced value keys, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cspline\">cspline</a>.</p><div class=\"usage\"> <code>float ckspline(float t, float value, float pos, ...)</code></div><div class=\"usage\"> <code>vector ckspline(float t, vector value, float pos, ...)</code></div><div class=\"usage\"> <code>vector4 ckspline(float t, vector4 value, float pos, ...)</code></div><div class=\"argument\"><code>t</code></div><p>The position along the spline to sample.</p><div class=\"argument\"><code><code>value</code>, <code>pos</code>, <code>...</code></code></div><p>A series of pairs of key values and positions that defines the curve to sample.</p><h2>Returns</h2><p>The interpolated value at position <code>t</code> along the curve.</p><p>Computes a Catmull-Rom (Cardinal) spline between the key points\nspecified. The values are spaced according to the keys given. The domain\nof the interpolant (t) should be between the second and second last key\nvalue specified. The keys should be specified in ascending order or\nresults will be unpredictable.</p><p>Because of the nature of the Cardinal spline, the value associated with\nthe first and last keys will never be returned. However, these keys are\nused to determine the shape of the curve on entry and exit. For\nexample:</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">Cf = ckspline(t,</code><code class=\"codeline\">        {1,1,1},    -0.25,    // First key</code><code class=\"codeline\">        {.5,.5,.5},  0.0,    // Second key</code><code class=\"codeline\">        {.5, 0,.5},  0.25,    // Third key</code><code class=\"codeline\">        {0,0,.8},    1.0,    // Fourth key</code><code class=\"codeline\">        {0,0,0},     1.25    // Fifth key</code><code class=\"codeline\">    );</code></div><p>The Catmull-Rom spline defined by the above keys would be valid for\n    interpolants in the range 0 to 1. The first and last keys are used\n    solely to determine the slope of the curve at the second and second last\n    keys.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cspline\">cspline</a></div></body>",
    "clamp": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/clamp\">clamp</a></h1><p class=\"summary\">Returns value clamped between min and max.</p><div class=\"usage\"> <code>int clamp(int value, int min, int max)</code></div><div class=\"usage\"> <code>float clamp(float value, float min, float max)</code></div><p>Returns <code class=\"var\">value</code> clamped between <code class=\"var\">min</code> and <code class=\"var\">max</code>.</p><div class=\"usage\"> <code>vector2 clamp(vector2 value, vector2 min, vector2 max)</code></div><div class=\"usage\"> <code>vector clamp(vector value, vector min, vector max)</code></div><div class=\"usage\"> <code>vector4 clamp(vector4 value, vector4 min, vector4 max)</code></div><p>Returns a new vector containing the clamped value of each component.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit\">fit</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit01\">fit01</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit10\">fit10</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit11\">fit11</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/efit\">efit</a></div></body>",
    "clip": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/clip\">clip</a></h1><p class=\"summary\">Clip the line segment between p0 and p1.</p><div class=\"usage\"> <code>void clip(int &amp;result, vector &amp;p0, vector &amp;p1, vector4 plane)</code></div><p>clip the line segment against an arbitrary 3D plane specified by the\nplane equation (plane.x*x + plane.y*y + plane.z*z + plane.w).</p><div class=\"usage\"> <code>void clip(int &amp;result, vector &amp;p0, vector &amp;p1, vector min, vector max)</code></div><p>clip the line segment to the bounding box specified by the min and max\ncorner points.</p><p>clip the line segment between p0 and p1.</p><p>If the line is entirely clipped out of the result will be set to 0.\notherwise, the values p0 and p1 will be clipped to the constraints\nspecified and the result will be 1.</p></body>",
    "colormap": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/colormap\">colormap</a></h1><p class=\"summary\">Looks up a (filtered) color from a texture file.</p><p>This function does bilinear interpolation of the pixel values. To get unfiltered pixel values, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rawcolormap\">rawcolormap</a>.</p><div class=\"usage\"> <code>vector|vector4 colormap(string filename, vector uvw, ...)</code></div><p>Uses the first two components of <code class=\"var\">uvw</code> as unit (0-1) coordinates to point sample the texture file.</p><div class=\"usage\"> <code>vector|vector4 colormap(string filename, float u, float v, ...)</code></div><p>Uses <code class=\"var\">u</code> and <code class=\"var\">v</code> as unit (0-1) coordinates to point sample the texture file.</p><div class=\"usage\"> <code>vector|vector4 colormap(string filename, vector uv, vector du, vector dv, int samples, ...)</code></div><p>Uses the quadrilateral formed by <code>(uv)-(uv+du)-(uv+du+dv)-(uv+dv)</code> to area sample the texture file.\n    Takes <code class=\"var\">samples</code> number of stochastic samples (unless the image is a .rat file).</p><div class=\"usage\"> <code>vector|vector4 colormap(string filename, vector uv0, vector uv1, vector uv2, vector uv3, ...)</code></div><p>Uses the quadrilateral formed by <code>(uv0)-(uv1)-(uv2)-(uv3)</code> to area sample the texture file.</p><div class=\"usage\"> <code>vector|vector4 colormap(string filename, vector uv0, vector uv1, vector uv2, vector uv3, int samples, ...)</code></div><p>Uses the quadrilateral formed by <code>(uv0)-(uv1)-(uv2)-(uv3)</code> to area sample the texture file.\n    Takes <code class=\"var\">samples</code> number of stochastic samples (unless the image is a .rat file).</p><div class=\"usage\"> <code>vector|vector4 colormap(string filename, float u0, float v0, float u1, float v1, float u2, float v2, float u3, float v3, int samples, ...)</code></div><p>Uses the quadrilateral formed by <code>(uv0)-(uv1)-(uv2)-(uv3)</code> to area sample the texture file.\n    Takes <code class=\"var\">samples</code> number of stochastic samples (unless the image is a .rat file).</p><h2>Returns</h2><p>If you call the function with a <code>vector4</code> return type, the fourth component is the alpha channel of the texture. If the image does not have alpha, the fourth component is always <code>1</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rawcolormap\">rawcolormap</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texture\">texture</a></div></body>",
    "colorname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/colorname\">colorname</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the default name of the color plane (as it appears in the\ncompositor preferences).</p><div class=\"usage\"> <code>string colorname()</code></div><p>Returns the default name of the color plane (as it appears in the\ncompositor preferences). Using this instead of hardcoding the default\nmakes your code more portable. Default is C.</p></body>",
    "combinelocaltransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/combinelocaltransform\">combinelocaltransform</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Combines Local and Parent Transforms with Scale Inheritance.</p><div class=\"usage\"> <code>matrix combinelocaltransform(matrix local, matrix parent_world, matrix parent_local, int scale_inherit_mode)</code></div><p>Returns a new world transform given its local and parent world transforms.</p><div class=\"usage\"> <code>matrix combinelocaltransform(matrix local, matrix parent_world, matrix parent_local, int scale_inherit_mode, matrix &amp;effective_local_transform)</code></div><p>Returns a new world transform given its local and parent world transforms. The local transform including any inherited scales is stored in the effective_local_transform matrix - this value will differ from the local matrix when the mode is set to SCALE_INHERIT_OFFSET_AND_SCALE or SCALE_INHERIT_SCALE_ONLY where we pass a parent\u2019s local scales onto its children as part of their own local transforms.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/extractlocaltransform\">extractlocaltransform</a></div></body>",
    "computenormal": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/computenormal\">computenormal</a></h1><p class=\"summary\">In shading contexts, computes a normal. In the SOP contexts, sets how/whether to recompute normals.</p><div class=\"usage\"> <code>vector computenormal(vector P, ...)</code></div><p>In shading contexts, computes the normal for position P using the cross product of the derivatives of P.</p><div class=\"usage\"> <code>vector computenormal(vector P, vector N, vector Ng, ...)</code></div><p>In shading contexts, computes the normal for position P using the cross product of the derivatives of P.\n    <code class=\"var\">N</code> is the original surface normal and <code class=\"var\">Ng</code> is the geometric normal.\n    This version adjusts the computed normal so interpolated normals will be relatively correct.</p><div class=\"usage\"> <code>void computenormal(int i)</code></div><p>(Obsolete) In SOP context, sets the hint for whether normals should be recomputed when <code>P</code> or <code>N</code> change (0=never, 1=automatic, 2=always).</p></body>",
    "concat": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/concat\">concat</a></h1><p class=\"summary\">Concatenate all the strings specified to form a single string.</p><div class=\"usage\"> <code>string concat(string s1, string s2, ...)</code></div><p>Concatenate the arguments to form a single string.</p><p>This is equivalent to <code>s1 + s2 + s3 ...</code>.\nHowever, <code>concat()</code> is slightly more efficient with more than 2 strings.</p></body>",
    "cone": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cone\">cone</a></h1><p class=\"summary\">Returns a cone reflection BSDF.</p><div class=\"usage\"> <code>bsdf cone(vector normal, vector dir, float angle, ...)</code></div><p>Returns a <code>bsdf</code> representing a cone reflection along a given direction vector. This BSDF is constant within the given <code class=\"var\">angle</code>, producing a similar result to the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gather\">gather</a> or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/irradiance\">irradiance</a> loops.</p><div class=\"usage\"> <code>bsdf cone(vector dir, float angle, ...)</code></div><p>In shading contexts, fills in the current surface normal automatically.</p><p><a href=\"https://www.sidefx.com/docs/houdini/images/rendering/cone.png\">/images/rendering/cone.png</a></p><div class=\"argument\"><code>normal</code></div><p>The surface normal direction.</p><div class=\"argument\"><code>dir</code></div><p>The direction of specularity.</p><div class=\"argument\"><code>angle</code></div><p>Cone angle <strong>in radians</strong>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "cos": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cos\">cos</a></h1><p class=\"summary\">Returns the cosine of the argument.</p><div class=\"usage\"> <code>float cos(float n)</code></div><p>Returns the cosine of <code>n</code>, where <code>n</code> is in radians.</p><div class=\"usage\"> <code>vector2 cos(vector2 n )</code></div><div class=\"usage\"> <code>vector cos(vector n )</code></div><div class=\"usage\"> <code>vector4 cos(vector4 n )</code></div><p>Returns a new vector with <code>cos()</code> applied to each component.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/acos\">acos</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cosh\">cosh</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sin\">sin</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tan\">tan</a></div></body>",
    "cosh": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cosh\">cosh</a></h1><p class=\"summary\">Returns the hyperbolic cosine of the argument.</p><div class=\"usage\"> <code>float cosh(float n)</code></div><p>Returns the hyperbolic cosine of the argument.</p><div class=\"usage\"> <code>vector2 cosh(vector2 v)</code></div><div class=\"usage\"> <code>vector cosh(vector v)</code></div><div class=\"usage\"> <code>vector4 cosh(vector4 v)</code></div><p>Returns a new vector with <code>cosh()</code> applied to each component.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cos\">cos</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sinh\">sinh</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tanh\">tanh</a></div></body>",
    "cracktransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cracktransform\">cracktransform</a></h1><p class=\"summary\">Depending on the value of c, returns the translate (c=0), rotate\n(c=1), scale (c=2), or shears (c=3)  component of the transform (xform).</p><div class=\"usage\"> <code>vector cracktransform(int trs, int xyz, int c, vector pivot, vector pivot_rotate, matrix xform)</code></div><div class=\"usage\"> <code>vector cracktransform(int trs, int xyz, int c, vector pivot, matrix xform)</code></div><p>Depending on the value of <code class=\"var\">c</code>, returns the translate (<code>c=0</code>), rotate\n(<code>c=1</code> or <code>c=4</code>), scale (<code>c=2</code>) or shears (<code>c=3</code>) component of the transform (<code class=\"var\">xform</code>). The\nfunction uses the given transform and rotation orders (<code class=\"var\">trs</code> and\n<code class=\"var\">xyz</code>) , the given pivot point (<code class=\"var\">pivot</code>) and optional pivot rotation (<code class=\"var\">pr</code>) to calculate the return\nvalue. The specifications for the <code class=\"var\">trs</code> and <code class=\"var\">xyz</code> parameters can be\nfound in <code>$HFS/houdini/vex/include/math.h</code>.</p><h2>Note</h2><p>Rotation angles (when <code>c=1</code>) are returned in degrees, whereas many other VEX functions use radians.\n    You can use the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/radians\">radians</a> VEX function to convert the vector of angles in degrees to a vector of angles in radians.\n    For example: <code>vector angles = radians(cracktransform(XFORM_TRS, XFORM_XYZ, 1, {0,0,0}, M));</code></p><h2>Note</h2><p>Rotation angles (when <code>c=4</code>) are returned in radians.</p><div class=\"usage\"> <code>void cracktransform(int trs, int xyz, vector pivot, vector pivot_rotate, matrix xform, vector &amp;t, vector &amp;r, vector &amp;s, vector &amp;shears)</code></div><p>Returns the translate, rotate, scale, and shear components of <code class=\"var\">xform</code> in <code class=\"var\">t</code>, <code class=\"var\">r</code>, <code class=\"var\">s</code>, and <code class=\"var\">shears</code>, respectively.\nIf more than one component is needed, using this overload is more efficient than making multiple calls to the other function signature.</p><div class=\"usage\"> <code>void cracktransform(int trs, int xyz, vector pivot, matrix xform, vector &amp;t, vector &amp;r, vector &amp;s)</code></div><p>Returns the translate, rotate, and scale of <code class=\"var\">xform</code> in <code class=\"var\">t</code>, <code class=\"var\">r</code>, <code class=\"var\">s</code> respectively.\nThis overload doesn\u2019t support pivot_rotate or shears.\nIf more than one component is needed, using this overload is more efficient than making multiple calls to the other function signature.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/quaternion\">quaternion</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/polardecomp\">polardecomp</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/eulertoquaternion\">eulertoquaternion</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/qconvert\">qconvert</a></div></body>",
    "create_cdf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/create_cdf\">create_cdf</a></h1><p class=\"summary\">Creates a cumulative distribution function (CDF) from an array of probability density function (PDF) values.</p><h2>Overview</h2><p>CDFs are useful when sampling from distributions. For example, you could create a CDF of light source power. This would allow sampling of lights with a probability based on power. This is an example of a discrete CDF, where sampling selects among a fixed set of probabilities. (See the example below.)</p><p>Use the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_cdf\">sample_cdf</a> function to sample values from the returned CDF array.</p><h2>Usage</h2><div class=\"usage\"> <code>float[] create_cdf(float pdf[])</code></div><p>Returns a CDF for the input PDF as an array of floats.</p><div class=\"argument\"><code>pdf</code></div><p>Array of PDF values to create the CDF for.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Iterate over all lights, sampling their power</code><code class=\"codeline\">int[] li = getlights();</code><code class=\"codeline\">float values[];</code><code class=\"codeline\">resize(values, len(li));</code><code class=\"codeline\">int nsamples = 256;</code><code class=\"codeline\">int sid = israytrace ? SID : newsampler();</code><code class=\"codeline\">vector s, pos, clr;</code><code class=\"codeline\">float scale;</code><code class=\"codeline\">for (int i = 0; i &lt; len(li); i++)</code><code class=\"codeline\">{</code><code class=\"codeline\">    for (int j = 0; j &lt; nsamples; j++)</code><code class=\"codeline\">    {</code><code class=\"codeline\">        nextsample(sid, s.x, s.y, \"mode\", \"nextpixel\");</code><code class=\"codeline\">        sample_light(li[i], P, s, Time, pos, clr, scale);</code><code class=\"codeline\">        values[i] += luminance(clr);</code><code class=\"codeline\">    }</code><code class=\"codeline\">    values[i] /= nsamples;</code><code class=\"codeline\">}</code><code class=\"codeline\"></code><code class=\"codeline\">// Create a CDF of the power distribution</code><code class=\"codeline\">float cdf[] = create_cdf(values);</code><code class=\"codeline\"></code><code class=\"codeline\">// Randomly select a light based on power distribution</code><code class=\"codeline\">nextsample(sid, s.x, s.y, \"mode\", \"nextpixel\");</code><code class=\"codeline\">int index = 0;</code><code class=\"codeline\">sample_cdf(cdf, s.x, index);</code><code class=\"codeline\"></code><code class=\"codeline\">// Do something with the selected light</code><code class=\"codeline\">// li[index] ...</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/create_pdf\">create_pdf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_cdf\">sample_cdf</a></div></body>",
    "create_pdf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/create_pdf\">create_pdf</a></h1><p class=\"summary\">Creates a probability density function from an array of input values.</p><div class=\"usage\"> <code>float[] create_pdf(float values[])</code></div><p>Create a PDF for the input <code>values</code> array and return it as a float array.</p><div class=\"argument\"><code>values</code></div><p>Array of values to create the PDF for.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/spline_cdf\">spline_cdf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_cdf\">sample_cdf</a></div></body>",
    "cregioncapturetransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cregioncapturetransform\">cregioncapturetransform</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the capture transform associated with a Capture Region SOP.</p><div class=\"usage\"> <code>matrix cregioncapturetransform(string path)</code></div><div class=\"usage\"> <code>matrix cregioncapturetransform(string path, float time)</code></div><div class=\"usage\"> <code>matrix cregioncapturetransform(int op_id)</code></div><div class=\"usage\"> <code>matrix cregioncapturetransform(int op_id, float time)</code></div><p>Returns the capture transform associated with a Capture Region SOP.\nThe transform is built from the parameters of the SOP without cooking the SOP.\nIt is possible to specify the time to evaluate the transform at (in seconds, not frames).</p><h2>Note</h2><p>The op: syntax can be used to simulate this behavior using the standard transform functions.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ntransform\">ntransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getspace\">getspace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparmtransform\">opparmtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/oppreconstrainttransform\">oppreconstrainttransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparmtransform\">opparmtransform</a></div></body>",
    "cregiondeformtransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cregiondeformtransform\">cregiondeformtransform</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the deform transform associated with a Capture Region SOP.</p><div class=\"usage\"> <code>matrix cregiondeformtransform(string path)</code></div><div class=\"usage\"> <code>matrix cregiondeformtransform(string path, float time)</code></div><div class=\"usage\"> <code>matrix cregiondeformtransform(int op_id)</code></div><div class=\"usage\"> <code>matrix cregiondeformtransform(int op_id, float time)</code></div><p>Returns the deform transform associated with a Capture Region SOP.\nThe transform is built from the parameters of the SOP without cooking the SOP.\nIt is possible to specify the time to evaluate the transform at (in seconds, not frames).</p><h2>Note</h2><p>The op: syntax can be used to simulate this behavior using the standard transform functions.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ntransform\">ntransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getspace\">getspace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparmtransform\">opparmtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/oppreconstrainttransform\">oppreconstrainttransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparmtransform\">opparmtransform</a></div></body>",
    "cregionoverridetransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cregionoverridetransform\">cregionoverridetransform</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the capture or deform transform associated with a Capture Region SOP based on the global capture override flag.</p><div class=\"usage\"> <code>matrix cregionoverridetransform(string path)</code></div><div class=\"usage\"> <code>matrix cregionoverridetransform(string path, float time)</code></div><div class=\"usage\"> <code>matrix cregionoverridetransform(int op_id)</code></div><div class=\"usage\"> <code>matrix cregionoverridetransform(int op_id, float time)</code></div><p>Returns the capture or deform transform associated with a Capture Region SOP based on the global capture override flag.\nThe transform is built from the parameters of the SOP without cooking the SOP.\nIt is possible to specify the time to evaluate the transform at (in seconds, not frames).</p><h2>Note</h2><p>The op: syntax can be used to simulate this behavior using the standard transform functions.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ntransform\">ntransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getspace\">getspace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparmtransform\">opparmtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/oppreconstrainttransform\">oppreconstrainttransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparmtransform\">opparmtransform</a></div></body>",
    "cross": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cross\">cross</a></h1><p class=\"summary\">Returns the cross product between the two vectors.</p><div class=\"usage\"> <code>vector cross(vector a, vector b)</code></div><p>Returns the <a href=\"https://en.wikipedia.org/wiki/Cross_product\">cross product</a> between the two vectors.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/dot\">dot</a></div></body>",
    "cspline": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cspline\">cspline</a></h1><p class=\"summary\">Samples a Catmull-Rom (Cardinal) spline defined by uniformly spaced keys.</p><p>To specify the curve using unevenly spaced keys, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ckspline\">ckspline</a>.</p><div class=\"usage\"> <code>float cspline(float t, float val1, ...)</code></div><div class=\"usage\"> <code>vector cspline(float t, vector val1, ...)</code></div><div class=\"usage\"> <code>vector4 cspline(float t, vector4 val1, ...)</code></div><div class=\"argument\"><code>t</code></div><p>The position along the spline to sample.</p><div class=\"argument\"><code><code>val1</code>, <code>val2</code>, <code>...</code></code></div><p>A series of of key values. The keys are assumed to be uniformly spaced along a range from 0 to 1.</p><h2>Returns</h2><p>The interpolated value at position <code>t</code> along the curve.</p><p>Computes a Catmull-Rom (Cardinal) spline between the key points\nspecified.</p><p>Because of the nature of the Cardinal spline, the value associated with\nthe first and last keys will never be returned. However, these keys are\nused to determine the shape of the curve on entry and exit.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ckspline\">ckspline</a></div></body>",
    "ctransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ctransform\">ctransform</a></h1><p class=\"summary\">Transforms between color spaces.</p><div class=\"usage\"> <code>vector ctransform(string fromspace, string tospace; vector clr)</code></div><div class=\"usage\"> <code>vector ctransform(string tospace; vector clr)</code></div><p>If you don\u2019t give a <code class=\"var\">fromspace</code>, assumes <code>\"cspace:rgb\"</code>.</p><p>Transforms color tuple <code class=\"var\">clr</code> from one color space to another.</p><p>The possible arguments for <code class=\"var\">fromspace</code> and <code class=\"var\">tospace</code> are\n<code>\"cspace:rgb\"</code>, <code>\"cspace:hsl\"</code>, <code>\"cspace:hsv\"</code>, <code>\"cspace:XYZ\"</code>,\n<code>\"cspace:Lab\"</code>, and <code>\"cspace:tmi\"</code>.</p><h2>Notes</h2><div class=\"related\">The hue-based systems are normalized with the hue going from <code>0</code> to <code>1</code>. LAB and TMI are not normalized.</div><div class=\"related\">For <code>\"cspace:rgb\"</code>, the primaries are assumed to be in linear NTSC space (gamma 1.0), using C reference white.</div><div class=\"related\">C reference white is used for conversion when converting from XYZ to LAB space (and vice versa).</div></body>",
    "curlgxnoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/curlgxnoise\">curlgxnoise</a></h1><p class=\"summary\">Computes divergence free noise based on simplex noise.</p><div class=\"usage\"> <code>vector curlgxnoise(vector xyz)</code></div><div class=\"usage\"> <code>vector curlgxnoise(vector4 xyzt)</code></div><p>Evaluates a divergence free vector field by computing curl of simplex noise\n(see <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gxnoise\">gxnoise</a>).</p></body>",
    "curlgxnoise2d": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/curlgxnoise2d\">curlgxnoise2d</a></h1><p class=\"summary\">Computes divergence free noise in the plane based on simplex noise.</p><div class=\"usage\"> <code>vector curlgxnoise2d(vector2 xy)</code></div><div class=\"usage\"> <code>vector curlgxnoise2d(float x, float y)</code></div><div class=\"usage\"> <code>vector curlgxnoise2d(vector xyz)</code></div><div class=\"usage\"> <code>vector curlgxnoise2d(vector4 xyzt)</code></div><p>Evaluates a divergence free vector field by computing curl of one-dimensional\nsimplex noise (see <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gxnoise\">gxnoise</a>). The first two components of the\noutput vector contain the divergence free noise, and its final component is 0.</p></body>",
    "curlnoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/curlnoise\">curlnoise</a></h1><p class=\"summary\">Computes divergence free noise based on Perlin noise.</p><div class=\"usage\"> <code>vector curlnoise(vector xyz)</code></div><div class=\"usage\"> <code>vector curlnoise(vector4 xyzt)</code></div><p>Computes a divergence free vector field based on the cross product of the derivatives of two Perlin noise functions.</p><h2>Related</h2></body>",
    "curlnoise2d": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/curlnoise2d\">curlnoise2d</a></h1><p class=\"summary\">Computes 2d divergence free noise based on Perlin noise.</p><div class=\"usage\"> <code>vector curlnoise2d(float x, float y)</code></div><div class=\"usage\"> <code>vector curlnoise2d(vector xyt)</code></div><p>Computes a divergence free vector field based on the cross product of the derivatives of two Perlin noise functions.</p><p>The resulting vectors all lie along the X-Y plane.</p><h2>Note</h2><p>This is not the same as projecting a <code>curlnoise</code> to a plane.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/random\">noise and randomness</a>  in the VEX language\nguide for more information.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/curlnoise\">pnoise</a></div></body>",
    "curlxnoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/curlxnoise\">curlxnoise</a></h1><p class=\"summary\">Computes divergence free noise based on Simplex noise.</p><div class=\"usage\"> <code>vector curlxnoise(vector xyz)</code></div><div class=\"usage\"> <code>vector curlxnoise(vector4 xyzt)</code></div><p>Computes a divergence free vector field based on the cross product of the derivatives of two simplex noise functions.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/random\">noise and randomness</a>  in the VEX language\nguide for more information.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/curlnoise\">pnoise</a></div></body>",
    "curlxnoise2d": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/curlxnoise2d\">curlxnoise2d</a></h1><p class=\"summary\">Computes 2d divergence free noise based on simplex noise.</p><div class=\"usage\"> <code>vector curlxnoise2d(float x, float y)</code></div><div class=\"usage\"> <code>vector curlxnoise2d(vector xyt)</code></div><p>Computes a divergence free vector field based on the cross product of the derivatives of two simplex noise functions.</p><p>The resulting vectors all lie along the X-Y plane.</p><h2>Note</h2><p>This is not the same as projecting a <code>curlnoise</code> to a plane!</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/random\">noise and randomness</a>  in the VEX language\nguide for more information.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/curlxnoise\">pnoise</a></div></body>",
    "curvearclen": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/curvearclen\">curvearclen</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Evaluates the length of an arc on a primitive defined by an array of points using parametric uv coordinates.</p><div class=\"usage\"> <code>float curvearclen(vector positions[]; float uv1; float uv2; int closedflag; int fmt; int order)</code></div><div class=\"usage\"> <code>float curvearclen(vector positions[]; float uv1; float uv2; int closedflag; int fmt; int order; int divs)</code></div><div class=\"usage\"> <code>float curvearclen(vector positions[]; float uv1; float uv2; int closedflag; int fmt; int order; int divs; int primuvmode)</code></div><div class=\"usage\"> <code>float curvearclen(vector positions[]; float uv1; float uv2; int closedflag; int fmt; int order; int divs; int primuvmode; float primuvtol)</code></div><p>Returns the arc length between two parametric UV coordinates on a given primitive. This lets you measure the distance across a polygon face or along a curve.</p><div class=\"argument\"><code>points</code></div><p>The array of control points to define the curve.</p><div class=\"argument\"><code>uv1</code></div><p>The start coordinate in the primitive\u2019s parametric space to measure between.</p><div class=\"argument\"><code>uv2</code></div><p>The end coordinate in the primitive\u2019s parametric space to measure between.</p><div class=\"argument\"><code>closedflag</code></div><p>The curve can be closed or open. In a closed curve, the last control point will be connected to the first one.</p><div class=\"argument\"><code>fmt</code></div><p>The curve type to create. You can used constants defined in math.h, or 0 to create a polygon curve, 1 to create a bezier curve or 2 to create a NURBS curve.</p><div class=\"argument\"><code>order</code></div><p>The curve order for NURBS or Bezier curves. This is ignored for polygon curves.</p><div class=\"argument\"><code>divs</code></div><p>The number of divisions per segment to use or 10 if not supplied.</p><div class=\"argument\"><code>primuvmode</code></div><p>Define the uv1 and uv2 coordinates units. See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primuvconvert\">primuvconvert</a> for the list of modes.</p><div class=\"argument\"><code>primuvtol</code></div><p>A tolerance used when computing the curve length to do uv coordinates conversions.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primarclen\">primarclen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primuvconvert\">primuvconvert</a></div></body>",
    "cvex_bsdf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cvex_bsdf\">cvex_bsdf</a></h1><p class=\"summary\">Creates a bsdf object from two CVEX shader strings.</p><div class=\"usage\"> <code>bsdf cvex_bsdf(string eval_cvex_shader, string sampler_cvex_shader, ...)</code></div><p>This function lets you define a BSDF reflectance function through a pair of <code>cvex</code> shaders:\nOne to <a href=\"https://www.sidefx.com/docs/houdini#eval_fn\">evaluate the reflectance function</a> and another to <a href=\"https://www.sidefx.com/docs/houdini#sample_fn\">sample</a> it.</p><p>You pass the shaders as VEX source strings in the first two arguments.\nYou can then use variadic arguments to define arbitrary data that will be passed to the shaders when they are invoked.</p><h2>Warning</h2><p>This interface is subject to change in future versions of Houdini,\n    though any potential changes will likely not require fundamental\n    changes to the structure of your shaders.</p><h2>Evaluation Function</h2><p>The evaluation function must accept the following arguments:</p><div class=\"codeblock\"><code class=\"codeline\">(vector u, vector v, int bounces, int reverse, vector &amp;refl, vector &amp;eval, float &amp;pdf)</code></div><div class=\"argument\"><code>u</code></div><p>Outgoing light direction, from the surface to the viewer.</p><div class=\"argument\"><code>v</code></div><p>Incoming light direction, from the surface to the light.</p><div class=\"argument\"><code>bounces</code></div><p>A mask specifying the type of reflections that should be evaluated.</p><div class=\"argument\"><code>reverse</code></div><p>Whether evaluating from the camera (<code>0</code>) or the light source (<code>1</code>).</p><div class=\"argument\"><code>refl</code></div><p>The function must overwrite this variable with the reflectivity (albedo) of the BSDF.</p><p>This should not be dependent on the <code>v</code> vector, since it is used as an average reflectivity over all lighting directions.  This is the value that the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/albedo\">albedo</a> function will return.</p><div class=\"argument\"><code>eval</code></div><p>The function must overwrite this variable with the evaluated reflectance for the given directions.</p><p>Set this to <code>0</code> to indicates to mantra whether the BSDF is a delta function. Delta functions reflect light in specific directions or lines, and are handled as a special case in the lighting algorithm to produce less noisy results.  The behavior of a delta BSDF is determined by the sampling function (below).</p><div class=\"argument\"><code>pdf</code></div><p>The function must overwrite this variable with the sampling pdf for the given directions.  The integral of this value over the sphere should be equal to <code>luminance(refl)*2*PI</code>.  For perfect importance sampling, <code>pdf == luminance(eval)</code>.</p><h2>Sampling Function</h2><p>The sampling function is responsible for selecting a random reflection direction that is importance sampled from the distribution defined by the evaluation function (above).</p><p>The sampling function must accept the following arguments:</p><div class=\"codeblock\"><code class=\"codeline\">(vector u, float sx, float sy, int bounces, vector &amp;refl, vector &amp;v, int &amp;bouncetype, float &amp;pdf)</code></div><p>If the evaluation function is a delta function (indicated by the evaluation function setting <code>eval</code> to <code>0</code>), you are free to choose the sampling directions in any way you want.  Otherwise, you should choose directions from a distribution that either matches the evaluation function or is close to it.  The <code>sx</code> and <code>sy</code> inputs are available to help produce high quality sample distributions. These values are initialized directly from mantra\u2019s pixel sampling patterns.</p><div class=\"argument\"><code>u</code></div><p>Outgoing light direction, from the surface to the viewer.</p><div class=\"argument\"><code>sx</code></div><p>Uniform random value between 0 and 1, correlated with sy in a 2D sampling pattern.</p><div class=\"argument\"><code>sy</code></div><p>Uniform random value between 0 and 1, correlated with sx in a 2D sampling pattern.</p><div class=\"argument\"><code>bounces</code></div><p>A mask specifying the type of reflections that should be evaluated.</p><div class=\"argument\"><code>refl</code></div><p>The reflectivity (albedo) of the BSDF, tinted by the color of the light in the sampled direction.  The luminance of this value should match <code>refl</code> from the evaluation function. If the sampling distribution does not match the evaluation function exactly, this value should be scaled by the ratio of the evaluation distribution to the sampling distribution.</p><div class=\"argument\"><code>v</code></div><p>Sampled light direction, from the surface to the light.</p><div class=\"argument\"><code>bouncetype</code></div><p>The specific component type selected by sampling.</p><div class=\"argument\"><code>pdf</code></div><p>The sampling pdf.  The integral of this value over the sphere should be a constant <code>2*PI</code>. Note that this differs from the <code>pdf</code> produced by the evaluation function by a factor of <code>luminance(refl)</code>.</p><p>Since Houdini 13, it is not necessary for the sampling function to directly sample from the evaluation function\u2019s distribution.  To use a different sampling function, adjust the <code>pdf</code> outputs from both the evaluation and sampling shaders so that they reflect the distribution being sampled.</p><h2>Component mask implicit argument</h2><p>If you add an <code>int mybounces</code> output argument to your evaluation or sample shader, it will be filled in with the component mask for the BSDF. You can check this against an extra <code>\"label\"</code> variadic argument passed to the <code>cvex_bsdf()</code> function to see if it should apply. This allows you to use the same CVEX shader source code for different component types.</p><h2>Custom variadic arguments</h2><p>Any extra <code>\"key\", value</code> pairs passed to the <code>cvex_bsdf()</code> after the shader strings define custom arguments that will be passed to the shaders when they are invoked.</p><div class=\"codeblock\"><code class=\"codeline\">F = cvex_bsdf(\"...\", \"...\", \"label\", \"diffuse\", \"N\", N);</code></div><p>In particular, you should provide a label keyword argument to specify the type of component for the new BSDF (for example, <code>\"diffuse\"</code> or <code>\"reflect\"</code>). You can specify multiple labels in a space-separated list (for example, <code>\"label\", \"reflect refract\"</code>).</p><h2>Validation</h2><p>There are 2 main approaches available to verify whether you have implemented the <code>cvex_bsdf</code> evaluation and sampling functions correctly.</p><div class=\"related\">You can use mantra\u2019s multiple importance sampling algorithm to\nensure that renders match in brightness apart from noise for different\nsampling techniques. To do this, create an environment light (with a\nmap assigned) and render with different values of the <strong>MIS Bias</strong>\nparameter.  You will need to add the <strong>MIS Bias</strong> parameter from the\nrendering properties dialog, since it is not available on the light by\ndefault. A value of -1 means to sample only from the BSDF while a value\nof 1 means to sample only from light source.  To verify the <code>refl</code> value\nin the sampling function, set the environment light rendering mode to\n<strong>Ray Tracing Background</strong>.  If the rendered results are the same\n(apart from noise) with values of -1, 0, 1, and for ray tracing\nbackground, your shader is bias-free.</div><div class=\"related\">Second, the <a href=\"https://www.sidefx.com/docs/houdini/nodes/obj/verifybsdf\">Verify BSDF</a> object can be used to\nverify that the albedo, pdf, and sampling function all align correctly\nand that they integrate to the correct values. This approach uses\npoint-based random sampling in SOPs and additionally will show the\nshape of the BSDF visually as a polar point cloud.</div><h2>Examples</h2><h2>Example: Diffuse</h2><p>Creation:</p><div class=\"codeblock\"><code class=\"codeline\">F = cvex_bsdf(\"diffuse_eval\", \"diffuse_sample\", \"label\", \"diffuse\", \"N\", N);</code></div><p>Evaluation shader:</p><div class=\"codeblock\"><code class=\"codeline\">#include \"pbr.h\"</code><code class=\"codeline\"></code><code class=\"codeline\">cvex diffuse_eval(</code><code class=\"codeline\">    vector u = 0;</code><code class=\"codeline\">    vector v = 0;</code><code class=\"codeline\">    int bounces = 0;</code><code class=\"codeline\">    int reverse = 0;</code><code class=\"codeline\">    export vector refl = 0;</code><code class=\"codeline\">    export vector eval = 0;</code><code class=\"codeline\">    export float pdf = 0;</code><code class=\"codeline\"></code><code class=\"codeline\">    int mybounces = 0;</code><code class=\"codeline\">    vector N = 0)</code><code class=\"codeline\">{</code><code class=\"codeline\">    if (bounces &amp; mybounces)</code><code class=\"codeline\">    {</code><code class=\"codeline\">        // If evaluating reversed, the incoming light direction is needed for</code><code class=\"codeline\">        // evaluation rather than the outgoing direction.  The select statement</code><code class=\"codeline\">        // swaps based on the value of the \"reverse\" toggle.</code><code class=\"codeline\">        vector vvec = select(reverse, u, v);</code><code class=\"codeline\">        pdf = max(dot(vvec, normalize(N)), 0);</code><code class=\"codeline\">        eval = pdf;</code><code class=\"codeline\">        refl = 0.5;</code><code class=\"codeline\">    }</code><code class=\"codeline\">}</code></div><p>Sample shader:</p><div class=\"codeblock\"><code class=\"codeline\">#include \"math.h\"</code><code class=\"codeline\">#include \"pbr.h\"</code><code class=\"codeline\"></code><code class=\"codeline\">cvex diffuse_sample(</code><code class=\"codeline\">    vector u = 0;</code><code class=\"codeline\">    float sx = 0;</code><code class=\"codeline\">    float sy = 0;</code><code class=\"codeline\">    int bounces = 0;</code><code class=\"codeline\"></code><code class=\"codeline\">    export vector refl = 0;</code><code class=\"codeline\">    export vector v = 0;</code><code class=\"codeline\">    export int bouncetype = 0;</code><code class=\"codeline\">    export float pdf = 0;</code><code class=\"codeline\"></code><code class=\"codeline\">    int mybounces = 0;</code><code class=\"codeline\">    vector N = 0)</code><code class=\"codeline\">{</code><code class=\"codeline\">    if (bounces &amp; mybounces)</code><code class=\"codeline\">    {</code><code class=\"codeline\">        vector nml = normalize(N);</code><code class=\"codeline\"></code><code class=\"codeline\">        v = set(cos(sx*PI*2), sin(sx*PI*2), 0);</code><code class=\"codeline\">        v *= sqrt(sy);</code><code class=\"codeline\">        v.z = sqrt(1-sy);</code><code class=\"codeline\"></code><code class=\"codeline\">        pdf = 2*v.z;</code><code class=\"codeline\"></code><code class=\"codeline\">        // Transform v into the reference frame for nml</code><code class=\"codeline\">        vector framex = normalize(cross(nml, u));</code><code class=\"codeline\">        vector framey = cross(nml, framex);</code><code class=\"codeline\"></code><code class=\"codeline\">        v = framex * v.x + framey * v.y + nml*v.z;</code><code class=\"codeline\"></code><code class=\"codeline\">        bouncetype = mybounces;</code><code class=\"codeline\">        refl = 0.5; // Luminance needs to match albedo</code><code class=\"codeline\">    }</code><code class=\"codeline\">}</code></div><h2>Example: Specular</h2><p>Creation:</p><div class=\"codeblock\"><code class=\"codeline\">F = cvex_bsdf(\"specular_eval\", \"specular_sample\", \"label\", \"reflect\", \"dir\", reflect(I, N));</code></div><p>Evaluation shader:</p><div class=\"codeblock\"><code class=\"codeline\">#include \"pbr.h\"</code><code class=\"codeline\"></code><code class=\"codeline\">cvex specular_eval(</code><code class=\"codeline\">    vector u = 0;</code><code class=\"codeline\">    vector v = 0;</code><code class=\"codeline\">    int bounces = 0;</code><code class=\"codeline\">    int reverse = 1;</code><code class=\"codeline\">    export vector refl = 0;</code><code class=\"codeline\">    export vector eval = 0; // Delta bsdf</code><code class=\"codeline\"></code><code class=\"codeline\">    int mybounces = 0;</code><code class=\"codeline\">    vector dir = 0)</code><code class=\"codeline\">{</code><code class=\"codeline\">    if (bounces &amp; mybounces)</code><code class=\"codeline\">        refl = 1;</code><code class=\"codeline\">}</code></div><p>Sample shader:</p><div class=\"codeblock\"><code class=\"codeline\">#include \"math.h\"</code><code class=\"codeline\">#include \"pbr.h\"</code><code class=\"codeline\"></code><code class=\"codeline\">cvex specular_sample(</code><code class=\"codeline\">    vector u = 0;</code><code class=\"codeline\">    float sx = 0;</code><code class=\"codeline\">    float sy = 0;</code><code class=\"codeline\">    int bounces = 0;</code><code class=\"codeline\"></code><code class=\"codeline\">    export vector refl = 0;</code><code class=\"codeline\">    export vector v = 0;</code><code class=\"codeline\">    export int bouncetype = 0;</code><code class=\"codeline\">    export float pdf = 0;</code><code class=\"codeline\"></code><code class=\"codeline\">    int mybounces = 0;</code><code class=\"codeline\">    vector dir = 0)</code><code class=\"codeline\">{</code><code class=\"codeline\">    if (bounces &amp; mybounces)</code><code class=\"codeline\">    {</code><code class=\"codeline\">        pdf = 1e6F;</code><code class=\"codeline\">        v = dir;</code><code class=\"codeline\">        bouncetype = mybounces;</code><code class=\"codeline\">        refl = 1; // Needs to match albedo</code><code class=\"codeline\">    }</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/diffuse\">diffuse</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/specular\">specular</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/verify_bsdf\">sop/verify_bsdf</a></div></body>",
    "cwnoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cwnoise\">cwnoise</a></h1><p class=\"summary\">Generates Worley (cellular) noise using a Chebyshev distance metric.</p><div class=\"usage\"> <code>void cwnoise( float position; int &amp;seed; float &amp;f1; float &amp;f2 )</code></div><div class=\"usage\"> <code>void cwnoise( float position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4 )</code></div><p>Generates 1D noise.</p><div class=\"usage\"> <code>void cwnoise( float position; int &amp;seed; float &amp;f1; float &amp;f2; int peiod)</code></div><div class=\"usage\"> <code>void cwnoise( float position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f4; float &amp;f4; int period)</code></div><p>Generates periodic 1D noise.</p><div class=\"usage\"> <code>void cwnoise( float posx; float posy; int &amp;seed; float &amp;f1; float &amp;f2 )</code></div><div class=\"usage\"> <code>void cwnoise( float posx; float posy; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4 )</code></div><p>Generates 2D noise. This is similar to the other forms but uses pairs of floats instead of a vector.</p><div class=\"usage\"> <code>void cwnoise( float posx; float posy; int &amp;seed; float &amp;f1; float &amp;f2; int periodx; int periody )</code></div><div class=\"usage\"> <code>void cwnoise( float posx; float posy; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4; int periodx; int periody)</code></div><p>Generates periodic 2D noise.</p><div class=\"usage\"> <code>void cwnoise( vector2 position; int &amp;seed; float &amp;f1; float &amp;f2 )</code></div><div class=\"usage\"> <code>void cwnoise( vector2 position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4 )</code></div><p>Generates 2D noise.</p><div class=\"usage\"> <code>void cwnoise( vector2 position; int &amp;seed; float &amp;f1; float &amp;f2; int periodx; int periody )</code></div><div class=\"usage\"> <code>void cwnoise( vector2 position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4; int periodx; int periody)</code></div><p>Generates periodic 2D noise.</p><div class=\"usage\"> <code>void cwnoise( vector position; int &amp;seed; float &amp;f1; float &amp;f2 )</code></div><div class=\"usage\"> <code>void cwnoise( vector position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4 )</code></div><p>Generates 3D noise.</p><div class=\"usage\"> <code>void cwnoise( vector position; int &amp;seed; float &amp;f1; float &amp;f2; int periodx; int periody; int periodx )</code></div><div class=\"usage\"> <code>void cwnoise( vector position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4; int periodx; int periody; int periodz )</code></div><p>Generates periodic 3D noise.</p><div class=\"usage\"> <code>void cwnoise( vector4 position; int &amp;seed; float &amp;f1; float &amp;f2 )</code></div><div class=\"usage\"> <code>void cwnoise( vector4 position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4 )</code></div><p>Generates 4D noise.</p><div class=\"usage\"> <code>void cwnoise( vector4 position; int &amp;seed; float &amp;f1; float &amp;f2; int periodx; int periody; int periodz; int periodw )</code></div><div class=\"usage\"> <code>void cwnoise( vector4 position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4; int periodx; int periody; int periodz; int periodw )</code></div><p>Generates periodic 4D noise.</p><div class=\"argument\"><code>position</code></div><p>The position at which to sample the noise.</p><div class=\"argument\"><code>seed</code></div><p>Outputs an integer value associated with the nearest seed point. This seed is pretty much guaranteed to be unique for every point (meaning that it\u2019s unlikely that two points close by have the same seed associated with them).</p><div class=\"argument\"><code><code>f1</code>, <code>f2</code>, <code>f3</code>, <code>f4</code></code></div><p>These variables are overwritten with the distances to the nearest seed points, in order of closeness.</p><p>You can combine these distances to generate noise patterns. The noise generated tends to be very cellular in nature. In fact, one of the nice things is that you can determine cell boundaries by using the expression: <code>if (f2 - f1)</code> which will be true if the point in space is crossing the boundary between two cells.</p><div class=\"argument\"><code><code>period</code>, <code>periodx</code>, <code>periody</code>, <code>periodz</code>, <code>periodw</code></code></div><p>If you include the period argument(s), the function generates repeating (periodic) noise.</p><p>Worley noise scatters seed points randomly through space (according to a nice Poisson distribution). The functions outputs the distances to the 2 (or 4) seed points nearest to the sample position.</p><h2>Related</h2></body>",
    "decode": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/decode\">decode</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Decodes a variable name that was previously encoded.</p><div class=\"usage\"> <code>string decode(string str)</code></div><p>Houdini VEX variable names are only allowed to contain letters, numbers, and\nunderscores, and must not begin with a number. Arbitrary strings can be passed\nthrough the <code>encode</code> function to generate a string that obeys these\nrestriction. This function takes one of these encoded strings, and returns the\noriginal string. A string that has not been encoded will be returned\nunmodified.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/encode\">encode</a></div></body>",
    "decodeattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/decodeattrib\">decodeattrib</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Decodes a geometry attribute name that was previously encoded.</p><div class=\"usage\"> <code>string decodeattrib(string str)</code></div><p>Houdini geometry attributes and group names are only allowed to contain\nletters, numbers, and underscores, and must not begin with a number. Arbitrary\nstrings can be passed through the <code>encodeattrib</code> function to generate a string\nthat obeys these restriction. This function takes one of these encoded\nstrings, and returns the original string. A string that has not been encoded\nwill be returned unmodified.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/encodeattrib\">encodeattrib</a></div></body>",
    "decodeparm": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/decodeparm\">decodeparm</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Decodes a node parameter name that was previously encoded.</p><div class=\"usage\"> <code>string decodeparm(string str)</code></div><p>Houdini parameter names are only allowed to contain letters, numbers, hash\ncharacters (for multiparms), and underscores, and must not begin with a\nnumber. Arbitrary strings can be passed through the <code>encodeparm</code> function to\ngenerate a string that obeys these restriction. This function takes one of\nthese encoded strings, and returns the original string. A string that has not\nbeen encoded will be returned unmodified.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/encodeparm\">encodeparm</a></div></body>",
    "decodeutf8": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/decodeutf8\">decodeutf8</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Decodes a UTF8 string into a series of codepoints.</p><div class=\"usage\"> <code>int [] decodeutf8(string str)</code></div><p>Converts a UTF8 string into a series of code points. VEX treats its strings as UTF8 by default, but this means indexing into strings can have unusual behavior. Generating code points ensures there\nis one index for each logical character.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/encodeutf8\">encodeutf8</a></div></body>",
    "degrees": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/degrees\">degrees</a></h1><p class=\"summary\">Converts the argument from radians into degrees.</p><div class=\"usage\"> <code>float degrees(float num_in_rads)</code></div><p>Returns the given radians in degrees.</p><div class=\"usage\"> <code>vector2 degrees(vector2 nums_in_rads)</code></div><div class=\"usage\"> <code>vector degrees(vector nums_in_rads)</code></div><div class=\"usage\"> <code>vector4 degrees(vector4 nums_in_rads)</code></div><p>Returns a new vector with the components converted to degrees.</p><p>Most VEX trig functions work with radians, but most users are more comfortable with degrees. You may want to convert from degrees in the UI to radians for internal use.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/radians\">radians</a></div></body>",
    "depthmap": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/depthmap\">depthmap</a></h1><p class=\"summary\">The depthmap functions work on an image which was rendered as a\nz-depth image from mantra.</p><div class=\"usage\"> <code>float depthmap(string filename, vector uvw)</code></div><div class=\"usage\"> <code>float depthmap(string filename, float u, float v)</code></div><p>The depthmap functions work on an image which was rendered as a z-depth\nimage from mantra. They return the floating point distance from the\ncamera to the pixel in question. There is no area sampling done when\nsampling depth values. As well, if the u/v values are not in the range 0\nto 1, a value of 1E6 will be returned (indicating a far value).</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/shadowmap\">shadowmap</a></div></body>",
    "depthname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/depthname\">depthname</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the default name of the depth plane (as it appears in the\ncompositor preferences).</p><div class=\"usage\"> <code>string depthname()</code></div><p>Returns the default name of the depth plane (as it appears in the\ncompositor preferences). Using this instead of hardcoding the default\nmakes your code more portable. Default is Z.</p></body>",
    "detail": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/detail\">detail</a></h1><p class=\"summary\">Reads the value of a detail attribute value from a geometry.</p><div class=\"usage\"> <code>&lt;type&gt; detail(&lt;geometry&gt;, string attribute_name, int ignored=0)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] detail(&lt;geometry&gt;, string attribute_name, int ignored=0)</code></div><div class=\"argument\"><code>ignored</code></div><p>The last argument is always ignored.\n    It is just there so you can change a prim/point/vertex call (which each have an element number argument) to a detail call by changing the name without having to change the arguments as well.</p><h2>Returns</h2><p><code>0</code> if importing the attribute failed, or the value of the attribute on success.</p></body>",
    "detailattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/detailattrib\">detailattrib</a></h1><p class=\"summary\">Reads a detail attribute value from a geometry.</p><div class=\"usage\"> <code>&lt;type&gt; detailattrib(&lt;geometry&gt;, string attribute_name, int ignored, int &amp;success)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] detailattrib(&lt;geometry&gt;, string attribute_name, int ignored, int &amp;success)</code></div><div class=\"argument\"><code>ignored</code></div><p>Pass <code>0</code> for this argument.</p><div class=\"argument\"><code>success</code></div><p>The function sets this variable to <code>1</code> if the attribute was successfully read, or <code>0</code> otherwise.</p><h2>Returns</h2><p><code>0</code> if importing the attribute failed, the value of the attribute on success.</p></body>",
    "detailattribsize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/detailattribsize\">detailattribsize</a></h1><p class=\"summary\">Returns the size of a geometry detail attribute.</p><div class=\"usage\"> <code>int detailattribsize(&lt;geometry&gt;, string attribute_name)</code></div><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribsize\">attribsize</a> for more information.</p><p>Returns <code>0</code> if the attribute cannot be found.</p></body>",
    "detailattribtype": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/detailattribtype\">detailattribtype</a></h1><p class=\"summary\">Returns the type of a geometry detail attribute.</p><div class=\"usage\"> <code>int detailattribtype(&lt;geometry&gt;, string attribute_name)</code></div><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribtype\">attribtype</a> for more information.</p></body>",
    "detailattribtypeinfo": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/detailattribtypeinfo\">detailattribtypeinfo</a></h1><p class=\"summary\">Returns the type info of a geometry attribute.</p><div class=\"usage\"> <code>string detailattribtypeinfo(&lt;geometry&gt;, string attribute_name)</code></div><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribtypeinfo\">attribtypeinfo</a> for more information.</p></body>",
    "detailintrinsic": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/detailintrinsic\">detailintrinsic</a></h1><p class=\"summary\">Reads the value of a detail intrinsic from a geometry.</p><p>Intrinsic values are similar to attributes, but are computed on-demand by Houdini rather than stored.</p><div class=\"usage\"> <code>&lt;type&gt; detailintrinsic(&lt;geometry&gt;, string intrinsic_name)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] detailintrinsic(&lt;geometry&gt;, string intrinsic_name)</code></div><h2>Returns</h2><p>The intrinsic value, or <code>0</code> if the given intrinsic does not exist.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primintrinsic\">primintrinsic</a></div></body>",
    "determinant": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/determinant\">determinant</a></h1><p class=\"summary\">Computes the determinant of the matrix.</p><div class=\"usage\"> <code>float determinant(matrix2 m)</code></div><div class=\"usage\"> <code>float determinant(matrix3 m)</code></div><div class=\"usage\"> <code>float determinant(matrix m)</code></div><p>See <a href=\"https://en.wikipedia.org/wiki/Determinant\">matrix determinant</a>.</p></body>",
    "diagonalizesymmetric": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/diagonalizesymmetric\">diagonalizesymmetric</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Diagonalizes Symmetric Matrices.</p><div class=\"usage\"> <code>matrix3 diagonalizesymmetric(matrix3 symmat, vector &amp;diag)</code></div><p><a href=\"https://en.wikipedia.org/wiki/Diagonalizable_matrix\">Diagonalize</a> a <a href=\"https://en.wikipedia.org/wiki/Symmetric_matrix\">symmetric matrix</a>.</p><p>Returns the orthogonal matrix which, combined with the diagonal matrix\nimplicit in the second argument, will form the original symmetric matrix.</p><p>This can be useful for analyzing the result of summing a series of\nouterproduct updates.</p><div class=\"argument\"><code>symmat</code></div><p>The symmetric matrix to diagonalize.</p><div class=\"argument\"><code>diag</code></div><p>The diagonal elements of the diagonal matrix.</p></body>",
    "diffuse": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/diffuse\">diffuse</a></h1><p class=\"summary\">Returns a diffuse BSDF or computes diffuse shading.</p><p><a href=\"https://www.sidefx.com/docs/houdini/images/rendering/diffuse.png\">/images/rendering/diffuse.png</a></p><div class=\"usage\"> <code>bsdf diffuse(...)</code></div><div class=\"usage\"> <code>bsdf diffuse(float roughness, ...)</code></div><div class=\"usage\"> <code>bsdf diffuse(vector nml, ...)</code></div><div class=\"usage\"> <code>bsdf diffuse(vector nml, float roughness, ...)</code></div><div class=\"usage\"> <code>bsdf diffuse(vector nml, vector geo_normal, ...)</code></div><div class=\"usage\"> <code>bsdf diffuse(vector nml, vector geo_normal, float roughness, ...)</code></div><p>Diffuse reflections. This BSDF has an albedo of 0.5. If your shader or\n    geometry has smooth normals (N and Ng differ) you should avoid the\n    signature <code>diffuse(vector nml)</code> since it assumes that the\n    shading normal matches the geometric normal.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">writing a PBR shader</a> for information on BSDFs.</p><div class=\"usage\"> <code>vector diffuse(vector nml, ...)</code></div><div class=\"usage\"> <code>vector diffuse(vector nml, vector V, float roughness, ...)</code></div><p>This form uses the\n    Oren-Nayar lighting model to compute the diffuse illumination for the\n    surface. The Oren-Nayar lighting model is a more sophisticated lighting\n    model than Lambertian lighting. The V vector represents a vector from\n    the surface to the eye (i.e. -normalize(I)). With a roughness of 0, the\n    Oren-Nayar lighting model is equivalent to the Lambertian model. As\n    roughness increases toward 1, the illumination changes to mimic rougher\n    materials (like clay). The Oren-Nayar form of diffuse() is more\n    expensive than Lambertian diffuse lighting.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wirediffuse\">wirediffuse</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/translucent\">translucent</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "diffuseBRDF": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/diffuseBRDF\">diffuseBRDF</a></h1><div class=\"usage\"> <code>float diffuseBRDF(vector L, vector N)</code></div><p>Equivalent to clamp(dot(L, N), 0, 1).</p><div class=\"usage\"> <code>float diffuseBRDF(vector L, vector N, vector V, float rough)</code></div><p><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/specularBRDF\">specularBRDF</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phongBRDF\">phongBRDF</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/blinnBRDF\">blinnBRDF</a>,\nand <code>diffuseBRDF</code> return the computed BRDF for the\ndifferent lighting models used in VEX shading. You can use them in\ncustom <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a> loops to replicate the lighting models of the\ncorresponding VEX lighting functions.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/specularBRDF\">specularBRDF</a> for some example code.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/specularBRDF\">specularBRDF</a></div></body>",
    "dihedral": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/dihedral\">dihedral</a></h1><p class=\"summary\">Computes the rotation matrix or quaternion which rotates the vector a onto the vector b.</p><div class=\"usage\"> <code>matrix3 dihedral(vector a, vector b)</code></div><p>Computes the rotation matrix which rotates the vector <code class=\"var\">a</code> onto the vector <code class=\"var\">b</code>.</p><div class=\"usage\"> <code>vector4 dihedral(vector a, vector b)</code></div><p>Computes the quaternion which rotates the vector <code class=\"var\">a</code> onto the vector <code class=\"var\">b</code>.</p></body>",
    "dimport": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/dimport\">dimport</a></h1><span class=\"padder\"><span class=\"pillow\">fog</span></span><span class=\"padder\"><span class=\"pillow\">light</span></span><span class=\"padder\"><span class=\"pillow\">shadow</span></span><span class=\"padder\"><span class=\"pillow\">surface</span></span><p class=\"summary\">Reads a variable from the displacement shader for the surface.</p><div class=\"usage\"> <code>int dimport(string name, &lt;type&gt; &amp;out)</code></div><p>Reads a variable from the displacement shader for the surface.</p><p>Mantra runs the shaders for a surface in a fixed order:</p><p>Once the displacement shader has run, you can use <code>dimport</code>\nto retrieve exported variables from it. Once the surface shader\nhas run, you can use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/simport\">simport</a> to retrieve exported variables\nfrom it.</p><p>If the shader variable named by the first argument is defined and\nexported, the function returns 1 and puts the value in the second\nargument. Otherwise, it returns 0.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/simport\">simport</a></div></body>",
    "distance": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/distance\">distance</a></h1><p class=\"summary\">Returns the distance between two points.</p><div class=\"usage\"> <code>float distance(vector2 a, vector2 b)</code></div><div class=\"usage\"> <code>float distance(vector a, vector b)</code></div><div class=\"usage\"> <code>float distance(vector4 a, vector4 b)</code></div><p>If you want the squared distance, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/distance2\">distance2</a> instead of using this and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pow\">pow</a>. </p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/distance2\">distance2</a></div></body>",
    "distance2": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/distance2\">distance2</a></h1><p class=\"summary\">Returns the squared distance between the two points.</p><div class=\"usage\"> <code>float distance2(vector2 a, vector2 b)</code></div><div class=\"usage\"> <code>float distance2(vector a, vector b)</code></div><div class=\"usage\"> <code>float distance2(vector4 a, vector4 b)</code></div><p>This returns the squared distance. To get the plain distance, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/distance\">distance</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/distance\">distance</a></div></body>",
    "dot": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/dot\">dot</a></h1><p class=\"summary\">Returns the dot product between the arguments.</p><div class=\"usage\"> <code>float dot(vector2 a, vector2 b)</code></div><div class=\"usage\"> <code>float dot(vector a, vector b)</code></div><div class=\"usage\"> <code>float dot(vector4 a, vector4 b)</code></div><div class=\"usage\"> <code>float dot(vector a, vector4 b)</code></div><div class=\"usage\"> <code>float dot(vector4 a, vector b)</code></div><div class=\"usage\"> <code>float dot(matrix2 a, matrix2 b)</code></div><div class=\"usage\"> <code>float dot(matrix3 a, matrix3 b)</code></div><div class=\"usage\"> <code>float dot(matrix a, matrix b)</code></div><p>Returns the <a href=\"https://en.wikipedia.org/wiki/Dot_product\">dot product</a> of the arguments.</p><p>When dotting a <code>vector</code> with a <code>vector4</code>, only the first three\n    components are used.</p><div class=\"usage\"> <code>float dot(&lt;type&gt; a[], &lt;type&gt; b[])</code></div><div class=\"usage\"> <code>int dot(int a[], int b[])</code></div><p>Returns the sum of dot products i.e. <code>dot(a, b) = dot(a[0], b[0]) + ... + dot(a[n-1], b[n-1])</code> where <code>n = min(len(a), len(b))</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cross\">cross</a></div></body>",
    "dsmpixel": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/dsmpixel\">dsmpixel</a></h1><p class=\"summary\">Reads the z-records stored in a pixel of a deep shadow map\nor deep camera map.</p><div class=\"usage\"> <code>int dsmpixel(string map, string channel; int x, int y; &lt;type&gt; &amp;values[])</code></div><p>Each pixel of a deep shadow map channel has multiple values.  This function\nwill extract the list of the values associated with the channel for the given\npixel.</p><p>Returns the number of values in the deep pixel (or -1 on failure).</p><p>A DSM will always have <code>Pz</code> and <code>Of</code> channels. The <code>Pz</code> channel stores the\nz-depth associated with each record. The <code>Of</code> channel stores the opacity.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/teximport\">teximport</a></div></body>",
    "Du": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Du\">Du</a></h1><p class=\"summary\">Returns the derivative of the given value with respect to U.</p><div class=\"usage\"> <code>float Du(float n, ...)</code></div><div class=\"usage\"> <code>vector Du(vector n, ...)</code></div><div class=\"usage\"> <code>vector4 Du(vector4 n, ...)</code></div><h2>Returns</h2><p>The derivative of <code>n</code> with respect to U.</p><p>In shading contexts, this is the change in the variable over the area\nbeing shaded.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dv\">Dv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dw\">Dw</a></div></body>",
    "Dv": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dv\">Dv</a></h1><p class=\"summary\">Returns the derivative of the given value with respect to V.</p><div class=\"usage\"> <code>float Dv(float n, ...)</code></div><div class=\"usage\"> <code>vector Dv(vector n, ...)</code></div><div class=\"usage\"> <code>vector4 Dv(vector4 n, ...)</code></div><h2>Returns</h2><p>The derivative of <code>n</code> with respect to V.</p><p>In shading contexts, this is the change in the variable over the area\nbeing shaded.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Du\">Du</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dw\">Dw</a></div></body>",
    "Dw": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dw\">Dw</a></h1><p class=\"summary\">Returns the derivative of the given value with respect to the 3rd axis (for volume rendering).</p><div class=\"usage\"> <code>float Dw(float p, ...)</code></div><div class=\"usage\"> <code>vector Dw(vector p, ...)</code></div><div class=\"usage\"> <code>vector4 Dw(vector4 p, ...)</code></div><h2>Returns</h2><p>Returns the derivative of <code>p</code> with respect to W.</p><p>When rendering surfaces, this function returns 0.</p><p>In shading contexts, this is the change in the variable over the volume being shaded.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Du\">Du</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dv\">Dv</a></div></body>",
    "efit": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/efit\">efit</a></h1><p class=\"summary\">Takes the value in one range and shifts it to the corresponding value in a new range.</p><div class=\"usage\"> <code>float efit(float value, float omin, float omax, float nmin, float nmax)</code></div><p>Takes the value in the range (<code class=\"var\">omin</code>, <code class=\"var\">omax</code>) and shifts it to the corresponding value in the new range (<code class=\"var\">nmin</code>, <code class=\"var\">nmax</code>).\n    Unlike <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit\">fit</a>, this function does not clamp values to the given range.</p><div class=\"usage\"> <code>&lt;vector&gt; efit(&lt;vector&gt; value, &lt;vector&gt; omin, &lt;vector&gt; omax, &lt;vector&gt; nmin, &lt;vector&gt; nmax)</code></div><div class=\"usage\"> <code>&lt;vector&gt; efit(&lt;vector&gt; value, &lt;vector&gt; omin, &lt;vector&gt; omax, float nmin, float nmax)</code></div><p>The vector versions fit per-component. You can specify per-component min/max values using vectors, or common min/max values using floats.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">efit(.3, 0, 1, 10, 20) == 13</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/clamp\">clamp</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit\">fit</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit01\">fit01</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit10\">fit10</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit11\">fit11</a></div></body>",
    "eigenvalues": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/eigenvalues\">eigenvalues</a></h1><p class=\"summary\">Computes the eigenvalues of a 3\u00d73 matrix.</p><div class=\"usage\"> <code>void eigenvalues(int &amp;nroot, matrix3 mat, vector &amp;real, vector &amp;imaginary)</code></div><p>Computes the <a href=\"https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors\">eigenvalues</a> of a 3\u00d73 matrix.</p><div class=\"argument\"><code>nroot</code></div><p>The function overwrites this variable with the number of real roots.</p><div class=\"argument\"><code>mat</code></div><p>The matrix to compute the eigenvalues for.</p><div class=\"argument\"><code><code>real</code>, <code>imaginary</code></code></div><p>The components of these two vectors are overwritten with corresponding pairs of real and imaginary parts of each eigenvalue.\n    For example, <code>real[0]</code> and <code>imaginary[0]</code> contain the real and imaginary parts of the first eigenvalue.</p></body>",
    "encode": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/encode\">encode</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Encodes any string into a valid variable name.</p><div class=\"usage\"> <code>string encode(string str)</code></div><p>Houdini VEX variable names are only allowed to contain letters, numbers, and\nunderscores, and must not begin with a number. This function takes any string,\nand encodes it into a string that obeys these restrictions. The original\nstring can be recovered using the <code>decode</code> function.  A string that already\nobeys the rules is returned unmodified.</p><p>One exception to this rule is that a string starting with <code>xn__</code> will be\nencoded even if it is already a valid variable name. This is because <code>xn__</code>\nis the prefix used to identify an encoded string. In this case, an additional\n<code>xn__</code> prefix will be added. This means a string can be encoded any number of\ntimes, then decoded the same number of times to always return to the original\nstring, regardless of its contents.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/decode\">decode</a></div></body>",
    "encodeattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/encodeattrib\">encodeattrib</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Encodes any string into a valid geometry attribute name.</p><div class=\"usage\"> <code>string encodeattrib(string str)</code></div><p>Houdini geometry attributes and group names are only allowed to contain\nletters, numbers, and underscores, and must not begin with a number. This\nfunction takes any string, and encodes it into a string that obeys these\nrestrictions. The original string can be recovered using the <code>decodeattrib</code>\nfunction.  A string that already obeys the rules is returned unmodified.</p><p>One exception to this rule is that a string starting with <code>xn__</code> will be\nencoded even if it is already a valid attribute name. This is because <code>xn__</code>\nis the prefix used to identify an encoded string. In this case, an additional\n<code>xn__</code> prefix will be added. This means a string can be encoded any number of\ntimes, then decoded the same number of times to always return to the original\nstring, regardless of its contents.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/decodeattrib\">decodeattrib</a></div></body>",
    "encodeparm": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/encodeparm\">encodeparm</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Encodes any string into a valid node parameter name.</p><div class=\"usage\"> <code>string encodeparm(string str)</code></div><p>Houdini parameter names are only allowed to contain letters, numbers, hash\ncharacters (for multiparms), and underscores, and must not begin with a\nnumber. This function takes any string, and encodes it into a string that\nobeys these restrictions. The original string can be recovered using the\n<code>decodeparm</code> function.  A string that already obeys the rules is returned\nunmodified.</p><p>One exception to this rule is that a string starting with <code>xn__</code> will be\nencoded even if it is already a valid parameter name. This is because <code>xn__</code>\nis the prefix used to identify an encoded string. In this case, an additional\n<code>xn__</code> prefix will be added. This means a string can be encoded any number of\ntimes, then decoded the same number of times to always return to the original\nstring, regardless of its contents.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/decodeparm\">decodeparm</a></div></body>",
    "encodeutf8": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/encodeutf8\">encodeutf8</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Encodes a UTF8 string from a series of codepoints.</p><div class=\"usage\"> <code>string encodeutf8(int [] codepoints)</code></div><p>Converts a series of code points into a UTF8 string. VEX treats its strings as UTF8 by default, but this means indexing into strings can have unusual behavior. Generating code points ensures there\nis one index for each logical character.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/decodeutf8\">decodeutf8</a></div></body>",
    "endswith": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/endswith\">endswith</a></h1><p class=\"summary\">Indicates the string ends with the specified string.</p><div class=\"usage\"> <code>int endswith(const string haystack, const string needle)</code></div><p>Returns 1 if the string ends with the given string. 0 otherwise.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/startswith\">startswith</a></div></body>",
    "environment": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/environment\">environment</a></h1><p class=\"summary\">Returns the color of the environment texture.</p><div class=\"usage\"> <code>vector environment(string texture_filename, vector reflect_dir, ...)</code></div><div class=\"usage\"> <code>vector4 environment(string texture_filename, vector reflect_dir, ...)</code></div><div class=\"usage\"> <code>vector environment(string texture_filename, vector reflect_dir0, vector reflect_dir1, vector reflect_dir2, vector reflect_dir3, ...)</code></div><div class=\"usage\"> <code>vector4 environment(string texture_filename, vector reflect_dir0, vector reflect_dir1, vector reflect_dir2, vector reflect_dir3, ...)</code></div><div class=\"usage\"> <code>vector environment(string texture_filename, vector reflect_dir, float filter_angle, ...)</code></div><div class=\"usage\"> <code>vector4 environment(string texture_filename, vector reflect_dir, float filter_angle, ...)</code></div><p>Returns the color of the environment texture in the direction given by the <code>reflect_dir</code> argument. The signatures that specify four vectors filter the map pixels found within the cone defined by the vectors.  Rather than specifying a filtering cone by providing four vectors, it is also possible to indicate an angle to filter over using the filter_angle argument with a single reflection direction.</p><p>The environment function can also be used to look up intensity values in an IES photometric light map, with the correct angular mapping applied.</p><h2>Note</h2><p>To perform environment map lookups in object space, you\u2019ll need to first transform the direction vector using the vtransform() function.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">vector dir = vtransform(\"space:current\", \"space:object\", {0, 1, 0});</code><code class=\"codeline\">vector clr = environment(\"sky.rat\", dir);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/ref/utils/isixpack\">isixpack</a></div></body>",
    "erf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/erf\">erf</a></h1><p class=\"summary\">Gauss error function.</p><div class=\"usage\"> <code>float erf(float v)</code></div><div class=\"usage\"> <code>vector2 erf(vector2 v)</code></div><p>The <a href=\"https://en.wikipedia.org/wiki/Error_function\">Gauss error function</a>. Houdini uses the Boost\nlibrary\u2019s implementation internally.</p><p>The erf(vector2) version computes the complex error function and returns\nthe complex result. This function is much slower than the erf(float)\nfunction for real values.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/erf_inv\">erf_inv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/erfc\">erfc</a></div></body>",
    "erfc": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/erfc\">erfc</a></h1><p class=\"summary\">Gauss error function\u2019s complement.</p><div class=\"usage\"> <code>float erfc(float v)</code></div><p>Equal to <code>1 - erf(v)</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/erf\">erf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/erf_inv\">erf_inv</a></div></body>",
    "erf_inv": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/erf_inv\">erf_inv</a></h1><p class=\"summary\">Inverse Gauss error function.</p><div class=\"usage\"> <code>float erf_inv(float v)</code></div><p>The inverse of the <a href=\"https://en.wikipedia.org/wiki/Error_function\">Gauss error function</a>.</p><p><code>erf_inv(erf(v)) = v = erf(erf_inv(v))</code></p><p>To generate a normally-distributed random number, <code>n</code>, with mean <code>mu</code> and standard deviation <code>sigma</code>,\nfrom a uniformly-distributed random number, <code>u</code>, between 0 and 1,</p><p><code>n = mu + sqrt(2)*sigma*erf_inv(2*u - 1)</code></p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/erf\">erf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/erfc\">erfc</a></div></body>",
    "error": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/error\">error</a></h1><p class=\"summary\">Reports a custom runtime VEX error.</p><div class=\"usage\"> <code>void error(string format, ...)</code></div><p>Reports a custom runtime VEX error.  This uses the same format string syntax as <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/printf\">printf</a>.</p><p>If something can still be done as an acceptable fallback, instead of outright failing,\n    it may be worth reporting a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/warning\">warning</a>, instead of an error.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">if (!pointattribtype(0,chs(\"nameattrib\")) != 2) {</code><code class=\"codeline\">    error(\"Name attribute %s must be a string attribute!\", chs(\"nameattrib\"));</code><code class=\"codeline\">    return;</code><code class=\"codeline\">}</code><code class=\"codeline\">if (chf(\"distance\") &lt; 0) {</code><code class=\"codeline\">    error(\"\")</code><code class=\"codeline\">}</code><code class=\"codeline\">float minimumValue = chf(\"min\");</code><code class=\"codeline\">float maximumValue = chf(\"max\");</code><code class=\"codeline\">if (minimumValue &gt;= maximumValue) {</code><code class=\"codeline\">    error(\"Minimum (%f) must be strictly less than maximum (%f)!  It's unclear what should be done.\", minimumValue, maximumValue);</code><code class=\"codeline\">    return;</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/warning\">warning</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/printf\">printf</a></div></body>",
    "eulertoquaternion": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/eulertoquaternion\">eulertoquaternion</a></h1><p class=\"summary\">Creates a vector4 representing a quaternion from euler angles.</p><div class=\"usage\"> <code>vector4 eulertoquaternion(vector rotations, int order)</code></div><p>Creates a vector4 representing a quaternion from a vector representing Euler rotations in X, Y, and Z.</p><p>The angles are in radians.  Use the <code>radians()</code> function to convert degrees into radians.</p><p>Specify the rotation order with the <code class=\"var\">order</code> integer. Use the constants defined in <code>$HH/vex/include/math.h</code> (for example, <code>XFORM_XYZ</code> will do the rotation order x, y, z).</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/dihedral\">dihedral</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/qconvert\">qconvert</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/quaternion\">quaternion</a></div></body>",
    "eval_bsdf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/eval_bsdf\">eval_bsdf</a></h1><p class=\"summary\">Evaluates a bsdf given two vectors.</p><div class=\"usage\"><code>vector eval_bsdf( bsdf b; vector viewer; vector light; ... )</code></div><div class=\"usage\"><code>vector eval_bsdf( bsdf b; vector viewer; vector light; int mask; ... )</code></div><div class=\"usage\"><code>vector eval_bsdf( bsdf b; vector viewer; vector light; float &amp;pdf; int mask; ... )</code></div><div class=\"usage\"><code>vector eval_bsdf( bsdf b; vector viewer; vector light; vector normal; ... )</code></div><div class=\"usage\"><code>vector eval_bsdf( bsdf b; vector viewer; vector light; vector normal; int mask; ... )</code></div><div class=\"usage\"><code>vector eval_bsdf( bsdf b; vector viewer; vector light; vector normal; float &amp;pdf; int mask; ... )</code></div><div class=\"argument\"><code>b</code></div><p>BSDF to evaluate.</p><div class=\"argument\"><code>viewer</code></div><p>Vector toward viewer.</p><div class=\"argument\"><code>light</code></div><p>Vector toward light.</p><div class=\"argument\"><code>normal</code></div><p>Surface normal.</p><div class=\"argument\"><code>mask</code></div><p>A bitmask indicating which types of shading component bounces to evaluate.</p><div class=\"argument\"><code>&amp;pdf</code></div><p>The function overwrites this variable with the computed PDF for the given directions, scaled by the albedo.</p><h2>Variadic arguments</h2><p>The <code>eval_bsdf</code> function passes any extra <code>\"name\", value</code> argument pairs to the BSDF being\nevaluated.  For custom BSDFs these keyword arguments are bound to shader\narguments (e.g. indicating whether the BSDF is being evaluated for direct or\nindirect illumination).  It\u2019s also possible for a BSDF to pass information back\nto <code>eval_bsdf</code>.  To indicate that a keyword argument value should be imported\nfrom the BSDF prefix the keyword with import:</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">v = eval_bsdf(F, inI, dir,</code><code class=\"codeline\">    \"direct\", 0,                        // Specify indirect illumination</code><code class=\"codeline\">    \"import:sssmfp\", sssmfp,        // Read the exported sssmfp parameter</code><code class=\"codeline\">    ...</code><code class=\"codeline\">);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/albedo\">albedo</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_bsdf\">sample_bsdf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/emission_bsdf\">emission_bsdf</a></div></body>",
    "exp": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/exp\">exp</a></h1><p class=\"summary\">Returns the exponential function of the argument.</p><div class=\"usage\"> <code>float exp(float n)</code></div><div class=\"usage\"> <code>&lt;vector&gt; exp(&lt;vector&gt; n)</code></div><p>Returns the <a href=\"https://en.wikipedia.org/wiki/Exponential_function\">Exponential function</a> of <code>n</code>. For vectors, this is done per-component.</p></body>",
    "expandedgegroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/expandedgegroup\">expandedgegroup</a></h1><div class=\"usage\"> <code>int [] expandedgegroup(&lt;geometry&gt;, string groupname)</code></div><div class=\"usage\"> <code>int [] expandedgegroup(&lt;geometry&gt;, string groupname, string mode)</code></div><p>Returns a list of point pairs of the edges in the specified group of a geometry file.</p><p>This can use ad-hoc groups, like <code>0</code> or <code>p0-1</code>.  It matches the SOP group naming convention, in particular that an empty string means all edges.</p><p><code>mode</code> can be <code>ordered</code>, <code>unordered</code> or <code>split</code>.\n<code>ordered</code> is the default mode and will return numbers in the order of appearance in the string, but only for numbers. The order won\u2019t be kept when using expressions such as <code>@Cd.x&gt;0.5</code>. The same number won\u2019t appear twice in returned array.\n<code>unordered</code> mode returns the resolved group following sorted point numbers order.\n<code>split</code> mode starts by splitting the <code>groupname</code> string on <code>@</code> characters and then does one resolution per sub string. The order is kept between the sub strings, but will fallback to unordered when resolving a group expression. This same number can appear multiple time when resolving using this mode.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/inedgegroup\">inedgegroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nedgesgroup\">nedgesgroup</a></div></body>",
    "expandpointgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/expandpointgroup\">expandpointgroup</a></h1><p class=\"summary\">Returns an array of point numbers corresponding to a group string.</p><div class=\"usage\"> <code>int [] expandpointgroup(&lt;geometry&gt;, string groupname)</code></div><div class=\"usage\"> <code>int [] expandpointgroup(&lt;geometry&gt;, string groupname, string mode)</code></div><p><code>groupname can use ad-hoc group syntax, like </code>0-3<code> or </code>@Cd.x&gt;0.5`.</p><p><code>mode</code> can be <code>ordered</code>, <code>unordered</code> or <code>split</code>.\n<code>ordered</code> is the default mode and will return numbers in the order of appearance in the string, but only for numbers. The order won\u2019t be kept when using expressions such as <code>@Cd.x&gt;0.5</code>. The same number won\u2019t appear twice in returned array.\n<code>unordered</code> mode returns the resolved group following sorted point numbers order.\n<code>split</code> mode starts by splitting the <code>groupname</code> string on <code>@</code> characters and then does one resolution per sub string. The order is kept between the sub strings, but will fallback to unordered when resolving a group expression. This same number can appear multiple time when resolving using this mode.</p><p>This uses the SOP group naming convention, in particular that an empty string means <em>all</em>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/inpointgroup\">inpointgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/npointsgroup\">npointsgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasattrib\">hasattrib</a></div></body>",
    "expandprimgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/expandprimgroup\">expandprimgroup</a></h1><p class=\"summary\">Returns an array of prim numbers corresponding to a group string.</p><div class=\"usage\"> <code>int [] expandprimgroup(&lt;geometry&gt;, string groupname)</code></div><div class=\"usage\"> <code>int [] expandprimgroup(&lt;geometry&gt;, string groupname, string mode)</code></div><p><code>groupname</code> can use ad-hoc groups, like <code>0-3</code> or <code>@Cd.x&gt;0.5</code>.\nThis uses the SOP group naming convention, in particular that an empty string means <em>all</em>.</p><p><code>mode</code> can be <code>ordered</code>, <code>unordered</code> or <code>split</code>.\n<code>ordered</code> is the default mode and will return numbers in the order of appearance in the string, but only for numbers. The order won\u2019t be kept when using expressions such as <code>@Cd.x&gt;0.5</code>. The same number won\u2019t appear twice in returned array.\n<code>unordered</code> mode returns the resolved group following sorted point numbers order.\n<code>split</code> mode starts by splitting the <code>groupname</code> string on <code>@</code> characters and then does one resolution per sub string. The order is kept between the sub strings, but will fallback to unordered when resolving a group expression. This same number can appear multiple time when resolving using this mode.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/inprimgroup\">inprimgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nprimitivesgroup\">nprimitivesgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasattrib\">hasattrib</a></div></body>",
    "expandvertexgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/expandvertexgroup\">expandvertexgroup</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Returns an array of linear vertex numbers corresponding to a group string.</p><div class=\"usage\"> <code>int [] expandvertexgroup(&lt;geometry&gt;, string groupname)</code></div><div class=\"usage\"> <code>int [] expandvertexgroup(&lt;geometry&gt;, string groupname, string mode)</code></div><p>This can use ad-hoc groups, like <code>0v3 1v2</code>.\nThis uses the SOP group naming convention, in particular that an empty string means <em>all</em>.</p><p><code>mode</code> can be <code>ordered</code>, <code>unordered</code> or <code>split</code>.\n<code>ordered</code> is the default mode and will return numbers in the order of appearance in the string, but only for numbers. The order won\u2019t be kept when using expressions such as <code>@Cd.x&gt;0.5</code>. The same number won\u2019t appear twice in returned array.\n<code>unordered</code> mode returns the resolved group following sorted point numbers order.\n<code>split</code> mode starts by splitting the <code>groupname</code> string on <code>@</code> characters and then does one resolution per sub string. The order is kept between the sub strings, but will fallback to unordered when resolving a group expression. This same number can appear multiple time when resolving using this mode.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/invertexgroup\">invertexgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nverticesgroup\">nverticesgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasattrib\">hasattrib</a></div></body>",
    "expand_udim": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/expand_udim\">expand_udim</a></h1><p class=\"summary\">Perform UDIM or UVTILE texture filename expansion.</p><div class=\"usage\"> <code>string expand_udim(float u, float v; string path, ...)</code></div><p>Scans the input path for special conversion characters to perform either UDIM\n    or UVTILE style filename expansion.</p><p>This is similar to <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texprintf\">texprintf</a>, with two significant differences:</p><div class=\"related\">There are no variadic print arguments. Only UDIM/UVTILE expansion is performed.</div><div class=\"related\">If UDIM/UVTILE expansion was performed, the function checks to see if the texture exists and is accessible.</div><div class=\"argument\"><code><code>u</code>, <code>v</code></code></div><p>The texture coordinates to translate into a UDIM tile specification.</p><div class=\"argument\"><code><code>path</code></code></div><p>A file path. Special character sequences in the path will be expanded into UDIM specifiers based on the given UV coordinates. The special conversion sequences are:</p><span><code>%(UDIM)d</code> or <code>&lt;UDIM&gt;</code> </span><p>The UDIM coordinate, as computed by <code>1000 + int(u)+1 + int(v)*10</code></p><span><code>%(U)d</code> </span><p>The UVTILE style u-coordinate (<code>int(u)+1</code>)</p><span><code>%(V)d</code> </span><p>The UVTILE style v-coordinate (<code>int(v)+1</code>)</p><span><code>%(UVTILE)d</code> or <code>&lt;UVTILE&gt;</code> </span><p>Expands both u and v coordinates in the form <code>u%d_v%d</code>.</p><p>The <code>d</code> conversion specifier for texture identification can be modified with\n    field modifiers.  For example <code>%(U)02d</code> or <code>%(V)04d</code>.</p><div class=\"argument\"><code>checkfile</code></div><span class=\"padder\"><span class=\"pillow\">int</span></span><span class=\"padder\"><span class=\"pillow\">1</span></span><p>Normally, the function checks whether the expanded path exists and is readable. If you pass the <code>\"checkfile\", 0</code> pair, the function will not perform this check.</p><h2>Returns</h2><p>The path with any UDIM control sequences replaced.</p><p>If the expanded file path does not exist or is not readable, the function will return an empty string, unless you turn off the <code>checkfile</code> variadic argument.</p><h2>Examples</h2><div class=\"related\"><code>expand_udim(3.1, 4.15, \"map_%(UDIM)d.rat\")</code> - Returns map_1044.rat</div><div class=\"related\"><code>expand_udim(3.1, 4.15, \"map_%(U)02d_%(V)02d.rat\")</code> - Returns map_04_05.rat</div><div class=\"related\"><code>expand_udim(3.14, 11.5, \"map_u%(U)d_v%(V)d.rat\")</code> - Returns map_u4_v12.rat</div><div class=\"related\"><code>expand_udim(3.14, 11.5, \"missing_file%(UDIM)d.rat\")</code> - Returns  for missing files.</div><div class=\"related\"><code>expand_udim(3.14, 11.5, \"missing_file%(UDIM)d.rat\", \"checkfile\", 0)</code> - Returns missing_file1044.rat since checkfile is disabled.</div><div class=\"related\"><code>expand_udim(3.14, 11.5, \"/path/file.rat\")</code> - Returns /path/file.rat whether the file exists or not since there are no UDIM/UVTILE expansions.</div><div class=\"codeblock\"><code class=\"codeline\">// sprintf() will leave the %(UDIM)d format sequence unmodified.</code><code class=\"codeline\">string map = sprintf(\"%s/%s_%(UDIM)d.rat\", texture_path, texture_base);</code><code class=\"codeline\">// Expand the %(UDIM)d, returning an empty string if the map doesn't exist.</code><code class=\"codeline\">map = expand_udim(u, v, map);</code><code class=\"codeline\">if (map != \"\")</code><code class=\"codeline\">Cf = texture(map, u, v);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texprintf\">texprintf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texture\">texture</a></div></body>",
    "extractlocaltransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/extractlocaltransform\">extractlocaltransform</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Extracts Local Transform from a World Transform with Scale Inheritance.</p><div class=\"usage\"> <code>matrix extractlocaltransform(matrix world, matrix parent_world, matrix parent_local, int scale_inherit_mode)</code></div><p>Returns a new local transform given its world and new parent transforms.</p><div class=\"usage\"> <code>matrix extractlocaltransform(matrix world, matrix parent_world, matrix parent_local, int mode, matrix &amp;effective_local_transform)</code></div><p>Returns a new world transform given its local and parent world transforms. The local transform including any inherited scales is stored in the effective_local_transform matrix;</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/combinelocaltransform\">combinelocaltransform</a></div></body>",
    "fastshadow": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fastshadow\">fastshadow</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Sends a ray from the position P along the direction specified by the\ndirection D.</p><div class=\"usage\"> <code>float fastshadow(vector P, vector D, float bias, ...)</code></div><p>Sends a ray from the position <code class=\"var\">P</code> along the direction specified by the\ndirection <code class=\"var\">D</code>. The length of the <code class=\"var\">D</code> vector represents the farthest\ndistance considered when check for occlusion.</p><p>Returns 1 if there are no occluding objects found, or 0 if the ray hit\nan object in between.</p></body>",
    "filamentsample": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/filamentsample\">filamentsample</a></h1><p class=\"summary\">Samples the velocity field defined by a set of <a href=\"https://www.sidefx.com/docs/houdini/dopparticles/filaments\">vortex filaments</a>.</p><div class=\"usage\"> <code>vector filamentsample(&lt;geometry&gt;, vector position)</code></div><p>Samples the velocity field defined by a set of vortex filaments at the\nspecified <code>position</code>. The <code>inputnum</code> or <code>filename</code> parameter specifies the\ngeometry to fetch the filament curves from. The <code>strength</code> and <code>thickness</code>\nprimitive attributes can be used on the geometry to customize the strength and\nthickness of each filament. Returns the zero vector if <code>inputnum</code> is out of\nrange or the <code>filename</code> is invalid.</p></body>",
    "file_stat": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/file_stat\">file_stat</a></h1><p class=\"summary\">Returns file system status for a given file.</p><div class=\"usage\"> <code>int file_stat(string filename, int &amp;stat_data[], ...)</code></div><p>Overwrites an integer array with data representing the file system\n    information for the given file.</p><p><strong>Do not use this function</strong>. The <code>file.h</code> include file has <a href=\"https://www.sidefx.com/docs/houdini#better\">more convenient versions of this function</a> which return a struct.</p><div class=\"argument\"><code><code>usecache</code></code></div><span class=\"padder\"><span class=\"pillow\">int</span></span><span class=\"padder\"><span class=\"pillow\">0</span></span><p>If this option is on, the function will use a persistent cache to store results of the function.  The cache is persistent over the entire run of the application.</p><h2>Returns</h2><p><code>1</code> if the path is valid or <code>0</code> otherwise.</p><h2>Better file_stat functions</h2><p>Instead of using the built-in <code>file_stat</code>, add this line at the top of the file:</p><div class=\"codeblock\"><code class=\"codeline\">#include &lt;file.h&gt;</code></div><p>Then use the <code>file_stat</code> or <code>cached_file_stat</code> functions from that file. They take a file path string and return a struct (defined in <code>file.h</code>) with the following members:</p><span><code>.st_size</code> </span><p>The size of the file in bytes.</p><span><code>.st_sizemb</code> </span><p>The size of the file in megabytes.</p><span><code>.st_mtime</code> </span><p>The last modified time of this file.</p><span><code>-&gt;isValid()</code> </span><p>Return 1 if the file path refers to a valid file.</p><span><code>-&gt;isFile()</code> </span><p>Returns 1 if the file path refers to a file (rather than a directory).</p><span><code>-&gt;isDir()</code> </span><p>Returns 1 if the file path refers to a directory (rather than a file).</p><span><code>-&gt;isRead()</code> </span><p>Returns 1 if the file is readable.</p><span><code>-&gt;isWrite()</code> </span><p>Returns 1 if the file is writable.</p><span><code>-&gt;isExecute()</code> </span><p>Returns 1 if the file is executable.</p><h2>Examples</h2><p>This simple <a href=\"https://www.sidefx.com/docs/houdini/vex/snippets\">snippet</a> checks if a texture file exists, and if so, colors points green instead of red:</p><div class=\"codeblock\"><code class=\"codeline\">#include &lt;file.h&gt;</code><code class=\"codeline\"></code><code class=\"codeline\">v@Cd = {1,0,0};</code><code class=\"codeline\">stat s = file_stat(\"$HH/pic/Mandril.pic\");</code><code class=\"codeline\">if (s-&gt;isValid())</code><code class=\"codeline\">   v@Cd = {0,1,0};</code></div><p>This example defines <code>file_size</code>, <code>file_exists</code>, and <code>file_isdir</code> convenience functions using the information from <code>file_stat</code>.</p><div class=\"codeblock\"><code class=\"codeline\">#include &lt;file.h&gt;</code><code class=\"codeline\"></code><code class=\"codeline\">int file_size(string name)</code><code class=\"codeline\">{</code><code class=\"codeline\">    stat        info(name);</code><code class=\"codeline\">    return file_stat(name)-&gt;st_size;</code><code class=\"codeline\">}</code><code class=\"codeline\"></code><code class=\"codeline\">int file_exists(string name)</code><code class=\"codeline\">{</code><code class=\"codeline\">    // Use cached file_stat() results</code><code class=\"codeline\">    return cached_file_stat(name)-&gt;isValid();</code><code class=\"codeline\">}</code><code class=\"codeline\"></code><code class=\"codeline\">int file_isdir(string name)</code><code class=\"codeline\">{</code><code class=\"codeline\">    return file_stat(name)-&gt;isDir();</code><code class=\"codeline\">}</code></div></body>",
    "filtershadow": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/filtershadow\">filtershadow</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Sends a ray from the position P along direction D.</p><div class=\"usage\"> <code>vector filtershadow(vector P, vector D, float bias, ...)</code></div><p>Sends a ray from the position <code class=\"var\">P</code> along direction <code class=\"var\">D</code>. The length of\nthe <code class=\"var\">D</code> vector represents the farthest distance considered when check\nfor occlusion.</p><p>Each occluding surface will be evaluated and its opacity will be added\nto the total occlusion. The return code of this function is the total\nocclusion of shaded surfaces between the point <code class=\"var\">P</code> and the point\nspecified by <code class=\"var\">P</code> + <code class=\"var\">D</code>.</p></body>",
    "filterstep": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/filterstep\">filterstep</a></h1><p class=\"summary\">Returns the anti-aliased weight of the step function.</p><div class=\"usage\"> <code>float filterstep(float edge, float x, ...)</code></div><div class=\"usage\"> <code>float filterstep(float edge, float x0, float x1, ...)</code></div><p>Returns the anti-aliased weight of the step function. The\nstep function returns 0 if x is less than edge and 1 if x is greater\nthan edge. <code>filterstep</code> returns a fraction representing the\nfiltered area under the step function.  Filtering is computed using\nderivatives <code>Du()</code> and <code>Dv()</code> which are only non-zero in shading and COP\ncontexts, so <code>filterstep</code> will not perform filtering in other contexts.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">f = filterstep(0.5, s+t, \"filter\", \"gauss\", \"width\", 2);</code></div><p>The <code>filterstep(float edge, x, ...)</code> form is roughly equivalent to:</p><div class=\"codeblock\"><code class=\"codeline\">f = filterstep(edge, x, x + abs(Du(x) + Dv(x)));</code></div></body>",
    "filter_remap": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/filter_remap\">filter_remap</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Computes an importance sample based on the given filter type and input uv.</p><div class=\"usage\"> <code>vector filter_remap(vector2 uv, string filter, float width, ...)</code></div><p>This function maps a uv coordinate to a pixel offset based on the importance\nsampling of the filter.</p><div class=\"argument\"><code><code>uv</code></code></div><p>Components should be in the range <code>0</code> to <code>1</code>. The function remaps these coordinates into a point in the filter\u2019s kernel, mapping more points to areas with higher weights. The returned points will be in a box of given <code class=\"var\">width</code> centered around <code>0</code>.</p><div class=\"argument\"><code><code>filter</code></code></div><p>The type of filter to use.</p><div class=\"argument\"><code><code>\"gauss\"</code></code></div><p>Gaussian filter</p><div class=\"argument\"><code><code>\"box\"</code></code></div><p>Box filter</p><div class=\"argument\"><code><code>\"sinc\"</code></code></div><p>Sinc filter</p><div class=\"argument\"><code><code>\"mitchell\"</code></code></div><p>Mitchell filter</p><div class=\"argument\"><code><code>\"bartlett\"</code></code></div><p>Bartlett filter (Cone filter)</p><div class=\"argument\"><code><code>\"blackman\"</code></code></div><p>Blackman filter</p><div class=\"argument\"><code><code>\"catrom\"</code></code></div><p>Catmull-Rom filter</p><div class=\"argument\"><code><code>\"hanning\"</code></code></div><p>Hanning filter</p><div class=\"argument\"><code><code>\"point\"</code></code></div><p>Point filter</p><div class=\"argument\"><code><code>width</code></code></div><p>The filter width.</p><p>A unit box filter will map the input values to the range <code>-0.5</code> to <code>0.5</code>.  Changing the <code>width</code> to <code>2.0</code> will result in returned values in the range <code>-1.0 to 1.0</code>.\n    For a Gaussian filter, for example, a <code>width</code> of <code>2.0</code> is more appropriate.</p><div class=\"argument\"><code><code>res</code></code></div><span class=\"padder\"><span class=\"pillow\">int</span></span><span class=\"padder\"><span class=\"pillow\">32</span></span><p>When building lookup tables for importance sampling, the filter is sampled radially at this resolution.</p><h2>Returns</h2><p>The returned vector\u2019s <code>x</code> and <code>y</code> components are the given uv coordinate remapped to pixel coordinates (centered around zero). The <code>z</code> component is the approximate weight of the kernel at the returned sample.</p><p>Note that some filters (<code>\"sinc\"</code>, <code>\"mitchell\"</code>, <code>\"catrom\"</code>), have negative weights in some areas. When importance sampling, you cannot use negative values, so you should use the absolute value of the weight (using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/abs\">abs</a>). However, some applications need to know whether the returned sample had a negative weight.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/importance_remap\">importance_remap</a></div></body>",
    "find": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/find\">find</a></h1><p class=\"summary\">Finds an item in an array or string.</p><div class=\"usage\"> <code>int find(string haystack; string needle)</code></div><div class=\"usage\"> <code>int find(string haystack; string needle; int start)</code></div><div class=\"usage\"> <code>int find(string haystack; string needle; int start; int end)</code></div><p>Returns the position of the first occurrence of the <code>needle</code> string within the <code>haystack</code> string. You can limit the result to the first substring that starts at or after a <code>start</code> position, and at or before an <code>end</code> position.</p><p>You can find each occurrence in a loop by setting <code>start</code> at each iteration to the end of the previous match.</p><p>Returns a negative number if the substring is not found.</p><div class=\"usage\"> <code>int [] find(string haystack; string needle)</code></div><div class=\"usage\"> <code>int [] find(string haystack; string needle; int start)</code></div><div class=\"usage\"> <code>int [] find(string haystack; string needle; int start; int end)</code></div><p>Returns a list of positions of occurrences of the <code>needle</code> string within the <code>haystack</code> string. You can limit the results to substrings that start at or after a <code>start</code> position, and before an <code>end</code> position.</p><p>Returns an empty array if the substring is not found.</p><div class=\"usage\"> <code>int find(&lt;type&gt; array[]; &lt;type&gt; target)</code></div><div class=\"usage\"> <code>int find(&lt;type&gt; array[]; &lt;type&gt; target; int start)</code></div><div class=\"usage\"> <code>int find(&lt;type&gt; array[]; &lt;type&gt; target; int start; int end)</code></div><p>Returns the position of the first occurrence of the <code>target</code> value within the <code>array</code>. You can limit the result to the first occurrence at or after a <code>start</code> position, and at or before an <code>end</code> position.</p><p>You can find each occurrence in a loop by setting <code>start</code> at each iteration to the next position after the previous match.</p><p>Returns a negative number if the target is not found.</p><div class=\"usage\"> <code>int [] find(&lt;type&gt; array[]; &lt;type&gt; target)</code></div><div class=\"usage\"> <code>int [] find(&lt;type&gt; array[]; &lt;type&gt; target; int start)</code></div><div class=\"usage\"> <code>int [] find(&lt;type&gt; array[]; &lt;type&gt; target; int start; int end)</code></div><p>Returns a list of positions of occurrences of the <code>target</code> value within the <code>array</code>. You can limit the results to occurrences at or after a <code>start</code> position, and before an <code>end</code> position.</p><div class=\"related\">When you specify an <code>end</code> position, it means the matching substring must <em>start</em> before the <code>end</code>.</div><div class=\"related\">The scalar versions return <code>-len(haystack)-1</code> to indicate no matches. This value is intended to cause an error if you try to use it as an index into the string/array.</div><div class=\"related\">Searching for the empty string always fails. This differs from Python.</div><div class=\"related\">You cannot use negative indices for the <code>start</code> and <code>end</code> arguments.</div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/len\">len</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/push\">push</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/append\">append</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/resize\">resize</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">Arrays</a></div></body>",
    "findattribval": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/findattribval\">findattribval</a></h1><p class=\"summary\">Finds a primitive/point/vertex that has a certain attribute value.</p><div class=\"usage\"> <code>int findattribval( &lt;geometry&gt;, string attribclass, string attribute_name, int|string value, int which=0)</code></div><div class=\"usage\"> <code>int[] findattribval( &lt;geometry&gt;, string attribclass, string attribute_name, int|string value)</code></div><div class=\"argument\"><code>value</code></div><p>The value to look for in the attribute.</p><div class=\"argument\"><code>which</code></div><p>If multiple elements have the given value in the attribute, this controls which match to return.</p><p>If you're searching for multiple elements with the same attribute value, you can use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/findattribvalcount\">findattribvalcount</a> to get the total number of matches and then iterate through them by increasing the <code>which</code> argument to this function in a loop. See the examples below.\n    The array signature can also be used to return a list of all of the matching elements.</p><h2>Returns</h2><p>The number of the first point/primitive/vertex where the named attribute matches the given <code>value</code>. Returns <code>-1</code> if no element has the given attribute value.\n    The array signature returns the numbers of all of the points/primitives/vertices where the named attribute matches the given <code>value</code>.</p><h2>Tip</h2><p>The most common use cases (finding an point/primitive by its <code>name</code> or <code>id</code> attribute) have easier-to-use dedicated wrapper functions: <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nametopoint\">nametopoint</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nametoprim\">nametoprim</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/idtopoint\">idtopoint</a>, and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/idtoprim\">idtoprim</a>.</p><div class=\"related\">You can only search for integer or string values.</div><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int prim_num = findattribval(0, \"prim\", \"id\", 10);</code><code class=\"codeline\">    // Note: you can use idtoprim(0, 10) instead</code></div><div class=\"codeblock\"><code class=\"codeline\">for (int point_num : findattribval(0, \"point\", \"age\", 10))</code><code class=\"codeline\">    {</code><code class=\"codeline\">        // ...do something with the point...</code><code class=\"codeline\">    }</code></div><div class=\"codeblock\"><code class=\"codeline\">int count = findattribvalcount(0, \"point\", \"age\", 10);</code><code class=\"codeline\">    int point_num;</code><code class=\"codeline\">    for (int i = 0; i &lt; count; i++) {</code><code class=\"codeline\">        point_num = findattribval(0, \"point\", \"age\", 10, i);</code><code class=\"codeline\">        // ...do something with the point...</code><code class=\"codeline\">    }</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nametopoint\">nametopoint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nametoprim\">nametoprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/idtopoint\">idtopoint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/idtoprim\">idtoprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/findattribvalcount\">findattribvalcount</a></div></body>",
    "findattribvalcount": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/findattribvalcount\">findattribvalcount</a></h1><p class=\"summary\">Returns number of elements where an integer or string attribute has a certain value.</p><div class=\"usage\"> <code>int findattribvalcount( &lt;geometry&gt;, string attribclass, string attribute_name, int|string value)</code></div><p>Returns the number of elements that has that integer or string value set on the given attribute name.</p><div class=\"argument\"><code>value</code></div><p>The value to match.  Must be of the same type as the attribute.</p></body>",
    "finput": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/finput\">finput</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns fully filtered pixel input.</p><div class=\"usage\"> <code>vector finput(int u, int v, ...)</code></div><div class=\"usage\"> <code>vector4 finput(int u, int v, ...)</code></div><div class=\"usage\"> <code>vector finput(float u, float v, ...)</code></div><div class=\"usage\"> <code>vector4 finput(float u, float v, ...)</code></div><div class=\"usage\"> <code>float finput(int component, int u, int v, ...)</code></div><div class=\"usage\"> <code>float finput(int component, float u, float v, ...)</code></div><div class=\"usage\"> <code>vector finput(int opinput, int planeindex, int u, int v, ...)</code></div><div class=\"usage\"> <code>vector4 finput(int opinput, int planeindex, int u, int v, ...)</code></div><div class=\"usage\"> <code>vector finput(int opinput, int planeindex, float u, float v, ...)</code></div><div class=\"usage\"> <code>vector4 finput(int opinput, int planeindex, float u, float v, ...)</code></div><div class=\"usage\"> <code>float finput(int opinput, int planeindex, int component, int u, int v, ...)</code></div><div class=\"usage\"> <code>float finput(int opinput, int planeindex, int component, float u, float v, ...)</code></div><div class=\"usage\"> <code>vector finput(int opinput, int planeindex, int arrayindex, int u, int v, int frame, ...)</code></div><div class=\"usage\"> <code>vector4 finput(int opinput, int planeindex, int arrayindex, int u, int v, int frame, ...)</code></div><div class=\"usage\"> <code>vector finput(int opinput, int planeindex, int arrayindex, float u, float v, int frame, ...)</code></div><div class=\"usage\"> <code>vector4 finput(int opinput, int planeindex, int arrayindex, float u, float v, int frame, ...)</code></div><div class=\"usage\"> <code>float finput(int opinput, int planeindex, int arrayindex, int component, int u, int v, int frame, ...)</code></div><div class=\"usage\"> <code>float finput(int opinput, int planeindex, int arrayindex, int component, float u, float v, int frame, ...)</code></div><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/cop_sample_suite\">COP pixel sampling functions</a> for more information.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/cop_sample_suite\">/vex/cop_sample_suite</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/binput\">binput</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cinput\">cinput</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ninput\">ninput</a></div></body>",
    "fit": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit\">fit</a></h1><p class=\"summary\">Takes the value in one range and shifts it to the corresponding value in a new range.</p><div class=\"usage\"> <code>float fit(float value, float omin, float omax, float nmin, float nmax)</code></div><div class=\"usage\"> <code>&lt;vector&gt; fit(&lt;vector&gt; value, &lt;vector&gt; omin, &lt;vector&gt; omax, &lt;vector&gt; nmin, &lt;vector&gt; nmax)</code></div><p>Takes the value in the range (<code class=\"var\">omin</code>, <code class=\"var\">omax</code>) and shifts it to the corresponding value in the new range (<code class=\"var\">nmin</code>, <code class=\"var\">nmax</code>).</p><p>The function clamps the given value the range (<code class=\"var\">omin</code>, <code class=\"var\">omax</code>) before fitting, so the resulting value will be guaranteed to be in the range (<code class=\"var\">nmin</code>, <code class=\"var\">nmax</code>). To avoid clamping use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/efit\">efit</a> instead.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">fit(.3, 0, 1, 10, 20) == 13</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/clamp\">clamp</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit01\">fit01</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit10\">fit10</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit11\">fit11</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/efit\">efit</a></div></body>",
    "fit01": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit01\">fit01</a></h1><p class=\"summary\">Takes the value in the range <code>(0, 1)</code> and shifts it to the corresponding value in a new range.</p><div class=\"usage\"> <code>float fit01(float value, float nmin, float nmax)</code></div><div class=\"usage\"> <code>&lt;vector&gt; fit01(&lt;vector&gt; value, &lt;vector&gt; nmin, &lt;vector&gt; nmax)</code></div><p>Takes the value in the range (0, 1) and shifts it to the corresponding value in the new range (<code class=\"var\">nmin</code>, <code class=\"var\">nmax</code>). For vectors it does this per-component.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/clamp\">clamp</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit\">fit</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit10\">fit10</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit11\">fit11</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/efit\">efit</a></div></body>",
    "fit10": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit10\">fit10</a></h1><p class=\"summary\">Takes the value in the range <code>(1, 0)</code> and shifts it to the corresponding value in a new range.</p><div class=\"usage\"> <code>float fit10(float value, float nmin, float nmax)</code></div><div class=\"usage\"> <code>&lt;vector&gt; fit10(&lt;vector&gt;  value, &lt;vector&gt;  nmin, &lt;vector&gt;  nmax)</code></div><p>Takes the value in the range (1, 0) and shifts it to the corresponding value in the new range (<code class=\"var\">nmin</code>, <code class=\"var\">nmax</code>). For vectors it does this per-component.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/clamp\">clamp</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit\">fit</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit01\">fit01</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit11\">fit11</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/efit\">efit</a></div></body>",
    "fit11": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit11\">fit11</a></h1><p class=\"summary\">Takes the value in the range <code>(-1, 1)</code> and shifts it to the corresponding value in a new range.</p><div class=\"usage\"> <code>float fit11(float value, float nmin, float nmax)</code></div><div class=\"usage\"> <code>&lt;vector&gt; fit11(&lt;vector&gt; value, &lt;vector&gt; nmin, &lt;vector&gt; nmax)</code></div><p>Takes the value in the range (-1, 1) and shifts it to the corresponding value in the new range (<code class=\"var\">nmin</code>, <code class=\"var\">nmax</code>). For vectors it does this per-component.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/clamp\">clamp</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit\">fit</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit01\">fit01</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fit10\">fit10</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/efit\">efit</a></div></body>",
    "floor": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/floor\">floor</a></h1><p class=\"summary\">Returns the largest integer less than or equal to the argument.</p><div class=\"usage\"> <code>int|float floor(float n)</code></div><div class=\"usage\"> <code>&lt;vector&gt; floor(&lt;vector&gt; v)</code></div><p>Returns the largest integer less than or equal to the argument. For vectors, this is done per-component.</p></body>",
    "flownoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/flownoise\">flownoise</a></h1><p class=\"summary\">Generates 1D and 3D Perlin Flow Noise from 3D and 4D data.</p><div class=\"usage\"> <code>float flownoise(vector xyz, float flow)</code></div><div class=\"usage\"> <code>vector flownoise(vector xyz, float flow)</code></div><div class=\"usage\"> <code>float flownoise(vector4 xyzt, float flow)</code></div><div class=\"usage\"> <code>vector flownoise(vector4 xyzt, float flow)</code></div><div class=\"usage\"> <code>float flownoise(float x, float y, float flow)</code></div><div class=\"usage\"> <code>vector flownoise(float x, float y, float flow)</code></div><p>This operator generates 1D and 3D Perlin Flow noise from 3D and 4D data.\nThere are two forms of Perlin flow noise: a non-periodic noise which changes\nrandomly throughout the N-dimensional space, and a periodic form which\nrepeats itself over a given range of the space. The periodic form can be\nused to generate patterns which tile over N-dimensional space, such as a\nnoise-based texture map which repeats seamlessly.</p><p>The noise has a range of (0, 1) with a median value of 0.5. The\ndistribution of the noise depends on the dimension, with higher\ndimensions approaching a Gaussian distribution of noise values.</p><p>Flow noise is very similar to Perlin noise, as in\n<a href=\"https://www.sidefx.com/docs/houdini/nodes/vop/periodicnoise\">vop/periodicnoise</a>, but with an extra flow parameter.  The flow\nparameter can be thought of as an extra dimension, but a dimension\nwhose period is always 1.  Moving through the flow dimension rotates\nthe noise vectors rather than adjusting slices through a noise space, which generates a more flowing appearance to the animation.</p><h2>Related</h2></body>",
    "flowpnoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/flowpnoise\">flowpnoise</a></h1><p class=\"summary\">There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space.</p><div class=\"usage\"> <code>float flowpnoise(vector xyz, vector p, float flow)</code></div><div class=\"usage\"> <code>vector flowpnoise(vector xyz, vector p, float flow)</code></div><div class=\"usage\"> <code>float flowpnoise(vector4 xyzt, vector4 p, float flow)</code></div><div class=\"usage\"> <code>vector flowpnoise(vector4 xyzt, vector4 p, float flow)</code></div><div class=\"usage\"> <code>float flowpnoise(float x, float y, int px, int py, float flow)</code></div><div class=\"usage\"> <code>vector flowpnoise(float x, float y, int px, int py, float flow)</code></div><div class=\"usage\"> <code>float flowpnoise(vector xyz, int px, int py, int pz, float flow)</code></div><div class=\"usage\"> <code>vector flowpnoise(vector xyz, int px, int py, int pz, float flow)</code></div><div class=\"usage\"> <code>float flowpnoise(vector4 xyzt, int px, int py, int pz, int pt, float flow)</code></div><div class=\"usage\"> <code>vector flowpnoise(vector4 xyzt, int px, int py, int pz, int pt, float flow)</code></div><p>This operator generates 1D and 3D Perlin Flow noise from 3D and 4D data.\nThere are two forms of Perlin flow noise: a non-periodic noise which changes\nrandomly throughout the N-dimensional space, and a periodic form which\nrepeats itself over a given range of the space. The periodic form can be\nused to generate patterns which tile over N-dimensional space, such as a\nnoise-based texture map which repeats seamlessly.</p><p>The noise has a range of (0, 1) with a median value of 0.5. The\ndistribution of the noise depends on the dimension, with higher\ndimensions approaching a Gaussian distribution of noise values.</p><p>Flow noise is very similar to Perlin noise, as in\n<a href=\"https://www.sidefx.com/docs/houdini/nodes/vop/periodicnoise\">vop/periodicnoise</a>, but with an extra flow parameter.  The flow\nparameter can be thought of as an extra dimension, but a dimension\nwhose period is always 1.  Moving through the flow dimension rotates\nthe noise vectors rather than adjusting slices through a noise space, which generates a more flowing appearance to the animation.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/random\">noise and randomness</a>  in the VEX language\nguide for more information.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pnoise\">noise</a></div></body>",
    "foreach": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/foreach\">foreach</a></h1><span class=\"padder\"><span class=\"pillow\">vexstatement</span></span><p class=\"summary\">Loops over the items in an array, with optional enumeration.</p><p>The length of the array is determined before the first iteration, so if the array is changed during the foreach this will not be reflected in the number of iterations.</p><h2>Simple form</h2><div class=\"codeblock\"><code class=\"codeline\">foreach ([element_type] value; array) {</code><code class=\"codeline\"></code><code class=\"codeline\">}</code></div><p>This loops over the members of <code class=\"var\">array</code>. For each iteration, it <strong>copies</strong>\nthe current member to <code class=\"var\">value</code> and then executes <code class=\"var\">statement</code>. For example:</p><div class=\"codeblock\"><code class=\"codeline\">int an_array[] = {1, 2}</code><code class=\"codeline\">foreach (int num; an_array) {</code><code class=\"codeline\">    printf(\"%d\", num);</code><code class=\"codeline\">}</code></div><h2>Enumerated form</h2><p>The second form lets you specify an enumeration variable:</p><div class=\"codeblock\"><code class=\"codeline\">foreach (index, value; array) statement;</code><code class=\"codeline\">foreach (int index; element_type value; array) statement;</code></div><p>For each iteration, this form assigns the current <em>position</em> in the array\nto <code class=\"var\">index</code>, <strong>copies</strong> the current member to <code class=\"var\">value</code>, and executes\n<code class=\"var\">statement</code>. For example:</p><div class=\"codeblock\"><code class=\"codeline\">string days[] = { \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\" }</code><code class=\"codeline\">foreach (int i; string name; days) {</code><code class=\"codeline\">    printf(\"Day number %d is %s\", i, name);</code><code class=\"codeline\">}</code></div><p>This is similar to the common Python idiom <code>for i, x in enumerate(xs):</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div></body>",
    "forpoints": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/forpoints\">forpoints</a></h1><span class=\"padder\"><span class=\"pillow\">vexstatement</span></span><span class=\"padder\"><span class=\"pillow\">image3d</span></span><p>In the <a href=\"https://www.sidefx.com/docs/houdini/vex/contexts/image3d\">image3d context</a>, when geometry is specified (i.e. metaball geometry or particles), you can iterate over the metaballs which affect a point in space.</p><div class=\"codeblock\"><code class=\"codeline\">forpoints ( position [, distance] ) {</code><code class=\"codeline\"></code><code class=\"codeline\">}</code></div><p>\u2026where the position is a vector representing a point in space. The statement will be executed once for each metaball/particle at the position passed in.</p><p>If you specify the distance, all metaballs/particles within the distance of the point specified will be iterated through. The distance parameter is optional and may result in slower execution of the shader.</p><p>Inside the loop, you can call the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/mdensity\">mdensity</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/mattrib\">mattrib</a> functions to query the contribution of the current point instead of getting a blended value.</p><p>For example, the following code will take the point color of the metaball which contributes the maximum weight to the point in space:</p><div class=\"codeblock\"><code class=\"codeline\">float d = 0, max = 0;</code><code class=\"codeline\">vector clr = 0;</code><code class=\"codeline\">vector blended_color;</code><code class=\"codeline\"></code><code class=\"codeline\">forpoints ( P ) {</code><code class=\"codeline\">    d = mdensity(P);</code><code class=\"codeline\">    if (d &gt; max) {</code><code class=\"codeline\">        clr = mattrib(\"Cd\", P);</code><code class=\"codeline\">        max = d;</code><code class=\"codeline\">    }</code><code class=\"codeline\">    blended_color = d * clr;</code><code class=\"codeline\">}</code></div><p>Note that when you call <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/mattrib\">mattrib</a> inside a <code>forpoints</code> loop, the attribute is not pre-blended by the density of the metaball.</p></body>",
    "frac": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/frac\">frac</a></h1><p class=\"summary\">Returns the fractional component of the floating point number.</p><div class=\"usage\"> <code>float frac(float n)</code></div><div class=\"usage\"> <code>&lt;vector&gt; frac(&lt;vector&gt; v)</code></div><p>Returns the fractional component of the floating point number. For example, <code>frac(1.5)</code> would return <code>0.5</code>. For vectors, this done per-component.</p></body>",
    "fresnel": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fresnel\">fresnel</a></h1><p class=\"summary\">Computes the fresnel reflection/refraction contributions given an\nincoming vector, surface normal (both normalized), and an index of\nrefraction (eta).</p><div class=\"usage\"> <code>void fresnel(vector i, vector n, float eta, float &amp;kr, float &amp;kt)</code></div><div class=\"usage\"> <code>void fresnel(vector i, vector n, float eta, float &amp;kr, float &amp;kt, vector &amp;R, vector &amp;T)</code></div><p>Computes the fresnel reflection/refraction contributions given an\nincoming vector, surface normal (both normalized), and an index of\nrefraction (eta). The amount of reflected light will be returned in\n<code class=\"var\">kr</code>, and the amount of transmitted light will be returned in <code class=\"var\">kt</code>.\nOptionally, the reflection and transmission vectors can be returned in\nthe <code class=\"var\">R</code> and <code class=\"var\">T</code> variables. The R and &lt;type&gt; variables will be normalized\nvectors on exit.</p><p><code class=\"var\">eta</code> is a relative index of refraction, the ratio between\nthe interior and exterior index of refraction, where the exterior\nis defined by the direction of the normals (normals point away from\nthe interior).</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/refract\">refract</a></div></body>",
    "fromNDC": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fromNDC\">fromNDC</a></h1><p class=\"summary\">Transforms a position from normal device coordinates to the\ncoordinates in the appropriate space.</p><div class=\"usage\"> <code>vector fromNDC(vector v)</code></div><p>Transforms the vector from NDC space to the current space.</p><div class=\"usage\"> <code>vector fromNDC(string space, vector v)</code></div><p>Transforms the vector from NDC space to the named space.</p><div class=\"argument\"><code>space</code></div><h2>Warning</h2><p>NDC space is only well-defined for the\n    <a href=\"https://www.sidefx.com/docs/houdini/vex/contexts/shading_contexts\">Displacement, Surface, and Light contexts</a>.</p></body>",
    "frontface": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/frontface\">frontface</a></h1><p class=\"summary\">If dot(I, Nref) is less than zero, N will be negated.</p><div class=\"usage\"> <code>vector frontface(vector N, vector I)</code></div><p>This form (which doesn\u2019t take a reference vector) is only available in\nthe shading contexts, where the <code class=\"var\">Ng</code> variable is used.</p><div class=\"usage\"> <code>vector frontface(vector N, vector I, vector Nref)</code></div><p>If <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/dot\">dot</a>(I, Nref) is less than zero, N will be negated.</p></body>",
    "fuzzify": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzify\">fuzzify</a></h1><div class=\"usage\"> <code>float fuzzify(string ramp_basis[]; float ramp_values[]; float ramp_positions[]; float crisp_value; float min_value; float max_value)</code></div><p>Converts a crisp value to a fuzzy value based on an input membership function.</p></body>",
    "fuzzy_and": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_and\">fuzzy_and</a></h1><div class=\"usage\"> <code>int fuzzy_and(int a, int b, ...)</code></div><div class=\"usage\"> <code>float fuzzy_and(float a, float b, ...)</code></div><p>Returns the fuzzy AND (Zadeh AND) of the input fuzzy values.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nand\">fuzzy_nand</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_not\">fuzzy_not</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_or\">fuzzy_or</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nor\">fuzzy_nor</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_xor\">fuzzy_xor</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nxor\">fuzzy_nxor</a></div></body>",
    "fuzzy_defuzz_centroid": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_defuzz_centroid\">fuzzy_defuzz_centroid</a></h1><div class=\"usage\"> <code>float fuzzy_defuzz_centroid(const float aggregated_membership[]; const float min_value; const float max_value)</code></div><p>Returns a crisp value given a range for the crisp value, and an aggregated membership function for the output variable.</p></body>",
    "fuzzy_nand": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nand\">fuzzy_nand</a></h1><div class=\"usage\"> <code>int fuzzy_nand(int a, int b, ...)</code></div><div class=\"usage\"> <code>float fuzzy_nand(float a, float b, ...)</code></div><p>Returns the fuzzy NAND (Zadeh NAND) of the input fuzzy values.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_and\">fuzzy_and</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_not\">fuzzy_not</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_or\">fuzzy_or</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nor\">fuzzy_nor</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_xor\">fuzzy_xor</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nxor\">fuzzy_nxor</a></div></body>",
    "fuzzy_nor": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nor\">fuzzy_nor</a></h1><div class=\"usage\"> <code>int fuzzy_nor(int a, int b, ...)</code></div><div class=\"usage\"> <code>float fuzzy_nor(float a, float b, ...)</code></div><p>Returns the fuzzy NOR (Zadeh NOR) of the input fuzzy values.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_and\">fuzzy_and</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nand\">fuzzy_nand</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_not\">fuzzy_not</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_or\">fuzzy_or</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_xor\">fuzzy_xor</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nxor\">fuzzy_nxor</a></div></body>",
    "fuzzy_not": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_not\">fuzzy_not</a></h1><div class=\"usage\"> <code>int fuzzy_not(int n)</code></div><div class=\"usage\"> <code>float fuzzy_not(float n)</code></div><p>Returns the fuzzy NOT (Zadeh NOT) of the input fuzzy value.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_and\">fuzzy_and</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nand\">fuzzy_nand</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_or\">fuzzy_or</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nor\">fuzzy_nor</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_xor\">fuzzy_xor</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nxor\">fuzzy_nxor</a></div></body>",
    "fuzzy_nxor": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nxor\">fuzzy_nxor</a></h1><div class=\"usage\"> <code>int fuzzy_nxor(int a, int b, ...)</code></div><div class=\"usage\"> <code>float fuzzy_nxor(float a, float b, ...)</code></div><p>Returns the fuzzy NXOR (Zadeh NXOR) of the input fuzzy values.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_and\">fuzzy_and</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nand\">fuzzy_nand</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_not\">fuzzy_not</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_or\">fuzzy_or</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nor\">fuzzy_nor</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_xor\">fuzzy_xor</a></div></body>",
    "fuzzy_or": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_or\">fuzzy_or</a></h1><div class=\"usage\"> <code>int fuzzy_or(int a, int b, ...)</code></div><div class=\"usage\"> <code>float fuzzy_or(float a, float b, ...)</code></div><p>Returns the fuzzy OR (Zadeh OR) of the input fuzzy values.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_and\">fuzzy_and</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nand\">fuzzy_nand</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_not\">fuzzy_not</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nor\">fuzzy_nor</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_xor\">fuzzy_xor</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nxor\">fuzzy_nxor</a></div></body>",
    "fuzzy_xor": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_xor\">fuzzy_xor</a></h1><div class=\"usage\"> <code>int fuzzy_xor(int a, int b, ...)</code></div><div class=\"usage\"> <code>float fuzzy_xor(float a, float b, ...)</code></div><p>Returns the fuzzy XOR (Zadeh XOR) of the input fuzzy values.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_and\">fuzzy_and</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nand\">fuzzy_nand</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_not\">fuzzy_not</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_or\">fuzzy_or</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nor\">fuzzy_nor</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fuzzy_nxor\">fuzzy_nxor</a></div></body>",
    "gather": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gather\">gather</a></h1><span class=\"padder\"><span class=\"pillow\">vexstatement</span></span><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Sends rays into the scene and returns information from the shaders of\nsurfaces hit by the rays.</p><p>You can use VEX\u2019s <code>gather</code> loop statement to send rays into the scene and gather the resulting information.</p><div class=\"codeblock\"><code class=\"codeline\">gather(vector origin, vector direction, ...)</code><code class=\"codeline\">{</code><code class=\"codeline\">    // Statements for rays that hit other surfaces</code><code class=\"codeline\">} else {</code><code class=\"codeline\">    // Statements for rays which didn't hit any surface</code><code class=\"codeline\">}</code></div><p>After the <code class=\"var\">origin</code> and <code class=\"var\">direction</code> arguments, any additional arguments are interpreted as keyword/value pairs.</p><div class=\"codeblock\"><code class=\"codeline\">gather(origin, dir, \"samples\", 100) {</code><code class=\"codeline\">    ...</code><code class=\"codeline\">}</code></div><h2>Note</h2><p>If you specify 0 samples, it will still take at least 1 sample.</p><h2>Examples</h2><p>Here are two shaders which communicate through <code>gather</code>.</p><p>This shader sends rays into the scene. It sends <code>1.234</code> in a message labeled <code>exportvalue</code>. Since the surface hit by the rays may not have an exported parameter called <code>amp</code>, it\u2019s important to initialize this variable before the gather loop.</p><div class=\"codeblock\"><code class=\"codeline\">surface</code><code class=\"codeline\">sendray(vector background=0; int nsamples=16)</code><code class=\"codeline\">{</code><code class=\"codeline\">    float   amp;</code><code class=\"codeline\"></code><code class=\"codeline\">    amp = 0;</code><code class=\"codeline\">    Cf = 0;</code><code class=\"codeline\"></code><code class=\"codeline\">    gather(P, N,</code><code class=\"codeline\">        \"bias\", 0.01,</code><code class=\"codeline\">        \"angle\", radians(15),</code><code class=\"codeline\">        \"samples\", nsamples,</code><code class=\"codeline\">        \"samplebase\", 1,</code><code class=\"codeline\">        \"distribution\", \"cosine\",</code><code class=\"codeline\">        \"send:exportvalue\", 0.8,</code><code class=\"codeline\">        \"amp\", amp)</code><code class=\"codeline\">    {</code><code class=\"codeline\">        Cf += amp;</code><code class=\"codeline\">        amp = 0;</code><code class=\"codeline\">    }</code><code class=\"codeline\">    else</code><code class=\"codeline\">    {</code><code class=\"codeline\">        Cf += background;</code><code class=\"codeline\">    }</code><code class=\"codeline\"></code><code class=\"codeline\">    Cf *= 1.0 / nsamples;</code><code class=\"codeline\">    Of = 1;</code><code class=\"codeline\">}</code></div><p>The following shader imports values which were sent to it by the gather loop. The exported parameter can be imported by the gather loop.</p><div class=\"codeblock\"><code class=\"codeline\">surface</code><code class=\"codeline\">hitsurf(export float amp=1)</code><code class=\"codeline\">{</code><code class=\"codeline\">    float   sendvalue = 0;</code><code class=\"codeline\"></code><code class=\"codeline\">    if (!rayimport(\"exportvalue\", sendvalue))</code><code class=\"codeline\">        printf(\"Error importing the send:exportvalue\\n\");</code><code class=\"codeline\"></code><code class=\"codeline\">    amp = sendvalue;</code><code class=\"codeline\"></code><code class=\"codeline\">    Cf = 1;</code><code class=\"codeline\">    Of = 1;</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rayimport\">rayimport</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/reflectlight\">reflectlight</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/refractlight\">refractlight</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/trace\">trace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/irradiance\">irradiance</a></div></body>",
    "geoself": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/geoself\">geoself</a></h1><p class=\"summary\">Returns a handle to the current geometry.</p><div class=\"usage\"> <code>int geoself()</code></div><p>Returns a handle to the current geometry, suitable for the geometry creation operations.</p></body>",
    "geounwrap": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/geounwrap\">geounwrap</a></h1><p class=\"summary\">Returns an <code>oppath:</code> string to unwrap the geometry in-place.</p><div class=\"usage\"> <code>string geounwrap( &lt;geometry&gt;, string unwrap_attribute)</code></div><p>Returns an oppath string that will cause the file or geometry to be unwrapped inplace based on a vector attribute.\nThis function adds an unwrap:attrname prefix followed by the <code class=\"var\">unwrap_attribute</code> to the <code class=\"var\">path</code>.\n<code class=\"var\">path</code> can be a filename, an oppath with the op: prefix or an opinput.\nAn <code class=\"var\">input</code> index can be supplied instead of a string.</p><p>Adding an unwrap:attrname prefix to an oppath will create a copy of the geometry and overwrite the point positions based on the unwrap attribute. The topology can change, if the attribute is a vertex attribute.</p><p>This then enables all the vex functions working on the point positions to work in a custom space such as UV space or Color space.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/intersect\">intersect</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uvdist\">uvdist</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uvintersect\">uvintersect</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uvsample\">uvsample</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xyzdist\">xyzdist</a></div></body>",
    "getattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getattrib\">getattrib</a></h1><p class=\"summary\">Reads an attribute value from geometry, with validity check.</p><div class=\"usage\"> <code>&lt;type&gt; getattrib(&lt;geometry&gt;, string attribclass, string attribute_name, int elemnum, int &amp;success)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] getattrib(&lt;geometry&gt;, string attribclass, string attribute_name, int elemnum, int &amp;success)</code></div><p>This general form lets you specify the attribute class at run-time. This can be useful for writing general code that can work on different classes.\n    If you know the class of attribute you want to read ahead of time, using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/detailattrib\">detailattrib</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primattrib\">primattrib</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointattrib\">pointattrib</a>, or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexattrib\">vertexattrib</a> may be faster.</p><div class=\"argument\"><code>success</code></div><p>If the given attribute exists and can be read, the function sets this variable to <code>1</code>. Otherwise, it sets this variable to <code>0</code>.</p><h2>Returns</h2><p>The value of the attribute.</p></body>",
    "getattribute": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getattribute\">getattribute</a></h1><p class=\"summary\">Copies the value of a geometry attribute into a variable and returns a success flag.</p><div class=\"usage\"> <code>int getattribute(string geometry, &lt;type&gt; &amp;value, string attribclass, string attribute_name, int element_number, int vertex_number)</code></div><div class=\"usage\"> <code>int getattribute(string geometry, &lt;type&gt; &amp;value[], string attribclass, string attribute_name, int element_number, int vertex_number)</code></div><h2>Warning</h2><p>This function does not allow reading from inputs in a node context, and is harder to use than the other attribute functions. You probably want to use one of the other attribute functions instead, such as <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getattrib\">getattrib</a>.</p><p>Returns <code>0</code> if the attribute does not exist or cannot be read, <code>1</code> on success. If the function returns <code>0</code> (failed), the given variable may remain uninitialized.</p><div class=\"argument\"><code>value</code></div><p>The variable to overwrite with the attribute value.</p><div class=\"argument\"><code>element_number</code></div><p>The point or primitive number. If you are reading a detail attribute, use <code>0</code> here.</p><div class=\"argument\"><code>vertex_number</code></div><div class=\"related\">When reading a vertex attribute, you can specify the primitive number in the <code>element_number</code> argument and the primitive\u2019s vertex number here.</div><div class=\"related\">To use a linear vertex index, use <code>-1</code> as the <code>element_number</code> and the vertex index here.</div><div class=\"related\">If you are not reading a vertex attribute, this argument is ignored.</div><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">vector pos, uv, clr;</code><code class=\"codeline\">// Get the position of point 3 in \"defgeo.bgeo\"</code><code class=\"codeline\">getattribute(\"defgeo.bgeo\", pos, \"point\", \"P\", 3, 0);</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the value of the \"uv\" attribute for vertex 2 of primitive</code><code class=\"codeline\">// number 3 in the file defgeo.bgeo</code><code class=\"codeline\">getattribute(\"defgeo.bgeo\", uv, \"vertex\", \"uv\", 3, 2);</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the value of the \"Cd\" attribute for primitive 7</code><code class=\"codeline\">// in the SOP specified by the path \"/obj/geo1/color1\" (Houdini</code><code class=\"codeline\">// only)</code><code class=\"codeline\">getattribute(\"op:/obj/geo1/color1\", clr, \"primitive\", \"Cd\", 7);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getattrib\">getattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/detailattrib\">detailattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primattrib\">primattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointattrib\">pointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexattrib\">vertexattrib</a></div></body>",
    "getbbox": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox\">getbbox</a></h1><p class=\"summary\">Sets two vectors to the minimum and maximum corners of the bounding box for the geometry.</p><div class=\"usage\"> <code>void getbbox(&lt;geometry&gt;, vector &amp;min, vector &amp;max)</code></div><p>Sets the vectors to the minimum and maximum corners of the bounding box\n    for the geometry.  This outputs the primitive bounding box, which includes\n    the extents of spheres and volumes.</p><div class=\"usage\"> <code>void getbbox(&lt;geometry&gt;, string primgroup, vector &amp;min, vector &amp;max)</code></div><p>Outputs the bounding box of the primitive in the given group.\n    An empty <code class=\"var\">primgroup</code> string will include all primitives.\n    The string supports Ad-hoc patterns like <code>0-10</code> and <code>@Cd.x&gt;0</code>.</p><div class=\"usage\"> <code>void getbbox(vector &amp;min, vector &amp;max)</code></div><h2>Warning</h2><p>This form of <code>getbbox</code> is deprecated and may be removed in the future. \n        Use the other forms as needed.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_center\">getbbox_center</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_max\">getbbox_max</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_min\">getbbox_min</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_size\">getbbox_size</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getpointbbox\">getpointbbox</a></div></body>",
    "getbbox_center": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_center\">getbbox_center</a></h1><p class=\"summary\">Returns the center of the bounding box for the geometry.</p><div class=\"usage\"> <code>vector getbbox_center(&lt;geometry&gt;)</code></div><p>Computes the center of the bounding box for the geometry.</p><div class=\"usage\"> <code>vector getbbox_center(&lt;geometry&gt;, string primgroup)</code></div><p>Computes the center of the bounding box of the primitives in the given group.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox\">getbbox</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_center\">getbbox_center</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_size\">getbbox_size</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_min\">getbbox_min</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_max\">getbbox_max</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getpointbbox\">getpointbbox</a></div></body>",
    "getbbox_max": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_max\">getbbox_max</a></h1><p class=\"summary\">Returns the maximum of the bounding box for the geometry.</p><div class=\"usage\"> <code>vector getbbox_max(&lt;geometry&gt;)</code></div><p>Computes the maximum of the bounding box for the geometry.</p><div class=\"usage\"> <code>vector getbbox_max(&lt;geometry&gt;, string primgroup)</code></div><p>Computes the maximum of the bounding box of the primitives in the given group.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox\">getbbox</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_center\">getbbox_center</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_size\">getbbox_size</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_min\">getbbox_min</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_max\">getbbox_max</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getpointbbox\">getpointbbox</a></div></body>",
    "getbbox_min": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_min\">getbbox_min</a></h1><p class=\"summary\">Returns the minimum of the bounding box for the geometry.</p><div class=\"usage\"> <code>vector getbbox_min(&lt;geometry&gt;)</code></div><p>Computes the minimum of the bounding box for the geometry.</p><div class=\"usage\"> <code>vector getbbox_min(&lt;geometry&gt;, string primgroup)</code></div><p>Computes the minimum of the bounding box of the primitives in the given group.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox\">getbbox</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_center\">getbbox_center</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_size\">getbbox_size</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_min\">getbbox_min</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_max\">getbbox_max</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getpointbbox\">getpointbbox</a></div></body>",
    "getbbox_size": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_size\">getbbox_size</a></h1><p class=\"summary\">Returns the size of the bounding box for the geometry.</p><div class=\"usage\"> <code>vector getbbox_size(&lt;geometry&gt;)</code></div><p>Computes the size of the bounding box for the geometry.</p><div class=\"usage\"> <code>vector getbbox_size(&lt;geometry&gt;, string primgroup)</code></div><p>Computes the size of the bounding box of the primitives in the given group.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox\">getbbox</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_center\">getbbox_center</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_size\">getbbox_size</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_min\">getbbox_min</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_max\">getbbox_max</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getpointbbox\">getpointbbox</a></div></body>",
    "getblurP": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getblurP\">getblurP</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Returns the blurred point position (<code>P</code>) vector at a fractional time within the motion blur exposure.</p><div class=\"usage\"> <code>vector getblurP(float <code class=\"var\">delta</code>)</code></div><p>Returns the position (<code>P</code>) of the current shading point at fractional time <code class=\"var\">delta</code> within the motion blur exposure. When motion blur is disabled, <code>getblurP() </code>will always return the shading position <code>P</code>.  When motion blur is enabled, <code>getblurP(0)</code> and <code>getblurP(1)</code> will return the positions at the extent of the shading position\u2019s motion path, with fractional values between 0 and 1 generating other intermediate shading positions.  For example, <code>getblurP(0.5)</code> returns the point\u2019s blurred position half-way through the current exposure.</p><p>When shading micropolygons, <code>P</code> will always store the initial position of the point (at time = 0). For raytracing, <code>P</code> will store the final position after motion transformation for the sample being shaded - at the time given by the <code>Time</code> global variable in the VEX shading context.  If you want to determine the shading position at other times it is necessary to use <code>getblurP</code>.</p><p>When using point clouds that were generated at time = 0, you should use <code>getblurP(0)</code> to find the position at the start of the frame\u2019s exposure and then use this position to look up in the point cloud.</p><p>For example:</p><div class=\"codeblock\"><code class=\"codeline\">vector p0 = getblurP(0);</code><code class=\"codeline\">int handle = pcopen(\"pcloud.pc\", p0, ...);</code></div></body>",
    "getbounces": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbounces\">getbounces</a></h1><div class=\"usage\"> <code>int getbounces(bsdf b)</code></div><p>Returns the bounce mask for the specified <code>bsdf</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nbouncetypes\">nbouncetypes</a></div></body>",
    "getbounds": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbounds\">getbounds</a></h1><p class=\"summary\">Returns the bounding box of the geometry specified by the filename.</p><div class=\"usage\"> <code>int getbounds(string filename, vector &amp;min, vector &amp;max)</code></div><div class=\"usage\"> <code>int getbounds(string filename, string group, vector &amp;min, vector &amp;max)</code></div><p>Returns the bounding box of the geometry specified by the filename. The\npoint corresponding to the minimum corner of the bounding box will be\nreturned in <code class=\"var\">min</code>, while the maximum will be in <code class=\"var\">max</code>.\nAlways returns 1.</p><p>If a group is specified, only primitives in that group will be used.\nThe group field\u2019s behavior matches that in SOPs.  An empty string\nwill include all primitives.  Ad-hoc patterns like <code>0-10</code> and\n<code>@Cd.x&gt;0</code> are also valid.</p><p>The <code>getbbox()</code> function should likely be used instead.</p></body>",
    "getcomp": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getcomp\">getcomp</a></h1><p class=\"summary\">Extracts a single component of a vector type, matrix type, or array.</p><div class=\"usage\"> <code>float getcomp(&lt;vector&gt; v; int index)</code></div><p>Returns the vector component at the given index.\n    This is the same as <code>v[index]</code>.</p><div class=\"usage\"> <code>float getcomp(&lt;matrix&gt; m; int row, int column)</code></div><p>Returns the matrix component at the given location.</p><div class=\"usage\"> <code>&lt;type&gt; getcomp(&lt;type&gt; array[]; int index)</code></div><p>Returns the array item at the given index.\n    This is the same as <code>array[index]</code>.</p><div class=\"usage\"> <code>&lt;type&gt; getcomp(&lt;vector&gt; array[]; int i, int j)</code></div><p>Returns the vector component at the given location and array index. This is the same as <code>getcomp(array[i], j)</code>.</p><div class=\"usage\"> <code>&lt;type&gt; getcomp(&lt;matrix&gt; array[]; int i, int j, int k)</code></div><p>Returns the matrix component at the given location and array index. This is the same as <code>getcomp(array[i], j, k)</code>.</p><div class=\"usage\"> <code>&lt;type&gt; getcomp(dict d; string index)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] getcomp(dict d; string index)</code></div><p>Returns the dictionary item at the given index.\n    This is the same as <code>d[index]</code>.</p><div class=\"usage\"> <code>&lt;type&gt; getcomp(dict d; string index; &lt;type&gt; defvalue)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] getcomp(dict d; string index; &lt;type&gt; defvalue[])</code></div><p>Returns the dictionary item at the given index.  If it doesn\u2019t exist,\n    return <code>defvalue</code>.\n    This is the same as <code>isvalidindex(d, index) ? d[index] : defvalue</code>.</p><div class=\"usage\"> <code>string getcomp(string value, int index)</code></div><p>Returns the <em>character</em> at the given index.\n    This is the same as <code>value[index]</code>.</p><p>Characters in VEX are strings as well.  UTF-8 encoding is used,\n    so if the index is part way through a UTF-8 encoding, the result\n    is an empty string.  Otherwise it is the entire valid UTF-8 character.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setcomp\">setcomp</a></div></body>",
    "getcomponents": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getcomponents\">getcomponents</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><div class=\"usage\"> <code>string[] getcomponents()</code></div><p>Returns an array of strings containing the components specified by the\n<a href=\"https://www.sidefx.com/docs/houdini/props/mantra#vm_exportcomponents\">vm_exportcomponents</a> rendering property.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/props/mantra#vm_exportcomponents\">vm_exportcomponents</a></div></body>",
    "getderiv": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getderiv\">getderiv</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Evaluates surface derivatives of an attribute.</p><div class=\"usage\"> <code>void getderiv(float attr, string attrName, int isVertexAttr, float s, float t, float &amp;du, float &amp;dv, ...)</code></div><div class=\"usage\"> <code>void getderiv(&lt;vector&gt; attr, string attrName, int isVertexAttr, float s, float t, &lt;vector&gt; &amp;du, &lt;vector&gt; &amp;dv, ...)</code></div><h2>Note</h2><p>If derivatives are queried for a polygonal mesh it is interally sampled as a Subdivision Surface.</p><div class=\"argument\"><code>attr</code></div><p>Attribute value.</p><div class=\"argument\"><code>attrName</code></div><p>Name of attribute to evaluate.</p><div class=\"argument\"><code>isVertexAttr</code></div><p>Set to <code>1</code> to indicate the attribute is a vertex type.</p><div class=\"argument\"><code>s</code></div><p>Parametric S shading value. This should be passed from the <code>s</code> global variable.</p><div class=\"argument\"><code>t</code></div><p>Parametric &lt;type&gt; shading value. This should be passed from the <code>t</code> global variable.</p><div class=\"argument\"><code>du</code></div><p>Derivative of attribute in U direction.</p><div class=\"argument\"><code>dv</code></div><p>Derivative of attribute in V direction.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get derivatives of point attribute 'N'</code><code class=\"codeline\">vector dNdu, dNdv;</code><code class=\"codeline\">getderiv(N, \"N\", 0, s, t, dNdu, dNdv);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Du\">Du</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dv\">Dv</a></div></body>",
    "getfogname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getfogname\">getfogname</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Returns the name of the current object whose shader is being run.</p><div class=\"usage\"> <code>string getfogname()</code></div><p>Returns the name of the current fog object whose shader is being run, or the empty string if there is no current fog object.</p></body>",
    "getglobalraylevel": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getglobalraylevel\">getglobalraylevel</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Returns the depth of the ray tree for computing global\nillumination.</p><div class=\"usage\"> <code>int getglobalraylevel()</code></div><p>Returns the depth of the ray tree for computing global illumination. If\nthis function returns a non-zero value, the shader is being called for\nthe purpose of evaluating global illumination.</p></body>",
    "getgroupid": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getgroupid\">getgroupid</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Returns group id containing current primitive.</p><div class=\"usage\"> <code>int getgroupid()</code></div><p>Returns the id of a primitive group containing the current face being shaded.\nThe id is the index of the group in the detail. If the primitive belongs\nto several groups, their indices are added up to calculate the returned id.</p></body>",
    "getlight": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlight\">getlight</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Returns a light struct for the specified light identifier.</p><div class=\"usage\"> <code>light getlight(int lid)</code></div><p>Given a integer light identifier (lid), you can get a reference to a light\nobject representing the light (see details on the <a href=\"https://www.sidefx.com/docs/houdini/vex/lang#mantratypes\">mantra specific type</a>)</p><div class=\"codeblock\"><code class=\"codeline\">int[] lights = getlights();</code><code class=\"codeline\">int nlights = len(lights);</code><code class=\"codeline\">for (int i = 0; i &lt; nlights; i++)</code><code class=\"codeline\">{</code><code class=\"codeline\">light lp = getlight(i);</code><code class=\"codeline\">lp-&gt;illuminate(...);</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlights\">getlights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlightname\">getlightname</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lightid\">lightid</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lightbounces\">lightbounces</a></div></body>",
    "getlightid": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlightid\">getlightid</a></h1><span class=\"padder\"><span class=\"pillow\">displace</span></span><span class=\"padder\"><span class=\"pillow\">fog</span></span><span class=\"padder\"><span class=\"pillow\">surface</span></span><p class=\"summary\">Returns the light id for a named light (or -1 for an invalid name).</p><div class=\"usage\"> <code>int getlightid(string lightname)</code></div><p>Returns the integer light identifier of the light referred to by the given name.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlights\">getlights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlightname\">getlightname</a></div></body>",
    "getlightname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlightname\">getlightname</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Returns the name of the current light when called from within an illuminance loop, or converts an integer light ID into the light\u2019s name.</p><div class=\"usage\"> <code>string getlightname()</code></div><p>Returns the name of the current light when called from within an\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a> loop or when a current light has been set using\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setcurrentlight\">setcurrentlight</a>.</p><div class=\"usage\"> <code>string getlightname(int lightid)</code></div><p>Returns the name of the light referred to by the given integer\nlight ID. Integer light IDs are used by some low-level VEX functions\ninstead of strings for efficiency.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlights\">getlights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getphotonlight\">getphotonlight</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/intersect_lights\">intersect_lights</a></div></body>",
    "getlights": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlights\">getlights</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Returns an array of light identifiers for the currently shaded surface.</p><div class=\"usage\"> <code>int[] getlights(...)</code></div><div class=\"usage\"> <code>int[] getlights(vector P, ...)</code></div><div class=\"usage\"> <code>int[] getlights(material mat; vector P; ...)</code></div><p>With this signature, the light mask is determined solely by the material (the\n    <code>lightmask</code> and <code>categories</code> keyword parameters are ignored).</p><p>This version\n    also accepts PBR keyword arguments to limit lights based on their Light\n    Contribution parameter.</p><div class=\"argument\"><code>label</code></div><span class=\"padder\"><span class=\"pillow\">string</span></span><p>A specific label.  This keyword argument may be specified multiple times.</p><div class=\"argument\"><code>direct</code></div><span class=\"padder\"><span class=\"pillow\">int</span></span><p>0 = limit lights to indirect contributions, 1 = limit lights to direct contributions.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">getlights(\"lightmask\", \"light*,^light2\");</code><code class=\"codeline\">getlights(\"categories\", \"shadow|occlusion\");</code><code class=\"codeline\">getlights(material(), P, \"direct\", 0);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getphotonlight\">getphotonlight</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/importance_light\">importance_light</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_light\">sample_light</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/intersect_lights\">intersect_lights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlightname\">getlightname</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/haslight\">haslight</a></div></body>",
    "getlightscope": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlightscope\">getlightscope</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Returns a selection of lights that illuminate a given material.</p><div class=\"usage\"> <code>void getlightscope(material mat, string &amp;scope, string &amp;categories)</code></div><p>Given a material handle, determine the lights illuminating the surface.  The light selection is given by the scope/categories returned.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getmaterial\">getmaterial</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getscope\">getscope</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/trace\">trace</a></div></body>",
    "getlocalcurvature": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlocalcurvature\">getlocalcurvature</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Evaluates local curvature of primitive grid, using the same curvature evaluation method as Measure SOPs.</p><div class=\"usage\"> <code>vector getlocalcurvature(float s, float t)</code></div><p>Returns 0 vector if the object does not have subdivision enabled, or has no displacement shader assigned.\nOtherwise, the measured convexity and concavity will be returned in <code>x</code> and <code>y</code> components respectively.</p><div class=\"argument\"><code>s</code></div><p>Parametric S shading value. This should be passed from the <code>s</code> global variable.</p><div class=\"argument\"><code>t</code></div><p>Parametric &lt;type&gt; shading value. This should be passed from the <code>t</code> global variable.</p></body>",
    "getmaterial": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getmaterial\">getmaterial</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Returns a material struct for the current surface.</p><div class=\"usage\"> <code>material getmaterial()</code></div><p>The material handle returned is opaque, but can be used by other functions to query information about the material (see details on the <a href=\"https://www.sidefx.com/docs/houdini/vex/lang#mantratypes\">mantra specific type</a>).</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlights\">getlights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlightscope\">getlightscope</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getscope\">getscope</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/haslight\">haslight</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/renderstate\">renderstate</a></div></body>",
    "getmaterialid": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getmaterialid\">getmaterialid</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Returns material id of shaded primitive.</p><div class=\"usage\"> <code>int getmaterialid()</code></div><p>Returns the material id of the primitive being shaded. The id corresponds to\nthe material being evaluated and accounts for overrides from style sheets and \ndetail assignments.</p></body>",
    "getobjectid": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getobjectid\">getobjectid</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Returns the object id for the current shading context.</p><div class=\"usage\"> <code>int getobjectid()</code></div><p>Returns the object id.</p></body>",
    "getobjectname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getobjectname\">getobjectname</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Returns the name of the current object whose shader is being run.</p><div class=\"usage\"> <code>string getobjectname()</code></div><p>Returns the name of the current object whose shader is being run, or the\nempty string if there is no current object.</p></body>",
    "getpackedtransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getpackedtransform\">getpackedtransform</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Gets the transform of a packed primitive.</p><div class=\"usage\"> <code>matrix getpackedtransform(int input, int primnum)</code></div><p>Gets the transform of a packed primitive. This is constructed from the <code>P</code>\nattribute of the primitive\u2019s point and its intrinsic <code>transform</code>.</p><h2>Warning</h2><p>This function builds a transform from <em>only</em> the <code>P</code> (position) attribute and the <code>transform</code> intrinsic attribute. It ignores various details that the <code>packedfulltransform</code> intrinsic attribute includes:</p><div class=\"related\">The packed primitive\u2019s <code>pivot</code> intrinsic attribute.</div><div class=\"related\">Instancing attributes such as <code>orient</code> (when the <code>pointinstancetransform</code> intrinsic attribute is on, as with crowd agents).</div><div class=\"related\">The <code>packedlocaltransform</code> intrinsic attribute (Alembic primitives).</div><p>So this function will not return the expected transform in several different cases.</p><p>The <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpackedtransform\">setpackedtransform</a> function has the same issues since it <em>only</em> overwrites <code>P</code> and <code>transform</code>. So, for example, the <code>packedfulltransform</code> won\u2019t contain the matrix you would expect if there is a non-zero packed pivot, or in the other cases listed above.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// matrix to transform by</code><code class=\"codeline\">matrix transform = ident();</code><code class=\"codeline\">rotate(transform, radians(45), {0,1,0});</code><code class=\"codeline\">translate(transform, {0,1,0});</code><code class=\"codeline\"></code><code class=\"codeline\">matrix tf = getpackedtransform(0, @primnum);</code><code class=\"codeline\">setpackedtransform(0, @primnum, transform * tf);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpackedtransform\">setpackedtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/packedtransform\">packedtransform</a></div></body>",
    "getphotonlight": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getphotonlight\">getphotonlight</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Returns the integer ID of the light being used for photon shading.</p><div class=\"usage\"> <code>int getphotonlight()</code></div><p>Returns <code>-1</code> if the shader is not generating photons from a light.</p><p>The return value is an integer identifying a light. You can get convert this\ninteger ID to the light name with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlightname\">getlightname</a></p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlights\">getlights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlightname\">getlightname</a></div></body>",
    "getpointbbox": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getpointbbox\">getpointbbox</a></h1><p class=\"summary\">Sets two vectors to the minimum and maximum corners of the bounding box for the geometry.</p><div class=\"usage\"> <code>void getpointbbox(&lt;geometry&gt;, vector &amp;min, vector &amp;max)</code></div><div class=\"usage\"> <code>void getpointbbox(&lt;geometry&gt;, string pointgroup, vector &amp;min, vector &amp;max)</code></div><p>This is the same as <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox\">getbbox</a> except it only computes the bounding box of the <em>points</em>. So if a primitive has extents that don\u2019t have points (for example, the boundary of a primitive sphere), they will not be included in the box.</p></body>",
    "getpointbbox_center": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getpointbbox_center\">getpointbbox_center</a></h1><p class=\"summary\">Returns the center of the bounding box for the geometry.</p><div class=\"usage\"> <code>vector getpointbbox_center(&lt;geometry&gt;)</code></div><div class=\"usage\"> <code>vector getpointbbox_center(&lt;geometry&gt;, string pointgroup)</code></div><p>This is the same as <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_center\">getbbox_center</a> except it only computes the bounding box of the <em>points</em>. So if a primitive has extents that don\u2019t have points (for example, the boundary of a primitive sphere), they will not be included in the box.</p></body>",
    "getpointbbox_max": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getpointbbox_max\">getpointbbox_max</a></h1><p class=\"summary\">Returns the maximum of the bounding box for the geometry.</p><div class=\"usage\"> <code>vector getpointbbox_max(&lt;geometry&gt;)</code></div><div class=\"usage\"> <code>vector getpointbbox_max(&lt;geometry&gt;, string pointgroup)</code></div><p>This is the same as <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_max\">getbbox_max</a> except it only computes the bounding box of the <em>points</em>. So if a primitive has extents that don\u2019t have points (for example, the boundary of a primitive sphere), they will not be included in the box.</p></body>",
    "getpointbbox_min": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getpointbbox_min\">getpointbbox_min</a></h1><p class=\"summary\">Returns the minimum of the bounding box for the geometry.</p><div class=\"usage\"> <code>vector getpointbbox_min(&lt;geometry&gt;)</code></div><div class=\"usage\"> <code>vector getpointbbox_min(&lt;geometry&gt;, string pointgroup)</code></div><p>This is the same as <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_min\">getbbox_min</a> except it only computes the bounding box of the <em>points</em>. So if a primitive has extents that don\u2019t have points (for example, the boundary of a primitive sphere), they will not be included in the box.</p></body>",
    "getpointbbox_size": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getpointbbox_size\">getpointbbox_size</a></h1><p class=\"summary\">Returns the size of the bounding box for the geometry.</p><div class=\"usage\"> <code>vector getpointbbox_size(&lt;geometry&gt;)</code></div><div class=\"usage\"> <code>vector getpointbbox_size(&lt;geometry&gt;, string pointgroup)</code></div><p>This is the same as <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox_size\">getbbox_size</a> except it only computes the bounding box of the <em>points</em>. So if a primitive has extents that don\u2019t have points (for example, the boundary of a primitive sphere), they will not be included in the box.</p></body>",
    "getprimid": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getprimid\">getprimid</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Returns the number of the current primitive.</p><div class=\"usage\"> <code>int getprimid()</code></div><p>Returns the primitive number for the current geometric primitive being shaded.</p></body>",
    "getptextureid": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getptextureid\">getptextureid</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Returns the ptexture face id for the current primitive.</p><div class=\"usage\"> <code>int getptextureid()</code></div><p>Returns the ptexture id for the current face being shaded.  This will typically\nbe the same as <code>getprimid()</code> except in the case of subdivision surfaces.  For\nsubdivision surfaces, mantra splits non-quadrilateral faces into multiple\npatches.  Each of these split faces is assigned a unique ptexture id.</p></body>",
    "getraylevel": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getraylevel\">getraylevel</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Returns the depth of the ray tree for the current shading.</p><div class=\"usage\"> <code>int getraylevel()</code></div><p>Returns the depth of the ray tree for the current shading. If the\nreturned value is 0, this represents a ray from the camera to the scene.\nIf the ray level is 1, the ray represents either a reflection/refraction\nray. If the level is 2, then this represents a reflection/refraction\nwhich appears in a previous reflection/refraction etc.</p></body>",
    "getrayweight": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getrayweight\">getrayweight</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Returns an approximation to the contribution of the ray to the final\npixel color.</p><div class=\"usage\"> <code>float getrayweight()</code></div><p>Returns an approximation to the contribution of the ray to the final\npixel color. Often, this is a better metric for judging contribution to\nthe final pixel color than <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getraylevel\">getraylevel</a>. However, this\nrelies on prior shaders giving good estimates on the contribution to\ntheir shading (see <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/reflectlight\">reflectlight</a>).</p></body>",
    "getsamplestore": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getsamplestore\">getsamplestore</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Looks up sample data in a channel, referenced by a point.</p><div class=\"usage\"> <code>int getsamplestore(string channel, vector P, int &amp;value)</code></div><div class=\"usage\"> <code>int getsamplestore(string channel, vector P, float &amp;value)</code></div><div class=\"usage\"> <code>int getsamplestore(string channel, vector P, vector &amp;value)</code></div><div class=\"usage\"> <code>int getsamplestore(string channel, vector P, vector4 &amp;value)</code></div><p>Looks up a value in a named channel at a specified point.\nReturns a non-zero value and sets <code class=\"var\">value</code> on success, or returns 0\nif the data could not be set.</p><p>The sample store can be thought of as an in-memory point cloud, storing\nshading data at points. This allows data to be accessed across shader\nboundaries, unlike the internal export/import system. For example,\na lens shader could store data to be passed to the surface shader,\nan operation that is not supported using export variables due to the\nlayout of the shading pipeline.</p><p>Please note that the stored samples can only be accessed within the same render\ntile.</p><h2>Example</h2><div class=\"codeblock\"><code class=\"codeline\">cvex displacedlens(</code><code class=\"codeline\">    // Inputs</code><code class=\"codeline\">    float x = 0;</code><code class=\"codeline\">    float y = 0;</code><code class=\"codeline\">    float Time = 0;</code><code class=\"codeline\">    float dofx = 0;</code><code class=\"codeline\">    float dofy = 0;</code><code class=\"codeline\">    float aspect = 1;</code><code class=\"codeline\"></code><code class=\"codeline\">    float displaceScale = 1.0;</code><code class=\"codeline\">    float displaceGain = 0.1;</code><code class=\"codeline\"></code><code class=\"codeline\">    // Outputs</code><code class=\"codeline\">    export vector P = 0;</code><code class=\"codeline\">    export vector I = 0;</code><code class=\"codeline\">)</code><code class=\"codeline\">{</code><code class=\"codeline\">    P = {x, y, 0};</code><code class=\"codeline\">    I = {1, 0, 0};</code><code class=\"codeline\"></code><code class=\"codeline\">    vector displace = noise(P * displaceScale) * displaceGain;</code><code class=\"codeline\">    I += displace;</code><code class=\"codeline\"></code><code class=\"codeline\">    // Store the displacement at the eye point, 'P'</code><code class=\"codeline\">    int status = setsamplestore(\"displacedlens_d\", P, displace);</code><code class=\"codeline\">}</code><code class=\"codeline\"></code><code class=\"codeline\">surface mysurface()</code><code class=\"codeline\">{</code><code class=\"codeline\">    // Get the displacement at the eye point, 'Eye'</code><code class=\"codeline\">    vector displace = 0;</code><code class=\"codeline\">    int status = getsamplestore(\"displacedlens_d\", Eye, displace);</code><code class=\"codeline\"></code><code class=\"codeline\">    //...</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setsamplestore\">setsamplestore</a></div></body>",
    "getscope": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getscope\">getscope</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Returns a selection of objects visible to rays for a given material.</p><div class=\"usage\"> <code>void getscope(material mat, string raystyle, string &amp;scope, string &amp;categories)</code></div><p>Given a material handle, determine the objects which are visible for a given raystyle (diffuse, reflect, or refract).  The object selection is given by the scope/categories returned.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getmaterial\">getmaterial</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlightscope\">getlightscope</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/trace\">trace</a></div></body>",
    "getsmoothP": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getsmoothP\">getsmoothP</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Returns modified surface position based on a smoothing function.</p><p>Returns a modified surface position based on a smoothing function.</p><div class=\"usage\"> <code>int getsmoothP(vector &amp;smoothP, vector ray_origin, ...)</code></div><p>Overwrites the <code>smoothP</code> variable with the modified surface position.\n    This function is only meaningful for some primitive types (such as polygons).</p><div class=\"usage\"> <code>vector getsmoothP(...)</code></div><p>Uses the global variables <code>Eye</code> and <code>I</code> to fill in the ray origin and direction.</p><h2>Variadic arguments</h2><div class=\"argument\"><code>style</code></div><span class=\"padder\"><span class=\"pillow\">string</span></span><div class=\"argument\"><code><code>none</code></code></div><p>No smoothing.</p><div class=\"argument\"><code><code>shadow</code></code></div><p>Apply a smoothing function appropriate to elimination of the shadow\n        terminator issue for polygons.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">shadow</code><code class=\"codeline\">fastshadow()</code><code class=\"codeline\">{</code><code class=\"codeline\">    vector        surfP;</code><code class=\"codeline\">    if (!getsmoothP(surfP, Eye, I))</code><code class=\"codeline\">        surfP = Ps;                // Set to the Ps (surface P) variable</code><code class=\"codeline\">    vector shad = trace(surfP, normalize(L), Time, \"raystyle\", \"shadow\");</code><code class=\"codeline\">    Cl *= ({1,1,1} - shad);</code><code class=\"codeline\">}</code></div></body>",
    "getspace": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getspace\">getspace</a></h1><p class=\"summary\">Returns a transform from one space to another.</p><div class=\"usage\"> <code>matrix getspace(string fromspace, string tospace)</code></div><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a> for a list of possible space names.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vtransform\">vtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ntransform\">ntransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a></div></body>",
    "getuvtangents": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getuvtangents\">getuvtangents</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Evaluates UV tangents at a point on an arbitrary object.</p><div class=\"usage\"> <code>void getuvtangents(string objName, vector P, vector dir, vector &amp;Tu, vector &amp;Tv)</code></div><p>This variant additionally sets Tn to the evaluation point\u2019s surface normal:</p><div class=\"usage\"> <code>void getuvtangents(string objName, vector P, vector dir, vector &amp;Tu, vector &amp;Tv, vector &amp;Tn)</code></div><h2>Note</h2><p>The object must have a vector attribute named uv.</p><h2>Tip</h2><p>Passing  as the <code>objName</code> parameter will cause the function to use the current shaded object.</p><div class=\"argument\"><code>objName</code></div><p>Name of object to evaluate UV tangents for.</p><div class=\"argument\"><code>P</code></div><p>Point at which to evaluate UV tangents.</p><div class=\"argument\"><code>dir</code></div><p>The direction to use for searching the object\u2019s surface.</p><p>The surface of the object is searched for by casting rays from <code>P</code> in this direction as well as the opposite direction.</p><p>When available, it makes sense to use the normal at the point being evaluated.</p><div class=\"argument\"><code>Tu</code></div><p>UV tangent in U direction.</p><div class=\"argument\"><code>Tv</code></div><p>UV tangent in V direction.</p><div class=\"argument\"><code>Tn</code></div><p>The surface normal at the point where tangents are evaluated.</p><div class=\"codeblock\"><code class=\"codeline\">// Get UV tangent at 'P', searching the surface in the direction of 'N'</code><code class=\"codeline\">vector Tu, Tv;</code><code class=\"codeline\">getuvtangents(\"/obj/geo1\", P, N, Tu, Tv);</code></div><div class=\"codeblock\"><code class=\"codeline\">// Find a surface location using an arbitrary ray.</code><code class=\"codeline\">// In this case the surface normal isn't known beforehand and can be fetched via 'Tn'.</code><code class=\"codeline\">vector Tu, Tv, Tn;</code><code class=\"codeline\">getuvtangents(\"/obj/geo1\", ray_orig, ray_dir, Tu, Tv, Tn);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Du\">Du</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dv\">Dv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getderiv\">getderiv</a></div></body>",
    "ggx": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ggx\">ggx</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns a ggx BSDF.</p><div class=\"usage\"> <code>bsdf ggx(vector ng, vector nn, vector xg, vector yg, vector F0, vector F90, float alphax, float alphay, int masking, int fresblend, float eta, float reflect, float refract, int reflectmask, int refractmask, float dispersion, ...)</code></div><p>Creates a BSDF for computation of the GGX microfacet model, used \n        for rough specular reflection and refraction.  </p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">writing a PBR shader</a> for information on BSDFs.</p><div class=\"argument\"><code>ng</code></div><p>Normalized geometry normal</p><div class=\"argument\"><code>nn</code></div><p>Normalized bumped/shading normal</p><div class=\"argument\"><code>xg</code></div><p>Normalized x tangent vector</p><div class=\"argument\"><code>yg</code></div><p>Normalized y tangent vector</p><div class=\"argument\"><code>F0</code></div><p>Color tint at oblique angles</p><div class=\"argument\"><code>F90</code></div><p>Color tint at grazing angles</p><div class=\"argument\"><code>alphax</code></div><p>Roughness along the x tangent vector</p><div class=\"argument\"><code>alphay</code></div><p>Roughness along the y tangent vector (use the same value as alphax for isotropic)</p><div class=\"argument\"><code>masking</code></div><p>Enable/Disable microfacet masking</p><div class=\"argument\"><code>fresblend</code></div><p>Enable/Disable fresnel</p><div class=\"argument\"><code>eta</code></div><p>Index of refraction</p><div class=\"argument\"><code>reflect</code></div><p>Explicit scalar on reflection (0-&gt;1).  Or -1 to let the function decide itself on the appriate value based on geometric information.</p><div class=\"argument\"><code>refract</code></div><p>Explicit scalar on refraction (0-&gt;1).  Or -1 to let the function decide itself on the appriate value based on geometric information.</p><div class=\"argument\"><code>reflectmask</code></div><p>Bitmask representing the desired reflection behaviour.  Simply passing in <code>bouncemask(reflectlabel)</code> will suffice        </p><div class=\"argument\"><code>refractmask</code></div><p>Bitmask representing the desired refraction behaviour.  Simply passing in <code>bouncemask(refractlabel)</code> will suffice        </p><div class=\"argument\"><code>dispersion</code></div><p>Amount of dispersion</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "gradient": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gradient\">gradient</a></h1><p class=\"summary\">Returns the gradient of a field.</p><div class=\"usage\"> <code>vector gradient(float val, ...)</code></div><div class=\"usage\"> <code>vector gradient(vector P, float val, ...)</code></div><p>This method computes the derivative of a volume field using the partial\nderivatives with respect to a given position (<code>Du</code>, <code>Dv</code>, and <code>Dw</code>).  If no\nposition is provided, <code>P</code> is assumed in shading contexts.  If only <code>Du</code> and\n<code>Dv</code> are defined, the derivative will be tangent to the surface being\nrendered.</p><h2>Examples</h2><p>Return the gradient of the density field:</p><div class=\"codeblock\"><code class=\"codeline\">surface test_grad(float density = 0)</code><code class=\"codeline\">{</code><code class=\"codeline\">Cf = gradient(density);</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volume\">volume</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Du\">Du</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dv\">Dv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dw\">Dw</a></div></body>",
    "gxnoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gxnoise\">gxnoise</a></h1><p class=\"summary\">Evaluates a simplex noise field.</p><div class=\"usage\"> <code>float|vector2|vector gxnoise(vector2 xy)</code></div><div class=\"usage\"> <code>float|vector2|vector gxnoise(float x, float y)</code></div><div class=\"usage\"> <code>float|vector2|vector gxnoise(vector xyz)</code></div><div class=\"usage\"> <code>float|vector2|vector gxnoise(vector4 xyzt)</code></div><p>Simplex noise is similar to Perlin noise, except with samples on a simplex mesh\nrather than a grid. This family of simplex noise functions uses a different\nlattice structure and a cheaper accumulation method compared to\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xnoise\">xnoise</a>.</p><p>The various functions return noise value at a 4D (<code>vector4</code> argument), 3D\n(<code>vector</code> argument), or 2D (a single <code>vector2</code> argument or two <code>float</code> inputs)\nposition. You can also get a random floating point value or a vector of two or\nthree entries.</p><p>Noise values will be in the 0-1 range. Nature of the noise field depends on the\nnumber of input dimensions. Higher-dimensional noise uses tighter noise\nelements, and the resultant noise field appears more structured and less smooth.\nConsider using the slower <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xnoise\">xnoise</a> function in higher dimensions if\nthis function gives you undesirable results.</p></body>",
    "hair": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hair\">hair</a></h1><p class=\"summary\">Returns a BSDF for shading hair.</p><div class=\"usage\"> <code>bsdf hair(vector N; vector tip; float lobe_shift; float lobe_width_lon, ...)</code></div><div class=\"usage\"> <code>bsdf hair(vector N; vector tip; float lobe_shift; float lobe_width_lon, float lobe_with_azi, ...)</code></div><div class=\"usage\"> <code>bsdf hair(vector N; vector tip; float lobe_shift; float lobe_width_lon, float lobe_with_azi, float glint_shift; float glint_intensity, ...)</code></div><p>Details of the hair BSDF can be found in the source file (<code>hair_eval.vfl</code>).</p><p>Any variadic arguments to the functions are passed through to the CVEX evaluation function.</p><h2>Examples</h2><p>These different signatures are equivalent to the following code:</p><div class=\"codeblock\"><code class=\"codeline\">bsdf hair(vector N; vector tip; float lobe_shift; float lobe_width_lon, ...)</code><code class=\"codeline\">{</code><code class=\"codeline\">    cvex_bsdf(\"hair_eval\", \"hair_sample\",</code><code class=\"codeline\">        \"label\", \"diffuse\",</code><code class=\"codeline\">        \"tip\", tip,</code><code class=\"codeline\">        \"lobe_shift\", lobe_shift,</code><code class=\"codeline\">        \"lobe_width_lon\", lobe_width_lon,</code><code class=\"codeline\">    ...);</code><code class=\"codeline\">}</code><code class=\"codeline\"></code><code class=\"codeline\">bsdf hair(vector N; vector tip; float lobe_shift; float lobe_width_lon, float lobe_with_azi, ...)</code><code class=\"codeline\">{</code><code class=\"codeline\">    cvex_bsdf(\"hair_eval\", \"hair_sample\",</code><code class=\"codeline\">        \"label\", \"refract\",</code><code class=\"codeline\">        \"tip\", tip,</code><code class=\"codeline\">        \"lobe_shift\", lobe_shift,</code><code class=\"codeline\">        \"lobe_width_lon\", lobe_width_lon,</code><code class=\"codeline\">        \"lobe_width_azi\", lobe_width_azi,</code><code class=\"codeline\">    ...);</code><code class=\"codeline\">}</code><code class=\"codeline\"></code><code class=\"codeline\">bsdf hair(vector N; vector tip; float lobe_shift; float lobe_width_lon, float glint_shift; float glint_intensity, ...)</code><code class=\"codeline\">{</code><code class=\"codeline\">    cvex_bsdf(\"hair_eval\", \"hair_sample\",</code><code class=\"codeline\">        \"label\", \"reflect\",</code><code class=\"codeline\">        \"tip\", tip,</code><code class=\"codeline\">        \"lobe_shift\", lobe_shift,</code><code class=\"codeline\">        \"lobe_width_lon\", lobe_width_lon,</code><code class=\"codeline\">        \"glint_shift\", glint_shift,</code><code class=\"codeline\">        \"glint_intensity\", glint_intensity,</code><code class=\"codeline\">    ...);</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phong\">phong</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phonglobe\">phonglobe</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "hasattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasattrib\">hasattrib</a></h1><p class=\"summary\">Checks whether a geometry attribute exists.</p><p>If you know the attribute class ahead of time, using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasdetailattrib\">hasdetailattrib</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasprimattrib\">hasprimattrib</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/haspointattrib\">haspointattrib</a>, or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasvertexattrib\">hasvertexattrib</a> may be faster.</p><div class=\"usage\"> <code>int hasattrib(&lt;geometry&gt;, string attribclass, string attribute_name)</code></div><p>Returns <code>1</code> if the attribute exists, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check whether the point group \"pointstouse\" exists.</code><code class=\"codeline\">if (hasattrib(\"defgeo.bgeo\", \"pointgroup\", \"pointstouse\")) {</code><code class=\"codeline\">    // Do something with the point group</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasdetailattrib\">hasdetailattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasprimattrib\">hasprimattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/haspointattrib\">haspointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasvertexattrib\">hasvertexattrib</a></div></body>",
    "hasdetailattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasdetailattrib\">hasdetailattrib</a></h1><p class=\"summary\">Returns if a geometry detail attribute exists.</p><div class=\"usage\"> <code>int hasdetailattrib(&lt;geometry&gt;, string attribute_name)</code></div><p>Returns <code>1</code> if the given attribute exists or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int        exists;</code><code class=\"codeline\">// Determine if the P attribute exists.</code><code class=\"codeline\">exists = hasdetailattrib(\"defgeo.bgeo\", \"P\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasattrib\">hasattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasprimattrib\">hasprimattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/haspointattrib\">haspointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasvertexattrib\">hasvertexattrib</a></div></body>",
    "haslight": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/haslight\">haslight</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Returns whether a light illuminates the given material.</p><div class=\"usage\"> <code>int haslight(material mat; vector P; int light; ...)</code></div><p>Returns 1 if the given light is used to illuminate the material at the point\nspecified.</p><p>This function accepts PBR keyword arguments to specify sampling types.  These\noptions may exclude lights which don\u2019t match the desired sampling paths.</p><p>The PBR sampling keywords include:</p><div class=\"argument\"><code>label</code></div><p>A string specifying a specific label.  This keyword argument may be specified multiple times.</p><div class=\"argument\"><code>direct</code></div><p>Expects an 0 or 1 integer value which will limit lights based on indirect or direct contribution categories.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">haslight(material(), P, light_num, \"direct\", 0);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlights\">getlights</a></div></body>",
    "hasmetadata": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasmetadata\">hasmetadata</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Queries if metadata exists on a composite operator.</p><div class=\"usage\"> <code>int hasmetadata(int opinput, string name)</code></div><p>This function checks if metadata named <code>name</code> exists on the COP attached to\nthe VEX COP\u2019s input <code>opinput</code>. If it exists then 1 is returned, otherwise 0.</p><div class=\"argument\"><code>name</code></div><p>The name of the metadata to check.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/metadata\">metadata</a></div></body>",
    "hasplane": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasplane\">hasplane</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns 1 if the plane specified by the parameter exists in this\nCOP.</p><div class=\"usage\"> <code>int hasplane(string planename)</code></div><p>Returns 1 if the plane specified by the parameter exists in this COP.</p></body>",
    "haspointattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/haspointattrib\">haspointattrib</a></h1><p class=\"summary\">Returns if a geometry point attribute exists.</p><div class=\"usage\"> <code>int haspointattrib(&lt;geometry&gt;, string attribute_name)</code></div><h2>Returns</h2><p><code>1</code> if the attribute exists, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Determine if the P attribute exists.</code><code class=\"codeline\">int exists = haspointattrib(\"defgeo.bgeo\", \"P\");</code></div></body>",
    "hasprimattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasprimattrib\">hasprimattrib</a></h1><p class=\"summary\">Returns if a geometry prim attribute exists.</p><div class=\"usage\"> <code>int hasprimattrib(&lt;geometry&gt;, string attribute_name)</code></div><p>Returns <code>1</code> if the attribute exists, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Determine if the P attribute exists.</code><code class=\"codeline\">int exists = hasprimattrib(\"defgeo.bgeo\", \"P\");</code></div></body>",
    "hasvertexattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasvertexattrib\">hasvertexattrib</a></h1><p class=\"summary\">Returns if a geometry vertex attribute exists.</p><div class=\"usage\"> <code>int hasvertexattrib(&lt;geometry&gt;, string attribute_name)</code></div><p>Returns <code>1</code> if the attribute exists, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Determine if the P attribute exists.</code><code class=\"codeline\">int exists = hasvertexattrib(\"defgeo.bgeo\", \"P\");</code></div></body>",
    "has_udim": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/has_udim\">has_udim</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Test string for UDIM or UVTILE patterns.</p><div class=\"usage\"> <code>int has_udim(string path)</code></div><p>Scans the input path for special conversion characters to perform either UDIM or UVTILE style filename expansion.  If the string has any UDIM/UVTILE expansion patterns, the function returns 1, otherwise the function returns 0.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/expand_udim\">expand_udim</a></div></body>",
    "hedge_dstpoint": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hedge_dstpoint\">hedge_dstpoint</a></h1><p class=\"summary\">Returns the destination point of a half-edge.</p><div class=\"usage\"> <code>int hedge_dstpoint(&lt;geometry&gt;, int hedge)</code></div><p>Returns <code>-1</code> if the half-edge hedge is invalid. Otherwise, returns the point number of the destination point of the half-edge <code>hedge</code>.</p><div class=\"argument\"><code>geometry</code></div><p>The name of the geometry file to reference.  Inside Houdini, this may be <code>op:full_path_to_sop</code> to reference a SOP.</p><div class=\"argument\"><code>hedge</code></div><p>Input half-edge.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int dstpt;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get vertex number of half-edge number 3.</code><code class=\"codeline\">dstpt = hedge_dstpoint(\"defgeo.bgeo\", 3);</code></div></body>",
    "hedge_dstvertex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hedge_dstvertex\">hedge_dstvertex</a></h1><p class=\"summary\">Returns the destination vertex of a half-edge.</p><div class=\"usage\"> <code>int hedge_dstvertex(&lt;geometry&gt;, int hedge)</code></div><div class=\"argument\"><code>hedge</code></div><p>Input half-edge.</p><h2>Returns</h2><p>The vertex number of the half-edge\u2019s destination vertex, or <code>-1</code> if the half-edge is not valid.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int dstvtx;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the destination vertex half-edge number 3.</code><code class=\"codeline\">dstvtx = hedge_dstvertex(\"defgeo.bgeo\", 3);</code></div></body>",
    "hedge_equivcount": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hedge_equivcount\">hedge_equivcount</a></h1><p class=\"summary\">Returns the number of half-edges equivalent to a given half-edge.</p><div class=\"usage\"> <code>int hedge_equivcount(&lt;geometry&gt;, int hedge)</code></div><h2>Note</h2><p>Equivalent half-edges may be oppositely oriented, i.e. the source of one can be the destination of the other and vice versa.</p><div class=\"argument\"><code>hedge</code></div><p>Input half-edge.</p><h2>Returns</h2><p>The number of half-edges that have the same endpoint as <code>hedge</code> (including <code>hedge</code>), or <code>-1</code> if the half-edge is not valid.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int is_boundary = 0;</code><code class=\"codeline\">int is_interior = 0;</code><code class=\"codeline\">int is_nonmanifold = 0;</code><code class=\"codeline\"></code><code class=\"codeline\">// Determine the type of edge represented by half-edge number 3:</code><code class=\"codeline\">int numeq;</code><code class=\"codeline\">numeq = hedge_equivcount(\"defgeo.bgeo\", 3);</code><code class=\"codeline\">if (numeq == 1)</code><code class=\"codeline\">is_boundary = 1;</code><code class=\"codeline\">else if (numeq &gt;= 3)</code><code class=\"codeline\">is_nonmanifold = 1;</code><code class=\"codeline\">else</code><code class=\"codeline\">is_interior = 1;</code></div></body>",
    "hedge_isequiv": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hedge_isequiv\">hedge_isequiv</a></h1><p class=\"summary\">Determines whether a two half-edges are equivalent (represent the same edge).</p><div class=\"usage\"> <code>int hedge_isequiv(&lt;geometry&gt;, int hedge1, int hedge2)</code></div><div class=\"argument\"><code>hedge1</code></div><p>The integer representing the first half-edge.</p><div class=\"argument\"><code>hedge2</code></div><p>The integer representing the second half-edge.</p><h2>Returns</h2><p><code>1</code> if <code>hedge1</code> and <code>hedge2</code> are equivalent, i.e. represent the same\n    edge in the geometry. This is the case when either source and destination points\n    of <code>hedge1</code> and <code>hedge2</code> are respectively the same, or source of each of <code>hedge1</code>\n    and <code>hedge2</code> is the same as the destination of the other.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int opposite = 0;</code><code class=\"codeline\"></code><code class=\"codeline\">// test if hedges 2 and 3 are oppositely oriented equivalent half-edges</code><code class=\"codeline\">if (hedge_isequiv(\"defgeo.bgeo\", 2, 3))</code><code class=\"codeline\">{</code><code class=\"codeline\">if (hedge_srcpoint(\"defgeo.bgeo\", 2) == hedge_dstpoint(\"defgeo.bgeo\", 3))</code><code class=\"codeline\">opposite = 1;</code><code class=\"codeline\">}</code></div></body>",
    "hedge_isprimary": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hedge_isprimary\">hedge_isprimary</a></h1><p class=\"summary\">Determines whether a half-edge number corresponds to a primary half-edge.</p><div class=\"usage\"> <code>int hedge_isprimary(string geometry, int hedge)</code></div><div class=\"usage\"> <code>int hedge_isprimary(int opinput, int hendge)</code></div><div class=\"argument\"><code>geometry</code></div><p>The name of the geometry file to reference.  Inside Houdini, this may be <code>op:full_path_to_sop</code> to reference a SOP.</p><div class=\"argument\"><code>hedge</code></div><p>The integer representing a half-edge.</p><h2>Returns</h2><p><code>1</code> if <code>hedge</code> represents a primary half-edge in the referenced geometry, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int numedges;</code><code class=\"codeline\"></code><code class=\"codeline\">// Count the number of edges</code><code class=\"codeline\"></code><code class=\"codeline\">if (hedge_isprimary(\"defgeo.bgeo\", 3))</code><code class=\"codeline\">numedges++;</code></div></body>",
    "hedge_isvalid": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hedge_isvalid\">hedge_isvalid</a></h1><p class=\"summary\">Determines whether a half-edge number corresponds to a valid half-edge.</p><div class=\"usage\"> <code>int hedge_isvalid(&lt;geometry&gt;, int hedge)</code></div><div class=\"argument\"><code>hedge</code></div><p>The integer representing a half-edge.</p><h2>Returns</h2><p><code>1</code> if <code>hedge</code> represents a valid half-edge in the referenced geometry, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int srcpt;</code><code class=\"codeline\"></code><code class=\"codeline\">// find the source point of a half-edge number 3 if it is valid</code><code class=\"codeline\">if (hedge_isvalid(\"defgeo.bgeo\", 3))</code><code class=\"codeline\">srcpt = hedge_srcpoint(\"defgeo.bgeo\", 3);</code></div></body>",
    "hedge_next": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hedge_next\">hedge_next</a></h1><p class=\"summary\">Returns the half-edge that follows a given half-edge in its polygon.</p><div class=\"usage\"> <code>int hedge_next(&lt;geometry&gt;, int hedge)</code></div><div class=\"argument\"><code>hedge</code></div><p>Input half-edge.</p><h2>Returns</h2><p>The number of the half-edges that follow (its source is the destination of) <code>hedge</code> in the polygon that contains it. Returns <code>-1</code> if the half-edge is not valid.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int nexthedge;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the next half-edge of half-edge number 3.</code><code class=\"codeline\">nexthedge = hedge_next(\"defgeo.bgeo\", 3);</code></div></body>",
    "hedge_nextequiv": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hedge_nextequiv\">hedge_nextequiv</a></h1><p class=\"summary\">Returns the next half-edges equivalent to a given half-edge.</p><div class=\"usage\"> <code>int hedge_nextequiv(&lt;geometry&gt;, int hedge)</code></div><div class=\"argument\"><code>hedge</code></div><p>Input half-edge.</p><h2>Returns</h2><p>The next half-edge equivalent to <code>hedge</code>, or <code>hedge</code> if there are no other half-edges equivalent to it.\n    Successive calls to <code>hedge_nextequiv()</code> cycle through all the equivalent half-edges.\n    Returns <code>-1</code> if the half-edge is not valid.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Determine the number of half-edges equivalent to half-edge number 3 (including itself)</code><code class=\"codeline\">int num_equiv = 0;</code><code class=\"codeline\">int h = 3;</code><code class=\"codeline\">do</code><code class=\"codeline\">{</code><code class=\"codeline\">h = hedge_nextequiv(\"defgeo.bgeo\", h);</code><code class=\"codeline\">num_equiv++;</code><code class=\"codeline\">} while (h != 3);</code></div></body>",
    "hedge_postdstpoint": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hedge_postdstpoint\">hedge_postdstpoint</a></h1><p class=\"summary\">Returns the point into which the vertex following the destination vertex of a half-edge in its primitive is wired.</p><div class=\"usage\"> <code>int hedge_postdstpoint(&lt;geometry&gt;, int hedge)</code></div><div class=\"argument\"><code>hedge</code></div><p>Input half-edge.</p><h2>Returns</h2><p>The point number of the point into which the vertex that comes after the destination vertex of the\n    half-edge <code>hedge</code> in the primitive that contains <code>hedge</code> is wired.\n    Returns <code>-1</code> if the half-edge is not valid.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int postdstpt;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the destination vertex half-edge number 3.</code><code class=\"codeline\">postdstpt = hedge_postdstpoint(\"defgeo.bgeo\", 3);</code></div></body>",
    "hedge_postdstvertex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hedge_postdstvertex\">hedge_postdstvertex</a></h1><p class=\"summary\">Returns the vertex following the destination vertex of a half-edge in its primitive.</p><div class=\"usage\"> <code>int hedge_postdstvertex(&lt;geometry&gt;, int hedge)</code></div><div class=\"argument\"><code>hedge</code></div><p>Input half-edge.</p><h2>Returns</h2><p>The vertex number of the vertex that comes after the destination vertex of the half-edge <code>hedge</code> in the primitive that contains <code>hedge</code>.\n    Returns <code>-1</code> if the half-edge is not valid.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int postdstvtx;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the destination vertex half-edge number 3.</code><code class=\"codeline\">postdstvtx = hedge_postdstvertex(\"defgeo.bgeo\", 3);</code></div></body>",
    "hedge_presrcpoint": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hedge_presrcpoint\">hedge_presrcpoint</a></h1><p class=\"summary\">Returns the point into which the vertex that precedes the source vertex of a half-edge in its primitive is wired.</p><div class=\"usage\"> <code>int hedge_presrcpoint(&lt;geometry&gt;, int hedge)</code></div><div class=\"argument\"><code>hedge</code></div><p>Input half-edge.</p><h2>Returns</h2><p>The point of the point into which the vertex that comes before the source vertex of the <code>hedge</code> in the primitive that contains <code>hedge</code> is wired.\n    Returns <code>-1</code> if the half-edge is not valid.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int presrcpt;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the pre-source point of half-edge number 3.</code><code class=\"codeline\">presrcpt = hedge_presrcpoint(\"defgeo.bgeo\", 3);</code></div></body>",
    "hedge_presrcvertex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hedge_presrcvertex\">hedge_presrcvertex</a></h1><p class=\"summary\">Returns the vertex that precedes the source vertex of a half-edge in its primitive.</p><div class=\"usage\"> <code>int hedge_presrcvertex(&lt;geometry&gt;, int hedge)</code></div><div class=\"argument\"><code>hedge</code></div><p>Input half-edge.</p><h2>Returns</h2><p>The vertex number of the vertex that comes before the source vertex of the <code>hedge</code> in the primitive that contains <code>hedge</code>.\n    Returns <code>-1</code> if the half-edge is not valid.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int presrcvtx;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the pre-source vertex of half-edge number 3.</code><code class=\"codeline\">presrcvtx = hedge_presrcvertex(\"defgeo.bgeo\", 3);</code></div></body>",
    "hedge_prev": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hedge_prev\">hedge_prev</a></h1><p class=\"summary\">Returns the half-edge that precedes a given half-edge in its polygon.</p><div class=\"usage\"> <code>int hedge_prev(&lt;geometry&gt;, int hedge)</code></div><p>Returns <code>-1</code> if <code>hedge</code> is invalid. Otherwise, returns the number of the half-edge\nthat precedes (its destination is the source of) <code>hedge</code> in the polygon that contains it.</p><div class=\"argument\"><code>hedge</code></div><p>Input half-edge.</p><h2>Returns</h2><p>The number of the half-edge that precedes (its destination is the source of) <code>hedge</code> in the polygon that contains it.\n    Returns <code>-1</code> if the half-edge is not valid.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int prev;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the previous half-edge of half-edge number 3.</code><code class=\"codeline\">prevhedge = hedge_prev(\"defgeo.bgeo\", 3);</code></div></body>",
    "hedge_prim": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hedge_prim\">hedge_prim</a></h1><p class=\"summary\">Returns the primitive that contains a half-edge.</p><div class=\"usage\"> <code>int hedge_prim(&lt;geometry&gt;, int hedge)</code></div><div class=\"argument\"><code>hedge</code></div><p>Input half-edge.</p><h2>Returns</h2><p>The primitive number of primitive that contains (the source and destination vertices of) <code>hedge</code>.\n    Returns <code>-1</code> if the half-edge is not valid.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int prim;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the primitive number of half-edge number 3.</code><code class=\"codeline\">prim = hedge_prim(\"defgeo.bgeo\", 3);</code></div></body>",
    "hedge_primary": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hedge_primary\">hedge_primary</a></h1><p class=\"summary\">Returns the primary half-edge equivalent to a given half-edge.</p><div class=\"usage\"> <code>int hedge_primary(&lt;geometry&gt;, int hedge)</code></div><p>Each class of equivalent half-edges has precisely one primary half-edge. In particular, a half-edge which is equivalent to no other half-edges is always primary. Primary half-edges are useful for accounting for each edge exactly once as each edge may be realized by any number of equivalent half-edges.</p><div class=\"argument\"><code>hedge</code></div><p>Input half-edge.</p><h2>Returns</h2><p>The primary half-edge <code>hedge</code> that shares the source and destination of <code>hedge</code> (possibly in reverse order).\n    Returns <code>-1</code> if the half-edge is not valid.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int primhedge;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the primary half-edge equivalent  to half-edge number 3.</code><code class=\"codeline\">primhedge = hedge_primary(\"defgeo.bgeo\", 3);</code></div></body>",
    "hedge_srcpoint": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hedge_srcpoint\">hedge_srcpoint</a></h1><p class=\"summary\">Returns the source point of a half-edge.</p><div class=\"usage\"> <code>int hedge_srcpoint(&lt;geometry&gt;, int hedge)</code></div><div class=\"argument\"><code>hedge</code></div><p>Input half-edge.</p><h2>Returns</h2><p>The point number of the source point of the <code>hedge</code>.\n    Returns <code>-1</code> if the half-edge is not valid.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int srcpt;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the source point of half-edge number 3.</code><code class=\"codeline\">srcpt = hedge_srcpoint(\"defgeo.bgeo\", 3);</code></div></body>",
    "hedge_srcvertex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hedge_srcvertex\">hedge_srcvertex</a></h1><p class=\"summary\">Returns the source vertex of a half-edge.</p><div class=\"usage\"> <code>int hedge_srcvertex(&lt;geometry&gt;, int hedge)</code></div><div class=\"argument\"><code>hedge</code></div><p>Input half-edge.</p><h2>Returns</h2><p>The vertex number of the source vertex of the <code>hedge</code>.\n    Returns <code>-1</code> if the half-edge is not valid.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int srcvtx;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the source vertex of half-edge number 3.</code><code class=\"codeline\">srcvtx = hedge_srcvertex(\"defgeo.bgeo\", 3);</code></div></body>",
    "henyeygreenstein": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/henyeygreenstein\">henyeygreenstein</a></h1><p class=\"summary\">Returns an anisotropic volumetric BSDF, which can scatter light forward or backward.</p><div class=\"usage\"> <code>bsdf henyeygreenstein(float anisotropic_bias, ...)</code></div><p>The Henyey-Greenstein function scatters light either forward or in reverse depending on the <code>anisotropic_bias</code> provided to the function which must be a floating point value between -1 and 1. A value of 0 will cause isotropic scattering (identical to the <code>isotropic()</code> bsdf) while positive values produce forward scattering and negative values produce reverse scattering. The extrema of -1 and 1 cause all light to be scattered in a single direction, back toward the light for -1 and without any directional change for 1.</p><h2>Note</h2><p>No normal vector is required to construct a Henyey-Greenstein BSDF since it has no directionality. The default albedo for the BSDF is 1, which means it scatters 100% of the incoming light.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isotropic\">isotropic</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/specular\">specular</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phong\">phong</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "hex_adjacent": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hex_adjacent\">hex_adjacent</a></h1><p class=\"summary\">Returns primitive number of an adjacent hexahedron.</p><div class=\"usage\"> <code>int hex_adjacent(&lt;geometry&gt;, int primindex, int faceno)</code></div><div class=\"argument\"><code>primindex</code></div><p>The primitive number.</p><div class=\"argument\"><code>faceno</code></div><p>The face on the hexahedron.   Ranges from <code>0</code> to <code>5</code>.</p><h2>Returns</h2><p>The primitive number of the hexahedron attached to the given face.\n    Returns <code>-1</code> f the primitive is not a hex or doesn\u2019t have an adjacent hexahedron.</p><p>Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hex_faceindex\">hex_faceindex</a> to get the vertex indices of each face of a hexahedron.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hex_faceindex\">hex_faceindex</a></div></body>",
    "hex_faceindex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hex_faceindex\">hex_faceindex</a></h1><p class=\"summary\">Returns vertex indices of each face of a hexahedron.</p><div class=\"usage\"> <code>int hex_faceindex(int faceno, int vtxno)</code></div><p>Returns <code>-1</code> if an invalid number is specified.</p><p>Returns <code>0</code> to <code>7</code> to refer to the eight vertices of a generic hexahedron.</p><div class=\"argument\"><code>faceno</code></div><p>The face on the hexahedron.   Ranges from <code>0</code> to <code>5</code>.</p><div class=\"argument\"><code>vtxno</code></div><p>Which vertex on the quadrilateral to return, <code>0</code> to <code>3</code>.  Starts with\n    the lowest number and follows Houdini\u2019s winding convention.</p></body>",
    "hscript_noise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hscript_noise\">hscript_noise</a></h1><p class=\"summary\">Generates noise matching the output of the Hscript noise() expression function.</p><div class=\"usage\"> <code>float hscript_noise(vector pos)</code></div><p>Matches the output of <a href=\"https://www.sidefx.com/docs/houdini/expressions/noise\">noise</a>. This function can be useful if you convert a workflow to VEX, or have VEX work in tandem with Hscript expressions, and need the noise to look the same as in an expression.</p><div class=\"argument\"><code>pos</code></div><p>Position at which to sample the noise.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hscript_snoise\">hscript_snoise</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hscript_rand\">hscript_rand</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hscript_turb\">hscript_turb</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hscript_sturb\">hscript_sturb</a></div></body>",
    "hscript_rand": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hscript_rand\">hscript_rand</a></h1><p class=\"summary\">Produces the exact same results as the Houdini expression function of\nthe same name.</p><div class=\"usage\"> <code>float|vector|vector4 hscript_rand(float seed)</code></div><p>Produces the exact same results as the Houdini expression function of\nthe same name. This function will generate different random values for\nevery floating point seed. This is different that the\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/random\">random</a> function which converts the floating point argument\nto an integer seed. The <code>hscript_rand()</code> function may produce different\nresults on different hardware or operating systems.</p></body>",
    "hscript_snoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hscript_snoise\">hscript_snoise</a></h1><div class=\"usage\"> <code>float hscript_snoise(vector pos)</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hscript_noise\">hscript_noise</a></div></body>",
    "hscript_sturb": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hscript_sturb\">hscript_sturb</a></h1><div class=\"usage\"> <code>float hscript_sturb(vector pos, int turbulence)</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hscript_noise\">hscript_noise</a></div></body>",
    "hscript_turb": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hscript_turb\">hscript_turb</a></h1><p class=\"summary\">Generates turbulence matching the output of the HScript turb() expression function.</p><div class=\"usage\"> <code>float hscript_turb(vector pos, int depth)</code></div><p>Matches the output of <a href=\"https://www.sidefx.com/docs/houdini/expressions/turb\">turb</a>. This function can be useful if you convert a workflow to VEX, or have VEX work in tandem with Hscript expressions, and need the turbulence to look the same as in an expression.</p><div class=\"argument\"><code>pos</code></div><p>Position at which to sample the turbulent noise.</p><div class=\"argument\"><code>depth</code></div><p>Number of fractal iterations of noise.</p><h2>Returns</h2><p>The range is usually within -1 to 1, but can exceed it depending on the depth. The maximum range is -2 to 2 for high depths.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hscript_sturb\">hscript_sturb</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hscript_noise\">hscript_noise</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hscript_snoise\">hscript_snoise</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hscript_rand\">hscript_rand</a></div></body>",
    "hsvtorgb": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hsvtorgb\">hsvtorgb</a></h1><p class=\"summary\">Convert HSV color space into RGB color space.</p><div class=\"usage\"> <code>vector hsvtorgb(vector hsv)</code></div><div class=\"usage\"> <code>vector hsvtorgb(float hue, float sat, float val)</code></div><p>Convert HSV color space into RGB color space. A vector representing the\nRGB triple is returned. The hue should be in the range 0 to 1.</p></body>",
    "iaspect": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/iaspect\">iaspect</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the aspect ratio of the specified input.</p><div class=\"usage\"> <code>float iaspect(int opinput)</code></div><p>Returns the aspect ratio of the specified input.</p></body>",
    "ichname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ichname\">ichname</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the channel name of the indexed plane of the given input.</p><div class=\"usage\"> <code>string ichname(int inputnum, int plane_index, int component_index)</code></div><p>Returns the component name (for example, r or x) of a component of a plane.</p></body>",
    "ident": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ident\">ident</a></h1><p class=\"summary\">Returns an identity matrix.</p><div class=\"usage\"> <code>&lt;matrix&gt; ident()</code></div><p>Returns the identity matrix for the given matrix type.</p></body>",
    "idtopoint": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/idtopoint\">idtopoint</a></h1><p class=\"summary\">Finds a point by its id attribute.</p><div class=\"usage\"> <code>int idtopoint(&lt;geometry&gt;, int id)</code></div><p>Returns the number of the point with the given value in the <code>id</code> attribute. Returns <code>-1</code> if no point has the given ID.</p><p>If the geometry doesn\u2019t have an <code>id</code> attribute, point numbers are used as ids.  In this case, the function will return the given <code>id</code> value, unless it is greater than the number of points in the source geometry, in which case the function will return <code>-1</code>.</p><p>To look up a point by its <code>name</code> attribute value, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nametopoint\">nametopoint</a>. To look up a point by an arbitrary string or int attribute value, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/findattribval\">findattribval</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nametopoint\">nametopoint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/idtoprim\">idtoprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/findattribval\">findattribval</a></div></body>",
    "idtoprim": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/idtoprim\">idtoprim</a></h1><p class=\"summary\">Finds a primitive by its id attribute.</p><div class=\"usage\"> <code>int idtoprim(&lt;geometry&gt;, int id)</code></div><p>Returns the number of the primitive with the given value in the <code>id</code> attribute. Returns <code>-1</code> if no primitive has the given ID.</p><p>If the geometry doesn\u2019t have an <code>id</code> attribute, primitive numbers are used as ids.  In this case, the function will return the given <code>id</code> value, unless it is greater than the number of points in the source geometry, in which case the function will return <code>-1</code>.</p><p>To look up a primitive by its <code>name</code> attribute value, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nametoprim\">nametoprim</a>. To look up a primitive by an arbitrary string or int attribute value, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/findattribval\">findattribval</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nametoprim\">nametoprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/idtopoint\">idtopoint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/findattribval\">findattribval</a></div></body>",
    "iend": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/iend\">iend</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the last frame of the specified input.</p><div class=\"usage\"> <code>int iend(int opinput)</code></div><p>Returns the last frame of the specified input.</p></body>",
    "iendtime": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/iendtime\">iendtime</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the end time of the specified input.</p><div class=\"usage\"> <code>float iendtime(int opinput)</code></div><p>Returns the end time of the specified input.</p></body>",
    "ihasplane": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ihasplane\">ihasplane</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns 1 if the specified input has a plane named <code>planename</code>.</p><div class=\"usage\"> <code>int ihasplane(int opinput, string planename)</code></div><p>Returns 1 if the specified input has a plane named <code>planename</code>. Input\nnumbers start at 0.</p></body>",
    "illuminance": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a></h1><span class=\"padder\"><span class=\"pillow\">vexstatement</span></span><span class=\"padder\"><span class=\"pillow\">displace</span></span><span class=\"padder\"><span class=\"pillow\">fog</span></span><span class=\"padder\"><span class=\"pillow\">surface</span></span><p class=\"summary\">Loops through all light sources in the scene, calling the light shader for each light source to set the <code>Cl</code> and <code>L</code> global variables.</p><h2>Overview</h2><p>// Need to indent this so the include below doesn\u2019t go under this heading</p><div class=\"codeblock\"><code class=\"codeline\">illuminance(position, [axis], [angle], [light_typemask], [lightmask])</code><code class=\"codeline\">    {</code><code class=\"codeline\">        // Here, Cl and L will be set to the value/direction for the</code><code class=\"codeline\">        // current light source.</code><code class=\"codeline\">        // To force the shadow shader to be called, use:</code><code class=\"codeline\">        // shadow(Cl);</code><code class=\"codeline\">    }</code></div><p>The shadow shader is not called unless you explicitly call it. However, once the shadow shader has been called, the value of <code>Cl</code> will be changed for the duration of the surface shader. The shadow shader is automatically called when using any of the built-in lighting calls (e.g. <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/diffuse\">diffuse</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/specular\">specular</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ambient\">ambient</a>).</p><p>The default value for the axis is the surface normal. The default value for the angle is PI/2. The default value for the light mask is LIGHT_DIFFUSE|LIGHT_SPECULAR (please see shading.h for the light definitions).</p><p>The <code>illuminance</code> statement loops through all light sources for which <code>dot(L, axis) &gt; cos(angle)</code>.</p><h2>Sending information to the light\u2019s shader</h2><p>You can give additional pairs of string/value arguments to <code>illuminance</code> to pass named values to each light\u2019s shader. For example, to pass the value of the <code>N</code> variable as <code>orgN</code>:</p><div class=\"codeblock\"><code class=\"codeline\">illuminance (P, nf, M_PI/2, \"orgN\", N) {</code><code class=\"codeline\">...</code><code class=\"codeline\">}</code></div><p>In the light\u2019s shader, you can receive the value from the illuminance loop with the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/simport\">simport</a> function.</p><div class=\"codeblock\"><code class=\"codeline\">vector orgN;</code><code class=\"codeline\">simport(\"orgN\", orgN);</code></div><p>The <code>simport</code> function returns 1 if the import succeeds and 0 otherwise, so you can use it as the condition in an <code>if</code> statement.</p><p>Here\u2019s a full example:</p><div class=\"codeblock\"><code class=\"codeline\">surface</code><code class=\"codeline\">exporter()</code><code class=\"codeline\">{</code><code class=\"codeline\">vector nf = frontface(normalize(N), I);</code><code class=\"codeline\">Cf = 0;</code><code class=\"codeline\">illuminance(P, nf, M_PI/2, \"orgN\", N)</code><code class=\"codeline\">{</code><code class=\"codeline\">Cf += Cl;</code><code class=\"codeline\">}</code><code class=\"codeline\"></code><code class=\"codeline\">light</code><code class=\"codeline\">importer()</code><code class=\"codeline\">{</code><code class=\"codeline\">vector orgN;</code><code class=\"codeline\">if (!simport(\"orgN\", orgN))</code><code class=\"codeline\">orgN = N;</code><code class=\"codeline\">// Use original N</code><code class=\"codeline\">Cl = orgN;</code><code class=\"codeline\">}</code></div><h2>Message passing</h2><p>Within the illuminance loop, you can retrieve values from the light shader\nwith the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/limport\">limport</a> function.</p><p>The light shader can retrieve any keyword arguments passed to the illuminance\nstatement with the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/simport\">simport</a> function.</p><p>For example, to send down the vector variable <code>uv</code> to the light shader\u2026</p><div class=\"codeblock\"><code class=\"codeline\">vector      uv = set(s, t, 0);</code><code class=\"codeline\">illuminance(P, dir, \"uv\", uv) { ... }</code></div><p>The light shader would be able to read this using\u2026</p><div class=\"codeblock\"><code class=\"codeline\">vector      uv;</code><code class=\"codeline\">if (simport(\"uv\", uv))</code><code class=\"codeline\">printf(\"Imported: %g from surface\\n\", uv);</code></div><h2>lightexport keyword argument</h2><p>You can supply the extra string argument <code>\"lightexport\"</code> followed by\na string argument containing the name(s) of the exported variables to\nassign within the loop.</p><p>In some shaders, multiple illuminance loops are used to define different\nlight contributions. The <code>lightexport</code> argument is useful in these cases\nto specify which variables should be exported from the different\nloops.</p><p>The <code>lightexport</code> value can be a space-separated list of wildcard\npatterns. For example, <code>illuminance(pos, dir, \"lightexport\", \"Front*\")</code>\nexports variables whose names start with <code>Front</code>.</p><div class=\"codeblock\"><code class=\"codeline\">surface</code><code class=\"codeline\">light_export_test(export vector diff=0;</code><code class=\"codeline\">export vector spec=0)</code><code class=\"codeline\">{</code><code class=\"codeline\">vector     nn = normalize(frontface(N, I));</code><code class=\"codeline\">vector     vv = -normalize(I);</code><code class=\"codeline\">vector     clr;</code><code class=\"codeline\"></code><code class=\"codeline\">Cf = 0;</code><code class=\"codeline\">// This illuminance loop only exports to the \"diff\" variable</code><code class=\"codeline\">illuminance(P, nn, \"lightexport\", \"diff\")</code><code class=\"codeline\">{</code><code class=\"codeline\">clr = Cl * diffuseBRDF(normalize(L), nn);</code><code class=\"codeline\">Cf += clr;</code><code class=\"codeline\">diff = clr;</code><code class=\"codeline\">}</code><code class=\"codeline\">// This illuminance loop only exports to the \"spec\" variable</code><code class=\"codeline\">illuminance(P, nn, \"lightexport\", \"spec\")</code><code class=\"codeline\">{</code><code class=\"codeline\">clr = Cl * specularBRDF(normalize(L), nn, vv, 0.1);</code><code class=\"codeline\">Cf += clr;</code><code class=\"codeline\">spec = clr;</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/simport\">simport</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/limport\">limport</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gather\">gather</a></div></body>",
    "import": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/import\">import</a></h1><span class=\"padder\"><span class=\"pillow\">sop</span></span><p class=\"summary\">Reads attribute data.</p><h2>Warning</h2><p>This function has been deprecated. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getattrib\">getattrib</a> instead.</p></body>",
    "importance_remap": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/importance_remap\">importance_remap</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Remaps a texture coordinate to another coordinate in the map to optimize sampling of brighter areas.</p><div class=\"usage\"> <code>vector2 importance_remap(string map, vector2 uv, ...)</code></div><p>This function remaps texture coordinates to new texture coordinates based on importance sampling of the texture.</p><div class=\"argument\"><code>map</code></div><p>The filename of the texture map to use to guide resampling.</p><div class=\"argument\"><code><code>uv</code></code></div><p>Components should be in the range <code>0</code> to <code>1</code>. The function remaps these coordinates so more important areas of the input text (that is, brighter areas) get more samples.</p><div class=\"argument\"><code><code>maxres</code></code></div><span class=\"padder\"><span class=\"pillow\">int</span></span><span class=\"padder\"><span class=\"pillow\">0</span></span><p>While building lookup tables for importance sampling, the function resamples the texture for faster evaluation. This argument clamps the resolution of the resampled map. Depending on the use, importance sample tables can often be significantly smaller resolution than the source image with no perceptible loss.</p><p>A value of <code>0</code> (the default) just uses the original texture size.</p><h2>Note</h2><p>It\u2019s a good idea to limit the lookup table size, since you typically don\u2019t need much resolution for importance sampling, and a large texture can generate a huge LUT.</p><h2>Returns</h2><p>The remapped texture coordinates.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texture\">texture</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/filter_remap\">filter_remap</a></div></body>",
    "inedgegroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/inedgegroup\">inedgegroup</a></h1><p class=\"summary\">Returns 1 if the edge specified by the point pair is in the group specified by the string.</p><div class=\"usage\"> <code>int inedgegroup(string filename, string groupname, int pointnum0, int pointnum1)</code></div><div class=\"usage\"> <code>int inedgegroup(int input, string groupname, int pointnum0, int pointnum1)</code></div><p>Returns 1 if the edge specified by the point pair is in the group specified by the string. This function returns 0 if the group does not exist or if the edge is not contained in the group.</p><p>This can use ad-hoc groups, like <code>p29-30</code>.  It matches the SOP group naming\nconvention, in particular that an empty string means all edges.</p></body>",
    "ingroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ingroup\">ingroup</a></h1><span class=\"padder\"><span class=\"pillow\">sop</span></span><h2>Warning</h2><p>This function has been deprecated. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/inpointgroup\">inpointgroup</a> instead.</p></body>",
    "inpointgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/inpointgroup\">inpointgroup</a></h1><p class=\"summary\">Returns 1 if the point specified by the point number is in the group specified by the string.</p><div class=\"usage\"> <code>int inpointgroup(&lt;geometry&gt;, string groupname, int pointnum)</code></div><h2>Returns</h2><p><code>1</code> if the group exists and the point is in the group, or <code>0</code> otherwise.</p><p>This can use ad-hoc groups, like <code>0-3</code> or <code>@Cd.x&gt;0.5</code>.  It matches the SOP\ngroup naming convention, in particular that an empty string means all points.</p></body>",
    "inprimgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/inprimgroup\">inprimgroup</a></h1><p class=\"summary\">Returns 1 if the primitive specified by the primitive number is in the group specified by the string.</p><div class=\"usage\"> <code>int inprimgroup(&lt;geometry&gt;, string groupname, int primnum)</code></div><h2>Returns</h2><p><code>1</code> if the groups exists and the primitive is in the group, or <code>0</code> otherwise.</p><p>This can use ad-hoc groups, like <code>0-3</code> or <code>@Cd.x&gt;0.5</code>.  It matches the SOP\ngroup naming convention, in particular that an empty string means all\nprimitives.</p></body>",
    "insert": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/insert\">insert</a></h1><p class=\"summary\">Inserts an item, array, or string into an array or string.</p><div class=\"usage\"> <code>void insert(string &amp;str; int index; string value)</code></div><p>Inserts the <code>value</code> into the string <code>str</code> at the given <code>index</code>.</p><p>If <code>index</code> is greater than the length of the string, the <code>value</code> will simply be appended to the existing <code>str</code>.</p><div class=\"usage\"> <code>void insert(&lt;type&gt; &amp;array[]; int index; &lt;type&gt; value)</code></div><div class=\"usage\"> <code>void insert(&lt;type&gt; &amp;array[]; int index; &lt;type&gt; values[])</code></div><p>Inserts the items or items into the <code>array</code> starting at the given <code>index</code>.</p><p>If <code>index</code> is greater than the length current length of the <code>array</code>, the function will fill the gaps with uninitialized values (for example, <code>0</code> or the empty string).</p><div class=\"related\">If the <code>index</code> is negative, it counts from the <em>end</em> of the string or array you're inserting into. (If the negative number is greater than the string/array length, it is clamped to <code>0</code>.)</div><p>For example, to insert the number <code>100</code> as the second-to-last item in an array:</p><div class=\"codeblock\"><code class=\"codeline\">insert(numbers; -1; 100)</code></div><div class=\"usage\"> <code>int insert(dict &amp;dstdict; string dstkey; dict srcdict; string srckey);</code></div><p>Copies the value from <code>srcdict[srckey]</code> into <code>dstdict[dstkey]</code>.   This will preserve the underlying type of the value.   If the key is not in the source dictionary, it will be removed from the destination dictionary.  The result is <code>1</code> if the key existed in the destination dictionary before the update, and <code>0</code> if it did not.</p><div class=\"usage\"> <code>void insert(dict &amp;dstdict; dict srcdict);</code></div><p>Merges <code>srcdict</code> into <code>dstdict</code>.  Keys that match will be overwritten by values in the source dictionary.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/len\">len</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/push\">push</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/append\">append</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/resize\">resize</a></div></body>",
    "instance": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/instance\">instance</a></h1><p class=\"summary\">Creates an instance transform matrix.</p><div class=\"usage\"> <code>matrix instance(vector P, vector N)</code></div><div class=\"usage\"> <code>matrix instance(vector P, vector N, vector scale)</code></div><div class=\"usage\"> <code>matrix instance(vector P, vector N, vector scale, vector pivot)</code></div><div class=\"usage\"> <code>matrix instance(vector P, vector N, vector scale, vector4 rotate, vector up)</code></div><div class=\"usage\"> <code>matrix instance(vector P, vector N, vector scale, vector4 rotate, vector up, vector pivot)</code></div><div class=\"usage\"> <code>matrix instance(vector P, vector N, vector scale, vector4 rotate, vector4 orient)</code></div><div class=\"usage\"> <code>matrix instance(vector P, vector N, vector scale, vector4 rotate, vector4 orient, vector pivot)</code></div><p>Creates a transform matrix from the given arguments, using the same\nmethod that the <a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/copy\">Copy SOP</a> uses to transform its\noutput instances. The instance is placed at point <code>P</code>, oriented\nalong the normal direction <code>N</code>, and, optionally, scaled by <code>scale</code>.  An\noptional <code>pivot</code> parameter can be supplied as the local transformation point\nfor the instance.</p><p>The function supports two methods for setting rotation. The first method\nrequires an explicit <code>up</code> vector, which should be tangent to <code>N</code>. This\n<code>up</code> vector, along with <code>N</code>, is used to construct an orthonormal frame\nin which the rotation takes place.\nThe second method uses an explicit orientation relative to the XYZ axis\nto construct the frame.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/scale\">scale</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rotate\">rotate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/translate\">translate</a></div></body>",
    "interpolate": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/interpolate\">interpolate</a></h1><p class=\"summary\">Interpolates a value across the currently shaded micropolygon.</p><div class=\"usage\"> <code>float interpolate(float val, float sx, float sy)</code></div><div class=\"usage\"> <code>vector interpolate(vector val, float sx, float sy)</code></div><div class=\"usage\"> <code>vector4 interpolate(vector4 val, float sx, float sy)</code></div><div class=\"usage\"> <code>bsdf interpolate(bsdf val, float sx, float sy)</code></div><p>These operations can be used to generate antialiasing positions within\nthe micropolygon rendering engine.</p><p><code>sx</code> and <code>sy</code> are random values, such as generated by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nextsample\">nextsample</a>. Different\nvalues of <code>sx</code> and <code>sy</code> translate into different random positions on the micropolygon.</p><p>The returned value is undefined in the raytracing engine.</p><div class=\"codeblock\"><code class=\"codeline\">vector hitP = interpolate(P, sx, sy);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nextsample\">nextsample</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_light\">sample_light</a></div></body>",
    "intersect": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/intersect\">intersect</a></h1><p class=\"summary\">This function computes the first intersection of a ray with geometry.</p><p>To get a list of <em>all</em> intersections along a ray, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/intersect_all\">intersect_all</a>.</p><div class=\"usage\"> <code>int intersect(&lt;geometry&gt;, vector orig, vector dir, vector &amp;p, float &amp;u, float &amp;v)</code></div><div class=\"usage\"> <code>int intersect(&lt;geometry&gt;, vector orig, vector dir, vector &amp;p, float &amp;u, float &amp;v, ...)</code></div><p>Computes the first intersection of the specified ray with the geometry.\n    To get <em>all</em> intersections along a vector, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/intersect_all\">intersect_all</a> instead.\n    The variadic argument <code>\"farthest\"</code> can be used to indicate whether to return the last intersection instead of the first.</p><div class=\"usage\"> <code>int intersect(&lt;geometry&gt;, vector orig, vector dir, vector &amp;p, vector &amp;uvw)</code></div><p>Computes the first intersection of the specified ray with the geometry.\n    To get <em>all</em> intersections along a vector, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/intersect_all\">intersect_all</a> instead.</p><div class=\"usage\"> <code>int intersect(&lt;geometry&gt;, string group, vector orig, vector dir, vector &amp;p, vector &amp;uvw)</code></div><p>Computes the intersection of the specified ray with primitives in the given group.</p><div class=\"argument\"><code>group</code></div><p>If given, only intersect primitives in this group.</p><div class=\"argument\"><code>orig</code></div><p>The ray origin point.</p><div class=\"argument\"><code>dir</code></div><p>The ray direction <em>and maximum distance</em>.\n    This function does not expect a normalized direction vector.\n    Instead, it uses the length of the vector as the maximum distance to search.</p><div class=\"argument\"><code>&amp;p</code></div><p>If the ray intersects a primitive, this variable is overwritten with the intersection position in world space.</p><div class=\"argument\"><code><code>&amp;u</code>, <code>&amp;v</code>, <code>&amp;uvw</code></code></div><p>If the ray intersects a primitive, this/these variable(s) is/are overwritten with the parametric intersection position on the primitive.</p><h2>Returns</h2><p>The intersected primitive number, or <code>-1</code> if there was an error or the ray didn\u2019t intersect anything.</p><h2>Note</h2><p>When intersections are performed against metaball geometry, it is\n    impossible to determine the primitive number of the metaball which\n    was hit. In this case, the function returns the number of primitives\n    in the intersection geometry.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Intersect against the second input's geometry, using a ray at the current</code><code class=\"codeline\">// point's position and in the direction of its velocity vector.</code><code class=\"codeline\">vector origin = @P;</code><code class=\"codeline\">float max_dist = 1000;</code><code class=\"codeline\">vector dir = max_dist * normalize(@v);</code><code class=\"codeline\"></code><code class=\"codeline\">vector isect_pos;</code><code class=\"codeline\">float isect_u, isect_v;</code><code class=\"codeline\">int isect_prim = intersect(@OpInput2, origin, dir, isect_pos, isect_u, isect_v);</code><code class=\"codeline\"></code><code class=\"codeline\">// Return the farthest intersection instead.</code><code class=\"codeline\">isect_prim = intersect(@OpInput2, origin, dir, isect_pos, isect_u, isect_v, \"farthest\", 1);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/intersect_all\">intersect_all</a></div></body>",
    "intersect_all": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/intersect_all\">intersect_all</a></h1><p class=\"summary\">Computes all intersections of the specified ray with geometry.</p><p>To get only the <em>first</em> intersection, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/intersect\">intersect</a>.</p><div class=\"usage\"> <code>int intersect_all( &lt;geometry&gt;; string group; vector orig; vector dir; vector &amp;pos[]; int &amp;prim[]; vector &amp;uvw[], float tol=0.01, float ttol=0.01 )</code></div><div class=\"argument\"><code>&amp;pos</code></div><p>The function overwrites this array with the world space positions of each hit.</p><div class=\"argument\"><code>&amp;prim</code></div><p>The function overwrites this array with the primitive numbers of the primitives hit by the ray.</p><div class=\"argument\"><code>&amp;uvw</code></div><p>The function overwrites this array with the parametric UVW coordinates of where each intersection occurred on the primitive.</p><div class=\"argument\"><code><code>tol</code>, <code>ttol</code></code></div><p><code>tol</code> is the 3D tolerance. <code>ttol</code> is the ray tolerance.\n    Collision points within the parametric ray tolerance, <code>ttol</code> will be merged\n    together, often useful to avoid getting extra intersects when hitting the edges\n    of geometry.</p><p>To get <em>all</em> intersections without merging, set <code>ttol</code> to <code>-1</code>.</p><h2>Returns</h2><p>The number of intersections, or <code>0</code> if the ray didn\u2019t hit anything.</p><h2>Note</h2><p>When intersections are performed against metaball geometry, it is\n    impossible to determine the primitive number of the metaball which\n    was hit. In this case, the function returns the number of primitives\n    in the intersection geometry.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/intersect\">intersect</a></div></body>",
    "intersect_lights": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/intersect_lights\">intersect_lights</a></h1><span class=\"padder\"><span class=\"pillow\">displace</span></span><span class=\"padder\"><span class=\"pillow\">fog</span></span><span class=\"padder\"><span class=\"pillow\">surface</span></span><p class=\"summary\">Finds the nearest intersection of a ray with any of a list of (area) lights and runs the light shader at the intersection point.</p><h2>Note</h2><p>This function only works with area lights.</p><div class=\"usage\"> <code>int intersect_lights(int lightids[], vector pos, vector dir, float time, int &amp;idx, float &amp;dist, vector &amp;clr, float &amp;scale, ...)</code></div><div class=\"argument\"><code>lightids</code></div><p>An array of light IDs, as returned by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlights\">getlights</a>.</p><div class=\"argument\"><code>pos</code></div><p>The origin of the ray (such as the global variable <code>P</code>).</p><div class=\"argument\"><code>dir</code></div><p>Direction vector from the origin. The length of this vector does not affect\n    the distance the ray will travel.</p><div class=\"argument\"><code>time</code></div><p>Time to send the ray at.</p><p>The function modifies the values of the following arguments:</p><div class=\"argument\"><code>idx</code></div><p>The light index for the light that was hit by the ray, or -1 if no intersection was found.</p><div class=\"argument\"><code>dist</code></div><p>The distance to the nearest intersected light.</p><div class=\"argument\"><code>clr</code></div><p>The light color set by the light shader.</p><div class=\"argument\"><code>scale</code></div><p>The light average hemispherical intensity (for area lights).</p><h2>Returns</h2><p>A <a href=\"https://www.sidefx.com/docs/houdinibouncemask\">component bitmask</a> indicating what types of component bounces the light affects,\n    or <code>0</code> if the ray did not hit a light.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlights\">getlights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlightname\">getlightname</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_light\">sample_light</a></div></body>",
    "inumplanes": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/inumplanes\">inumplanes</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the number of planes in the given input.</p><div class=\"usage\"> <code>int inumplanes(int opinput)</code></div><h2>Returns</h2><p>The number of planes in the given input.</p></body>",
    "invert": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/invert\">invert</a></h1><p class=\"summary\">Inverts a matrix.</p><div class=\"usage\"> <code>&lt;matrix&gt; invert(&lt;matrix&gt; m)</code></div><div class=\"argument\"><code>m</code></div><p>The matrix to <a href=\"https://en.wikipedia.org/wiki/Invertible_matrix\">invert</a>.</p><h2>Returns</h2><p>The inverted matrix, or the original matrix if the matrix is singular.</p></body>",
    "invertexgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/invertexgroup\">invertexgroup</a></h1><p class=\"summary\">Returns 1 if the vertex specified by the vertex number is in the group specified by the string.</p><div class=\"usage\"> <code>int invertexgroup(string filename, string groupname, int vertexnum)</code></div><div class=\"usage\"> <code>int invertexgroup(int opinput, string groupname, int vertexnum)</code></div><div class=\"argument\"><code>vertexnum</code></div><p>The linear vertex number of the vertex to test.</p><p>To convert a primitive number and vertex number within that primitive to a linear vertex number for the <code>vertexnum</code> parameter, use the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexindex\">vertexindex</a> function.</p><h2>Returns</h2><p><code>1</code> if the group exists and the vertex is in the group, or <code>0</code> otherwise.</p><p>This can use ad-hoc groups, like <code>42p0-2</code>.  It matches the SOP group naming\nconvention, in particular that an empty string means all vertices.</p></body>",
    "invlerp": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/invlerp\">invlerp</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Inverses a linear interpolation between the values.</p><div class=\"usage\"> <code>float invlerp(float a, float min, float max)</code></div><div class=\"usage\"> <code>&lt;vector&gt; invlerp(&lt;vector&gt; a, &lt;vector&gt; min, &lt;vector&gt; max)</code></div><p>Returns the amount to mix <code>min</code> and <code>max</code> to generate the\n    input value <code>a</code>.  This is the inverse of the <code>lerp</code> function.</p><p>The vector version operates component-wise, so the resulting\n    vector will be the independent mixing amount for each dimension.</p><p>If <code>a</code> is outside the range <code>min</code> to <code>max</code>, values greater than\n    <code>1</code> or less than <code>0</code> will be produced.</p><p>If <code>min</code> and <code>max</code> are equal, the mixing value is <code>0.5</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lerp\">lerp</a></div></body>",
    "iplaneindex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/iplaneindex\">iplaneindex</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the index of the plane named 'planename' in the specified input.</p><div class=\"usage\"> <code>int iplaneindex(int opinput, string planename)</code></div><h2>Returns</h2><p>The index of the plane named 'planename' in the specified input.</p></body>",
    "iplanename": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/iplanename\">iplanename</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the name of the plane specified by the planeindex of the given input</p><div class=\"usage\"> <code>string iplanename(int opinput, int planeindex)</code></div><h2>Returns</h2><p>The name of the plane specified by the planeindex of the given input (e.g. C, A).</p></body>",
    "iplanesize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/iplanesize\">iplanesize</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the number of components in the plane named <code>planename</code> in\nthe specified input.</p><div class=\"usage\"> <code>int iplanesize(int opinput, int planeindex)</code></div><h2>Returns</h2><p>The number of components in the plane named <code>planename</code> in the specified input.</p></body>",
    "irate": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/irate\">irate</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the frame rate of the specified input.</p><div class=\"usage\"> <code>float irate(int opinput)</code></div><h2>Returns</h2><p>The frame rate of the specified input.</p></body>",
    "irradiance": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/irradiance\">irradiance</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Computes irradiance (global illumination) at the point P with the normal N.</p><div class=\"usage\"> <code>vector irradiance(vector P, vector N, ...)</code></div><p>Computes irradiance (global illumination) at the point P with the normal\nN.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/occlusion\">occlusion</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pathtrace\">pathtrace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/reflectlight\">reflectlight</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gather\">gather</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/trace\">trace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/irradiance\">irradiance</a></div></body>",
    "isalpha": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isalpha\">isalpha</a></h1><p class=\"summary\">Returns 1 if all the characters in the string are alphabetic</p><div class=\"usage\"> <code>int isalpha(const string str)</code></div><p>Returns 1 if all the characters in the string are alphabetic. No numerals, punctuation\nor other special characters. If any are present then returns 0.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isdigit\">isdigit</a></div></body>",
    "isbound": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isbound\">isbound</a></h1><p class=\"summary\">Parameters in VEX can be overridden by geometry attributes (if the attributes exist on the surface being rendered).</p><div class=\"usage\"> <code>int isbound(string variable_name)</code></div><p>Parameters in VEX can be overridden by geometry attributes (if the\nattributes exist on the surface being rendered). If the geometry\noverrides the default attribute, this function will return 1. Otherwise\nit will return 0.</p><h2>Note</h2><p>Though this function is defined for all contexts, it is only useful in the Displacement, Surface, and SOP contexts. No other contexts</p><p>can currently bind geometry attributes to VEX variables.</p><p>Example, in a SOP function:</p><div class=\"codeblock\"><code class=\"codeline\">sop</code><code class=\"codeline\">mycolor(vector uv=0; string map=\"\")</code><code class=\"codeline\">{</code><code class=\"codeline\">if (isbound(\"uv\") &amp;&amp; map != \"\")</code><code class=\"codeline\">{</code><code class=\"codeline\">    // User has texture coordinates here, so create</code><code class=\"codeline\">    // velocity based on a texture map.</code><code class=\"codeline\">    v = colormap(map, uv);</code><code class=\"codeline\">}</code><code class=\"codeline\">else</code><code class=\"codeline\">{</code><code class=\"codeline\">    // No texture coordinates, so use a random value</code><code class=\"codeline\">    v = random(id);</code><code class=\"codeline\">}</code></div><h2>Note</h2><p><code>isbound</code> does not tell you if the attribute exists. It tells you if the attribute is bound. If you added an <code>@a</code> to a wrangle to bind the <code>a</code>, then <code>isbound</code> will work as you expect in CVEX. Without an <code>@a</code>, there is no parameter in your CVEX function to bind the attribute to, so it will be unbound. </p></body>",
    "isconnected": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isconnected\">isconnected</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><span class=\"padder\"><span class=\"pillow\">cop2</span></span><span class=\"padder\"><span class=\"pillow\">sop</span></span><p class=\"summary\">Returns 1 if input_number is connected, or 0 if the input is not connected.</p><div class=\"usage\"> <code>int isconnected(int opinput)</code></div><h2>Returns</h2><p>1 if <code class=\"var\">input_number</code> is connected, or 0 if the input is not connected.</p></body>",
    "isdigit": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isdigit\">isdigit</a></h1><p class=\"summary\">Returns 1 if all the characters in the string are numeric</p><div class=\"usage\"> <code>int isdigit(const string str)</code></div><p>Returns 1 if all the characters in the string are numeric (0-9). No alphabetic characters,\npunctuation or other special characters. If any are present then returns 0.</p><p>If passed the string 543.34, this function will return 0 because . is not a digit.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isalpha\">isalpha</a></div></body>",
    "isfinite": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isfinite\">isfinite</a></h1><p class=\"summary\">Checks whether a value is a normal finite number.</p><div class=\"usage\"> <code>int isfinite(float x)</code></div><p>Returns 1 if the given value is a normal, finite, number.</p><p>Returns 0 if it is a NAN or infinite.  Note that VEX generally\nwill not produce these: 3/0 is defined as 0, for example.</p></body>",
    "isfogray": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isfogray\">isfogray</a></h1><span class=\"padder\"><span class=\"pillow\">light</span></span><span class=\"padder\"><span class=\"pillow\">shadow</span></span><p class=\"summary\">Returns 1 if the shader is being called to evaluate illumination for\nfog objects, or 0 if the light or shadow shader is being called to\nevaluate surface illumination.</p><div class=\"usage\"> <code>int isfogray()</code></div><p>Returns 1 if the shader is being called to evaluate illumination for fog\nobjects, or 0 if the light or shadow shader is being called to evaluate\nsurface illumination.</p><p>Use this function to simplify light shaders when evaluating for fog.</p></body>",
    "isframes": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isframes\">isframes</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Returns 1 if the Vex CHOP\u2019s Unit Menu is currently set to 'frames', 0\notherwise.</p><div class=\"usage\"> <code>int isframes()</code></div><p>Returns 1 if the Vex CHOP\u2019s Unit Menu is currently set to 'frames', 0\notherwise.</p></body>",
    "islpeactive": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/islpeactive\">islpeactive</a></h1><span class=\"padder\"><span class=\"pillow\">surface</span></span><p class=\"summary\">Returns 1 if Light Path Expressions are enabled. 0 Otherwise.</p><div class=\"usage\"> <code>int islpeactive()</code></div><p>Returns 1 if there are any image planes with vex variable that starts with\n<code>\"lpe:\"</code>, which indicates that Light Path Expression (LPE) is enabled. Returns 0\nif no such image plane exists.</p><p>This function is used to optimize out any LPE related function calls if the\ncurrent render doesn\u2019t have any AOVs that uses LPE.</p></body>",
    "isnan": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isnan\">isnan</a></h1><p class=\"summary\">Checks whether a value is not a number.</p><div class=\"usage\"> <code>int isnan(float x)</code></div><p>Returns 1 if the given value is not a number.</p><p>Returns 0 if it is a normal number or infinite.</p><p>NAN, or Not A Number, is a special value floating point numbers can be set to\nto signal something has gone wrong in the computation.  They are carried\nforward by all further operations (adding or multiplying with them produces\nmore NANs) and tend to cause problems with downstream operations.</p><p>In traditional programming, these are generated by 0/0 or <code>sqrt(-1)</code>, but in VEX\nmost such operations are guarded so normally VEX will not produce NANs.</p></body>",
    "isotropic": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isotropic\">isotropic</a></h1><p class=\"summary\">Returns an isotropic BSDF, which scatters light equally in all directions.</p><div class=\"usage\"> <code>bsdf isotropic(...)</code></div><p>The isotropic function scatters light equally in all directions and is suitable for use in rendering dense volumetric materials such as smoke. Note that no normal vector is required to construct an isotropic bsdf since it has no directionality. The default albedo for an isotropic <code>bsdf</code> is 1, which means the isotropic() function scatters 100% of the incoming light.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/henyeygreenstein\">henyeygreenstein</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/specular\">specular</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phong\">phong</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "israytracing": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/israytracing\">israytracing</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Indicates whether a shader is being executed for ray tracing.</p><div class=\"usage\"> <code>int israytracing()</code></div><p>Returns true when the current shader is shading ray hits.  For micropolygon\nrendering, the return value will be false.  This function can be used to\ndisambiguate shading styles for renders that use the vm_rayshade property -\nwhere only some objects are ray traced.</p></body>",
    "issamples": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/issamples\">issamples</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Returns 1 if the Vex CHOP\u2019s Unit Menu is currently set to 'samples',\n0 otherwise.</p><div class=\"usage\"> <code>int issamples()</code></div><p>Returns 1 if the Vex CHOP\u2019s Unit Menu is currently set to 'samples', 0\notherwise.</p></body>",
    "isseconds": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isseconds\">isseconds</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Returns 1 if the Vex CHOP\u2019s Unit Menu is currently set to 'seconds',\n0 otherwise.</p><div class=\"usage\"> <code>int isseconds()</code></div><p>Returns 1 if the Vex CHOP\u2019s Unit Menu is currently set to 'seconds', 0\notherwise.</p></body>",
    "isshadingRHS": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isshadingRHS\">isshadingRHS</a></h1><span class=\"padder\"><span class=\"pillow\">fog</span></span><span class=\"padder\"><span class=\"pillow\">light</span></span><span class=\"padder\"><span class=\"pillow\">shadow</span></span><span class=\"padder\"><span class=\"pillow\">surface</span></span><span class=\"padder\"><span class=\"pillow\">displace</span></span><p class=\"summary\">Detects the orientation of default shading space.</p><div class=\"usage\"> <code>int isshadingRHS()</code></div><p>Shading can occur in either a left or right handed vector space.  This function\ncan be used to check the native orientation in shading space.  By default,\nMantra is left-handed space while Karma is in right-handed space.</p></body>",
    "isshadowray": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isshadowray\">isshadowray</a></h1><span class=\"padder\"><span class=\"pillow\">surface</span></span><p class=\"summary\">Returns 1 if the shader is being called to evaluate opacity for\nshadow rays, or 0 if the shader is being called to evaluate for surface\ncolor.</p><div class=\"usage\"> <code>int isshadowray()</code></div><p>Returns 1 if the shader is being called to evaluate opacity for shadow\nrays, or 0 if the shader is being called to evaluate for surface color.</p><p>Use this function to compute different opacity if the surface is\nshadowing another surface.</p></body>",
    "istart": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/istart\">istart</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the starting frame of the specified input.</p><div class=\"usage\"> <code>int istart(int opinput)</code></div><h2>Returns</h2><p>The starting frame of the specified input.</p></body>",
    "istarttime": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/istarttime\">istarttime</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the start time of the specified input.</p><div class=\"usage\"> <code>float istarttime(int opinput)</code></div><h2>Returns</h2><p>The start time of the specified input.</p></body>",
    "isuvrendering": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isuvrendering\">isuvrendering</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Indicates whether the shader is being evaluated while doing UV rendering (e.g. texture unwrapping)</p><div class=\"usage\"> <code>int isuvrendering()</code></div><p>Returns 1 if the shader is being called while evaluating uv rendering (texture unwrapping), and 0 for normal rendering.</p><p>Use this function to evaluate shaders differently when baking illumination.</p></body>",
    "isvalidindex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isvalidindex\">isvalidindex</a></h1><p class=\"summary\">Checks if the index given is valid for the array or string given.</p><div class=\"usage\"> <code>int isvalidindex(&lt;type&gt; &amp;array[], int index)</code></div><div class=\"usage\"> <code>int isvalidindex(string str, int index)</code></div><p>Returns <code>1</code> if <code>index</code> is within range for the given string/array, or <code>0</code> otherwise.</p><p>This is equivalent to <code>index &lt; len(array) &amp;&amp; index &gt;= -len(array)</code>.</p><div class=\"usage\"> <code>int isvalidindex(dict d, string key)</code></div><p>Returns <code>1</code> if the key is in the dictionary, or <code>0</code> otherwise.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/len\">len</a></div></body>",
    "isvarying": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isvarying\">isvarying</a></h1><p class=\"summary\">Check whether a VEX variable is varying or uniform.</p><div class=\"usage\"> <code>int isvarying(&lt;type&gt; x)</code></div><div class=\"usage\"> <code>int isvarying(&lt;type&gt; x[])</code></div><p>Returns 1 when the given variable is varying, or 0 when it is uniform. A\nvariable is varying when it may have a different value for each processor\nin the VEX SIMD array. If a value is varying, shader execution will\ngenerally be slower - so this function can be useful when debugging shader\nperformance. Any variable type can be passed to the <code>isvarying()</code> function.</p></body>",
    "itoa": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/itoa\">itoa</a></h1><p class=\"summary\">Converts an integer to a string.</p><div class=\"usage\"> <code>string itoa(int number)</code></div><p>Converts an integer to a string.</p></body>",
    "ixres": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ixres\">ixres</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the X resolution of the specified input.</p><div class=\"usage\"> <code>int ixres(int opinput)</code></div><h2>Returns</h2><p>The X resolution of the specified input.</p></body>",
    "iyres": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/iyres\">iyres</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the Y resolution of the specified input.</p><div class=\"usage\"> <code>int iyres(int opinput)</code></div><h2>Returns</h2><p>The Y resolution of the specified input.</p></body>",
    "join": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/join\">join</a></h1><p class=\"summary\">Concatenate all the strings of an array inserting a common spacer.</p><div class=\"usage\"> <code>string join(const string s[]; const string spacer)</code></div><p>Concatenate all the strings in the array to form a single string.\nThe spacer will be placed between each pair of strings.</p></body>",
    "json_dumps": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/json_dumps\">json_dumps</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Converts a VEX dictionary into a JSON string.</p><div class=\"usage\"> <code>string json_dumps(dict d, int flags)</code></div><p>Converts the dictionary into a JSON-compatible string.  Because JSON\nis not typed, but VEX dictionaries are, there are two formats to convert\nto.   The fully-typed format has each dictionary value correspond to\na map with a type and value explicitly provided, allowing full\nround tripping.  The compact format omits this, which means when\nconverting back guesses have to be performed, so things like vectors\nwill become float arrays.</p><p>The possible flag values are:</p><span><code>0</code> </span><p>Fully typed JSON on a single line.</p><span><code>1</code> </span><p>Fully typed JSON on multiple lines.</p><span><code>2</code> </span><p>Compact typeless JSON on a single line.</p><span><code>3</code> </span><p>Compact typeless JSON on multiple lines.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/json_loads\">json_loads</a></div></body>",
    "json_loads": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/json_loads\">json_loads</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Converts a JSON string into a VEX dictionary.</p><div class=\"usage\"> <code>dict json_loads(string json, int flags)</code></div><p>Tries to create a dictionary out of a JSON-style string.  If a parsing\nerror occurs, an empty dictionary is created.  There are two formats\nfor JSON recognized.  The fully typed format consists of maps for\neach element that stores the type and value.  This allows proper\nround-tripping of VEX dictionaries, but is verbose.  The compact\nformat requires the dictionary to guess the type of JSON elements,\nso things like vectors will be created as float arrays.</p><p>The VEX dictionaries need to have arrays of uniform type.  If an\narray has varying type, the elements will be created as strings\nof the raw JSON values.</p><p>The possible flag values are:</p><span><code>0</code> </span><p>Auto-detect if the string is a typed or typeless JSON</p><span><code>1</code> </span><p>Require a fully typed JSON</p><span><code>2</code> </span><p>Require a typeless JSON.  If a fully-typed JSON is read, an extra layer of dictionaries will be created.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/json_dumps\">json_dumps</a></div></body>",
    "keys": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/keys\">keys</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Returns all the keys in a dictionary.</p><div class=\"usage\"> <code>string [] keys(dict d)</code></div><p>Returns all the keys in the dictionary.  Returns an empty string array\nif the dictionary is empty.  The returned keys are always sorted\nalphabetically.</p></body>",
    "kspline": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/kspline\">kspline</a></h1><p class=\"summary\">Returns an interpolated value along a curve defined by a basis and key/position pairs.</p><div class=\"usage\"> <code>float kspline(string basis; float sample_pos; float value1, float key_pos1, ...)</code></div><p>Samples a curve defined by a series of value/position pairs.\n    This is useful for specifying a 1D data ramp.</p><div class=\"usage\"> <code>vector kspline(string basis; float sample_pos; vector value1, float key_pos1, ...)</code></div><div class=\"usage\"> <code>vector4 kspline(string basis; float sample_pos; vector4 value1, float key_pos1, ...)</code></div><p>Samples a curve defined by a series of vector value/position pairs.\n    This is useful for specifying a color ramp.</p><p>If you just want linearly spaced keys, or if you need to vary the basis, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/spline\">spline</a> instead.</p><h2>Tip</h2><p>The <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/spline\">spline</a> function is a more flexible superset of this function.</p><p>This function is the equivalent of:</p><div class=\"codeblock\"><code class=\"codeline\">type kspline(basis, t, v0, k0, v1, k1, v2, k2...)</code><code class=\"codeline\">{</code><code class=\"codeline\">    float tk = spline(\"linearsolve\", t, k0, k1, k2, ...);</code><code class=\"codeline\">    return spline(basis, tk, v0, v1, v2, ...);</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/spline\">spline</a></div></body>",
    "len": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/len\">len</a></h1><p class=\"summary\">Returns the length of an array.</p><div class=\"usage\"> <code>int len(&lt;vector&gt; v)</code></div><div class=\"usage\"> <code>int len(&lt;matrix&gt; m)</code></div><div class=\"usage\"> <code>int len(&lt;type&gt; array[])</code></div><div class=\"usage\"> <code>int len(string s)</code></div><div class=\"usage\"> <code>int len(dict d)</code></div><p>Returns the number of items/components in the given object. For an array, this is the number of items in the array. For a matrix or vector, this is the number of components.</p><p>For a string, this returns the number of <em>bytes</em> (not characters).</p><p>For a dictionary, this returns the number of keys in the dictionary.</p><p>Don\u2019t confuse this function with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/length\">length</a>, which returns the magnitude of a vector.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">len(\"hello\") == 5;</code><code class=\"codeline\">len({ {1,0,0}, {0,1,0}, {0,0,1} }) == 9;</code><code class=\"codeline\">len({0, 10, 20, 30}) == 4;</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/resize\">resize</a></div></body>",
    "length": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/length\">length</a></h1><p class=\"summary\">Returns the magnitude of a vector.</p><p>To get the length of a string, or number of items in an array, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/len\">len</a>.</p><div class=\"usage\"> <code>float length(float f)</code></div><p>Simply returns the given number.</p><div class=\"usage\"> <code>float length(vector2 v)</code></div><div class=\"usage\"> <code>float length(vector v)</code></div><div class=\"usage\"> <code>float length(vector4 v)</code></div><p>Returns the distance of the vector or vector4 from the origin.</p><p>If you want the squared length, using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/length2\">length2</a> is faster than squaring the result of this function.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">length({1.0, 0, 0}) == 1.0;</code><code class=\"codeline\">length({1.0, 1.0, 0}) == 1.41421;</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/length2\">length2</a></div></body>",
    "length2": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/length2\">length2</a></h1><p class=\"summary\">Returns the squared distance of the vector or vector4.</p><div class=\"usage\"> <code>float length2(vector2 v)</code></div><div class=\"usage\"> <code>float length2(vector v)</code></div><div class=\"usage\"> <code>float length2(vector4 v)</code></div><p>Returns the squared distance of the vector.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">length2({0.5, 0.75, 0}) == 0.8125;</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/length\">length</a></div></body>",
    "lerp": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lerp\">lerp</a></h1><p class=\"summary\">Performs linear interpolation between the values.</p><div class=\"usage\"> <code>float lerp(float value1, float value2, float amount)</code></div><p>Performs linear interpolation between the values.</p><div class=\"usage\"> <code>&lt;vector&gt; lerp(&lt;vector&gt; value1, &lt;vector&gt; value2, float amount)</code></div><p>Performs linear interpolation between corresponding components.</p><div class=\"usage\"> <code>&lt;vector&gt; lerp(&lt;vector&gt; value1, &lt;vector&gt; value2, &lt;vector&gt; amount)</code></div><p>Performs linear interpolation between corresponding components by specific amounts for each component pair.</p><div class=\"usage\"> <code>bsdf lerp( bsdf bsdf1; bsdf bsdf2; float amount)</code></div><p>Returns a BSDF that linearly interpolates between the output of the two given BSDFS.</p><div class=\"argument\"><code>amount</code></div><p>If the amount is outside the range 0 to 1, the values will be extrapolated linearly.</p><p>If amount is 0, the first value is returned.  If it is 1, the second value is returned.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/slerp\">slerp</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/invlerp\">invlerp</a></div></body>",
    "lightbounces": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lightbounces\">lightbounces</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Returns the bounce mask for a light struct.</p><div class=\"usage\"> <code>int lightbounces(light lp)</code></div><p>Returns the bounce mask for the light struct passed in. The bounce mask is based on the light object\u2019s <strong>Lighting contribution</strong> parameter.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlight\">getlight</a></div></body>",
    "lightid": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lightid\">lightid</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Returns the light id for a light struct.</p><div class=\"usage\"> <code>int lightid(light lp)</code></div><p>Returns the integer light identifier of the light struct passed in.  The function returns -1 if the argument is invalid.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlight\">getlight</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlights\">getlights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlightname\">getlightname</a></div></body>",
    "lightstate": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lightstate\">lightstate</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Queries the renderer for a named property.</p><div class=\"usage\"> <code>int lightstate(string query, &lt;type&gt; &amp;value)</code></div><div class=\"usage\"> <code>int lightstate(string query, &lt;type&gt;[] &amp;value)</code></div><p>Returns a non-zero value and sets <code class=\"var\">value</code> on success, or returns <code>0</code>\nif the renderer cannot evaluate the query.</p><p>See the <a href=\"https://www.sidefx.com/docs/houdini/props/mantra\">list of IFD properties</a> you can query. Use\nthe <strong>IFD</strong> name (e.g. <code>image:samples</code>),\nnot the Houdini name (e.g. <code>vm_samples</code>).</p><h2>Useful properties</h2><p>The following properties are commonly useful and are reproduced here\nfor convenience, but you can query any property from the\n<a href=\"https://www.sidefx.com/docs/houdini/props/mantra\">the full list of IFD properties</a>.</p><div class=\"argument\"><code><code>image:name</code></code></div><p>(string) The name of the image being rendered.</p><div class=\"argument\"><code><code>image:pixelaspect</code></code></div><p>(float) The pixel aspect ratio (X/Y) of the image.</p><div class=\"argument\"><code><code>image:resolution</code></code></div><p>(vector) Gives the resolution as {<code class=\"var\">x_res</code>, <code class=\"var\">y_res</code>, <code class=\"var\">samples_per_pixel</code>}.</p><div class=\"argument\"><code><code>image:samples</code></code></div><p>(vector) Gives samples as {<code class=\"var\">x_samples</code>, <code class=\"var\">y_samples</code>, 0}.</p><div class=\"argument\"><code><code>image:raysamples</code></code></div><p>(vector) Gives the raytracing samples as {<code class=\"var\">x_samples</code>, <code class=\"var\">y_samples</code>, 0}.</p><div class=\"argument\"><code><code>light:name</code></code></div><p>(string) The name of the light object which is currently active in the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a> loop.</p><div class=\"argument\"><code><code>light:shadowscope</code></code></div><p>(string) The list of objects casting shadows from a light.</p><div class=\"argument\"><code><code>object:name</code></code></div><p>(string) The name of the object being shaded. This is valid within light and shadow shaders and can be used to query which object is being lit (or shadowed) by the light source.</p><div class=\"argument\"><code><code>object:reflectscope</code></code></div><p>(string) The default reflection scope pattern for the object being shaded.</p><div class=\"argument\"><code><code>object:refractscope</code></code></div><p>(string) The default refraction scope pattern for the object being shaded.</p><div class=\"argument\"><code><code>object:reflectlimit</code></code></div><p>(float or int) The hard limit for maximum refraction bounces for the object being shaded.</p><div class=\"argument\"><code><code>object:shadingquality</code></code></div><p>(float) The shading quality for the object being shaded.</p><div class=\"argument\"><code><code>object:lightmask</code></code></div><p>(string) The object\u2019s light mask string.</p><div class=\"argument\"><code><code>object:area</code></code></div><p>(float) The object\u2019s surface area.</p><div class=\"argument\"><code><code>object:materialname</code></code></div><div class=\"argument\"><code>(string) Path to the material that\u2019s assigned to the object being shaded. \n    NOTE</code></div><p>This is for informational purpose only and has no effect on material assignment or appearance.</p><div class=\"argument\"><code><code>renderer:name</code></code></div><p>(string) The name of the renderer.</p><div class=\"argument\"><code><code>renderer:version</code></code></div><p>As a string, gives the renderer version as <code class=\"var\">major</code>.<code class=\"var\">minor</code>.<code class=\"var\">build</code>\n    As a vector, gives the renderer version as {<code class=\"var\">major</code>, <code class=\"var\">minor</code>, <code class=\"var\">build</code>}.</p><div class=\"argument\"><code><code>renderer:renderengine</code></code></div><p>(string) The render method in use, such as <code>micropoly</code> or <code>raytrace</code>. \n    See the <a href=\"https://www.sidefx.com/docs/houdini/props/mantra\">properties list</a> for the full list of possible values.</p><div class=\"argument\"><code><code>shader:name</code></code></div><p>(string) The name of the current shader being run.</p><h2>Packed Primitives</h2><p>When mantra renders packed primitives, the geometry gets unpacked before rendering.  This means primitive attributes on the packed primitive aren\u2019t available to shaders (since they aren\u2019t passed down to the unpacked geometry).</p><p>Before unpacking, mantra will automatically convert the primitive attributes to custom object properties (see <code>ray_declare</code> on the <a href=\"https://www.sidefx.com/docs/houdini/render/ifd\">IFD file format</a> page).  The property will be named <code>packed:ATTRIBNAME</code> (where <code>ATTRIBNAME</code> is the name of the attribute).  The <code>lightstate()</code> function can be used to access these properties, just like any other object property.</p><p>For example:</p><div class=\"codeblock\"><code class=\"codeline\">vector Cd;</code><code class=\"codeline\">    if (!lightstate(\"packed:Cd\", Cd))</code><code class=\"codeline\">        Cd = 1;   // There was no Cd attribute on packed geometry</code></div><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">surface showversion() </code><code class=\"codeline\">{</code><code class=\"codeline\">    string    rname, rversion;</code><code class=\"codeline\">    if (!lightstate(\"renderer:name\", rname))</code><code class=\"codeline\">        rname = \"Unknown renderer\";</code><code class=\"codeline\">    if (!lightstate(\"renderer:version\", rversion))</code><code class=\"codeline\">        rversion = \"Unknown version\";</code><code class=\"codeline\">    printf(\"Image rendered by %s (%s)\\n\", rname, rversion);</code><code class=\"codeline\">}</code><code class=\"codeline\"></code><code class=\"codeline\">vector mapToScreen(vector NDC_P)</code><code class=\"codeline\">{</code><code class=\"codeline\">    // Given a point in NDC space, find out which pixel it</code><code class=\"codeline\">    // maps to.</code><code class=\"codeline\">    vector    result;</code><code class=\"codeline\">    if (!lightstate(\"image:resolution\", result))</code><code class=\"codeline\">        result = {640, 486, 0};</code><code class=\"codeline\">    return result * NDC_P;</code><code class=\"codeline\">}</code></div></body>",
    "limit_sample_space": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/limit_sample_space\">limit_sample_space</a></h1><p class=\"summary\">Limits a unit value in a way that maintains uniformity and in-range consistency.</p><div class=\"usage\"> <code>float limit_sample_space(float minu, float maxu, float u)</code></div><div class=\"usage\"> <code>float limit_sample_space(float maxu, float u)</code></div><div class=\"argument\"><code>minu</code></div><p>Minimum desired value of <code>u</code>.  <code>minu</code> will be clamped to between 0 and 1.\n    If not specified, <code>minu</code> is 0.</p><div class=\"argument\"><code>maxu</code></div><p>Maximum desired value of <code>u</code>.  <code>maxu</code> will be clamped to between 0 and 1.</p><div class=\"argument\"><code>u</code></div><p>Number between 0 and 1.</p><p>If <code>u</code> is outside of <code>[minu,maxu]</code>, <code>u</code> is wrapped in the space in such a\nway that uniform random <code>u</code> in [0,1) will yield uniform random samples in\n<code>[minu,maxu]</code> and returned.  This avoids the extra samples at the bounds\nof the range that clamping to the range would introduce.  It also avoids the\nchanging of samples inside the range that fitting to the range would\nintroduce, i.e. if <code>u</code> is already in the range, the return value is exactly <code>u</code>.</p><p>However, this is much slower than fitting or clamping, so only use\nit when both uniformity and consistency are needed.  For example, it can be\nuseful in avoiding outliers in probability distributions without affecting\nsamples that are not outliers.  It also introduces the issue that results\nwill no longer be monotone increasing with respect to <code>u</code>.\nFitting will often suffice for avoiding outliers too, at the expense\nof slightly affecting samples that are not outliers.</p><p>To find <code>minu</code> and <code>maxu</code> given a <code>minvalue</code> and <code>maxvalue</code> of some probability\ndistribution, <code>minu = CDF(minvalue)</code> and <code>maxu = CDF(maxvalue)</code>, where <code>CDF</code>\nis the cumulative distribution function (not inverse) of the probability\ndistribution.  The versions of <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_exponential\">sample_exponential</a>,\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_cauchy\">sample_cauchy</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_normal\">sample_normal</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_lognormal\">sample_lognormal</a>, and\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_lognormal_by_median\">sample_lognormal_by_median</a> that take a <code>minvalue</code> or <code>maxvalue</code> use fitting\ninstead of this limiting, because it maintains monotonicity, but this\nfunction can be applied to <code>u</code> before sampling, in order to have better\nconsistency for samples in the range.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_exponential\">sample_exponential</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_cauchy\">sample_cauchy</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_normal\">sample_normal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_lognormal\">sample_lognormal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_lognormal_by_median\">sample_lognormal_by_median</a></div></body>",
    "limport": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/limport\">limport</a></h1><span class=\"padder\"><span class=\"pillow\">displace</span></span><span class=\"padder\"><span class=\"pillow\">fog</span></span><span class=\"padder\"><span class=\"pillow\">shadow</span></span><span class=\"padder\"><span class=\"pillow\">surface</span></span><p class=\"summary\">Imports a variable from the light shader for the surface.</p><h2>Note</h2><p>This function is only valid inside an <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a> loop.</p><div class=\"usage\"> <code>int limport(const string name; &lt;type&gt; &amp;value)</code></div><div class=\"argument\"><code>name</code></div><p>The name of the shader variable to read.</p><div class=\"argument\"><code>&amp;value</code></div><p>If the named variable is defined and exported, the function overwrites this variable with the variable\u2019s value.</p><h2>Returns</h2><p>Returns <code>1</code> if the shader variable is defined and exported, or <code>0</code> otherwise.</p></body>",
    "lkspline": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lkspline\">lkspline</a></h1><p class=\"summary\">Samples a polyline between the key points.</p><div class=\"usage\"> <code>float lkspline( float sample_pos; float value1; float key_pos1; ... )</code></div><p>Samples a polyline defined by a series of value/position pairs.\n    This is useful for specifying a 1D data ramp.</p><div class=\"usage\"> <code>vector lkspline( float sample_pos; vector value1; float key_pos1; ... )</code></div><div class=\"usage\"> <code>vector4 lkspline( float sample_pos; vector4 value1; float key_pos1; ... )</code></div><p>Samples a polyline defined by a series of vector value/position pairs.\n    This is useful for specifying a color ramp.</p><p>If you just want linearly spaced keys, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lspline\">lspline</a> instead.</p><div class=\"argument\"><code>sample_pos</code></div><p>The position along the curve at which to sample.</p><div class=\"argument\"><code><code>value<code class=\"var\">n</code></code>, <code>key_pos<code class=\"var\">n</code></code></code></div><p>To define the shape of the curve, you pass a number of value/position pairs specifying the key points through which the curve passes.</p><p>You must specify key positions in ascending order or the results will be unpredictable.</p><h2>Returns</h2><p>The value of the curve at the sampled position.</p><h2>Tip</h2><p>The <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/spline\">spline</a> function is a more flexible superset of this function.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/spline\">spline</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/kspline\">kspline</a></div></body>",
    "log": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/log\">log</a></h1><p class=\"summary\">Returns the natural logarithm of the argument.</p><div class=\"usage\"> <code>float log(float n)</code></div><div class=\"usage\"> <code>&lt;vector&gt; log(&lt;vector&gt; v)</code></div><p>Returns the natural logarithm of <code>n</code>. For vectors, this is done per-component.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/log10\">log10</a></div></body>",
    "log10": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/log10\">log10</a></h1><p class=\"summary\">Returns the logarithm (base 10) of the argument.</p><div class=\"usage\"> <code>float log10(float n)</code></div><div class=\"usage\"> <code>&lt;vector&gt; log10(&lt;vector&gt; n)</code></div><p>Returns the base 10 logarithm of <code>n</code>. For vectors, this is done per-component.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/log\">log</a></div></body>",
    "lookat": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lookat\">lookat</a></h1><p class=\"summary\">Computes a rotation matrix or angles to orient the negative z-axis along the vector (to-from) under the transformation.</p><div class=\"usage\"> <code>matrix3 lookat(vector from, vector to)</code></div><div class=\"usage\"> <code>matrix3 lookat(vector from, vector to, float roll)</code></div><div class=\"usage\"> <code>matrix3 lookat(vector from, vector to, vector up)</code></div><div class=\"usage\"> <code>vector lookat(vector from, vector to, float roll, int xyz)</code></div><div class=\"usage\"> <code>vector lookat(vector from, vector to, vector up, int xyz)</code></div><p>Computes a rotation matrix or angles to orient the negative z-axis along the\nvector (to-from) under the transformation. If an up vector is specified, this\nwill determine the roll.</p><p><code>xyz</code> is a rotation order defined in <code>$HFS/houdini/support/vex/include/math.h</code>.</p></body>",
    "lspline": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lspline\">lspline</a></h1><p class=\"summary\">Samples a polyline defined by linearly spaced values.</p><div class=\"usage\"> <code>float lspline(float sample_pos, float value1, ...)</code></div><p>Samples a polyline defined by a series of (linearly spaced) values.\n    This is useful for specifying a 1D data ramp.</p><div class=\"usage\"> <code>vector lspline(float sample_pos, vector value1, ...)</code></div><div class=\"usage\"> <code>vector4 lspline(float sample_pos, vector4 value1, ...)</code></div><p>Samples a polyline defined by a series of (linearly spaced) vector values.\n    This is useful for specifying a color ramp.</p><p>If you need variably-spaced keys, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lkspline\">lkspline</a> instead.</p><div class=\"argument\"><code>value<code class=\"var\">n</code></code></div><p>To define the shape of the curve, you pass a number of values specifying the key points through which the curve passes. The function automatically spaces the keys evenly.</p><h2>Tip</h2><p>The <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/spline\">spline</a> function is a more flexible superset of this function.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/spline\">spline</a></div></body>",
    "lstrip": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lstrip\">lstrip</a></h1><p class=\"summary\">Strips leading whitespace from a string.</p><div class=\"usage\"> <code>string lstrip(string value)</code></div><div class=\"usage\"> <code>string lstrip(string value, string whitespace)</code></div><p>Returns a string with the leading whitespace removed.  If whitespace is provided, it is a string of characters that will be stripped.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rstrip\">rstrip</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/strip\">strip</a></div></body>",
    "luminance": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/luminance\">luminance</a></h1><p class=\"summary\">Compute the luminance of the RGB color specified by the parameters.</p><div class=\"usage\"> <code>float luminance(const vector rgb)</code></div><div class=\"usage\"> <code>float luminance(const vector4 rgb)</code></div><div class=\"usage\"> <code>float luminance(const float r, float g, float b)</code></div></body>",
    "lumname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lumname\">lumname</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the default name of the luminaence plane (as it appears in the\ncompositor preferences).</p><div class=\"usage\"> <code>string lumname()</code></div><p>Returns the default name of the luminaence plane (as it appears in the\ncompositor preferences). Using this instead of hardcoding the default\nmakes your code more portable. Default is L.</p></body>",
    "makebasis": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/makebasis\">makebasis</a></h1><p class=\"summary\">Creates an orthonormal basis given a z-axis vector.</p><div class=\"usage\"> <code>void makebasis(vector &amp;xaxis, vector &amp;yaxis, vector zaxis)</code></div><div class=\"usage\"> <code>void makebasis(vector &amp;xaxis, vector &amp;yaxis, vector zaxis, vector u)</code></div><p>Completes an orthonormal basis for the given <code>zaxis</code> vector consisting of\nthe <code>xaxis</code> and <code>yaxis</code> basis vectors. When only the <code>zaxis</code> vector is\ngiven, the basis will have an arbitrary orientation. When a second vector\n<code>u</code> is provided, the <code>yaxis</code> vector will be constrained so that it is aligned\nwith that vector.</p></body>",
    "maketransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/maketransform\">maketransform</a></h1><p class=\"summary\">Builds a 3\u00d73 or 4\u00d74 transform matrix.</p><div class=\"usage\"> <code>matrix3 maketransform(vector zaxis, vector yaxis)</code></div><div class=\"usage\"> <code>matrix3 maketransform(int xyz, vector angles)</code></div><div class=\"usage\"> <code>matrix maketransform(vector zaxis, vector yaxis, vector translate)</code></div><div class=\"usage\"> <code>matrix maketransform(int trs, int xyz; const vector t, vector r)</code></div><div class=\"usage\"> <code>matrix maketransform(int trs, int xyz; const vector t, vector r, vector s)</code></div><div class=\"usage\"> <code>matrix maketransform(int trs, int xyz; const vector t, vector r, vector s, vector p)</code></div><div class=\"usage\"> <code>matrix maketransform(int trs, int xyz; const vector t, vector r, vector s, vector p, vector pr)</code></div><div class=\"usage\"> <code>matrix maketransform(int trs, int xyz; const vector t, vector r, vector s, vector p, vector pr, vector shears)</code></div><p>Builds a 3\u00d73 or 4\u00d74 transform matrix.</p><p><code>maketransform(int trs, ...)</code> builds a general 4\u00d74 transform matrix\ngiven an order of transformations (<code class=\"var\">trs</code>), an order for rotations\n(<code class=\"var\">xyz</code>), a vector representing the translation (<code class=\"var\">t</code>), rotation\n(<code class=\"var\">r</code>), scale (<code class=\"var\">s</code>) (and optionally a pivot (<code class=\"var\">p</code>), pivot rotation\n(<code class=\"var\">pr</code>), and shears (<code class=\"var\">shears</code>)). The specifications for the <code class=\"var\">trs</code> and\n<code class=\"var\">xyz</code> parameters can be found in <code>$HFS/houdini/vex/include/math.h</code>.  For example, XFORM_SRT will do the trs order Scale, Rotate, Translate; and XFORM_XYZ will do the xyz rotation order X, Y, Z.</p><p><code>maketransform(int xyz, vector angles)</code> builds a 3\u00d73 rotation matrix\nusing the same rules as <code>maketransform(int trs, ...)</code> but only using\nthe rotation parameters.</p><p><code>maketransform(vector zaxis, yaxis, ...)</code> builds either a 3\u00d73 transform\nmatrix or a 4\u00d74 transform matrix. The matrix will be constructed so that the \nz-axis will be transformed to the z-axis specified with the given up vector \n(yaxis). Thus, maketransform({0,0,1}, {0,1,0}) will result in an identity \nmatrix. The version which returns a 4\u00d74 transform will apply the translation \nto the 4\u00d74 matrix. This function is very similar to the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lookat\">lookat</a> \nfunction. The vectors passed in are <em>not</em> normalized meaning that scales \nshould be preserved in construction of the transform.</p><h2>Note</h2><p>Unlike most VEX functions, this function expects rotations \n    in <em>degrees</em>, not radians.</p></body>",
    "makevalidvarname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/makevalidvarname\">makevalidvarname</a></h1><span class=\"padder\"><span class=\"pillow\">19.5</span></span><p class=\"summary\">Forces a string to conform to the rules for variable names.</p><div class=\"usage\"> <code>string makevalidvarname(string name)</code></div><div class=\"usage\"> <code>string makevalidvarname(string name; string safe_chars)</code></div><p>Variable names in languages such as VEX are only allowed to contain letters, numbers, and underscores, and must not begin with a number.\nNode names and attribute names in Houdini have similar requirements.\nThis function takes any string, and converts it into a string that obeys these restrictions by replacing invalid characters with an underscore.</p><div class=\"argument\"><code>name</code></div><p>String that should be turned into a valid variable name.</p><div class=\"argument\"><code>safe_chars</code></div><p>String specifying any extra characters to allow instead of replacing with underscores.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Returns \"foo_bar\"</code><code class=\"codeline\">string s = makevalidvarname(\"foo:bar\");</code><code class=\"codeline\"></code><code class=\"codeline\">// Returns \"_123\"</code><code class=\"codeline\">s = makevalidvarname(\"123\");</code><code class=\"codeline\"></code><code class=\"codeline\">// Returns \"foo:_bar\"</code><code class=\"codeline\">s = makevalidvarname(\"foo:?bar\", \":\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/encode\">encode</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/decode\">decode</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/hom/hou/text#variableName\">hou.text#variableName</a></div></body>",
    "maskname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/maskname\">maskname</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the default name of the mask plane (as it appears in the\ncompositor preferences).</p><div class=\"usage\"> <code>string maskname()</code></div><p>Returns the default name of the mask plane (as it appears in the\ncompositor preferences). Using this instead of hardcoding the default\nmakes your code more portable. Default is M.</p></body>",
    "mask_bsdf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/mask_bsdf\">mask_bsdf</a></h1><p class=\"summary\">Returns new BSDF that only includes the components specified by the mask.</p><div class=\"usage\"> <code>bsdf mask_bsdf(bsdf b, int mask)</code></div><div class=\"argument\"><code>b</code></div><p>BSDF to mask.</p><div class=\"argument\"><code>mask</code></div><p>A bitmask indicating which types of shading component bounces to evaluate.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// outF will have every component from inF except refraction</code><code class=\"codeline\">bsdf outF = mask_bsdf(inF, PBR_ALL_MASK &amp; ~PBR_REFRACT_MASK);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/albedo\">albedo</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/eval_bsdf\">eval_bsdf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_bsdf\">sample_bsdf</a></div></body>",
    "match": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/match\">match</a></h1><p class=\"summary\">This function returns 1 if the subject matches the pattern specified,\nor 0 if the subject doesn\u2019t match.</p><div class=\"usage\"> <code>int match(string pattern, string subject)</code></div><p>This function returns 1 if the subject matches the pattern specified, or\n0 if the subject doesn\u2019t match. The standard Houdini pattern matching is\nused. Multiple patterns may be separated by spaces or commas. The\nspecial characters for matching are:</p><div class=\"related\"><code>?</code> Match any character</div><div class=\"related\"><code>*</code> Match any substring</div><div class=\"related\"><code>[list]</code> Match any of the characters specified in the list.</div><div class=\"related\">If a pattern is prefixed by a caret (^), then subjects which match\nthis pattern will be excluded from the match.</div><p>Examples:</p><div class=\"related\"><code>a*</code> - Match any string beginning with a.</div><div class=\"related\"><code>a*,^aardvark</code> - Match any string beginning with a except for\naardvark.</div><div class=\"related\"><code>[abc]*z</code> - Match any string beginning with a, b or c and ending with\nz.</div><div class=\"related\"><code>g*,^geo*</code> - Match any string beginning with g, but not any string\nbeginning with geo.</div></body>",
    "matchvex_blinn": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/matchvex_blinn\">matchvex_blinn</a></h1><p class=\"summary\">Returns a BSDF that matches the output of the traditional VEX blinn function.</p><div class=\"usage\"> <code>bsdf matchvex_blinn(float exponent, ...)</code></div><div class=\"usage\"> <code>bsdf matchvex_blinn(vector nml, float exponent, ...)</code></div><p><a href=\"https://www.sidefx.com/docs/houdini/images/rendering/matchvex_blinn.png\">/images/rendering/matchvex_blinn.png</a></p><p>The BSDF produced by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/blinn\">blinn</a> is not the same as the traditional VEX \n<code>blinn()</code> output. Use this function to produce a closer approximate match to \nthe traditional VEX <code>blinn()</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/blinn\">blinn</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "matchvex_specular": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/matchvex_specular\">matchvex_specular</a></h1><p class=\"summary\">Returns a BSDF that matches the output of the traditional VEX specular function.</p><div class=\"usage\"> <code>bsdf matchvex_specular(float exponent, ...)</code></div><div class=\"usage\"> <code>bsdf matchvex_specular(vector nml, float exponent, ...)</code></div><p><a href=\"https://www.sidefx.com/docs/houdini/images/rendering/matchvex_specular.png\">/images/rendering/matchvex_specular.png</a></p><p>The BSDF produced by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/specular\">specular</a> is not the same as the traditional VEX <code>specular()</code> output. Use this function to produce a closer approximate match to the traditional VEX <code>specular()</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/specular\">specular</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "mattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/mattrib\">mattrib</a></h1><span class=\"padder\"><span class=\"pillow\">image3d</span></span><p class=\"summary\">Returns the value of the point attribute for the metaballs if\nmetaball geometry is specified to i3dgen.</p><div class=\"usage\"> <code>&lt;type&gt; mattrib(string name, vector P)</code></div><h2>Note</h2><p>The <code>image3d</code> context is deprecated. Use volumes instead. </p></body>",
    "max": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/max\">max</a></h1><div class=\"usage\"> <code>int max(int value1, int value2, ...)</code></div><div class=\"usage\"> <code>float max(float value1, float value2, ...)</code></div><p>Returns the maximum value of the arguments.</p><div class=\"usage\"> <code>&lt;vector&gt; max(&lt;vector&gt; value1, &lt;vector&gt; value2, ...)</code></div><p>Returns a vector where each component is the maximum of the corresponding components in the arguments.</p><div class=\"usage\"> <code>&lt;type&gt; max(&lt;type&gt; values[])</code></div><p>Returns the maximum value in the array.</p><div class=\"usage\"> <code>float max(&lt;vector&gt; values)</code></div><p>Returns the maximum of the vector\u2019s components.</p><div class=\"usage\"> <code>&lt;type&gt; max(&lt;type&gt; value)</code></div><p>Returns the argument.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/min\">min</a></div></body>",
    "mdensity": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/mdensity\">mdensity</a></h1><span class=\"padder\"><span class=\"pillow\">image3d</span></span><p class=\"summary\">Returns the density of the metaball field if metaball geometry is\nspecified to i3dgen.</p><div class=\"usage\"> <code>float mdensity(vector P)</code></div><p>Returns the density of the metaball field if metaball geometry is\nspecified to i3dgen.</p></body>",
    "metadata": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/metadata\">metadata</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns a metadata value from a composite operator.</p><div class=\"usage\"> <code>&lt;type&gt; metadata(int opinput, string name)</code></div><div class=\"usage\"> <code>float|int metadata(int opinput, string name, int index)</code></div><p>Returns the metadata value associated with metadata <code>name</code>, or zero if the \nmetadata doesn\u2019t exist, the input isn\u2019t connected, or the index is out of range\n(identity matrices for the matrix versions).</p><div class=\"argument\"><code>name</code></div><p>The name of the metadata to fetch.</p><div class=\"argument\"><code>index</code></div><p>For compound data types, this indicates the component of the\n   vector/matrix, or which item of the array, to fetch.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasmetadata\">hasmetadata</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cinput\">cinput</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/binput\">binput</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/finput\">finput</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ninput\">ninput</a></div></body>",
    "metaimport": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/metaimport\">metaimport</a></h1><p class=\"summary\">Once you get a handle to a metaball using metastart and metanext, you\ncan query attributes of the metaball with metaimport.</p><div class=\"usage\"> <code>int metaimport(int handle, string attrib, vector P, &lt;type&gt; &amp;value)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] metaimport(string file, string attribute; vector P)</code></div><p>Rather than iterating over all the values, this form imports the values from all metaballs simultaneously. As with the scalar form, you can use the keywords\u2026</p><div class=\"related\"><code>meta:density</code></div><div class=\"related\"><code>meta:prim</code></div><div class=\"related\"><code>meta:transform</code></div><p>\u2026to import non-attribute information from the metaballs.</p><p>Once you get a handle to a metaball using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/metastart\">metastart</a> and\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/metanext\">metanext</a>, you can query attributes of the metaball with\n<code>metaimport</code>.</p><p>There are three special attributes you can query:</p><p><code>float meta:density</code> :\nThe density of the current metaball</p><p><code>float meta:prim</code> :\nThe primitive number of the current metaball</p><p><code>matrix meta:transform</code> :\nThe transform associated with the current metaball. Applying the\ninverse of this transform will transform a point into the space of\nthe metaball.</p><p>For example, the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/metaweight\">metaweight</a> function can be expressed in the following\nway:</p><div class=\"codeblock\"><code class=\"codeline\">float</code><code class=\"codeline\">metaweight(string file; vector P)</code><code class=\"codeline\">{</code><code class=\"codeline\">int        handle;</code><code class=\"codeline\">float    density, tmp;</code><code class=\"codeline\"></code><code class=\"codeline\">density = 0;</code><code class=\"codeline\">handle = metastart(file, P);</code><code class=\"codeline\">while (metanext(handle))</code><code class=\"codeline\">{</code><code class=\"codeline\">if (metaimport(handle, \"meta:density\", P, tmp))</code><code class=\"codeline\">density += tmp;</code><code class=\"codeline\">}</code><code class=\"codeline\">return density;</code><code class=\"codeline\">}</code></div><p>The attributes evaluated are un-premultiplied by the weight of the\nmetaball at the position and must be multiplied for blending. For\nexample, to evaluate a vector attribute (say color) on metaballs, the\nfollowing function could be used:</p><div class=\"codeblock\"><code class=\"codeline\">vector</code><code class=\"codeline\">meta_attribute(string file, attrib_name; vector P)</code><code class=\"codeline\">{</code><code class=\"codeline\">int        handle;</code><code class=\"codeline\">vector    result, tmp;</code><code class=\"codeline\">float    density;</code><code class=\"codeline\"></code><code class=\"codeline\">handle = metastart(file, P);</code><code class=\"codeline\">result = 0;</code><code class=\"codeline\">while (metanext(handle))</code><code class=\"codeline\">{</code><code class=\"codeline\">if (metaimport(handle, \"meta:density\", P, density))</code><code class=\"codeline\">{</code><code class=\"codeline\">if (metaimport(handle, attrib_name, P, tmp))</code><code class=\"codeline\">result += density * tmp;</code><code class=\"codeline\">}</code><code class=\"codeline\">return result;</code><code class=\"codeline\">}</code></div><p>In the i3d context, there is a default metaball geometry (specified\nby the <code>-g</code> option on the command line to the i3dgen program). If the\nfilename is an empty string, the default geometry will be used.</p></body>",
    "metamarch": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/metamarch\">metamarch</a></h1><p class=\"summary\">Takes the ray defined by p0 and p1 and partitions it into zero or\nmore sub-intervals where each interval intersects a cluster of metaballs\nfrom filename.</p><div class=\"usage\"> <code>int metamarch(int &amp;index, string filename, vector &amp;p0, vector &amp;p1, float displace_bound)</code></div><p>Takes the ray defined by <code class=\"var\">p0</code> and <code class=\"var\">p1</code> and partitions it into zero\nor more sub-intervals where each interval intersects a cluster of\nmetaballs from <code class=\"var\">filename</code>. The interval may not actually intersect any\nmetaballs, but will provide fairly tight bounds on the cluster.</p><p>This allows a ray-marching algorithm to skip uninteresting areas and\nonly focus on marching through areas where metaballs might be found.</p><p>The first time you call the function, use <code class=\"var\">index</code>=-1 and set <code class=\"var\">p0</code>\nand <code class=\"var\">p1</code> to the endpoints of the ray. If the function finds an\ninterval, it returns 1 and sets <code class=\"var\">p0</code> and <code class=\"var\">p1</code> to the endpoints of\nthe interval and increments <code class=\"var\">index</code>. Otherwise it returns 0 and\ndoesn\u2019t alter the arguments.</p><p>So, you can repeatedly call the function with variables for the\n<code class=\"var\">index</code>, <code class=\"var\">index</code>, and <code class=\"var\">index</code> arguments to ray-march through areas\nof interest, skipping the dead space:</p><div class=\"codeblock\"><code class=\"codeline\">int    index;</code><code class=\"codeline\">vector    p0, p1;</code><code class=\"codeline\">// Initialize input values</code><code class=\"codeline\">index = -1;</code><code class=\"codeline\">p0 = Eye; p1 = P;</code><code class=\"codeline\">result = 0;</code><code class=\"codeline\">while (metamarch(index, metaball_file, p0, p1, displace_bound))</code><code class=\"codeline\">{</code><code class=\"codeline\">result += ray_march(metaball_file, p0, p1);</code><code class=\"codeline\">}</code></div></body>",
    "metanext": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/metanext\">metanext</a></h1><p class=\"summary\">Iterate to the next metaball in the list of metaballs returned by the <code>metastart()</code> function.</p><div class=\"usage\"> <code>int metanext(int handle)</code></div><p>This iterates through the list of metaballs returned by <code>metastart()</code>.  The function returns <code>0</code> if there are no further metaballs in selected by <code>metastart()</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/metastart\">metastart</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/metadata\">metadata</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/metaimport\">metaimport</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/metamarch\">metamarch</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/metaweight\">metaweight</a></div></body>",
    "metastart": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/metastart\">metastart</a></h1><p class=\"summary\">Open a geometry file and return a handle for the metaballs of\ninterest, at the position p.</p><div class=\"usage\"> <code>int metastart(string filename, vector p)</code></div><p>Open a geometry file and return a handle for the metaballs of\ninterest, at the position <code class=\"var\">p</code>. You can then use\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/metanext\">metanext</a> to move the handle to the next metaball for\nevaluation, and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/metaimport\">metaimport</a> to query attributes of the\nmetaball.</p></body>",
    "metaweight": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/metaweight\">metaweight</a></h1><p class=\"summary\">Returns the metaweight of the geometry at position p.</p><div class=\"usage\"> <code>float metaweight(&lt;geometry&gt;, vector p)</code></div><p>Returns the metaweight of the geometry at position <code class=\"var\">p</code>.\nThis is the result of evaluating all the metaballs in the\ngeometry at that position.  Usually this is the sum of their\nvalues, but meta expressions can change that.</p></body>",
    "min": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/min\">min</a></h1><div class=\"usage\"> <code>int min(int value1, int value2, ...)</code></div><div class=\"usage\"> <code>float min(float value1, float value2, ...)</code></div><p>Returns the minimum of the arguments.</p><div class=\"usage\"> <code>&lt;vector&gt; min(&lt;vector&gt; value1, &lt;vector&gt; value2, ...)</code></div><p>Returns a vector where each component is the minimum of the corresponding components in the arguments.</p><div class=\"usage\"> <code>&lt;type&gt; min(&lt;type&gt; values[])</code></div><p>Returns the minimum value in the array.</p><div class=\"usage\"> <code>float min(&lt;vector&gt; v)</code></div><p>Returns the minimum of the vector\u2019s components.</p><div class=\"usage\"> <code>&lt;type&gt; min(&lt;type&gt; value)</code></div><p>Returns the argument.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/max\">max</a></div></body>",
    "minpos": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/minpos\">minpos</a></h1><p class=\"summary\">Finds the closest position on the surface of a geometry.</p><div class=\"usage\"> <code>vector minpos(&lt;geometry&gt;, vector point)</code></div><p>Returns the position of the closest point in the given geometry to the point.</p><div class=\"usage\"> <code>vector minpos(&lt;geometry&gt;, vector point, float maxdist)</code></div><p>Returns the position of the closest point in the given geometry to the point,\n    within the <code class=\"var\">maxdist</code> radius.</p><div class=\"usage\"> <code>vector minpos(&lt;geometry&gt;, string primgroup, vector point)</code></div><p>Returns the position of the closest point in the given geometry to the point,\n    limiting the search to primitives in the named group.</p><div class=\"usage\"> <code>vector minpos(&lt;geometry&gt;, string primgroup, vector point, float maxdist)</code></div><p>Returns the position of the closest point in the given geometry to the point,\n    limiting the search to primitives in the named group and to the <code class=\"var\">maxdist</code> radius.</p><div class=\"argument\"><code>primgroup</code></div><p>If specified, only report points on \n    You can also use group specification syntax like <code>@Cd.x&gt;0</code>,\n    but note that the <code>@</code> may need to be escaped with a backslash in a Wrangle snippet.\n    An empty string matches all primitives.</p><div class=\"argument\"><code>point</code></div><p>The point in world space to start looking for the closest point on the geometry.</p><div class=\"argument\"><code>maxdist</code></div><p>The maximum distance to search. Specifying this can speed up the function since it may allow quitting the search early.</p><h2>Returns</h2><p>The position of the nearest point on the geometry, or <code class=\"var\">point</code> if no nearest point was found.</p></body>",
    "mspace": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/mspace\">mspace</a></h1><span class=\"padder\"><span class=\"pillow\">image3d</span></span><p class=\"summary\">Transforms the position specified into the local space of the\nmetaball.</p><div class=\"usage\"> <code>vector mspace(vector P)</code></div><p>Transforms the position specified into the local space of the\nmetaball. This function is only valid inside the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/forpoints\">forpoints</a> loop\nconstruct.</p><p>An example use of this function would be to compute noise based on a\nrest position\u2026 For example:</p><div class=\"codeblock\"><code class=\"codeline\">forpoints(P) {</code><code class=\"codeline\">vector npos = mspace(P) - mattrib(\"rest\", P);</code><code class=\"codeline\">nval += noise(npos);</code><code class=\"codeline\">}</code></div></body>",
    "mwnoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/mwnoise\">mwnoise</a></h1><p class=\"summary\">Generates Worley (cellular) noise using a Manhattan distance metric.</p><div class=\"usage\"> <code>void mwnoise( float position; int &amp;seed; float &amp;f1; float &amp;f2 )</code></div><div class=\"usage\"> <code>void mwnoise( float position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4 )</code></div><p>Generates 1D noise.</p><div class=\"usage\"> <code>void mwnoise( float position; int &amp;seed; float &amp;f1; float &amp;f2; int peiod)</code></div><div class=\"usage\"> <code>void mwnoise( float position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f4; float &amp;f4; int period)</code></div><p>Generates periodic 1D noise.</p><div class=\"usage\"> <code>void mwnoise( float posx; float posy; int &amp;seed; float &amp;f1; float &amp;f2 )</code></div><div class=\"usage\"> <code>void mwnoise( float posx; float posy; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4 )</code></div><p>Generates 2D noise. This is similar to the other forms but uses pairs of floats instead of a vector.</p><div class=\"usage\"> <code>void mwnoise( float posx; float posy; int &amp;seed; float &amp;f1; float &amp;f2; int periodx; int periody )</code></div><div class=\"usage\"> <code>void mwnoise( float posx; float posy; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4; int periodx; int periody)</code></div><p>Generates periodic 2D noise.</p><div class=\"usage\"> <code>void mwnoise( vector2 position; int &amp;seed; float &amp;f1; float &amp;f2 )</code></div><div class=\"usage\"> <code>void mwnoise( vector2 position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4 )</code></div><p>Generates 2D noise.</p><div class=\"usage\"> <code>void mwnoise( vector2 position; int &amp;seed; float &amp;f1; float &amp;f2; int periodx; int periody )</code></div><div class=\"usage\"> <code>void mwnoise( vector2 position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4; int periodx; int periody)</code></div><p>Generates periodic 2D noise.</p><div class=\"usage\"> <code>void mwnoise( vector position; int &amp;seed; float &amp;f1; float &amp;f2 )</code></div><div class=\"usage\"> <code>void mwnoise( vector position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4 )</code></div><p>Generates 3D noise.</p><div class=\"usage\"> <code>void mwnoise( vector position; int &amp;seed; float &amp;f1; float &amp;f2; int periodx; int periody; int periodx )</code></div><div class=\"usage\"> <code>void mwnoise( vector position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4; int periodx; int periody; int periodz )</code></div><p>Generates periodic 3D noise.</p><div class=\"usage\"> <code>void mwnoise( vector4 position; int &amp;seed; float &amp;f1; float &amp;f2 )</code></div><div class=\"usage\"> <code>void mwnoise( vector4 position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4 )</code></div><p>Generates 4D noise.</p><div class=\"usage\"> <code>void mwnoise( vector4 position; int &amp;seed; float &amp;f1; float &amp;f2; int periodx; int periody; int periodz; int periodw )</code></div><div class=\"usage\"> <code>void mwnoise( vector4 position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4; int periodx; int periody; int periodz; int periodw )</code></div><p>Generates periodic 4D noise.</p><div class=\"argument\"><code>position</code></div><p>The position at which to sample the noise.</p><div class=\"argument\"><code>seed</code></div><p>Outputs an integer value associated with the nearest seed point. This seed is pretty much guaranteed to be unique for every point (meaning that it\u2019s unlikely that two points close by have the same seed associated with them).</p><div class=\"argument\"><code><code>f1</code>, <code>f2</code>, <code>f3</code>, <code>f4</code></code></div><p>These variables are overwritten with the distances to the nearest seed points, in order of closeness.</p><p>You can combine these distances to generate noise patterns. The noise generated tends to be very cellular in nature. In fact, one of the nice things is that you can determine cell boundaries by using the expression: <code>if (f2 - f1)</code> which will be true if the point in space is crossing the boundary between two cells.</p><div class=\"argument\"><code><code>period</code>, <code>periodx</code>, <code>periody</code>, <code>periodz</code>, <code>periodw</code></code></div><p>If you include the period argument(s), the function generates repeating (periodic) noise.</p><p>Worley noise scatters seed points randomly through space (according to a nice Poisson distribution). The functions outputs the distances to the 2 (or 4) seed points nearest to the sample position.</p><h2>Related</h2></body>",
    "mx_cellnoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/mx_cellnoise\">mx_cellnoise</a></h1><p class=\"summary\">MaterialX compatible cellnoise</p><div class=\"usage\"> <code>float mx_cellnoise(float pos)</code></div><div class=\"usage\"> <code>float mx_cellnoise(vector2 pos)</code></div><div class=\"usage\"> <code>float mx_cellnoise(vector pos)</code></div><div class=\"usage\"> <code>float mx_cellnoise(vector4 pos)</code></div><div class=\"usage\"> <code>vector mx_cellnoise(float pos)</code></div><div class=\"usage\"> <code>vector mx_cellnoise(vector2 pos)</code></div><div class=\"usage\"> <code>vector mx_cellnoise(vector pos)</code></div><div class=\"usage\"> <code>vector mx_cellnoise(vector4 pos)</code></div><p>Returns a random number between 0 and 1.  This function will produce the same values as the standard MaterialX library.</p></body>",
    "mx_perlin": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/mx_perlin\">mx_perlin</a></h1><p class=\"summary\">MaterialX compatible Perlin noise</p><div class=\"usage\"> <code>float|vector mx_perlin(vector2 pos)</code></div><div class=\"usage\"> <code>float|vector mx_perlin(vector pos)</code></div><p>Returns a noise value that matches the values as in the standard MaterialX library.</p></body>",
    "mx_voronoi": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/mx_voronoi\">mx_voronoi</a></h1><p class=\"summary\">MaterialX compatible Voronoi noise</p><p>Generates 2D noise.</p><div class=\"usage\">  <code>void mx_voronoi( vector2 position, float jitter, int metric, float &amp;d1, float &amp;d2, float &amp;d3, vector2 &amp;p1, vector2 &amp;p2, vector2 &amp;p3)</code></div><div class=\"usage\">  <code>void mx_voronoi( vector2 position, float jitter, int metric, float &amp;d1, float &amp;d2, vector2 &amp;p1, vector2 &amp;p2)</code></div><div class=\"usage\">  <code>void mx_voronoi( vector2 position, float jitter, int metric, float &amp;d1, vector2 &amp;p1)</code></div><p>Generates 3D noise.</p><div class=\"usage\">  <code>void mx_voronoi( vector position, float jitter, int metric, float &amp;d1, float &amp;d2, float &amp;d3, vector &amp;p1, vector &amp;p2, vector &amp;p3)</code></div><div class=\"usage\">  <code>void mx_voronoi( vector position, float jitter, int metric, float &amp;d1, float &amp;d2, vector &amp;p1, vector &amp;p2)</code></div><div class=\"usage\">  <code>void mx_voronoi( vector position, float jitter, int metric, float &amp;d1, vector &amp;p1)</code></div><p>Returns a Voronoi Noise values of distances which are similar to Worley noise, but has additional outputs of cells positions.\n    There is no analogue of this noise in the standard MaterialX library yet.</p><div class=\"argument\"><code>position</code></div><p>The position at which to sample the noise.</p><div class=\"argument\"><code>jitter</code></div><p>The jitter should normally be clamped between 0 and 1.</p><div class=\"argument\"><code>metric</code></div><div class=\"argument\"><code>The metric is an integer representing how the distance is measured for Worley noise</code></div><div class=\"related\">0 - Euclidean Distance</div><div class=\"related\">1 - Distance Squared</div><div class=\"related\">2 - Manhattan Distance</div><div class=\"related\">3 - Chebyshev Distance</div><div class=\"argument\"><code><code>d1</code>, <code>d2</code>, <code>d3</code></code></div><p>These variables are overwritten with the distances to the nearest cell points, in order of closeness.</p><div class=\"argument\"><code><code>p1</code>, <code>p2</code>, <code>p3</code></code></div><p>These variables are overwritten with the cell positions, in order of closeness to the input position.</p></body>",
    "mx_worley": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/mx_worley\">mx_worley</a></h1><p class=\"summary\">MaterialX compatible Worley noise</p><div class=\"usage\"> <code>float|vector2|vector mx_worley(vector2 pos, float jitter, int metric)</code></div><div class=\"usage\"> <code>float|vector2|vector mx_worley(vector pos, float jitter, int metric)</code></div><p>Returns a Worley Noise value that matches the values as in the standard MaterialX library.</p><p>Jitter should normally be clamped between 0 and 1.</p><div class=\"argument\"><code>The metric is an integer representing how the distance is measured for Worley noise</code></div><div class=\"related\">0 - Euclidean Distance</div><div class=\"related\">1 - Distance Squared</div><div class=\"related\">2 - Manhattan Distance</div><div class=\"related\">3 - Chebyshev Distance</div></body>",
    "nametopoint": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nametopoint\">nametopoint</a></h1><p class=\"summary\">Finds a point by its name attribute.</p><div class=\"usage\"> <code>int nametopoint(&lt;geometry&gt;, string name)</code></div><h2>Returns</h2><p>The number of the point with the given value in the <code>name</code> attribute. Returns <code>-1</code> if no primitive has the given ID, or if the geometry has no <code>name</code> attribute.</p><p>To look up a primitive by its <code>id</code> attribute value, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/idtoprim\">idtoprim</a>. To look up a point by an arbitrary string or int attribute value, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/findattribval\">findattribval</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/idtoprim\">idtoprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nametopoint\">nametopoint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/findattribval\">findattribval</a></div></body>",
    "nametoprim": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nametoprim\">nametoprim</a></h1><p class=\"summary\">Finds a primitive by its name attribute.</p><div class=\"usage\"> <code>int nametoprim(&lt;geometry&gt;, string name)</code></div><h2>Returns</h2><p>The number of the point with the given value in the <code>name</code> attribute. Returns <code>-1</code> if no point has the given ID, or if the geometry has no <code>name</code> attribute.</p><p>To look up a point by its <code>id</code> attribute value, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/idtopoint\">idtopoint</a>. To look up a point by an arbitrary string or int attribute value, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/findattribval\">findattribval</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/idtopoint\">idtopoint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nametoprim\">nametoprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/findattribval\">findattribval</a></div></body>",
    "nbouncetypes": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nbouncetypes\">nbouncetypes</a></h1><div class=\"usage\"> <code>int nbouncetypes()</code></div><p>Return the number of different bounce types supported by the renderer.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/bouncemask\">bouncemask</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbounces\">getbounces</a></div></body>",
    "ndcdepth": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ndcdepth\">ndcdepth</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the camera space z-depth of the NDC z-depth value.</p><div class=\"usage\"><code>float ndcdepth(float z)</code></div><p>When Karma converts a position to NDC space, the z depth value is</p><p>transformed based on the render camera projection and clipping planes.  This\nfunction converts the NDC z-depth into the camera space.  That is, the distance\ndown the z-axis in the space of the camera.</p><p>This function is only meaningful in Karma.  In all other cases, the</p><p>function returns the argument passed in.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">vector ndc = ptransform(\"space:ndc\", P);</code><code class=\"codeline\">float pz_camera = ndcspace(ndc.z);</code><code class=\"codeline\"></code><code class=\"codeline\">// This value can also be computed using</code><code class=\"codeline\">float pz_camera = -ptransform(\"space:camera\", P).z;</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a></div></body>",
    "nearpoint": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoint\">nearpoint</a></h1><p class=\"summary\">Finds the closest point in a geometry.</p><div class=\"usage\"> <code>int nearpoint(&lt;geometry&gt;, vector pt)</code></div><div class=\"usage\"> <code>int nearpoint(&lt;geometry&gt;, vector pt, float maxdist)</code></div><div class=\"usage\"> <code>int nearpoint(&lt;geometry&gt;, string ptgroup, vector pt)</code></div><div class=\"usage\"> <code>int nearpoint(&lt;geometry&gt;, string ptgroup, vector pt, float maxdist)</code></div><p>Returns the number of the closest point on the geometry.\nThis will only search against points, not the surface locations\nof the geometry.  Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xyzdist\">xyzdist</a> to find the closest point on surfaces or curves.</p><p>-1 is returned if no point is found in the search distance.</p><div class=\"argument\"><code>ptgroup</code></div><p>A point group pattern to limit the search to.  Can be a SOP-style group\n  pattern such as <code>0-10</code> or <code>@Cd.x&gt;0.5</code>.  An empty string will match all points.</p><div class=\"argument\"><code>pt</code></div><p>The position in space to find the closest point on the geometry to.</p><div class=\"argument\"><code>maxdist</code></div><p>The maximum distance to search.  The operation can be sped up if it\n  is allowed to quit early.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoints\">nearpoints</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind\">pcfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind_radius\">pcfind_radius</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pgfind\">pgfind</a></div></body>",
    "nearpoints": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoints\">nearpoints</a></h1><p class=\"summary\">Finds the all the closest point in a geometry.</p><div class=\"usage\"> <code>int[] nearpoints(&lt;geometry&gt;, vector pt, float maxdist)</code></div><div class=\"usage\"> <code>int[] nearpoints(&lt;geometry&gt;, vector pt, float maxdist, int maxpts)</code></div><div class=\"usage\"> <code>int[] nearpoints(&lt;geometry&gt;, string ptgroup, vector pt, float maxdist)</code></div><div class=\"usage\"> <code>int[] nearpoints(&lt;geometry&gt;, string ptgroup, vector pt, float maxdist, int maxpts)</code></div><div class=\"argument\"><code>opinput</code></div><p>The number of the input to the current node, starting with <code>0</code> being the first input.</p><div class=\"argument\"><code>geometry</code></div><p>The name of the geometry file to reference.  Inside Houdini,\n    this may be op:full_path_to_sop to reference a SOP.</p><div class=\"argument\"><code>ptgroup</code></div><p>A point group pattern to limit the search to.  Can be a SOP-style group\n    pattern such as <code>0-10</code> or <code>@Cd.x&gt;0.5</code>.  An empty string will match\n    all points.</p><div class=\"argument\"><code>pt</code></div><p>The position in space to find the closest point on the geometry to.</p><div class=\"argument\"><code>maxdist</code></div><p>The maximum distance to search.</p><div class=\"argument\"><code>maxpts</code></div><p>The maximum number of points to find.</p><h2>Returns</h2><p>An array of point numbers\n    This will only search against points, not the surface locations of the geometry.\n    Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xyzdist\">xyzdist</a> to find the closest point on surfaces or curves.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoint\">nearpoint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind\">pcfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind_radius\">pcfind_radius</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pgfind\">pgfind</a></div></body>",
    "nedgesgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nedgesgroup\">nedgesgroup</a></h1><p class=\"summary\">Returns the number of edges in the group.</p><div class=\"usage\"> <code>int nedgesgroup(string filename, string groupname)</code></div><div class=\"usage\"> <code>int nedgesgroup(int input, string groupname)</code></div><p>Returns the number of edges in the specified group in the input or geometry file.</p><p>This must refer to an exact group name, not an adhoc group pattern.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/expandedgegroup\">expandedgegroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/inedgegroup\">inedgegroup</a></div></body>",
    "neighbour": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/neighbour\">neighbour</a></h1><p class=\"summary\">Returns the point number of the next point connected to a given point.</p><p>This function lets you walk the points connected to a point (separated by a single edge). To get a list of all connected points at once, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/neighbours\">neighbours</a>.</p><div class=\"usage\"> <code>int neighbour(&lt;geometry&gt;, int point_num, int neighbour_num)</code></div><div class=\"argument\"><code>point_num</code></div><p>The number of the point whose neighbours you want to find.</p><div class=\"argument\"><code>neighbour_num</code></div><p>Which neighbour to find. The neighbours are in no particular order. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/neighbourcount\">neighbourcount</a> to get the total number of connected points.</p><h2>Returns</h2><p>The point index of the neighbour of the point. The order is undefined, but will be consistent for consistent geometry. Returns <code>-1</code> if the <code>neighbournum</code> is out of range for that point, or the point is out of range for that input, or the input doesn\u2019t exist.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/neighbourcount\">neighbourcount</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/neighbours\">neighbours</a></div></body>",
    "neighbourcount": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/neighbourcount\">neighbourcount</a></h1><p class=\"summary\">Returns the number of points that are connected to the specified point.</p><div class=\"usage\"> <code>int neighbourcount(&lt;geometry&gt;, int point_num)</code></div><div class=\"argument\"><code>point_num</code></div><p>The number of the point whose neighbours you want to count.</p><h2>Returns</h2><p>The number of points that are connected to the specified point.\n    A point is connected if it is adjacent in some polygon, is one of the\n    four surrounding points in a grid or NURBs surface, or in some other\n    manner directly shares an edge with <code>point_num</code>. Returns 0 if there\n    is no input, or if the point number is out of range.</p></body>",
    "neighbours": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/neighbours\">neighbours</a></h1><p class=\"summary\">Returns an array of the point numbers of the neighbours of a point.</p><div class=\"usage\"> <code>int[] neighbours(&lt;geometry&gt;, int ptnum)</code></div><p>This is a simpler, array-based replacement for the combination of\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/neighbourcount\">neighbourcount</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/neighbour\">neighbour</a>.  The array contains the numbers\nof all points that share an edge with <code>ptnum</code>.  The point numbers are in no particular order.</p><h2>Examples</h2><p>This is roughly equivalent to the following code:</p><div class=\"codeblock\"><code class=\"codeline\">int []</code><code class=\"codeline\">neighbours(int opinput, int ptnum)</code><code class=\"codeline\">{</code><code class=\"codeline\">    int     i, n;</code><code class=\"codeline\">    int     result[];</code><code class=\"codeline\">    n = neighbourcount(input, ptnum);</code><code class=\"codeline\">    resize(result, n);</code><code class=\"codeline\">    for (i = 0; i &lt; n; i++)</code><code class=\"codeline\">        result[i] = neighbour(input, ptnum, i);</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/neighbourcount\">neighbourcount</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/neighbour\">neighbour</a></div></body>",
    "newgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/newgroup\">newgroup</a></h1><span class=\"padder\"><span class=\"pillow\">sop</span></span><h2>Warning</h2><p>This function has been deprecated. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addattrib\">addattrib</a> instead.</p></body>",
    "newsampler": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/newsampler\">newsampler</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Initializes a sampling sequence for the nextsample function.</p><div class=\"usage\"> <code>int newsampler(...)</code></div><div class=\"usage\"> <code>int newsampler(int seed, ...)</code></div><p>Returns an initialized sampler sequence for use as the first argument\n    to the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nextsample\">nextsample</a> function.</p><div class=\"argument\"><code>seed</code></div><p>You can specify a seed value for the sequence.\n    Using the same seed will generate the same sequence.\n    This can be useful when random sampling into a point cloud, for consistent results.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nextsample\">nextsample</a></div></body>",
    "nextsample": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nextsample\">nextsample</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><div class=\"usage\"> <code>void nextsample(int &amp;sid, float &amp;sx, float &amp;sy, ...)</code></div><div class=\"usage\"> <code>void nextsample(int &amp;sid, vector &amp;svec, ...)</code></div><p><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/newsampler\">newsampler</a> and this function expose the high-quality deterministic sampling patterns used by mantra for pixel anti-aliasing. When rendering in raytracing mode, it\u2019s possible to generate deterministic 2D samples with <code>nextsample</code> routine by initializing the sampling sequence with the <code>SID</code> global variable.</p><p>This method can generate either 2D or 3D sampling patterns.  To generate 2D samples, use the signature with 2 float write-only arguments.  To generate 3D samples, use the signature with a vector write-only argument.</p><p>You can add an extra argument, <code>\"mode\"</code>, followed by one of the following:</p><div class=\"argument\"><code>qstrat</code></div><p>Advances to the next sample in the pattern. You should use this mode when using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/newsampler\">newsampler</a>.</p><div class=\"argument\"><code>nextpixel</code></div><p>Advances to a new pixel sampling pattern. You should use this mode when using SID with raytracing to generate good-quality sampling patterns within a pixel. This mode takes into account other samples within the current pixel and will appropriately stratify itself.  If rendering with micropolygon rendering, nextpixel will behave the same as qstrat.</p><div class=\"argument\"><code>decorrelate</code></div><p>Advances to a new decorrelated sample. You should use this mode to deterministically generate a new sampling sequence that is unrelated to an existing sequence. Similarly to nextpixel, this mode preserves high-quality pixel sampling when used with SID and raytracing.</p><div class=\"codeblock\"><code class=\"codeline\">int nsamples = 10;</code><code class=\"codeline\">int sid = israytrace ? SID : newsampler();</code><code class=\"codeline\"></code><code class=\"codeline\">for (i = 0; i &lt; nsamples; i++)</code><code class=\"codeline\">{</code><code class=\"codeline\">if (israytrace)</code><code class=\"codeline\">nextsample(sid, sx, sy, \"mode\", \"nextpixel\");</code><code class=\"codeline\">else</code><code class=\"codeline\">nextsample(sid, sx, sy, \"mode\", \"qstrat\");</code><code class=\"codeline\">// Sample something using sx/sy...</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/newsampler\">newsampler</a></div></body>",
    "ninput": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ninput\">ninput</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Reads a component from a pixel and its eight neighbors.</p><div class=\"usage\"> <code>matrix3 ninput(int opinput, int plane, int component, int array_index, int u, int v, int frame, ...)</code></div><div class=\"usage\"> <code>matrix3 ninput(int opinput, int plane, int component, int array_index; float u, float v; int frame, ...)</code></div><p>Reads the given component from the targeted pixel and its eight neighbors and returns them in a 3\u00d73 matrix.\nNote that this function only reads one component (for example, red, green, or blue) at a time.\nTo sample full color, you need to call the function three times with <code>component</code> set to 0, 1, and 2.</p><div class=\"argument\"><code>plane</code></div><p>The index of the plane to read from.</p><div class=\"argument\"><code>component</code></div><p>The index of the component to read from. For example, 0 is red, 1 is green, 2 is blue in an RGB plane.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/binput\">binput</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cinput\">cinput</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/finput\">finput</a></div></body>",
    "ninputs": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ninputs\">ninputs</a></h1><span class=\"padder\"><span class=\"pillow\">chop</span></span><p class=\"summary\">Returns the number of inputs.</p><div class=\"usage\"> <code>int ninputs()</code></div><p>Returns the number of inputs on the current node.</p></body>",
    "noise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/noise\">noise</a></h1><p class=\"summary\">There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space.</p><div class=\"usage\"> <code>float noise(float pos)</code></div><div class=\"usage\"> <code>vector noise(float pos)</code></div><p>Sample one or three numbers at the given position from 1D noise.</p><div class=\"usage\"> <code>float noise(float posx, float posy)</code></div><div class=\"usage\"> <code>vector noise(float posx, float posy)</code></div><p>Sample one or three numbers at the given position from 2D noise.</p><div class=\"usage\"> <code>float noise(vector pos)</code></div><div class=\"usage\"> <code>vector noise(vector pos)</code></div><p>Sample one or three numbers at the given position from 3D noise.</p><div class=\"usage\"> <code>float noise(vector4 pos)</code></div><div class=\"usage\"> <code>vector noise(vector4 pos)</code></div><p>Sample one or three numbers at the given position from 4D noise.</p><p>There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space.</p><h2>Note</h2><p>This function generates non-periodic noise. Use the\n    <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pnoise\">pnoise</a> function to generate periodic Perlin noise.</p><p>The various functions return the noise value at a 4D (vector4 argument),\n3D (vector argument), 2D (two float arguments) or 1D (float argument)\nposition. You can get a random float value or a vector of three random\nvalues.</p><p>The noise is in the range 0-1 with a median of 0.5. The distribution of\nthe noise depends on the dimension, with higher dimensions approaching a\nGaussian distribution of noise values.</p><h2>Related</h2></body>",
    "noised": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/noised\">noised</a></h1><p class=\"summary\">Derivatives of Perlin Noise.</p><div class=\"usage\"> <code>void noised(float x, float &amp;v, float &amp;dvdx)</code></div><div class=\"usage\"> <code>void noised(float x, vector &amp;v, vector &amp;dvdx)</code></div><div class=\"usage\"> <code>void noised(float x, float y, float &amp;v, float &amp;dvdx, float &amp;dvdy)</code></div><div class=\"usage\"> <code>void noised(float x, float y, vector &amp;v, vector &amp;dvdx, vector &amp;dvdy)</code></div><div class=\"usage\"> <code>void noised(vector xyz, float &amp;v, float &amp;dvdx, float &amp;dvdy, float &amp;dvdz)</code></div><div class=\"usage\"> <code>void noised(vector xyz, vector &amp;v, vector &amp;dvdx, vector &amp;dvdy, vector &amp;dvdz)</code></div><div class=\"usage\"> <code>void noised(vector4 xyzw, float &amp;v, float &amp;dvdx, float &amp;dvdy, float &amp;dvdz, float &amp;dvdw)</code></div><div class=\"usage\"> <code>void noised(vector4 xyzw, vector &amp;v, vector &amp;dvdx, vector &amp;dvdy, vector &amp;dvdz, vector &amp;dvdw)</code></div><p>This computes both the perlin noise value, and the derivatives of the\nnoise along each axis.  This can be performed quite efficiently as\nthere are analytic derivatives available.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/random\">noise and randomness</a>  in the VEX language\nguide for more information.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/noise\">noise</a></div></body>",
    "normalize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/normalize\">normalize</a></h1><p class=\"summary\">Returns a normalized vector.</p><div class=\"usage\"> <code>&lt;vector&gt; normalize(&lt;vector&gt; v)</code></div><p>Returns the <a href=\"https://en.wikipedia.org/wiki/Unit_vector\">normalized</a> version of <code>v</code>.</p></body>",
    "normalname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/normalname\">normalname</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the default name of the normal plane (as it appears in the\ncompositor preferences).</p><div class=\"usage\"> <code>string normalname()</code></div><p>Returns the default name of the normal plane (as it appears in the\ncompositor preferences). Using this instead of hardcoding the default\nmakes your code more portable. Default is N.</p></body>",
    "normal_bsdf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/normal_bsdf\">normal_bsdf</a></h1><p class=\"summary\">Returns the normal for the diffuse component of a BSDF.</p><div class=\"usage\"> <code>vector normal_bsdf(bsdf b)</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/albedo\">albedo</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/eval_bsdf\">eval_bsdf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_bsdf\">sample_bsdf</a></div></body>",
    "npoints": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/npoints\">npoints</a></h1><p class=\"summary\">Returns the number of points in the input or geometry file.</p><div class=\"usage\"> <code>int npoints(&lt;geometry&gt;)</code></div></body>",
    "npointsgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/npointsgroup\">npointsgroup</a></h1><p class=\"summary\">Returns the number of points in the group.</p><div class=\"usage\"> <code>int npointsgroup(&lt;geometry&gt;, string groupname)</code></div><div class=\"argument\"><code>groupname</code></div><p>This must refer to an exact group name, not an adhoc group pattern.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/expandpointgroup\">expandpointgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/inpointgroup\">inpointgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasattrib\">hasattrib</a></div></body>",
    "nprimitives": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nprimitives\">nprimitives</a></h1><p class=\"summary\">Returns the number of primitives in the input or geometry file.</p><div class=\"usage\"> <code>int nprimitives(&lt;geometry&gt;)</code></div></body>",
    "nprimitivesgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nprimitivesgroup\">nprimitivesgroup</a></h1><p class=\"summary\">Returns the number of primitives in the group.</p><div class=\"usage\"> <code>int nprimitivesgroup(&lt;geometry&gt;, string groupname)</code></div><div class=\"argument\"><code>groupname</code></div><p>This must refer to an exact group name, not an adhoc group pattern.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/expandprimgroup\">expandprimgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/inprimgroup\">inprimgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/hasattrib\">hasattrib</a></div></body>",
    "nrandom": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nrandom\">nrandom</a></h1><p class=\"summary\">Non-deterministic random number generation function.</p><div class=\"usage\"> <code>float nrandom(...)</code></div><div class=\"usage\"> <code>vector2 nrandom(...)</code></div><div class=\"usage\"> <code>vector nrandom(...)</code></div><div class=\"usage\"> <code>vector4 nrandom(...)</code></div><p>Returns a random number between 0 and 1, or a random unit vector.</p><div class=\"usage\"> <code>void nrandom(float &amp;x, float &amp;y, ...)</code></div><p>Overwrites the given variables with random numbers between 0 and 1.</p><p>These random generators will generate the same sequence of random numbers if called in precisely the same order. However, there is no seed involved so it is not possible to reproduce the same random number or sequence multiple times.</p><div class=\"argument\"><code>\u2026</code></div><p>You can optionally specify a string argument to choose the random number\n    generation method. The string may be one of:</p><div class=\"related\"><code>default</code>: Efficient random number generation. This method is backward\n    compatible with previous releases of Houdini.</div><div class=\"related\"><code>mersenne</code> or <code>twister</code>: Uses the Mersenne Twister which has some very\n    nice properties. This code is based of the work of: Copyright (C) 1997</div><div class=\"related\">2002, Makoto Matsumoto and Takuji Nishimura, All rights reserved.</div><div class=\"related\"><code>qstrat</code>: Uses a quasi-stratified random number generator. This tends\n    to distribute the random numbers evenly, reducing clumping and\n    spacing.</div></body>",
    "ntransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ntransform\">ntransform</a></h1><p class=\"summary\">Transforms a normal vector.</p><div class=\"usage\"> <code>vector ntransform(vector v, matrix transform)</code></div><div class=\"usage\"> <code>vector ntransform(string tospace, vector v)</code></div><div class=\"usage\"> <code>vector ntransform(string fromspace, string tospace, vector v)</code></div><p>Transforms a vector representing a normal. See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a> for more information.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vtransform\">vtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getspace\">getspace</a></div></body>",
    "nuniqueval": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nuniqueval\">nuniqueval</a></h1><p class=\"summary\">Returns the number of unique values from an integer or string attribute.</p><div class=\"usage\"> <code>int nuniqueval( &lt;geometry&gt;, string attribclass, string attribute_name)</code></div><p>Returns the number of <em>unique</em> values across all values of an attribute.\nYou can use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uniqueval\">uniqueval</a> to iterate though the set of unique values.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int test = nuniqueval(0, \"point\", \"foo\") == npoints(0)</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uniqueval\">uniqueval</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uniquevals\">uniquevals</a></div></body>",
    "nvertices": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nvertices\">nvertices</a></h1><p class=\"summary\">Returns the number of vertices in the input or geometry file.</p><div class=\"usage\"> <code>int nvertices(&lt;geometry&gt;)</code></div></body>",
    "nverticesgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nverticesgroup\">nverticesgroup</a></h1><p class=\"summary\">Returns the number of vertices in the group.</p><div class=\"usage\"> <code>int nverticesgroup(&lt;geometry&gt;, string groupname)</code></div><div class=\"argument\"><code>groupname</code></div><p>This must refer to an exact group name, not an adhoc group pattern.</p></body>",
    "objectstate": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/objectstate\">objectstate</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Queries the renderer for a named property.</p><div class=\"usage\"> <code>int objectstate(string query, &lt;type&gt; &amp;value)</code></div><div class=\"usage\"> <code>int objectstate(string query, &lt;type&gt;[] &amp;value)</code></div><p>Returns a non-zero value and sets <code class=\"var\">value</code> on success, or returns <code>0</code>\nif the renderer cannot evaluate the query.</p><p>See the <a href=\"https://www.sidefx.com/docs/houdini/props/mantra\">list of IFD properties</a> you can query. Use\nthe <strong>IFD</strong> name (e.g. <code>image:samples</code>),\nnot the Houdini name (e.g. <code>vm_samples</code>).</p><h2>Useful properties</h2><p>The following properties are commonly useful and are reproduced here\nfor convenience, but you can query any property from the\n<a href=\"https://www.sidefx.com/docs/houdini/props/mantra\">the full list of IFD properties</a>.</p><div class=\"argument\"><code><code>image:name</code></code></div><p>(string) The name of the image being rendered.</p><div class=\"argument\"><code><code>image:pixelaspect</code></code></div><p>(float) The pixel aspect ratio (X/Y) of the image.</p><div class=\"argument\"><code><code>image:resolution</code></code></div><p>(vector) Gives the resolution as {<code class=\"var\">x_res</code>, <code class=\"var\">y_res</code>, <code class=\"var\">samples_per_pixel</code>}.</p><div class=\"argument\"><code><code>image:samples</code></code></div><p>(vector) Gives samples as {<code class=\"var\">x_samples</code>, <code class=\"var\">y_samples</code>, 0}.</p><div class=\"argument\"><code><code>image:raysamples</code></code></div><p>(vector) Gives the raytracing samples as {<code class=\"var\">x_samples</code>, <code class=\"var\">y_samples</code>, 0}.</p><div class=\"argument\"><code><code>light:name</code></code></div><p>(string) The name of the light object which is currently active in the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a> loop.</p><div class=\"argument\"><code><code>light:shadowscope</code></code></div><p>(string) The list of objects casting shadows from a light.</p><div class=\"argument\"><code><code>object:name</code></code></div><p>(string) The name of the object being shaded. This is valid within light and shadow shaders and can be used to query which object is being lit (or shadowed) by the light source.</p><div class=\"argument\"><code><code>object:reflectscope</code></code></div><p>(string) The default reflection scope pattern for the object being shaded.</p><div class=\"argument\"><code><code>object:refractscope</code></code></div><p>(string) The default refraction scope pattern for the object being shaded.</p><div class=\"argument\"><code><code>object:reflectlimit</code></code></div><p>(float or int) The hard limit for maximum refraction bounces for the object being shaded.</p><div class=\"argument\"><code><code>object:shadingquality</code></code></div><p>(float) The shading quality for the object being shaded.</p><div class=\"argument\"><code><code>object:lightmask</code></code></div><p>(string) The object\u2019s light mask string.</p><div class=\"argument\"><code><code>object:area</code></code></div><p>(float) The object\u2019s surface area.</p><div class=\"argument\"><code><code>object:materialname</code></code></div><div class=\"argument\"><code>(string) Path to the material that\u2019s assigned to the object being shaded. \n    NOTE</code></div><p>This is for informational purpose only and has no effect on material assignment or appearance.</p><div class=\"argument\"><code><code>renderer:name</code></code></div><p>(string) The name of the renderer.</p><div class=\"argument\"><code><code>renderer:version</code></code></div><p>As a string, gives the renderer version as <code class=\"var\">major</code>.<code class=\"var\">minor</code>.<code class=\"var\">build</code>\n    As a vector, gives the renderer version as {<code class=\"var\">major</code>, <code class=\"var\">minor</code>, <code class=\"var\">build</code>}.</p><div class=\"argument\"><code><code>renderer:renderengine</code></code></div><p>(string) The render method in use, such as <code>micropoly</code> or <code>raytrace</code>. \n    See the <a href=\"https://www.sidefx.com/docs/houdini/props/mantra\">properties list</a> for the full list of possible values.</p><div class=\"argument\"><code><code>shader:name</code></code></div><p>(string) The name of the current shader being run.</p><h2>Packed Primitives</h2><p>When mantra renders packed primitives, the geometry gets unpacked before rendering.  This means primitive attributes on the packed primitive aren\u2019t available to shaders (since they aren\u2019t passed down to the unpacked geometry).</p><p>Before unpacking, mantra will automatically convert the primitive attributes to custom object properties (see <code>ray_declare</code> on the <a href=\"https://www.sidefx.com/docs/houdini/render/ifd\">IFD file format</a> page).  The property will be named <code>packed:ATTRIBNAME</code> (where <code>ATTRIBNAME</code> is the name of the attribute).  The <code>objectstate()</code> function can be used to access these properties, just like any other object property.</p><p>For example:</p><div class=\"codeblock\"><code class=\"codeline\">vector Cd;</code><code class=\"codeline\">    if (!objectstate(\"packed:Cd\", Cd))</code><code class=\"codeline\">        Cd = 1;   // There was no Cd attribute on packed geometry</code></div><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">surface showversion() </code><code class=\"codeline\">{</code><code class=\"codeline\">    string    rname, rversion;</code><code class=\"codeline\">    if (!objectstate(\"renderer:name\", rname))</code><code class=\"codeline\">        rname = \"Unknown renderer\";</code><code class=\"codeline\">    if (!objectstate(\"renderer:version\", rversion))</code><code class=\"codeline\">        rversion = \"Unknown version\";</code><code class=\"codeline\">    printf(\"Image rendered by %s (%s)\\n\", rname, rversion);</code><code class=\"codeline\">}</code><code class=\"codeline\"></code><code class=\"codeline\">vector mapToScreen(vector NDC_P)</code><code class=\"codeline\">{</code><code class=\"codeline\">    // Given a point in NDC space, find out which pixel it</code><code class=\"codeline\">    // maps to.</code><code class=\"codeline\">    vector    result;</code><code class=\"codeline\">    if (!objectstate(\"image:resolution\", result))</code><code class=\"codeline\">        result = {640, 486, 0};</code><code class=\"codeline\">    return result * NDC_P;</code><code class=\"codeline\">}</code></div></body>",
    "occlusion": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/occlusion\">occlusion</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Computes ambient occlusion.</p><div class=\"usage\"> <code>vector occlusion(vector P, vector N, ...)</code></div><p>Computes ambient occlusion at the point P with the normal N. Just as\n    in the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/irradiance\">irradiance</a> function, the hemisphere is\n    sampled. However, unlike irradiance, surfaces intersected during the\n    hemisphere sampling are not shaded. For this function to work\n    properly, either a constant background color or an environment map\n    must be specified in the\n    <a href=\"https://www.sidefx.com/docs/houdini/vex/contexts/shading_contexts#scope\">optional scope parameters</a>.</p><div class=\"usage\"> <code>void occlusion(float &amp;coverage, vector &amp;missed_direction, vector P, vector N, ...)</code></div><p>Instead of computing color information from ambient occlusion, this\n    form computes the coverage (the percentage of occlusion) and the\n    average direction of empty space. The average direction can be used to\n    look up the color in a pre-blurred environment map.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/irradiance\">irradiance</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pathtrace\">pathtrace</a></div></body>",
    "ocean_sample": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ocean_sample\">ocean_sample</a></h1><p class=\"summary\">Evaluates an ocean spectrum and samples the result at a given time and location.</p><div class=\"usage\"> <code>vector ocean_sample(string geometry, int phase, int frequency, int amplitude, float hscale, float time, int mode, int downsample, vector pos)</code></div><p>Evaluates the input ocean spectrum at the given time and position and returns the value specified by <code>mode</code>.  The input is typically the output of the <a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/oceanspectrum\">Ocean Spectrum</a> SOP.</p><div class=\"argument\"><code>geometry</code></div><p>The name of the geometry file to reference.  Inside Houdini, this may be <code>op:full_path_to_sop</code> to reference a SOP.</p><div class=\"argument\"><code>phase</code></div><p>The primitive number of the volume representing wave phase.</p><div class=\"argument\"><code>frequency</code></div><p>The primitive number of the volume representing wave frequency.</p><div class=\"argument\"><code>amplitude</code></div><p>The primitive number of the volume representing wave amplitude.</p><div class=\"argument\"><code>hscale</code></div><p>The amount to scale any horizontal motion in the ocean waves.</p><div class=\"argument\"><code>mode</code></div><p>The type of value to sample from the ocean spectrum, where 0 means displacement, 1 means velocity, and 2 means horizontal spatial derivatives.</p><div class=\"argument\"><code>downsample</code></div><p>The number of times to downsample the input spectrum before evaluation.  Each downsample level halves the resolution of the input.</p><div class=\"argument\"><code>pos</code></div><p>The position in object space at which to sample the evaluated ocean.</p><h2>Examples</h2><p>Displace the point position by an ocean spectrum stored in a file.</p><div class=\"codeblock\"><code class=\"codeline\">@P += ocean_sample(\"spectrum.bgeo\", 0, 1, 2, 0.7, @Time, 0, 0, @P);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/oceanspectrum\">sop/oceanspectrum</a></div></body>",
    "ocio_activedisplays": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ocio_activedisplays\">ocio_activedisplays</a></h1><p class=\"summary\">Returns the names of active displays supported in Open Color IO</p><div class=\"usage\"> <code>string [] ocio_activedisplays()</code></div><p>Returns a list of names of the active displays supported by Open Color IO in Houdini.</p></body>",
    "ocio_activeviews": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ocio_activeviews\">ocio_activeviews</a></h1><p class=\"summary\">Returns the names of active views supported in Open Color IO</p><div class=\"usage\"> <code>string [] ocio_activeviews()</code></div><p>Returns a list of names of the active views supported by Open Color IO in Houdini.</p></body>",
    "ocio_import": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ocio_import\">ocio_import</a></h1><p class=\"summary\">Imports attributes from OpenColorIO spaces.</p><div class=\"usage\"> <code>int ocio_import(string space, string property; int &amp;value)</code></div><div class=\"usage\"> <code>int ocio_import(string space, string property; vector &amp;value)</code></div><div class=\"usage\"> <code>int ocio_import(string space, string property; string &amp;value)</code></div><p>This function queries data associated with a color space.</p><p>If the function fails, the <code class=\"var\">value</code> variable will not be modified,\nand may be left uninitialized.</p><h2>Queryable attributes</h2><p>There list of properties includes most of the properties defined in the OCIO configuration file:</p><div class=\"argument\"><code><code>string name</code></code></div><p>The name of the color space.</p><div class=\"argument\"><code><code>string family</code></code></div><p>The color space family.</p><div class=\"argument\"><code><code>string equalitygroup</code></code></div><p>The equality group for the color space.</p><div class=\"argument\"><code><code>string description</code></code></div><p>A description of the color space.</p><div class=\"argument\"><code><code>int isdata</code></code></div><p>True if the color space is suitable for non-color pixel data (such as normals, point positions, etc.)</p><div class=\"argument\"><code><code>string bitdepth</code></code></div><p>A string representing the color space bit depth.</p><div class=\"argument\"><code><code>string allocation</code></code></div><p>Either <code>uniform</code> or <code>lg2</code> (log2).</p><div class=\"argument\"><code><code>vector allocationvars</code></code></div><p>The allocation variables (min, max, offset).</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">cvex test()</code><code class=\"codeline\">{</code><code class=\"codeline\">    string        token;</code><code class=\"codeline\">    string        sval;</code><code class=\"codeline\">    int                ival;</code><code class=\"codeline\">    vector        vval;</code><code class=\"codeline\"></code><code class=\"codeline\">    // Color spaces may be specified by name or by role</code><code class=\"codeline\">    foreach(space; { \"sRGB\", \"color_picker\" })</code><code class=\"codeline\">    {</code><code class=\"codeline\">        foreach(token; { \"name\",</code><code class=\"codeline\">            \"description\",</code><code class=\"codeline\">            \"isdata\",</code><code class=\"codeline\">            \"allocation\",</code><code class=\"codeline\">            \"allocationvars\",</code><code class=\"codeline\">            \"description\",</code><code class=\"codeline\">        } )</code><code class=\"codeline\">        {</code><code class=\"codeline\">            printf(\"----------------- %s ---------------------\\n\", token);</code><code class=\"codeline\">            if (teximport(map, token, sval))</code><code class=\"codeline\">                fprintf(stderr, \"'%s' = %s\\n\", token, sval);</code><code class=\"codeline\">            if (teximport(map, token, ival))</code><code class=\"codeline\">                fprintf(stderr, \"'%s' = %d\\n\", token, ival);</code><code class=\"codeline\">            else if (teximport(map, token, vval))</code><code class=\"codeline\">                fprintf(stderr, \"'%s' = %g\\n\", token, vval);</code><code class=\"codeline\">        }</code><code class=\"codeline\">    }</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/dsmpixel\">dsmpixel</a></div></body>",
    "ocio_parsecolorspace": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ocio_transform\">ocio_transform</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Parse the color space from a string</p><div class=\"usage\"> <code>string ocio_parsecolorspace(string input)</code></div><p>Use OCIO to detect the color space in an input string.  The input string is typically a filename.</p><div class=\"argument\"><code>input</code></div><p>The string to scan for a color space string.  This is typically an image filename that has the color space encoded in the name.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ocio_spaces\">ocio_spaces</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ocio_transform\">ocio_transform</a></div></body>",
    "ocio_roles": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ocio_roles\">ocio_roles</a></h1><p class=\"summary\">Returns the names of roles supported in Open Color IO</p><div class=\"usage\"> <code>string [] ocio_roles()</code></div><p>Returns a list of names of the roles supported by Open Color IO in Houdini.</p></body>",
    "ocio_spaces": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ocio_spaces\">ocio_spaces</a></h1><p class=\"summary\">Returns the names of color spaces supported in Open Color IO.</p><div class=\"usage\"> <code>string[] ocio_spaces()</code></div></body>",
    "ocio_transform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ocio_transform\">ocio_transform</a></h1><p class=\"summary\">Transform colors using Open Color IO</p><div class=\"usage\"> <code>vector ocio_transform(string dest; vector clr)</code></div><div class=\"usage\"> <code>vector ocio_transform(string src, string dest; vector clr)</code></div><div class=\"usage\"> <code>vector ocio_transform(string src, string dest, string looks; vector clr)</code></div><p>Transform a three-component color into a new color space.</p><div class=\"usage\"> <code>vector4 ocio_transform(string dest; vector4 clr)</code></div><div class=\"usage\"> <code>vector4 ocio_transform(string src, string dest; vector4 clr)</code></div><div class=\"usage\"> <code>vector4 ocio_transform(string src, string dest, string looks; vector4 clr)</code></div><p>Transform a four-component color into a new color space.</p><div class=\"argument\"><code>src</code></div><p>The name of the color space to transform from. If this is not given, the function assumes the space assigned to <code>\"data\"</code>.</p><div class=\"argument\"><code>dest</code></div><p>The name of the color space to transform to.</p><div class=\"argument\"><code>looks</code></div><p>A comma separated list of color gradings (also known as looks).</p><div class=\"argument\"><code>clr</code></div><p>The color to transform.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ocio_spaces\">ocio_spaces</a></div></body>",
    "onoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/onoise\">onoise</a></h1><p class=\"summary\">These functions are similar to wnoise and vnoise.</p><div class=\"usage\"> <code>float onoise(vector pos)</code></div><div class=\"usage\"> <code>vector onoise(vector pos)</code></div><div class=\"usage\"> <code>float onoise(vector pos, int turbulence, float rough, float atten)</code></div><div class=\"usage\"> <code>vector onoise(vector pos, int turbulence, float rough, float atten)</code></div><div class=\"usage\"> <code>float onoise(vector pos, int periodX, int periodY, int periodZ)</code></div><div class=\"usage\"> <code>vector onoise(vector pos, int periodX, int periodY, int periodZ)</code></div><div class=\"usage\"> <code>float onoise(vector pos, int periodX, int periodY, int periodZ, int turbulence, float rough, float atten)</code></div><div class=\"usage\"> <code>vector onoise(vector pos, int periodX, int periodY, int periodZ, int turbulence, float rough, float atten)</code></div><p>These functions are similar to <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wnoise\">wnoise</a> and\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vnoise\">vnoise</a>. However, they are marginally less efficient in\ncomputation and don\u2019t have the same characteristics. The bounds on the\nnoise are roughly (-1, 1). Only 3D noise is supported. However, this\nnoise has the ability to compute turbulence with roughness and\nattenuation on the noise.</p><h2>Related</h2></body>",
    "opdigits": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opdigits\">opdigits</a></h1><p class=\"summary\">Returns the integer value of the last sequence of digits of a string</p><div class=\"usage\"> <code>int opdigits(const string str)</code></div><div class=\"usage\"> <code>int opdigits()</code></div><p>Returns the integer value of the last sequence of digits in the input string.</p><p>If no argument is passed, the code is equivalent to</p><div class=\"codeblock\"><code class=\"codeline\">string dir, name;</code><code class=\"codeline\">splitpath(opfullpath(\".\"), dir, name);</code><code class=\"codeline\">return opdigits(name);</code></div><h2>Examples</h2><div class=\"related\"><code>opdigits(\"/obj/geo34/box21\")</code> - returns 21</div><div class=\"related\"><code>opdigits(\"/obj/geo34/box\")</code> - returns 34</div><div class=\"related\"><code>opdigits(\"/obj/geo34/box2.1\")</code> - returns 1 (. is not a digit)</div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/isdigit\">isdigit</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/atoi\">atoi</a></div></body>",
    "opend": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opend\">opend</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Ends a long operation.</p><div class=\"usage\"> <code>void opend(int handle)</code></div><p>Informs mantra that a long operation begun with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opstart\">opstart</a> has completed. Pass in the value returned by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opstart\">opstart</a>.</p><div class=\"codeblock\"><code class=\"codeline\">int op_handle = opstart(\"Performing long operation\");</code><code class=\"codeline\">perform_long_operation();</code><code class=\"codeline\">if (op_handle &gt;= 0)</code><code class=\"codeline\">    opend(op_handle);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opstart\">opstart</a></div></body>",
    "opfullpath": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opfullpath\">opfullpath</a></h1><p class=\"summary\">Returns the full path for the given relative path</p><div class=\"usage\"> <code>string opfullpath(const string relative_path)</code></div><p>This function returns the absolute path for a given relative path to the object being evaluated.</p><p>The function is currently only meaningful in Houdini.</p><h2>Examples</h2><div class=\"related\"><code>opfullpath(\".\")</code> - The full path of the current node being evaluated</div><div class=\"related\"><code>opfullpath(\"..\")</code> - The full path of the current node\u2019s parent</div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/split\">split</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opdigits\">opdigits</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/splitpath\">splitpath</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/relativepath\">relativepath</a></div></body>",
    "opid": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opid\">opid</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Resolves an operator path string and return its op_id.</p><div class=\"usage\"> <code>int opid(string op_path)</code></div><div class=\"usage\"> <code>int opid( int op_id )</code></div><p>Resolves an operator path and returns its corresponding operator id.</p><p>Return -1 on failure. The form that takes an operator id as an input returns 1\nif it is a valid operator id, otherwise it returns 0. This can be used to test\nif an operator id is valid.</p><p>The operator id can change when reloading the scene.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch\">ch</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chf\">chf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chs\">chs</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chi\">chi</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chv\">chv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch3\">ch3</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ch4\">ch4</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chramp\">chramp</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chrampderiv\">chrampderiv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chid\">chid</a></div></body>",
    "opparentbonetransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparentbonetransform\">opparentbonetransform</a></h1><p class=\"summary\">Returns the parent bone transform associated with an OP.</p><div class=\"usage\"> <code>matrix opparentbonetransform(string path)</code></div><div class=\"usage\"> <code>matrix opparentbonetransform(string path, float time)</code></div><div class=\"usage\"> <code>matrix opparentbonetransform(int opid)</code></div><div class=\"usage\"> <code>matrix opparentbonetransform(int opid, float time)</code></div><p>Returns the parent bone transform associated with an OP. If the specified OP has no\ntransform associated with it (such as a COP), then an identity matrix is returned. It is possible to specify the time at which to evaluate the transform (in seconds, not frames). Returns the transform at the root of the parent bone or the parent transform otherwise.</p><h2>Note</h2><p>The op: syntax can be used to simulate this behavior using the standard transform functions.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ntransform\">ntransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getspace\">getspace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/optransform\">optransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/oppreconstrainttransform\">oppreconstrainttransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparmtransform\">opparmtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparenttransform\">opparenttransform</a></div></body>",
    "opparenttransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparenttransform\">opparenttransform</a></h1><p class=\"summary\">Returns the parent transform associated with an OP.</p><div class=\"usage\"> <code>matrix opparenttransform(string path)</code></div><div class=\"usage\"> <code>matrix opparenttransform(string path, float time)</code></div><div class=\"usage\"> <code>matrix opparenttransform(int opid)</code></div><div class=\"usage\"> <code>matrix opparenttransform(int opid, float time)</code></div><p>Returns the parent transform associated with an OP. If the specified OP has no\ntransform associated with it (such as a COP), then an identity matrix is returned. It is possible to specify the time at which to evaluate the transform (in seconds, not frames).</p><h2>Note</h2><p>The op: syntax can be used to simulate this behavior using the standard transform functions.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ntransform\">ntransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getspace\">getspace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/optransform\">optransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/oppreconstrainttransform\">oppreconstrainttransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparmtransform\">opparmtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparentbonetransform\">opparentbonetransform</a></div></body>",
    "opparmtransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparmtransform\">opparmtransform</a></h1><p class=\"summary\">Returns the parm transform associated with an OP.</p><div class=\"usage\"> <code>matrix opparmtransform(string path)</code></div><div class=\"usage\"> <code>matrix opparmtransform(string path, float time)</code></div><div class=\"usage\"> <code>matrix opparmtransform(int opid)</code></div><div class=\"usage\"> <code>matrix opparmtransform(int opid, float time)</code></div><p>Returns the parm transform associated with an OP. If the specified OP has no\ntransform associated with it (such as a COP), then an identity matrix is returned. It is possible to specify the time at which to evaluate the transform (in seconds, not frames).</p><h2>Note</h2><p>The op: syntax can be used to simulate this behavior using the standard transform functions.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ntransform\">ntransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getspace\">getspace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/optransform\">optransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/oppreconstrainttransform\">oppreconstrainttransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparenttransform\">opparenttransform</a></div></body>",
    "oppreconstrainttransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/oppreconstrainttransform\">oppreconstrainttransform</a></h1><p class=\"summary\">Returns the preconstraint transform associated with an OP.</p><div class=\"usage\"> <code>matrix oppreconstrainttransform(string path)</code></div><div class=\"usage\"> <code>matrix oppreconstrainttransform(string path, float time)</code></div><div class=\"usage\"> <code>matrix oppreconstrainttransform(int opid)</code></div><div class=\"usage\"> <code>matrix oppreconstrainttransform(int opid, float time)</code></div><p>Returns the preconstraint transform associated with an OP. If the specified OP has no\ntransform associated with it (such as a COP), then an identity matrix is returned. It is possible to specify the time at which to evaluate the transform (in seconds, not frames).</p><h2>Note</h2><p>The op: syntax can be used to simulate this behavior using the standard transform functions.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ntransform\">ntransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getspace\">getspace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/optransform\">optransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparmtransform\">opparmtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparenttransform\">opparenttransform</a></div></body>",
    "oppreparmtransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/oppreparmtransform\">oppreparmtransform</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the pre and parm transform associated with an OP.</p><div class=\"usage\"> <code>matrix oppreparmtransform(string path)</code></div><div class=\"usage\"> <code>matrix oppreparmtransform(string path, float time)</code></div><div class=\"usage\"> <code>matrix oppreparmtransform(int opid)</code></div><div class=\"usage\"> <code>matrix oppreparmtransform(int opid, float time)</code></div><p>Returns the pre and parm transform associated with an OP. If the specified OP has no\ntransform associated with it (such as a COP), then an identity matrix is returned. It is possible to specify the time at which to evaluate the transform (in seconds, not frames).</p><h2>Note</h2><p>The op: syntax can be used to simulate this behavior using the standard transform functions.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ntransform\">ntransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getspace\">getspace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/optransform\">optransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/oppreconstrainttransform\">oppreconstrainttransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparmtransform\">opparenttransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/oprawparmtransform\">opparenttransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparenttransform\">opparenttransform</a></div></body>",
    "opprerawparmtransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opprerawparmtransform\">opprerawparmtransform</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the pre and raw parm transform associated with an OP.</p><div class=\"usage\"> <code>matrix opprerawparmtransform(string path)</code></div><div class=\"usage\"> <code>matrix opprerawparmtransform(string path, float time)</code></div><div class=\"usage\"> <code>matrix opprerawparmtransform(int opid)</code></div><div class=\"usage\"> <code>matrix opprerawparmtransform(int opid, float time)</code></div><div class=\"usage\"> <code>matrix opprerawparmtransform(int opid, int trsorder, int xyzorder, int mask)</code></div><p>Returns the pre and raw parm transform associated with an OP. If the specified OP has no\ntransform associated with it (such as a COP), then an identity matrix is returned. It is possible to specify the time at which to evaluate the transform (in seconds, not frames).</p><p>The raw parameter transform is built from the transform parameters and does not include the effect of the CHOP IK solver.</p><h2>Note</h2><p>The op: syntax can be used to simulate this behavior using the standard transform functions.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ntransform\">ntransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getspace\">getspace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/optransform\">optransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/oppreconstrainttransform\">oppreconstrainttransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparmtransform\">opparenttransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparenttransform\">opparenttransform</a></div></body>",
    "oppretransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/oppretransform\">oppretransform</a></h1><p class=\"summary\">Returns the pretransform associated with an OP.</p><div class=\"usage\"> <code>matrix oppretransform(string path)</code></div><div class=\"usage\"> <code>matrix oppretransform(string path, float time)</code></div><div class=\"usage\"> <code>matrix oppretransform(int opid)</code></div><div class=\"usage\"> <code>matrix oppretransform(int opid, float time)</code></div><p>Returns the transform associated with an OP. If the OP specified has no\ntransform associated with it (for example a COP), then an identity\nmatrix is returned. It is possible to specify the time to evaluate the\ntransform at (in seconds, not frames).</p><h2>Note</h2><p>The op: syntax can be used to simulate this behavior using the standard transform functions.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/optransform\">ntransform</a></div></body>",
    "oprawparmtransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/oprawparmtransform\">oprawparmtransform</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the raw parm transform associated with an OP.</p><div class=\"usage\"> <code>matrix oprawparmtransform(string path)</code></div><div class=\"usage\"> <code>matrix oprawparmtransform(string path, float time)</code></div><div class=\"usage\"> <code>matrix oprawparmtransform(int opid)</code></div><div class=\"usage\"> <code>matrix oprawparmtransform(int opid, float time)</code></div><div class=\"usage\"> <code>matrix oprawparmtransform(int opid, int trsorder, int xyzorder, int mask)</code></div><p>Returns the raw parm transform associated with an OP. If the specified OP has no\ntransform associated with it (such as a COP), then an identity matrix is returned. It is possible to specify the time at which to evaluate the transform (in seconds, not frames).</p><p>The raw parameter transform is built from the transform parameters and does not include the effect of the CHOP IK solver.</p><h2>Note</h2><p>The op: syntax can be used to simulate this behavior using the standard transform functions.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ntransform\">ntransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getspace\">getspace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/optransform\">optransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/oppreconstrainttransform\">oppreconstrainttransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparmtransform\">opparenttransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparenttransform\">opparenttransform</a></div></body>",
    "opstart": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opstart\">opstart</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Start a long operation.</p><div class=\"usage\"> <code>int opstart(string message)</code></div><p>Inform mantra about the start of a long operation (operation start).  The string argument is passed to mantra and may be displayed in the IPR viewer.</p><p>The function will return a non-negative integer when successfully started.</p><p>The integer returned should be passed to <code>opend()</code> at the completion of the long operation.</p><div class=\"codeblock\"><code class=\"codeline\">int started = opstart(\"Performing long operation\");</code><code class=\"codeline\">perform_long_operation();</code><code class=\"codeline\">if (started &gt;= 0)</code><code class=\"codeline\">opend(started);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opend\">opend</a></div></body>",
    "optransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/optransform\">optransform</a></h1><p class=\"summary\">Returns the transform associated with an OP.</p><div class=\"usage\"> <code>matrix optransform(string path)</code></div><div class=\"usage\"> <code>matrix optransform(string path, float time)</code></div><div class=\"usage\"> <code>matrix optransform(int op_id)</code></div><div class=\"usage\"> <code>matrix optransform(int op_id, float time)</code></div><p>Returns the transform associated with an OP. If the OP specified has no\ntransform associated with it (for example a COP), then an identity\nmatrix is returned. It is possible to specify the time to evaluate the\ntransform at (in seconds, not frames).</p><p>NOTE: The op: syntax can be used to simulate this behavior using the\nstandard transform functions.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ntransform\">ntransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getspace\">getspace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparmtransform\">opparmtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/oppreconstrainttransform\">oppreconstrainttransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/opparmtransform\">opparmtransform</a></div></body>",
    "ord": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ord\">ord</a></h1><p class=\"summary\">Converts an UTF8 string into a codepoint.</p><div class=\"usage\"> <code>int ord(string value)</code></div><p>Returns the code point of the first UTF8 character in the given string.</p><p>If the prefix of the string isn\u2019t a valid UTF8 encoding, or is empty, -1 is returned.</p><p>Overlong UTF8 encodings will return -1.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/chr\">chr</a></div></body>",
    "orthographic": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/orthographic\">orthographic</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Create an orthographic projection matrix.</p><div class=\"usage\"> <code>matrix orthographic(float zoom, float orthowidth, float image_aspect, float pixel_aspect, float clip_near, float clip_far)</code></div><div class=\"usage\"> <code>matrix orthographic(float zoom, float orthowidth, float image_aspect, float pixel_aspect, float clip_near, float clip_far, vector4 window)</code></div><p>Create an orthographic projection matrix with the given parameters. This can be used to project points onto the so-called NDC coordinates of a camera.</p><p>To make a single transform from world space to NDC space given a camera matrix and a projection matrix, you would use, <code>worldToNDC = worldToCamera * projection;</code></p><div class=\"argument\"><code>zoom</code></div><p>The zoom for the lens. Sometimes the zoom is expressed in terms of focal and aperture.  In this case, <code>zoom = focal/aperture</code>.</p><div class=\"argument\"><code>orthowidth</code></div><p>An additional zoom factor.</p><div class=\"related\">arg:image_aspect</div><p>The aspect ratio of the image. Sometimes the image_aspect is expressed in terms of <code>xres</code> and <code>yres</code>.  In this case, <code>image_aspect = xres / yres</code>.</p><div class=\"related\">arg::clip_near</div><p>The near clipping plane.</p><div class=\"related\">arg::clip_far</div><p>The far clipping plane.</p><div class=\"related\">arg::window</div><p>The offset for the projection window encoded in a vector4.\n    window.x and window.y are the window min xy coordinates and\n    window.z, window.w are the window max xy coordinates.\n    This argument is optional and defaults to {0,0,1,1} when not given.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/perspective\">perspective</a></div></body>",
    "osd_facecount": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_facecount\">osd_facecount</a></h1><div class=\"usage\"> <code>int osd_facecount(&lt;geometry&gt;)</code></div><p>Returns the number of coarse faces in the subdivision hull.  This is different that the number of patches in the subdivision surface.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_facecount\">osd_facecount</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_firstpatch\">osd_firstpatch</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_limitsurface\">osd_limitsurface</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_patchcount\">osd_patchcount</a></div></body>",
    "osd_firstpatch": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_firstpatch\">osd_firstpatch</a></h1><div class=\"usage\"> <code>int osd_firstpatch(&lt;geometry&gt;, int face_id)</code></div><p>For a given face in the coarse mesh, this returns the number of the first patch associated with the face.  Since each face in a hull may generate multiple patches, this function will return the first of the patches generated by the face.  See also <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_patchcount\">osd_patchcount</a> to find out the number of patches generated by the face.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_facecount\">osd_facecount</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_firstpatch\">osd_firstpatch</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_limitsurface\">osd_limitsurface</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_patchcount\">osd_patchcount</a></div></body>",
    "osd_limitsurface": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_limitsurface\">osd_limitsurface</a></h1><p class=\"summary\">Evaluates a point attribute at the subdivision limit surface using Open Subdiv.</p><p><code>osd_limitsurface</code> evaluates the point attribute in the geometry specified as a\nsubdivision surface.</p><p>For vertex attributes, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_limitsurfacevertex\">osd_limitsurfacevertex</a>.</p><div class=\"usage\"> <code>int osd_limitsurface(&lt;geometry&gt;, string attrib_name, int patch_id, float u, float v, &lt;type&gt; &amp;result)</code></div><div class=\"usage\"> <code>int osd_limitsurface(&lt;geometry&gt;, string attrib_name, int patch_id, float u, float v, float &amp;result[])</code></div><div class=\"argument\"><code>&amp;result</code></div><p>The computed attribute value is stored in the variable you pass to this argument.\n    The type of the variable should match the type of the attribute you are reading.</p><h2>Returns</h2><p><code>1</code> if computing the attribute was successful, <code>0</code> if it failed.</p><p>Possible reasons for failure are:</p><div class=\"related\">The geometry contains no polygons or the topology can\u2019t be converted using Open Subdiv</div><div class=\"related\">The attribute doesn\u2019t exist on the input geometry.</div><div class=\"related\">The attribute size/type doesn\u2019t match the VEX type of the <code>result</code> argument.</div><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int npatches = osd_patchcount(file);</code><code class=\"codeline\">    for (int patch = 0; patch &lt; npatches; patch++)</code><code class=\"codeline\">    {</code><code class=\"codeline\">        for (int v = 0; v &lt; 100; v++)</code><code class=\"codeline\">        {</code><code class=\"codeline\">            vector P;</code><code class=\"codeline\">            if (osd_limitsurface(file, \"P\", patch, nrandom(), nrandom(), P))</code><code class=\"codeline\">            {</code><code class=\"codeline\">                int ptid = addpoint(geohandle, P);</code><code class=\"codeline\">            }</code><code class=\"codeline\">        }</code><code class=\"codeline\">    }</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_facecount\">osd_facecount</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_firstpatch\">osd_firstpatch</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_patchcount\">osd_patchcount</a></div></body>",
    "osd_limitsurfacevertex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_limitsurfacevertex\">osd_limitsurfacevertex</a></h1><p class=\"summary\">Evaluates a vertex attribute at the subdivision limit surface using Open Subdiv.</p><p>This is like <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_limitsurface\">osd_limitsurface</a> but for vertex attributes instead of point attributes.\nSee <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_limitsurface\">osd_limitsurface</a> for more information.</p><div class=\"usage\"> <code>int osd_limitsurfacevertex(&lt;geometry&gt;, string attrib_name, int face_id, float u, float v, &lt;type&gt; &amp;result)</code></div><div class=\"usage\"> <code>int osd_limitsurfacevertex(&lt;geometry&gt;, string attrib_name, int face_id, float u, float v, float &amp;result[])</code></div></body>",
    "osd_lookupface": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_lookupface\">osd_lookupface</a></h1><p class=\"summary\">Outputs the Houdini face and UV coordinates corresponding to the given coordinates on an OSD patch.</p><div class=\"usage\"> <code>int osd_lookupface(&lt;geometry&gt;, int patch_id, float patch_u, float patch_v, int &amp;face_id, float &amp;face_u, float &amp;face_v)</code></div><p>If you don\u2019t specify a texture attribute, the function uses intrinsic polygon interpolants.</p><div class=\"usage\"> <code>int osd_lookupface(&lt;geometry&gt;, int patch_id, float patch_u, float patch_v, int &amp;face_id, float &amp;face_u, float &amp;face_v, string attribute)</code></div><p>If you specify a texture attribute, the function uses the UVs in that attribute to translate the patch coordinates onto the Houdini geometry.</p><p>Each polygon in a piece of geometry will generate one or more Catmull-Clark subdivision patches.  A quadrilateral will generate a single patch, while a pentagon will generate five patches.  This function helps map between the subdivision patch id and the Houdini polygon (face). The reverse function to map from face to patch is <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_lookuppatch\">osd_lookuppatch</a>.</p><div class=\"argument\"><code><code>patch_id</code></code></div><p>The ID number of the OSD patch.</p><div class=\"argument\"><code><code>patch_u</code>, <code>patch_v</code></code></div><p>The coordinates in the subdivision patch to map onto a Houdini primitive. These values should be in the range 0 to 1.</p><div class=\"argument\"><code><code>&amp;face_id</code></code></div><p>The function overwrites this variable with the Houdini primitive number of the corresponding face.</p><div class=\"argument\"><code><code>&amp;face_u</code>, <code>&amp;face_v</code></code></div><p>The function overwrites these variables with the corresponding U/V coordinates on the Houdini face. The output coordinates will have values in the range 0 to 1.</p><h2>Returns</h2><p><code>1</code> on success or <code>0</code> on an error.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">void</code><code class=\"codeline\">scatterOnLimitSurface(string file, texmap; int geo_handle; int npts)</code><code class=\"codeline\">{</code><code class=\"codeline\">    int npatches = osd_patchcount(file);</code><code class=\"codeline\">    for (int i = 0; i &lt; npts; ++i)</code><code class=\"codeline\">    {</code><code class=\"codeline\">        int patch_id = nrandom() * npatches;</code><code class=\"codeline\">        float patch_s = nrandom();</code><code class=\"codeline\">        float patch_t = nrandom();</code><code class=\"codeline\">        int face_id;</code><code class=\"codeline\">        float face_u, face_v;</code><code class=\"codeline\">        if (osd_lookupface(file, patch_id, patch_s, patch_t, face_id, face_u, face_v, \"uv\"))</code><code class=\"codeline\">        {</code><code class=\"codeline\">            vector clr = texture(texmap, face_u, face_v);</code><code class=\"codeline\">            vector P;</code><code class=\"codeline\">            osd_limitsurface(file, \"P\", patch_id, patch_s, patch_t, P);</code><code class=\"codeline\">            int ptnum = addpoint(geo_handle, P);        // add a scattered point.</code><code class=\"codeline\">            if (ptnum &gt;= 0)</code><code class=\"codeline\">            {</code><code class=\"codeline\">                addpointattrib(geo_handle, \"Cd\", clr);</code><code class=\"codeline\">                addpointattrib(geo_handle, \"face_id\", face_id);</code><code class=\"codeline\">            }</code><code class=\"codeline\">        }</code><code class=\"codeline\">    }</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_lookuppatch\">osd_lookuppatch</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_patchcount\">osd_patchcount</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_facecount\">osd_facecount</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_firstpatch\">osd_firstpatch</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_limitsurface\">osd_limitsurface</a></div></body>",
    "osd_lookuppatch": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_lookuppatch\">osd_lookuppatch</a></h1><p class=\"summary\">Outputs the OSD patch and UV coordinates corresponding to the given coordinates on a Houdini polygon face.</p><div class=\"usage\"> <code>int osd_lookuppatch(&lt;geometry&gt;, int face_id, float face_u, float face_v, int &amp;patch_id, float &amp;patch_u, float &amp;patch_v)</code></div><p>If you don\u2019t specify a texture attribute, the function uses intrinsic polygon interpolants.</p><div class=\"usage\"> <code>int osd_lookuppatch(&lt;geometry&gt;, int face_id, float face_u, float face_v, int &amp;patch_id, float &amp;patch_u, float &amp;patch_v, string attribute)</code></div><p>If you specify a texture attribute, the function uses the UVs in that attribute to translate the face coordinates onto the OSD patch.</p><p>Given the <code>face_id</code> and texture coordinates for a point inside the face (<code>face_u</code> and<code>face_v</code>), this function will return the corresponding <code>patch_id</code> (Catmull-Clark subdivision face) and the patch interpolants (<code>patch_u</code> and <code>patch_v</code>). The reverse function to map from patch to face is <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_lookupface\">osd_lookupface</a>.</p><div class=\"argument\"><code><code>face_id</code></code></div><p>The primitive number of the Houdini polygon face.</p><div class=\"argument\"><code><code>face_u</code>, <code>face_v</code></code></div><p>The coordinates in the subdivision patch to map onto a Houdini primitive.\n    These should have values in the range 0 to 1. Not all values are valid for triangles.\n    The texture coordinates should be specified according to the attribute passed in.\n    If you pass invalid coordinates, the function will fail and return <code>0</code>.</p><div class=\"argument\"><code><code>&amp;patch_id</code></code></div><p>The function overwrites this variable with the corresponding OSD patch number.\n    This is also the same integer value used to identify the face when performing PTex texture mapping.</p><div class=\"argument\"><code><code>&amp;patch_u</code>, <code>&amp;patch_v</code></code></div><p>The function overwrites these variables with the corresponding U/V coordinates on the OSD patch.</p><h2>Returns</h2><p><code>1</code> on success or <code>0</code> on an error.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// This function can be used to move points generated by a scatter SOP to the</code><code class=\"codeline\">// subdivision limit surface.  The scatter SOP needs to store the \"sourceprim\"</code><code class=\"codeline\">// (the Output Attributes tab).  Texture coordinates also need to be</code><code class=\"codeline\">// transferred from the source geometry.</code><code class=\"codeline\">void</code><code class=\"codeline\">movePointToLimitSurface(string file; vector P, uv; int sourceprim)</code><code class=\"codeline\">{</code><code class=\"codeline\">    int        patch_id = -1;</code><code class=\"codeline\">    float patch_u, patch_v;</code><code class=\"codeline\">    if (osd_lookuppatch(file, sourceprim, uv.x, uv.y,</code><code class=\"codeline\">            patch_id, patch_u, patch_v, \"uv\"))</code><code class=\"codeline\">    {</code><code class=\"codeline\">        vector        tmpP;</code><code class=\"codeline\">        if (osd_limitsurface(file, \"P\", patch_id, patch_u, patch_v, tmpP))</code><code class=\"codeline\">            P = tmpP;</code><code class=\"codeline\">    }</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_lookupface\">osd_lookupface</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_patchcount\">osd_patchcount</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_facecount\">osd_facecount</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_firstpatch\">osd_firstpatch</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_limitsurface\">osd_limitsurface</a></div></body>",
    "osd_patchcount": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_patchcount\">osd_patchcount</a></h1><div class=\"usage\"> <code>int osd_patchcount(&lt;geometry&gt;)</code></div><p>Returns the number of base level patches in the subdivision hull specified by the geometry filename.  This is different that the number of faces in the subdivision hull.  For example, in a tetrahedron, each triangle face will generate three patches.</p><div class=\"usage\"> <code>int osd_patchcount(&lt;geometry&gt;, int face_id)</code></div><p>For a given face in the coarse mesh, this returns the number of patches which are generated by that face.  While a quadrilateral only generates 1 patch, all other faces will generate multiple patches based on their vertex count.  For example, a triangle will generate 3 patches, a pentagon will generate 5 patches.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_facecount\">osd_facecount</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_firstpatch\">osd_firstpatch</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_limitsurface\">osd_limitsurface</a></div></body>",
    "osd_patches": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_patches\">osd_patches</a></h1><p class=\"summary\">Returns a list of patch IDs for the patches in a subdivision hull.</p><div class=\"usage\"> <code>int[] osd_patches(&lt;geometry&gt;, int face_id)</code></div><p>Each face in a subdivision hull may create one or more patches.  This function lists the patch ids for a corresponding face.</p><p>This is implemented using the following algorithm:</p><div class=\"codeblock\"><code class=\"codeline\">int []</code><code class=\"codeline\">osd_patches(const string file; const face_id)</code><code class=\"codeline\">{</code><code class=\"codeline\">    int        patches[] = {};</code><code class=\"codeline\">    int        first = osd_firstpatch(file, face_id);</code><code class=\"codeline\">    if (first &gt;= 0)</code><code class=\"codeline\">    {</code><code class=\"codeline\">        int        npatches = osd_patchcount(file, face_id);</code><code class=\"codeline\">        for (int i = 0; i &lt; npatches; i++)</code><code class=\"codeline\">            append(patches, first+i);</code><code class=\"codeline\">    }</code><code class=\"codeline\">    return patches;</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_facecount\">osd_facecount</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_firstpatch\">osd_firstpatch</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_limitsurface\">osd_limitsurface</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_limitsurfacevertex\">osd_limitsurfacevertex</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/osd_patchcount\">osd_patchcount</a></div></body>",
    "outerproduct": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/outerproduct\">outerproduct</a></h1><p class=\"summary\">Returns the outer product between the arguments.</p><div class=\"usage\"> <code>matrix2 outerproduct(vector2 v, vector2 v)</code></div><div class=\"usage\"> <code>matrix3 outerproduct(vector v, vector v)</code></div><div class=\"usage\"> <code>matrix outerproduct(vector4 v, vector4 v)</code></div><p>Returns the <a href=\"https://en.wikipedia.org/wiki/Outer_product\">outer product</a> of the given vectors.</p></body>",
    "ow_nspace": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ow_nspace\">ow_nspace</a></h1><p class=\"summary\">Transforms a normal vector from Object to World space.</p><div class=\"usage\"> <code>vector ow_nspace(vector v)</code></div><p>Transforms a normal vector from <em>Object</em> to <em>World</em> space.</p></body>",
    "ow_space": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ow_space\">ow_space</a></h1><p class=\"summary\">Transforms a position value from Object to World space.</p><div class=\"usage\"> <code>matrix ow_space()</code></div><div class=\"usage\"> <code>vector ow_space(vector v)</code></div><div class=\"usage\"> <code>vector4 ow_space(vector4 v)</code></div><p>Transforms a position value from <em>Object</em> to <em>World</em> space.</p></body>",
    "ow_vspace": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ow_vspace\">ow_vspace</a></h1><p class=\"summary\">Transforms a direction vector from Object to World space.</p><div class=\"usage\"> <code>vector ow_vspace(vector v)</code></div><p>Transforms a direction vector from <em>Object</em> to <em>World</em> space.</p></body>",
    "packedtransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/packedtransform\">packedtransform</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Transforms a packed primitive.</p><div class=\"usage\"> <code>void packedtransform(int input, int primnum, matrix transform)</code></div><p>Transforms a packed primitive by the specified transform. This modifies the <code>P</code>\nattribute of the primitive\u2019s point as well as its intrinsic <code>transform</code>.</p><p>This is equivalent to the following code.</p><div class=\"codeblock\"><code class=\"codeline\">// matrix to transform by</code><code class=\"codeline\">matrix transform = ident();</code><code class=\"codeline\">rotate(transform, radians(45), {0,1,0});</code><code class=\"codeline\">translate(transform, {0,1,0});</code><code class=\"codeline\"></code><code class=\"codeline\">// get current packed transform</code><code class=\"codeline\">matrix3 primtf = primintrinsic(0, \"transform\", primnum);</code><code class=\"codeline\">setprimintrinsic(0, \"transform\", primnum, primtf * (matrix3)transform);</code><code class=\"codeline\">int primpoint = primpoint(0, primnum, 0);</code><code class=\"codeline\">vector pos = point(0, \"P\", primpoint);</code><code class=\"codeline\">setpointattrib(0, \"P\", primpoint, pos * transform);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpackedtransform\">setpackedtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getpackedtransform\">getpackedtransform</a></div></body>",
    "pack_inttosafefloat": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pack_inttosafefloat\">pack_inttosafefloat</a></h1><p class=\"summary\">Reversibly packs an integer into a finite, non-denormal float.</p><div class=\"usage\"> <code>float pack_inttosafefloat(int i)</code></div><p>This is used to find the w component of a primitive uvw vector\nreferring to a polygon soup primitive, from the inner polygon number.</p><div class=\"related\">Integers in the range <code>abs(i) &lt;= (2^24) = 16,777,216</code> will be represented exactly by the floats of the same value.</div><div class=\"related\">Integers in the range <code>16,777,216 &lt; abs(i) &lt; (2^24) + 104*(2^23) = 889,192,448</code> will be represented by larger, non-infinite floats.</div><div class=\"related\">Integers in the range <code>889,192,448 &lt;= abs(i) &lt; (2^24) + 230*(2^23) = 1,946,157,056</code>\nwill be represented by small, non-denormal floats.</div><div class=\"related\">Any other integers, <code>abs(i) &gt;= 1,946,157,056</code>, will not be represented correctly.</div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/unpack_intfromsafefloat\">unpack_intfromsafefloat</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primuv\">primuv</a></div></body>",
    "pathtrace": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pathtrace\">pathtrace</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Computes global illumination using PBR for secondary bounces.</p><div class=\"usage\"> <code>vector pathtrace(vector P, vector N, ...)</code></div><p><code>pathtrace</code> works like <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/irradiance\">irradiance</a>, but uses the physically based\nrendering (PBR) engine to do secondary bounces.</p><p><code>pathtrace</code> provides a simple (and not very flexible) method of invoking the\nPBR rendering engine from micro-polygon rendering. It uses path tracing and\nthe <code>F</code> (BSDF) output, not <code>Cf</code>/<code>Of</code> on the hit shaders. Maximum path depth\nis controlled by the diffuse bounces parameter on the PBR tab of the\n<a href=\"https://www.sidefx.com/docs/houdini/nodes/out/ifd\">mantra output driver</a>.</p><p>Irradiance caching works the same way it works with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/occlusion\">occlusion</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/occlusion\">occlusion</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/irradiance\">irradiance</a></div></body>",
    "pcclose": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcclose\">pcclose</a></h1><p class=\"summary\">This function closes the handle associated with a pcopen\nfunction.</p><div class=\"usage\"> <code>void pcclose(int &amp;handle)</code></div><p>This function closes the handle associated with a pcopen function. VEX\nwill close handles automatically, however, it\u2019s good practice to call\npcclose. When there are pcopen calls made from within a loop, VEX may\nconsume additional memory if pcclose isn\u2019t called when the handle is no\nlonger required.</p></body>",
    "pccone": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pccone\">pccone</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns a list of closest points from a file within a specified cone.</p><div class=\"usage\"> <code>int[] pccone(&lt;geometry&gt;, string PChannel, vector P, vector dir, float angle, float max_distance, int maxpoints)</code></div><div class=\"usage\"> <code>int[] pccone(&lt;geometry&gt;, string ptgroup, string PChannel, vector P, vector dir, float angle, float max_distance, int maxpoints)</code></div><p>These functions open a geometry file and return a list of points within the cone whose apex is <code class=\"var\">P</code>, opens in the vector direction <code class=\"var\">dir</code>, and with angle <code class=\"var\">angle</code> to <code class=\"var\">dir</code>. Additionally, it only returns the closest <code class=\"var\">maxpoints</code> points within distance <code class=\"var\">max_distance</code> of <code class=\"var\">P</code>.</p><p>The <code>ptgroup</code> is a point group that limits the points to search.  This is a SOP-style group pattern, so can be something like <code>0-10</code> or <code>@Cd.x&gt;0.5</code>.  A blank string is treated as matching all points.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoint\">nearpoint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoints\">nearpoints</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pccone_radius\">pccone_radius</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind\">pcfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind_radius\">pcfind_radius</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pgfind\">pgfind</a></div></body>",
    "pccone_radius": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pccone_radius\">pccone_radius</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns a list of closest points from a file in a cone, taking into account their radii</p><div class=\"usage\"> <code>int[] pccone_radius(&lt;geometry&gt;, string PChannel, string RadChannel, float radscale, vector P, vector dir, float angle, float max_distance, int maxpoints)</code></div><div class=\"usage\"> <code>int[] pccone_radius(&lt;geometry&gt;, string ptgroup, string PChannel, string RadChannel, float radscale, vector P, vector dir, float angle, float max_distance, int maxpoints)</code></div><p>These functions open a geometry file and return a list of points within the cone whose apex is <code class=\"var\">P</code>, opens in the vector direction <code class=\"var\">dir</code>, and with angle <code class=\"var\">angle</code> to <code class=\"var\">dir</code>. Additionally, it only returns the closest <code class=\"var\">maxpoints</code> points within distance <code class=\"var\">max_distance</code> of <code class=\"var\">P</code>. Each of the points will be expanded by their <code class=\"var\">RadChannel</code> attribute, which will be dilated by <code class=\"var\">radscale</code>.</p><p>Using a radius channel allows intersection detection between spheres of varying radii. In this case you cannot use only your own sphere radius, as the intersecting sphere may have a much larger radius so not be in your search window.  Because of this, it is also sensible to use a 0.0 <code class=\"var\">radius</code> with this function just to find all the source spheres that your query position is inside of.</p><p>The <code>ptgroup</code> is a point group that limits the points to search.  This is a SOP-style group pattern, so can be something like <code>0-10</code> or <code>@Cd.x&gt;0.5</code>.  A blank string is treated as matching all points.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoint\">nearpoint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoints\">nearpoints</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pccone\">pccone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind\">pcfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind_radius\">pcfind_radius</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pgfind\">pgfind</a></div></body>",
    "pcconvex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcconvex\">pcconvex</a></h1><div class=\"usage\"> <code>float pcconvex(int handle, string channel, vector N)</code></div><p>Calculates the 2D projected convex hull area for the given point cloud <code>handle</code>\nalong the given normal, where <code>handle</code> was returned by a prior call to <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div></body>",
    "pcexport": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcexport\">pcexport</a></h1><p class=\"summary\">Writes data to a point cloud inside a <code>pciterate</code> or a <code>pcunshaded</code> loop.</p><div class=\"usage\"> <code>int pcexport(int handle, string channel_name, &lt;type&gt; value, ...)</code></div><div class=\"usage\"> <code>int pcexport(int handle, string channel_name, vector value, float radius, ...)</code></div><p>Returns 1 if the export succeeded or 0 if the export failed.\nThe export will fail if <code class=\"var\">channel_name</code> is not read-write or if (in the\nversion of pcexport taking a radius) the point being exported is at a\ndistance less than the specified radius from a point that is already in the\npoint cloud.</p><p>This function writes to the channels of points opened with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a> or\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcgenerate\">pcgenerate</a>. The second version of this function takes a radius parameter and uses it to accept or reject the point being exported according to its distance to the points that are already in the point cloud.  It must be separated from all other points by at least the specified radius.  To write new point data into a point cloud file, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcwrite\">pcwrite</a>.</p><h2>Storage type</h2><p>If you add the <code>\"storage\"</code> optional keyword, the next argument specifies a storage type for the data.\nStorage types are the standard tile based format data types:</p><span><code>int8, uint8</code> </span><p>8 bit signed/unsigned integers</p><span><code>int16, uint16</code> </span><p>16 bit signed/unsigned integers</p><span><code>int32, uint32</code> </span><p>32 bit signed/unsigned integers</p><span><code>int64, uint64</code> </span><p>64 bit signed/unsigned integers</p><span><code>real16</code> </span><p>16 bit floating point values</p><span><code>real32</code> </span><p>32 bit floating point values</p><span><code>real64</code> </span><p>64 bit floating point values</p><span><code>int</code>, <code>uint</code>, <code>real</code> </span><p>Default precision integer/floating point values</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcwrite\">pcwrite</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pciterate\">pciterate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcunshaded\">pcunshaded</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcimport\">pcimport</a></div></body>",
    "pcfarthest": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfarthest\">pcfarthest</a></h1><p class=\"summary\">Returns the distance to the farthest point found in the search\nperformed by pcopen.</p><div class=\"usage\"> <code>float pcfarthest(int handle)</code></div><p>Returns the distance to the farthest point found in the search performed\nby pcopen. If no points were found, the function will return a very\nlarge value (1.0\u00d710^37)</p></body>",
    "pcfilter": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfilter\">pcfilter</a></h1><p class=\"summary\">Filters points found by <code>pcopen</code> using a simple reconstruction filter.</p><div class=\"usage\"> <code>&lt;type&gt; pcfilter(int handle, string channel_name, ...)</code></div><p>Filters the points queued up by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a>\nusing a simple reconstruction filter.</p><p>This function is roughly equivalent to:</p><div class=\"codeblock\"><code class=\"codeline\">float pcfilter(int handle; string channel)</code><code class=\"codeline\">{</code><code class=\"codeline\">    float    sum, w, d;</code><code class=\"codeline\">    float    value, result = 0;</code><code class=\"codeline\">    while (pciterate(handle))</code><code class=\"codeline\">    {</code><code class=\"codeline\">        pcimport(handle, \"point.distance\", d);</code><code class=\"codeline\">        pcimport(handle, channel, value);</code><code class=\"codeline\">        w = 1 - smooth(0, radius, d);</code><code class=\"codeline\">        sum += w;</code><code class=\"codeline\">        result += w * value;</code><code class=\"codeline\">    }</code><code class=\"codeline\">    result /= sum;</code><code class=\"codeline\">    return result;</code><code class=\"codeline\">}</code></div><p><code>pcfilter</code> takes the points that were opened by the point cloud and produces a filtered value. The following equation shows how the individual points are weighted.</p><div class=\"codeblock\"><code class=\"codeline\">w_i = 1-smooth(0, maxd*1.1, d_i);</code></div><p><code>maxd</code> is the farthest point, and <code>w_i</code> is the weight for a given point at distance (<code>d_i</code>). Points that are closer to the center will be weighted higher with that formula, rather than it being an average.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div></body>",
    "pcfind": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind\">pcfind</a></h1><p class=\"summary\">Returns a list of closest points from a file.</p><div class=\"usage\"> <code>int[] pcfind(&lt;geometry&gt;, string Pchannel, vector P, float radius, int maxpoints)</code></div><div class=\"usage\"> <code>int[] pcfind(&lt;geometry&gt;, string ptgroup, string Pchannel, vector P, float radius, int maxpoints)</code></div><div class=\"usage\"> <code>int[] pcfind(&lt;geometry&gt;, string Pchannel, vector P, float radius, int maxpoints, float &amp;distances[])</code></div><div class=\"usage\"> <code>int[] pcfind(&lt;geometry&gt;, string ptgroup, string Pchannel, vector P, float radius, int maxpoints, float &amp;distances[])</code></div><p>These functions open a geometry file and return a list of points with the location <code class=\"var\">P</code> within <code class=\"var\">radius</code>, based on point positions found in <code class=\"var\">Pchannel</code>.  Only the <code class=\"var\">maxpoints</code> closest points within the given radius will be returned. The file name may use the <code>op:</code> syntax to reference SOP geometry in the OP contexts.  The <code class=\"var\">Pchannel</code> parameter indicates the attribute which contains the positions to be searched.</p><p>The <code>ptgroup</code> is a point group that limits the points to search.  This is a SOP-style group pattern, so can be something like <code>0-10</code> or <code>@Cd.x&gt;0.5</code>.  A blank string is treated as matching all points.</p><p>The function also optionally takes a float array <code>distances</code>, which it modifies with the distances to each point.</p><p>The closest point is in entry 0 of the returned array, and the other points are sorted by increasing distance.</p><h2>Examples</h2><p>Performing a proximity query:</p><div class=\"codeblock\"><code class=\"codeline\">int closept[] = pcfind(filename, \"P\", P, maxdistance, maxpoints);</code><code class=\"codeline\">P = 0;</code><code class=\"codeline\">foreach (int ptnum; closept)</code><code class=\"codeline\">{</code><code class=\"codeline\">    vector closepos = point(filename, \"P\", ptnum);</code><code class=\"codeline\">    P += closepos;</code><code class=\"codeline\">}</code><code class=\"codeline\">P /= len(closept);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoint\">nearpoint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoints\">nearpoints</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind_radius\">pcfind_radius</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pgfind\">pgfind</a></div></body>",
    "pcfind_radius": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind_radius\">pcfind_radius</a></h1><p class=\"summary\">Returns a list of closest points from a file taking into account their radii.</p><div class=\"usage\"> <code>int[] pcfind_radius(&lt;geometry&gt;, string Pchannel, string RadChannel, float radscale, vector P, float radius, int maxpoints)</code></div><div class=\"usage\"> <code>int[] pcfind_radius(&lt;geometry&gt;, string ptgroup, string Pchannel, string RadChannel, float radscale, vector P, float radius, int maxpoints)</code></div><div class=\"usage\"> <code>int[] pcfind_radius(&lt;geometry&gt;, string Pchannel, string RadChannel, float radscale, vector P, float radius, int maxpoints, float &amp;distances[])</code></div><div class=\"usage\"> <code>int[] pcfind_radius(&lt;geometry&gt;, string ptgroup, string Pchannel, string RadChannel, float radscale, vector P, float radius, int maxpoints, float &amp;distances[])</code></div><p>These functions open a geometry file and return a list of points with the\nlocation <code class=\"var\">P</code> within <code class=\"var\">radius</code>, based on point positions found in\n<code class=\"var\">Pchannel</code>.  Each of the points will be expanded by their <code class=\"var\">RadChannel</code>\nattribute, which will be dilated by <code class=\"var\">radscale</code>.</p><p>Using a radius channel allows intersection detection between spheres of varying radii.  In this case you cannot use only your own sphere radius, as the intersecting sphere may have a much larger radius so not be in your search window.  Because of this, it is also sensible to use a 0.0 <code class=\"var\">radius</code> with this function just find all the source spheres that your query position is inside of.</p><p>Only the <code class=\"var\">maxpoints</code> closest points within the given radius\nwill be returned. The file name may use the <code>op:</code> syntax to reference SOP\ngeometry in the OP contexts.  The <code class=\"var\">Pchannel</code> parameter indicates the\nattribute which contains the positions to be searched.</p><p>The <code class=\"var\">ptgroup</code> is a point group that limits the points to search.  This is a <a href=\"https://www.sidefx.com/docs/houdini/model/groups#manual\">SOP-style group pattern</a>, so can be something like <code>0-10</code> or <code>@Cd.x&gt;0.5</code>.  A blank string is treated as matching all points.</p><p>The function also optionally takes a float array <code>distances</code>, which it modifies with the distances to each point.</p><h2>Note</h2><p>The radius attribute and radius scale apply to the points being searched, not to the point you are doing the searching with!</p><h2>Note</h2><p>If the radius attribute does not exist, this becomes equivalent to <code>pcfind</code>.</p><h2>Examples</h2><p>Performing a proximity query:</p><div class=\"codeblock\"><code class=\"codeline\">int closept[] = pcfind_radius(filename, \"P\", \"pscale\", 1.0, P, maxdistance, maxpoints);</code><code class=\"codeline\">P = 0;</code><code class=\"codeline\">foreach (int ptnum; closept)</code><code class=\"codeline\">{</code><code class=\"codeline\">    vector closepos = point(filename, \"P\", ptnum);</code><code class=\"codeline\">    P += closepos;</code><code class=\"codeline\">}</code><code class=\"codeline\">P /= len(closept);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoint\">nearpoint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoints\">nearpoints</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind\">pcfind</a></div></body>",
    "pcgenerate": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcgenerate\">pcgenerate</a></h1><p class=\"summary\">Generates a point cloud.</p><div class=\"usage\"> <code>int pcgenerate(string filename, int npoints)</code></div><p>This function returns a handle to the point cloud with the specified name or\ncreates a new point cloud with the specified name and number of points.\nInitially, the point cloud has no channels, but channels can be added using\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcexport\">pcexport</a> in a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcunshaded\">pcunshaded</a> loop.  Note that if pcgenerate() is called\nwith the name of a point cloud that already exists, that point cloud will not\nbe re-sized to contain the specified number of points.</p><p>Once a position channel has been established, call <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a> to query the\ngenerated point cloud.  Note that calling <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a> will lock the specified\nposition channel.  Once a point cloud has been opened, it is considered to be\ngenerated.  Calling pcgenerate() with the name of a generated point cloud is\nsimilar to calling pcopen() and requesting 0 points: no points will be available\nin a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcunshaded\">pcunshaded</a> or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pciterate\">pciterate</a> loop.</p><p>This function only stores a point cloud in RAM. To write points to disk, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcwrite\">pcwrite()</a>.</p><h2>Note</h2><p>We refer to the parameter as a filename to be consistent with <code>pcopen()</code>. The two functions share the same namespace. That is, if you call <code>pcgenerate(\"myfile.pc\", ...)</code>, you can then query <code>\"myfile.pc\"</code> by calling <code>pcopen(\"myfile.pc\", ...)</code> or <code>pcopenlod(\"myfile.pc\", ...)</code>.</p><p>This works the other way as well. If you call <code>pcopen(\"myfile.pc\", ...)</code> and then call <code>pcgenerate(\"myfile.pc\", ...)</code>, the <code>pcgenerate()</code> call will use the point cloud that is already loaded into memory through the <code>pcopen()</code> call rather than creating a new point cloud.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">vector position;</code><code class=\"codeline\">int ohandle, ghandle, rval;</code><code class=\"codeline\"></code><code class=\"codeline\">ghandle = pcgenerate(texturename, npoints);</code><code class=\"codeline\">while (pcunshaded(ghandle, \"P\"))</code><code class=\"codeline\">{</code><code class=\"codeline\">    // Compute 'position'...</code><code class=\"codeline\">    rval = pcexport(ghandle, \"P\", position);</code><code class=\"codeline\">}</code><code class=\"codeline\"></code><code class=\"codeline\">ohandle = pcopen(texturename, \"P\", P, maxdistance, maxpoints);</code><code class=\"codeline\">while (pciterate(ohandle))</code><code class=\"codeline\">{</code><code class=\"codeline\">    rval = pcimport(ohandle, \"P\", position);</code><code class=\"codeline\">    // Do something with 'position'...</code><code class=\"codeline\">}</code><code class=\"codeline\"></code><code class=\"codeline\">pcclose(ohandle);</code><code class=\"codeline\">pcclose(ghandle);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcwrite\">pcwrite</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfilter\">pcfilter</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pciterate\">pciterate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcunshaded\">pcunshaded</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcimport\">pcimport</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcexport\">pcexport</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcclose\">pcclose</a></div></body>",
    "pcimport": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcimport\">pcimport</a></h1><p class=\"summary\">Imports channel data from a point cloud inside a <code>pciterate</code> or a <code>pcunshaded</code> loop.</p><p>This function is only valid while looping with <code>pciterate</code> or <code>pcunshaded</code>.</p><div class=\"usage\"> <code>int pcimport(int handle, string channel_name, &lt;type&gt; &amp;value)</code></div><p>Imports data from the point cloud file into the given variable.</p><div class=\"argument\"><code>channel_name</code></div><p>There are two special channel names you can import:</p><div class=\"argument\"><code><code>point.number</code></code></div><p>The number of the point being processed.</p><div class=\"argument\"><code><code>point.distance</code></code></div><p>The distance of the point being processed from the query point.\n        This is only available when iterating over unshaded points.</p><div class=\"argument\"><code>value</code></div><p>If the import succeeds the function overwrites this variable with the channel value.</p><h2>Returns</h2><p><code>1</code> if the import succeeded or <code>0</code> if the import failed (usually due to the given channel name not existing).</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pciterate\">pciterate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcunshaded\">pcunshaded</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcexport\">pcexport</a></div></body>",
    "pcimportbyidx3": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcimportbyidx3\">pcimportbyidx3</a></h1><p class=\"summary\">Imports channel data from a point cloud outside a <code>pciterate</code> or a <code>pcunshaded</code> loop.</p><div class=\"usage\"> <code>matrix3 pcimportbyidx3(int handle, string channel_name, int idx)</code></div><p>After a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a> and a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcnumfound\">pcnumfound</a>, this can be used to extract\nspecific search results from the found points.</p><p>This will return 0 if the channel doesn\u2019t exist.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcnumfound\">pcnumfound</a></div></body>",
    "pcimportbyidx4": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcimportbyidx4\">pcimportbyidx4</a></h1><p class=\"summary\">Imports channel data from a point cloud outside a <code>pciterate</code> or a <code>pcunshaded</code> loop.</p><div class=\"usage\"> <code>matrix pcimportbyidx4(int handle, string channel_name, int idx)</code></div><p>After a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a> and a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcnumfound\">pcnumfound</a>, this can be used to extract specific search results from the found points.</p><p>This will return 0 if the channel doesn\u2019t exist.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcnumfound\">pcnumfound</a></div></body>",
    "pcimportbyidxf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcimportbyidxf\">pcimportbyidxf</a></h1><p class=\"summary\">Imports channel data from a point cloud outside a <code>pciterate</code> or a <code>pcunshaded</code> loop.</p><div class=\"usage\"> <code>float pcimportbyidxf(int handle, string channel_name, int idx)</code></div><p>After a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a> and a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcnumfound\">pcnumfound</a>, this can be used to extract specific search results from the found points.</p><p>This will return 0 if the channel doesn\u2019t exist.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcnumfound\">pcnumfound</a></div></body>",
    "pcimportbyidxi": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcimportbyidxi\">pcimportbyidxi</a></h1><p class=\"summary\">Imports channel data from a point cloud outside a <code>pciterate</code> or a <code>pcunshaded</code> loop.</p><div class=\"usage\"> <code>int pcimportbyidxi(int handle, string channel_name, int idx)</code></div><p>After a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a> and a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcnumfound\">pcnumfound</a>, this can be used to extract specific search results from the found points.</p><p>This will return 0 if the channel doesn\u2019t exist.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcnumfound\">pcnumfound</a></div></body>",
    "pcimportbyidxp": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcimportbyidxp\">pcimportbyidxp</a></h1><p class=\"summary\">Imports channel data from a point cloud outside a <code>pciterate</code> or a <code>pcunshaded</code> loop.</p><div class=\"usage\"> <code>vector4 pcimportbyidxp(int handle, string channel_name, int idx)</code></div><p>After a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a> and a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcnumfound\">pcnumfound</a>, this can be used to extract specific search results from the found points.</p><p>This will return 0 if the channel doesn\u2019t exist.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcnumfound\">pcnumfound</a></div></body>",
    "pcimportbyidxs": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcimportbyidxs\">pcimportbyidxs</a></h1><p class=\"summary\">Imports channel data from a point cloud outside a <code>pciterate</code> or a <code>pcunshaded</code> loop.</p><div class=\"usage\"> <code>string pcimportbyidxs(int handle, string channel_name, int idx)</code></div><p>After a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a> and a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcnumfound\">pcnumfound</a>, this can be used to extract specific search results from the found points.</p><p>This will return 0 if the channel doesn\u2019t exist.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcnumfound\">pcnumfound</a></div></body>",
    "pcimportbyidxv": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcimportbyidxv\">pcimportbyidxv</a></h1><p class=\"summary\">Imports channel data from a point cloud outside a <code>pciterate</code> or a <code>pcunshaded</code> loop.</p><div class=\"usage\"> <code>vector pcimportbyidxv(int handle, string channel_name, int idx)</code></div><p>After a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a> and a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcnumfound\">pcnumfound</a>, this can be used to extract specific search results from the found points.</p><p>This will return 0 if the channel doesn\u2019t exist.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcnumfound\">pcnumfound</a></div></body>",
    "pciterate": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pciterate\">pciterate</a></h1><p class=\"summary\">This function can be used to iterate over all the points which were\nfound in the pcopen query.</p><div class=\"usage\"> <code>int pciterate(int handle)</code></div><p>This function can be used to iterate over all the points which were\nfound in a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a> query. The first argument is the <code class=\"var\">handle</code>\nreturned by <code>pcopen</code>.\nThe function returns 1 while there are points left in the iteration loop,\nor 0 when there are no further points. This lets you use the function as\nthe condition in a <a href=\"https://www.sidefx.com/docs/houdini/vex/statement\">while loop</a>.</p><p>Warnings:</p><div class=\"related\">It is not possible to nest pcunshaded or pciterate loops for the same\nhandle. That is, for a single <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a> call, only one\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcunshaded\">pcunshaded</a> or <code>pciterate</code> loop may be entered.</div><div class=\"related\">Computations involving derivatives inside <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcunshaded\">pcunshaded</a>\nloops may have slightly different results. If derivatives are required\nfor variables which aren\u2019t set by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcimport\">pcimport</a> it may be\nbetter to pre-compute the derivatives before the\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcunshaded\">pcunshaded</a> loop is entered.</div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcunshaded\">pcunshaded</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcimport\">pcimport</a></div></body>",
    "pcline": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcline\">pcline</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns a list of closest points to an infinite line from a specified file</p><div class=\"usage\"> <code>int[] pcline(&lt;geometry&gt;, string PChannel, vector P, vector dir, float max_distance, int maxpoints)</code></div><div class=\"usage\"> <code>int[] pcline(&lt;geometry&gt;, string ptgroup, string PChannel, vector P, vector dir, float max_distance, int maxpoints)</code></div><p>These functions open a geometry file and return a list of points within <code class=\"var\">max_distance</code> of the line passing through <code class=\"var\">P</code> with direction <code class=\"var\">dir</code>. </p><p>The <code>ptgroup</code> is a point group that limits the points to search.  This is a SOP-style group pattern, so can be something like <code>0-10</code> or <code>@Cd.x&gt;0.5</code>.  A blank string is treated as matching all points.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoint\">nearpoint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoints\">nearpoints</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pccone_radius\">pccone_radius</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind\">pcfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind_radius\">pcfind_radius</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pgfind\">pgfind</a></div></body>",
    "pcline_radius": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcline_radius\">pcline_radius</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns a list of closest points to an infinite line from a specified file</p><div class=\"usage\"> <code>int[] pcline_radius(&lt;geometry&gt;, string PChannel, string RadChannel, float radscale, vector P, vector dir, float max_distance, int maxpoints)</code></div><div class=\"usage\"> <code>int[] pcline_radius(&lt;geometry&gt;, string ptgroup, string PChannel, string RadChannel, float radscale, vector P, vector dir, float max_distance, int maxpoints)</code></div><p>These functions open a geometry file and return a list of points (treated as spheres) within <code class=\"var\">max_distance</code> of the line passing through <code class=\"var\">P</code> with direction <code class=\"var\">dir</code>. Each point is treated as a sphere with radius equal to its <code class=\"var\">RadChannel</code> attribute, </p><p>multiplied by <code class=\"var\">radscale</code>.</p><p>The <code>ptgroup</code> is a point group that limits the points to search.  This is a SOP-style group pattern, so can be something like <code>0-10</code> or <code>@Cd.x&gt;0.5</code>.  A blank string is treated as matching all points.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoint\">nearpoint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoints\">nearpoints</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pccone_radius\">pccone_radius</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind\">pcfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind_radius\">pcfind_radius</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pgfind\">pgfind</a></div></body>",
    "pcnumfound": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcnumfound\">pcnumfound</a></h1><p class=\"summary\">This node returns the number of points found by pcopen.</p><p>This node returns the number of points found by a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a> query.</p><p>For example, if 10 points are being filtered, and 6 are within the\nsearch radius, <code>pcnumfound</code> will return 6.</p><div class=\"usage\"> <code>int pcnumfound(int handle)</code></div><p>Returns the number of found points from the search performed by\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div></body>",
    "pcopen": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></h1><p class=\"summary\">Returns a handle to a point cloud file.</p><div class=\"usage\"> <code>int pcopen(string filename, string channel, int shaded, ...)</code></div><div class=\"usage\"> <code>int pcopen(string filename, string Pchannel, vector P, float radius, int maxpoints, ...)</code></div><div class=\"usage\"> <code>int pcopen(string filename, string Pchannel, vector P, string Nchannel, vector N, float radius, int maxpoints, ...)</code></div><div class=\"usage\"> <code>int pcopen(int opinput, string Pchannel, vector P, float radius, int maxpoints)</code></div><p>This function opens a point cloud file (<code>.pc</code>) and queues up access to the\npoints contained in it.  You can then iterate over the points with\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcunshaded\">pcunshaded</a> or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pciterate\">pciterate</a>.</p><p>The first two versions of this function queue up points centered around a\ncertain location <code class=\"var\">P</code> within <code class=\"var\">radius</code>, based on point positions found in\n<code class=\"var\">Pchannel</code>.  Only the <code class=\"var\">maxpoints</code> closest points within the given\nradius will be queued.  When using <code>pcopen()</code> with <code>pciterate()</code>, points will\nbe sorted from nearest to farthest.  The file name may use the <code>op:</code> syntax\nto reference SOP geometry in the OP contexts.  The <code class=\"var\">Pchannel</code> parameter\nindicates the channel in the texture which contains the positions to be\nsearched. <code class=\"var\">Pchannel</code> will be made read-only if it is not already. Any\nsubsequent attempts to use the channel with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcexport\">pcexport</a> or\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcunshaded\">pcunshaded</a> will fail.  Optionally, the <code class=\"var\">Nchannel</code> specifies a\ndirection channel and the <code class=\"var\">N</code> vector specifies a search direction. Only\npoints which are pointed in the same direction (i.e. <code>dot(N, Npoint) &gt; 0</code>)\nwill be queued.</p><p>In some cases, you may need to add additional channels to a point cloud.  You can do this by using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcexport\">pcexport</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcunshaded\">pcunshaded</a>.  Often,\nyou will not need to add extra channel data to every point in the point cloud. For example, if only part of the point cloud is inside the camera\u2019s frustum.\nIn these cases, it is best to only add channel data to points returned by\na proximity query.  However, sometimes all points in a point cloud must\nreceive extra channel data before meaningful queries can be made. For example, when adding a position channel.  In these cases, the third version of this function can be used to queue up all shaded (<code class=\"var\">shaded</code> != 0) or unshaded (<code class=\"var\">shaded</code> == 0) points of a certain channel, <code class=\"var\">channel</code>.  If <code class=\"var\">channel</code> does not exist, all points will be queued.  This function, unlike the first two, does not lock <code class=\"var\">channel</code>.</p><p>You can specify an additional string parameter <code>\"prefix\"</code>, with the next\nparameter being a channel prefix string, used to reference tiled block\nfiles.</p><h2>Note</h2><p>The preload option loads the entire point cloud into memory. Disabling this option will cause it to use a tile cache.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int handle = pcopen(texturename, \"P\", P, maxdistance, maxpoints);</code><code class=\"codeline\">    while (pcunshaded(handle, \"irradiance\"))</code><code class=\"codeline\">    {</code><code class=\"codeline\">        pcimport(handle, \"P\", cloudP);</code><code class=\"codeline\">        pcimport(handle, \"N\", cloudN);</code><code class=\"codeline\">        ir = computeIrraciance(cloudP, cloudN);</code><code class=\"codeline\">        pcexport(handle, \"irradiance\", ir);</code><code class=\"codeline\">    }</code><code class=\"codeline\">    pcfilter(handle, radius, \"irradiance\", ir);</code></div><div class=\"codeblock\"><code class=\"codeline\">vector sample;</code><code class=\"codeline\">    int rval, handle;</code><code class=\"codeline\"></code><code class=\"codeline\">    handle = pcopen(texturename, \"P\", 0);</code><code class=\"codeline\">    while (pcunshaded(handle, \"P\"))</code><code class=\"codeline\">    {</code><code class=\"codeline\">        sample = set(nrandom(\"qstrat\"), nrandom(\"qstrat\"), 0.0);</code><code class=\"codeline\">        rval = sample_geometry(</code><code class=\"codeline\">            sample, sample, Time,</code><code class=\"codeline\">            \"scope\", getobjectname(),</code><code class=\"codeline\">            \"pipeline\", \"displacement\",</code><code class=\"codeline\">            \"P\", pos);</code><code class=\"codeline\">        if (rval)</code><code class=\"codeline\">            rval = pcexport(handle, \"P\", pos);</code><code class=\"codeline\">    }</code><code class=\"codeline\">    pcclose(handle);</code></div><div class=\"codeblock\"><code class=\"codeline\">// This will only return points where dot(N, Npoint) &gt; 0.8</code><code class=\"codeline\">    int handle = pcopen(\"test.pc\", \"P\", P, \"N\", N, 1e6, 100, \"ndot\", 0.8);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcgenerate\">pcgenerate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcwrite\">pcwrite</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfilter\">pcfilter</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pciterate\">pciterate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcunshaded\">pcunshaded</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcimport\">pcimport</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcclose\">pcclose</a></div></body>",
    "pcopenlod": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopenlod\">pcopenlod</a></h1><p class=\"summary\">Returns a handle to a point cloud file.</p><div class=\"usage\"> <code>int pcopenlod(string filename, string Pchannel, vector P, int min_pts, ...)</code></div><p>This function opens a point cloud file (<code>.pc</code>) and queues up access to the\npoints contained in it.  You can then iterate over the points with\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcunshaded\">pcunshaded</a> or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pciterate\">pciterate</a> and add new data to the point cloud using\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcexport\">pcexport</a>.</p><p>While this function is similar to <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a>, the major difference is the points that it queues up may be aggregates of entire groups of points.  In\nother words, a single point may represent many points.  This allows you to\nperform queries at any desired level of detail without ignoring points in the\npoint cloud.  For example, you can perform a query in which points\nnear the query origin are queued up as usual, but points far from the origin\nare averaged.  This can lead to dramatic performance increases because entire\ngroups of points can be processed as if they are a single point.</p><p>As in <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a>, <code class=\"var\">P</code> specifies the query origin and <code class=\"var\">Pchannel</code>\nspecifies the position channel.  During construction, the tree structure\nstarts out as a single bounding box that encompasses all the points in a\npoint cloud, and is recursively subdivided until there are fewer than\n<code class=\"var\">min_pts</code> points in a node - at which point subdivision stops and a leaf\nnode is created.  A good default for <code class=\"var\">min_pts</code> is 8.</p><p>Queries are performed by descending the tree structure from the root node\nuntil some condition is met.  Conceptually, you start with a coarse query\nand refine it until you decide that it is detailed enough.  You use a\n<code>measure</code> to decide when the query has the desired level of detail.  Two\n<code>measure</code> values are supported: <code>distance</code> and <code>solidangle</code>.</p><h2>Distance Queries</h2><p><code>distance</code> mode is provided for compatibility with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a> and does\nnot queue up aggregate points.  Distance queries take a threshold parameter\nthat indicates the radius within which to accept points.</p><p>The <code>threshold</code> argument specifies the radius within which points are\naccepted - identical to the radius passed to <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a>.  For example,\ncalling <code>pcopenlod</code>(\u2026, <code>\"measure\"</code>, <code>\"distance\"</code>, <code>\"threshold\"</code>, radius, \u2026)\nqueues up points that lie within the specified radius of the query origin.</p><h2>Solid Angle Queries</h2><p>Solid angle queries prioritize points by how close they are to the query\npoint and also by the area of the point, so points that are close to the\nquery point and that have a large area are given a greater weight.  The\nquery process will tend to split points with a larger contribution by\nqueueing their children.</p><p>The exact equation used to compute point contribution is the following:</p><p>Ai / ||Pi - P||^2,</p><p>where Ai is an aggregate area value, Pi is the closest point to P in the\naggregate box, and P is the query origin.  Calling <code>pcopenlod</code>(\u2026,\n<code>\"measure\"</code>, <code>\"solidangle\"</code>, <code>\"area\"</code>, <code>\"A\"</code>, \u2026) performs a solid-angle query\nin which the <code>A</code> channel is assumed to hold area values.</p><p>There are two different ways to use the solid angle query - an unlimited\n(<code>threshold</code>) query which returns a different number of points depending on\nhow many points meet the given threshold, and a limited (<code>samples</code>) query\nwhich always returns the same number of points.  If a <code>samples</code> argument is\npresent, a limited query is assumed.</p><p>Limited queries work by prioritizing rather than thresholding samples - so\nthat regardless of the total weight of the points being considered, the\nsame number of points are returned.  The algorithm works by iteratively\npicking the point that has the greatest contribution and splitting that\npoint until enough points have been split to meet the desired sample count.\nLimited queries are useful when you need a fixed performance or minimum\nquality level for the query.</p><p>Threshold queries work by comparing the point contribution to a fixed\nthreshold - and accepting or rejecting the point based on this comparison.\nSince different query points lead to different point contributions, a\nvariable number of points will be queued up for threshold queries.\nThreshold queries are useful when it is acceptable to use a lower number of\npoints for query positions that are far from the point cloud.</p><h2>Aggregation</h2><p>Additional string parameters indicate how point values are aggregated.  Each\nchannel can have a different aggregation mode: <code>mean</code>, <code>sum</code>, or\n<code>weighted</code>.  Calling <code>pcopenlod</code>(\u2026, <code>aggregate:P</code>, <code>sum</code>) will aggregate\nthe values in channel <code>P</code> by summing them.  Calling <code>pcopenlod</code>(\u2026,\n<code>aggregate:A</code>, <code>weighted</code>, <code>weight</code>, <code>W</code>) will aggregate the values in\nchannel <code>A</code> using a weighted mean with weights from channel <code>W</code>.</p><h2>Example: Proximity Query</h2><div class=\"codeblock\"><code class=\"codeline\">int handle = pcopenlod(texturename, \"P\", P, 8,</code><code class=\"codeline\">\"measure\", \"distance\", \"threshold\", 2.0,</code><code class=\"codeline\">\"aggregate:P\", \"mean\",</code><code class=\"codeline\">\"aggregate:value\", \"sum\");</code><code class=\"codeline\">Cf = 0;</code><code class=\"codeline\">while (pciterate(handle))</code><code class=\"codeline\">{</code><code class=\"codeline\">pcimport(handle, \"value\", valueSum);</code><code class=\"codeline\">Cf += valueSum;</code><code class=\"codeline\">}</code><code class=\"codeline\">pcclose(handle);</code></div><h2>Example: Threshold Solid-angle Query</h2><div class=\"codeblock\"><code class=\"codeline\">handle = pcopenlod(texturename, \"P\", P, 8,</code><code class=\"codeline\">\"measure\", \"solidangle\", \"area\", \"A\", \"threshold\", 0.01,</code><code class=\"codeline\">\"aggregate:A\", \"sum\",</code><code class=\"codeline\">\"aggregate:irradiance\", \"weighted\", \"weight\", \"A\",</code><code class=\"codeline\">\"aggregate:P\", \"mean\");</code><code class=\"codeline\">Cf = 0;</code><code class=\"codeline\">while (pciterate(handle))</code><code class=\"codeline\">{</code><code class=\"codeline\">pcimport(handle, \"irradiance\", irradiance);</code><code class=\"codeline\">Cf += irradiance;</code><code class=\"codeline\">}</code><code class=\"codeline\">pcclose(handle);</code></div><h2>Example: Limited Solid-angle Query</h2><div class=\"codeblock\"><code class=\"codeline\">handle = pcopenlod(texturename, \"P\", P, 8,</code><code class=\"codeline\">\"measure\", \"solidangle\", \"area\", \"A\", \"samples\", 4,</code><code class=\"codeline\">\"aggregate:A\", \"sum\",</code><code class=\"codeline\">\"aggregate:irradiance\", \"weighted\", \"weight\", \"A\",</code><code class=\"codeline\">\"aggregate:P\", \"mean\");</code><code class=\"codeline\">Cf = 0;</code><code class=\"codeline\">while (pciterate(handle))</code><code class=\"codeline\">{</code><code class=\"codeline\">pcimport(handle, \"irradiance\", irradiance);</code><code class=\"codeline\">Cf += irradiance;</code><code class=\"codeline\">}</code><code class=\"codeline\">pcclose(handle);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcgenerate\">pcgenerate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcwrite\">pcwrite</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfilter\">pcfilter</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pciterate\">pciterate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcunshaded\">pcunshaded</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcimport\">pcimport</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcclose\">pcclose</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcsampleleaf\">pcsampleleaf</a></div></body>",
    "pcsampleleaf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcsampleleaf\">pcsampleleaf</a></h1><p class=\"summary\">Changes the current iteration point to a leaf descendant of the current aggregate point.</p><div class=\"usage\"> <code>void pcsampleleaf(int handle, float sample)</code></div><p>This function can only be used with the pcopenlod() function, and then only\nwithin a pciterate() loop.  It replaces the current iteration point with an\nimportance sampled leaf descendent of that point.  The weighting used to\nselect the leaf point is the area channel provided to the pcopenlod()\nfunction\u2019s measure parameter, or a uniform weight if no area channel\nwas specified when opening the point cloud.  The sample parameter is\nexpected to be a uniform random value between 0 and 1.</p><p>If the current iteration point is already a leaf point or the point cloud\nwas not opened with pcopenlod(), pcsampleleaf() has no effect.</p><p>This function is useful when aggregate point information cannot be used in\na meaningful way, and provides a mechanism to access the information\ncontained in child nodes in the point tree.  For example, it wouldn\u2019t make\nsense to trace shadow rays from an averaged point position, but it is\nuseful to choose one of the child points and then send the shadow ray to\nthat point.</p><h2>Example: Shadow Rays</h2><div class=\"codeblock\"><code class=\"codeline\">// Open a point cloud and retrieve a single aggregate point representing the</code><code class=\"codeline\">// entire cloud</code><code class=\"codeline\">string texturename = \"points.pc\";</code><code class=\"codeline\">int handle = pcopenlod(texturename, \"P\", P, 8,</code><code class=\"codeline\">\"measure\", \"solidangle\",</code><code class=\"codeline\">\"area\", \"A\",</code><code class=\"codeline\">\"samples\", 1,</code><code class=\"codeline\">\"aggregate:A\", \"sum\",</code><code class=\"codeline\">\"aggregate:P\", \"mean\");</code><code class=\"codeline\"></code><code class=\"codeline\">Cf = 0;</code><code class=\"codeline\"></code><code class=\"codeline\">// This loop will iterate only once</code><code class=\"codeline\">while (pciterate(handle))</code><code class=\"codeline\">{</code><code class=\"codeline\">    // Query A from the averaged point</code><code class=\"codeline\">    float        ptarea;</code><code class=\"codeline\">    pcimport(handle, \"A\", ptarea);</code><code class=\"codeline\"></code><code class=\"codeline\">    pcsampleleaf(handle, nrandom());</code><code class=\"codeline\"></code><code class=\"codeline\">    // Query P from a sampled leaf point</code><code class=\"codeline\">    vector        pos;</code><code class=\"codeline\">    pcimport(handle, \"P\", pos);</code><code class=\"codeline\"></code><code class=\"codeline\">    if (trace(pos, P-pos, Time))</code><code class=\"codeline\">        Cf += ptarea / length2(P-pos);</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopenlod\">pcopenlod</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pciterate\">pciterate</a></div></body>",
    "pcsegment": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcsegment\">pcsegment</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns a list of closest points to a line segment from a specified file</p><div class=\"usage\"> <code>int[] pcsegment(&lt;geometry&gt;, string PChannel, vector P0, vector P1, float max_distance, int maxpoints)</code></div><div class=\"usage\"> <code>int[] pcsegment(&lt;geometry&gt;, string ptgroup, string PChannel, vector P0, vector P1, float max_distance, int maxpoints)</code></div><div class=\"usage\"> <code>int[] pcsegment(&lt;geometry&gt;, string PChannel, vector P0, vector P1, float max_distance, int maxpoints, float &amp;distances[])</code></div><div class=\"usage\"> <code>int[] pcsegment(&lt;geometry&gt;, string ptgroup, string PChannel, vector P0, vector P1, float max_distance, int maxpoints, float &amp;distances[])</code></div><p>These functions open a geometry file and return a list of points within <code class=\"var\">max_distance</code> of the line segment passing from <code class=\"var\">P0</code> to <code class=\"var\">P1</code>. </p><p>The <code>ptgroup</code> is a point group that limits the points to search.  This is a SOP-style group pattern, so can be something like <code>0-10</code> or <code>@Cd.x&gt;0.5</code>.  A blank string is treated as matching all points.</p><p>The function also optionally takes a float array <code>distances</code>, which it modifies with the distances to each point.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoint\">nearpoint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoints\">nearpoints</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pccone_radius\">pccone_radius</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind\">pcfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind_radius\">pcfind_radius</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pgfind\">pgfind</a></div></body>",
    "pcsegment_radius": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcsegment_radius\">pcsegment_radius</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns a list of closest points to a line segment from a specified file</p><div class=\"usage\"> <code>int[] pcsegment_radius(&lt;geometry&gt;, string PChannel, string RadChannel, float radscale, vector P0, vector P1, float max_distance, int maxpoints)</code></div><div class=\"usage\"> <code>int[] pcsegment_radius(&lt;geometry&gt;, string ptgroup, string PChannel, string RadChannel, float radscale, vector P0, vector P1, float max_distance, int maxpoints)</code></div><div class=\"usage\"> <code>int[] pcsegment_radius(&lt;geometry&gt;, string PChannel, string RadChannel, float radscale, vector P0, vector P1, float max_distance, int maxpoints, float &amp;distances[])</code></div><div class=\"usage\"> <code>int[] pcsegment_radius(&lt;geometry&gt;, string ptgroup, string PChannel, string RadChannel, float radscale, vector P0, vector P1, float max_distance, int maxpoints, float &amp;distances[])</code></div><p>These functions open a geometry file and return a list of points (treated as spheres) within <code class=\"var\">max_distance</code> of the line segment passing from <code class=\"var\">P0</code> to <code class=\"var\">P1</code>. Each point is treated as a sphere with radius equal to its <code class=\"var\">RadChannel</code> attribute, </p><p>multiplied by <code class=\"var\">radscale</code>.</p><p>The <code>ptgroup</code> is a point group that limits the points to search.  This is a SOP-style group pattern, so can be something like <code>0-10</code> or <code>@Cd.x&gt;0.5</code>.  A blank string is treated as matching all points.</p><p>The function also optionally takes a float array <code>distances</code>, which it modifies with the distances to each point.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoint\">nearpoint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nearpoints\">nearpoints</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pccone_radius\">pccone_radius</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind\">pcfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind_radius\">pcfind_radius</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pgfind\">pgfind</a></div></body>",
    "pcsize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcsize\">pcsize</a></h1><div class=\"usage\"> <code>int pcsize(int handle)</code></div><p>Returns the total number of points in the point cloud specified by <code>handle</code>, where <code>handle</code> was returned by a prior call to <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div></body>",
    "pcunshaded": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcunshaded\">pcunshaded</a></h1><p class=\"summary\">Iterate over all of the points of a read-write channel which haven\u2019t\nhad any data written to the channel yet.</p><div class=\"usage\"> <code>int pcunshaded(int handle, string channel_name)</code></div><p>Like <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pciterate\">pciterate</a>, this function can be used to iterate over\npoints which were found in a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a> query. The first argument is\nthe <code class=\"var\">handle</code> returned by <code>pcopen</code>.</p><p>However, where <code>pciterate</code> iterates over all the points, this function\nonly iterates over points where the channel in <code class=\"var\">channel_name</code> has\nnot yet been written to.</p><p>The function returns 1 while there are points left in the iteration loop,\nor 0 when there are no further points. This lets you use the function as\nthe condition in a <a href=\"https://www.sidefx.com/docs/houdini/vex/statement\">while loop</a>.</p><p>Warnings:</p><div class=\"related\">This function will not work correctly when used in multi-threaded OPs.\nIt is not possible to nest <code>pcunshaded</code> or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pciterate\">pciterate</a>\nloops for the same handle. That is, for a single <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a>\ncall, only one <code>pcunshaded</code> or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pciterate\">pciterate</a> loop may be\nentered.</div><div class=\"related\">Computations involving derivatives inside <code>pcunshaded</code> loops may have\nslightly different results. If derivatives are required for variables\nwhich aren\u2019t set by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcimport\">pcimport</a> it may be better to\npre-compute the derivatives before the <code>pcunshaded</code> loop is entered.</div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pciterate\">pciterate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcimport\">pcimport</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcexport\">pcexport</a></div></body>",
    "pcwrite": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcwrite\">pcwrite</a></h1><p class=\"summary\">Writes data to a point cloud file.</p><div class=\"usage\"> <code>int pcwrite(string filename, ...)</code></div><p>Writes data for the current shading point out to a point cloud file.</p><div class=\"argument\"><code>filename</code></div><p>The name of the file to write to. You can read the resulting file into a geometry network with the <a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/file\">File surface node</a>. This file should have a <code>.pc</code> extension (Houdini will use the extension to determine how to import the file).</p><div class=\"argument\"><code>\u2026</code></div><p>Subsequent arguments specify one or more pairs of a channel name (a string naming the attribute you're saving, such as <code>\"P\"</code>, <code>\"N\"</code>, <code>\"v\"</code>, <code>\"area\"</code>, <code>\"u\"</code>, etc.) and value (the value you wish to store).</p><div class=\"codeblock\"><code class=\"codeline\">pcwrite(\"out.pc\", \"P\", P, \"N\", N)</code></div><p>To write a variable as a vector type instead of a triple, append <code>:vector</code> to the channel name.</p><div class=\"codeblock\"><code class=\"codeline\">pcwrite(\"out.pc\", \"P\", P, \"N:vector\", N)</code></div><p>In micropolygon rendering, points are interpolated with neighbor points so that duplicate vertices on corners and edges are eliminated in the point cloud.  If you want to disable this behavior, use the <code>\"interpolate\"</code> argument described below.</p><div class=\"argument\"><code>interpolate</code></div><span class=\"padder\"><span class=\"pillow\">int</span></span><span class=\"padder\"><span class=\"pillow\">1</span></span><p>When you pass this argument a value of <code>1</code> (the default), one interpolated point is written representing the four corners of a micropolygon. This prevents writing out overlapping values.</p><div class=\"codeblock\"><code class=\"codeline\">pcwrite(\"out.pc\", \"P\", P, \"interpolate\", 1)</code></div><p>Using a value of <code>0</code> will disable interpolation, which can be useful when writing points that are not based on <code>P</code>. Interpolation will have no effect in ray tracing mode.</p><p>(Note that this means you can\u2019t use <code>interpolate</code> as the name of a data channel.)</p><div class=\"argument\"><code>countphotons</code></div><span class=\"padder\"><span class=\"pillow\">int</span></span><p>For photon generation modes, add the number of points stored\n    to the total number of photons, for the purposes of progress reporting and termination\n    of photon map generation.</p><div class=\"argument\"><code>mkdir</code></div><span class=\"padder\"><span class=\"pillow\">int</span></span><span class=\"padder\"><span class=\"pillow\">0</span></span><p>When you pass an argument of <code>1</code>, the function will automatically create missing sub-directories/paths.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">surface</code><code class=\"codeline\">dumpsomepoints(string fname = \"points.$F4.pc\"; int do_cull = 0; float keepamt = 0.05)</code><code class=\"codeline\">{</code><code class=\"codeline\">    vector    nn = normalize(frontface(N, I));</code><code class=\"codeline\">    int       rval=0;</code><code class=\"codeline\">    float     A = area(P,\"smooth\",0);  // area without smoothed derivs</code><code class=\"codeline\"></code><code class=\"codeline\">    if( !do_cull  ||  do_cull &amp; (nrandom()&lt;keepamt) )</code><code class=\"codeline\">    {</code><code class=\"codeline\">        if( do_cull &amp;&amp; keepamt &gt; 0 )</code><code class=\"codeline\">        {</code><code class=\"codeline\">            A = A/keepamt;</code><code class=\"codeline\">        }</code><code class=\"codeline\">        rval = pcwrite(fname, \"interpolate\", 1,</code><code class=\"codeline\">        \"P\", ptransform(\"space:camera\",\"space:world\", P),</code><code class=\"codeline\">        \"N\", ntransform(\"space:camera\",\"space:world\", normalize(N)),</code><code class=\"codeline\">        \"area\", A);  // output an \"area\" channel in pc</code><code class=\"codeline\">    }</code><code class=\"codeline\">    Cf =abs(nn)*rval;</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcopen\">pcopen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcexport\">pcexport</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/file\">File node</a></div></body>",
    "perspective": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/perspective\">perspective</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Create a perspective projection matrix.</p><div class=\"usage\"> <code>matrix perspective(float zoom, float image_aspect, float pixel_aspect, float clip_near, float clip_far)</code></div><div class=\"usage\"> <code>matrix perspective(float zoom, float image_aspect, float pixel_aspect, float clip_near, float clip_far, vector4 window)</code></div><p>Create a perspective projection matrix with the given parameters. This can be used to project points onto the so-called NDC coordinates of a camera.</p><p>To make a single transform from world space to NDC space given a camera matrix and a projection matrix, you would use, <code>worldToNDC = worldToCamera * projection;</code></p><div class=\"argument\"><code>zoom</code></div><p>The zoom for the lens. Sometimes the zoom is expressed in terms of focal and aperture.  In this case, <code>zoom = focal/aperture</code>.</p><div class=\"related\">arg:image_aspect</div><p>The aspect ratio of the image. Sometimes the image_aspect is expressed in terms of <code>xres</code> and <code>yres</code>.  In this case, <code>image_aspect = xres / yres</code>.</p><div class=\"related\">arg::clip_near</div><p>The near clipping plane.</p><div class=\"related\">arg::clip_far</div><p>The far clipping plane.</p><div class=\"related\">arg::window</div><p>The offset for the projection window encoded in a vector4.\n    window.x and window.y are the window min xy coordinates and\n    window.z, window.w are the window max xy coordinates.\n    This argument is optional and defaults to {0,0,1,1} when not given.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/orthographic\">orthographic</a></div></body>",
    "pgfind": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pgfind\">pgfind</a></h1><p class=\"summary\">Returns a list of closest points from a file.</p><div class=\"usage\"> <code>int [] pgfind(&lt;geometry&gt;, vector P, float radius, int maxpoints, float divsize)</code></div><div class=\"usage\"> <code>int [] pgfind(&lt;geometry&gt;, string ptgroup, vector P, float radius, int maxpoints, float divsize)</code></div><p>These functions are very similar to the <code>pcfind</code> functions.  The difference is that they use a grid-based acceleration structure.  This can provide faster initialization and lookups, provided the right grid size tuning parameter is used.</p><p>If you are searching a point cloud using an near-constant search radius, that radius can be used as the division size.</p><h2>Note</h2><p>The division size must be not vary per point.</p><h2>Note</h2><p>The division size is clamped above 3.0\u00d7105.</p><p>The <code>ptgroup</code> is a point group that limits the points to search.  This is a SOP-style group pattern, so can be something like <code>0-10</code> or <code>@Cd.x&gt;0.5</code>.  A blank string is treated as matching all points.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind\">pcfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind_radius\">pcfind_radius</a></div></body>",
    "phong": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phong\">phong</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Returns a Phong BSDF or computes Phong shading.</p><p><a href=\"https://www.sidefx.com/docs/houdini/images/rendering/phong.png\">/images/rendering/phong.png</a></p><div class=\"usage\"> <code>bsdf phong(float exponent, ...)</code></div><div class=\"usage\"> <code>bsdf phong(vector nml, float exponent, ...)</code></div><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">writing a PBR shader</a> for information on BSDFs.</p><div class=\"usage\"> <code>vector phong(vector nml, vector V, float shinyness, ...)</code></div><p><code class=\"var\">V</code> represents the normalized vector from the surface to the eye\n    (-normalize(I)). <code class=\"var\">shinyness</code> is the Phong exponent (typically around\n    20 or higher). <code class=\"var\">roughness</code> represents the surface roughness (typically\n    0 to 1).</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ashikhmin\">ashikhmin</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phonglobe\">phonglobe</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "phongBRDF": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phongBRDF\">phongBRDF</a></h1><div class=\"usage\"> <code>float phongBRDF(vector L, vector N, vector V, float rough)</code></div><p><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/specularBRDF\">specularBRDF</a>, <code>phongBRDF</code>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/blinnBRDF\">blinnBRDF</a>,\nand <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/diffuseBRDF\">diffuseBRDF</a> return the computed BRDF for the\ndifferent lighting models used in VEX shading. You can use them in\ncustom <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a> loops to replicate the lighting models of the\ncorresponding VEX lighting functions.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/specularBRDF\">specularBRDF</a> for some example code.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/specularBRDF\">specularBRDF</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/blinnBRDF\">blinnBRDF</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/diffuseBRDF\">diffuseBRDF</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a></div></body>",
    "phonglobe": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phonglobe\">phonglobe</a></h1><div class=\"usage\"> <code>bsdf phonglobe(vector dir, float exponent, ...)</code></div><div class=\"usage\"> <code>bsdf phonglobe(vector nml, vector dir, float exponent, ...)</code></div><div class=\"usage\"> <code>bsdf phonglobe(vector dir, float exponentx, float exponenty, vector framex, vector framey, ...)</code></div><div class=\"usage\"> <code>bsdf phonglobe(vector nml, vector dir, float exponentx, float exponenty, vector framex, vector framey, ...)</code></div><p><a href=\"https://www.sidefx.com/docs/houdini/images/rendering/phonglobe.png\">/images/rendering/phonglobe.png</a></p><p>A phong (blurred) reflection along a given direction vector. This will produce the same result as <code>phong()</code> when the direction vector is the reflection vector, but with this function you can also gather illumination from other directions (such as transmission).</p><p>It is possible to create anisotropic phong lobes by providing x and y exponents and tangent vectors.</p><div class=\"argument\"><code>dir</code></div><p>the direction of specularity.</p><div class=\"argument\"><code>nml</code></div><p>optional normal to specify the hemisphere for reflection directions.</p><div class=\"argument\"><code>exponent</code></div><p>phong exponent.</p><div class=\"argument\"><code>exponentx</code></div><p>phong exponent along the <code>framex</code> vector.</p><div class=\"argument\"><code>exponenty</code></div><p>phong exponent along the <code>framey</code> vector.</p><div class=\"argument\"><code>framex</code></div><p>highlight X direction</p><div class=\"argument\"><code>framey</code></div><p>highlight Y direction</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phong\">phong</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ashikhmin\">ashikhmin</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "photonmap": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/photonmap\">photonmap</a></h1><p class=\"summary\">Samples a color from a photon map.</p><div class=\"usage\"> <code>vector photonmap(string mapname, vector position, vector normal, ...)</code></div><div class=\"usage\"> <code>void photonmap(string mapname, vector position, vector normal, vector &amp;color, float &amp;area, ...)</code></div><h2>Variadic arguments</h2><p>You can specify additional keyword,value argument pairs to set the\nbehavior of the evaluation. These arguments must be defined at load\ntime (literals or parameters).</p><p>To specify one of the additional arguments, pass the keyword as a\nstring, with the next argument being the value for the keyword. For\nexample <code>..., \"wrap\", \"clamp\", \"border\", {.1,1,1})</code>.</p><span>Keyword </span><span>Type </span><span>Value </span><span><code>\"nphotons\"</code> </span><span><code>int</code> </span><p>Maximum number of photons to filter to produce the final color.\n        Default is <code>50</code>.</p><span><code>\"type\"</code> </span><span><code>string</code> </span><p>How to interpret the photons.</p><div class=\"argument\"><code><code>\"diffuse\"</code> (the default)</code></div><p>Scale each photon by the Lambertian cosine law.</p><div class=\"argument\"><code><code>\"irradiance\"</code></code></div><p>Use the raw energy of each photon without filtering.</p><span><code>\"error\"</code> </span><span><code>float</code> </span><p>The amount of error allowed in the evaluation.\n        Larger numbers give less accurate evaluations (i.e. smaller areas of the map will be scanned),\n        while smaller number will result in larger areas of the map being scanned.\n        Render time goes up as the error tolerance goes down.</p><p>Default <code>0.001</code>.</p><span><code>\"filter\"</code> </span><span><code>string</code> </span><p>Specifies the filter for computing the irradiance from\n        photons. When evaluating photon contributions, the incoming\n        radiance is divided by the area that the photons cover (to\n        determine the flux). The area can be computed in three\n        different fashions:</p><div class=\"argument\"><code><code>sphere</code> (default)</code></div><p>The minimum bounding sphere of all photons will be used\n            to estimate the area. This estimator will result in soft\n            blobby looking photon evaluation. It can be inaccurate\n            near edges of primitives.</p><div class=\"argument\"><code><code>volume</code></code></div><p>Like sphere, but uses the volume of the minimum bounding\n            sphere rather than area to normalize photon tracing\n            results.  When using volume filtering it is usually\n            necessary to divide the photon lookup result by the volume\n            density to correct for the density-weighted photon\n            distribution that occurs in volumes.</p><p>When using volume filtering, the normal passed to the\n            <code>photonmap</code> function is ignored.</p><div class=\"argument\"><code><code>convex</code></code></div><p>Use the convex hull of all photons is to estimate the\n            area. This estimator will result in slightly sharper\n            edges in the photon evaluation, and can be more accurate\n            near edges of primitives. However, since there are\n            sharper edges, this estimator can produce very noisy\n            evaluations.</p><div class=\"argument\"><code><code>direct</code></code></div><p>This filter should be used for photon maps that have been\n            pre-filtered (for example, for maps that have already been\n            filtered by the pcfilter utility).  It will cause the\n            photon energies to be averaged without area estimation.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">Cf = photonmap(map, P, normalize(frontface(N, I)),</code><code class=\"codeline\">\"nphotons\", 100,</code><code class=\"codeline\">\"type\", \"diffuse\",</code><code class=\"codeline\">\"error\", 0.05,</code><code class=\"codeline\">\"filter\", \"convex);</code></div><div class=\"codeblock\"><code class=\"codeline\">vector        clr;</code><code class=\"codeline\">float        area;</code><code class=\"codeline\">photonmap(map, P, normalize(frontface(N, I)), clr, area,</code><code class=\"codeline\">\"nphotons\", 100,</code><code class=\"codeline\">\"type\", \"diffuse\",</code><code class=\"codeline\">\"error\", 0.05,</code><code class=\"codeline\">\"filter\", \"convex);</code><code class=\"codeline\">Cf = clr;</code></div></body>",
    "planeindex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/planeindex\">planeindex</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the index of the plane specified by the parameter, starting\nat zero.</p><div class=\"usage\"> <code>int planeindex(string planename)</code></div><p>Returns the index of the plane specified by the parameter, starting at\nzero.</p></body>",
    "planename": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/planename\">planename</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the name of the plane specified by the index (e.</p><div class=\"usage\"> <code>string planename(int planeindex)</code></div><p>Returns the name of the plane specified by the index (e.g. C, A).</p></body>",
    "planepointdistance": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/planepointdistance\">planepointdistance</a></h1><p class=\"summary\">Computes the distance and closest point of a point to an infinite plane.</p><div class=\"usage\"> <code>float planepointdistance(vector plane_pos, vector plane_normal, vector point_pos, vector &amp;intersect_pos)</code></div><p>Given a 3D point <code>point_pos</code>, and a 3D plane with <code>plane_normal</code> normal vector passing through a 3D point <code>plane_pos</code>, return the closest distance and closest position between the plane and the point.</p></body>",
    "planesize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/planesize\">planesize</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the number of components in the plane (1 for scalar planes\nand up to 4 for vector planes).</p><div class=\"usage\"> <code>int planesize(int planeindex)</code></div><p>Returns the number of components in the plane (1 for scalar planes and\nup to 4 for vector planes). Returns 0 if the index is out of range.</p></body>",
    "planesphereintersect": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/planesphereintersect\">planesphereintersect</a></h1><p class=\"summary\">Computes the intersection of a 3D sphere and an infinite 3D plane.</p><div class=\"usage\"> <code>int planesphereintersect(vector plane_pos, vector plane_normal, vector sphere_pos, float sphere_radius, vector &amp;intersect_pos, float &amp;intersect_radius, float &amp;intersect_distance)</code></div><p>Given a 3D sphere centered at <code>sphere_pos</code> with a <code>sphere_radius</code> radius, and a 3D plane with <code>plane_normal</code> normal vector passing through a 3D point <code>plane_pos</code>, return 1 if there is an intersection or 0 if there isn\u2019t.</p><p>The intersection is most often a 2D circle on the intersecting plane centered at <code>intersect_pos</code> with a <code>intersect_radius</code> radius. It can also be a single point, in which case <code>intersect radius</code> is set to 0.\nThe distance between the <code>sphere_pos</code> and the <code>intersect_pos</code> is returned even when there is no intersection.</p></body>",
    "pluralize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pluralize\">pluralize</a></h1><p class=\"summary\">Converts an English noun to its plural.</p><div class=\"usage\"> <code>string pluralize(string noun)</code></div><p>The English language is full of nonstandard rules for pluralizing nouns.  This function will properly create the plural ending for the input string.  Only the end of the input string is used.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">string boxes = pluralize(\"box\");</code><code class=\"codeline\">string women = pluralize(\"woman\");</code><code class=\"codeline\">string geometries = pluralize(\"geometry\");</code><code class=\"codeline\"></code><code class=\"codeline\">// Returns the string \"Pluralize the last words\"</code><code class=\"codeline\">string phrase = pluralize(\"Pluralize the last word\");</code></div></body>",
    "pnoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pnoise\">pnoise</a></h1><p class=\"summary\">There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space.</p><div class=\"usage\"> <code>float|vector pnoise(float x, int px)</code></div><div class=\"usage\"> <code>float|vector pnoise(vector x, vector p)</code></div><div class=\"usage\"> <code>float|vector pnoise(vector4 xyzt, vector4 p)</code></div><div class=\"usage\"> <code>float|vector pnoise(float x, float y, int px, int py)</code></div><div class=\"usage\"> <code>float|vector pnoise(vector xyz, int px, int py, int pz)</code></div><div class=\"usage\"> <code>float|vector pnoise(vector4 xyzt, int px, int py, int pz, int pt)</code></div><p>There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space.</p><p>This function generates periodic noise. Use the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/noise\">noise</a>\nfunction to generate non-periodic Perlin noise.</p><p>The various functions return the noise value at a 4D (vector4 argument),\n3D (vector argument), 2D (two float arguments) or 1D (float argument)\nposition. You can get a random float value or a vector of three random\nvalues.</p><p>The p int or vector arguments specify the range of periodicity. For\nexample, if you're making a 2D image and you want it to tile:</p><div class=\"codeblock\"><code class=\"codeline\">clr = pnoise(X * 4, Y * 5, _4, 5_)</code></div><p>In this example, X is in the range 0-4, Y is in the range 0-5, and the\nnoise is periodic within that segment.</p><p>If a period argument is 0, VEX treats that as <em>no</em> periodicity. Use\nthis to make the noise periodic in one dimension but not another.</p><p>The distribution of the noise depends on the dimension, with higher\ndimensions approaching a Gaussian distribution of noise values.</p><h2>Related</h2></body>",
    "point": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/point\">point</a></h1><p class=\"summary\">Reads a point attribute value from a geometry.</p><div class=\"usage\"> <code>&lt;type&gt; point(&lt;geometry&gt;; string attribute_name; int pointnumber)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] point(&lt;geometry&gt;; string attribute_name; int pointnumber)</code></div><div class=\"argument\"><code>pointnumber</code></div><p>The point number to read the attribute on.</p><h2>Returns</h2><p>The value of the given attribute on the given point number, or <code>0</code> if the attribute or point do not exist.</p></body>",
    "pointattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointattrib\">pointattrib</a></h1><p class=\"summary\">Reads a point attribute value from a geometry and outputs a success/fail flag.</p><div class=\"usage\"> <code>&lt;type&gt; pointattrib(&lt;geometry&gt;, string attribute_name, int pointnumber, int &amp;success)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] pointattrib(&lt;geometry&gt;, string attribute_name, int pointnumber, int &amp;success)</code></div><div class=\"argument\"><code>&amp;success</code></div><p>The function overwrites this variable with <code>1</code> if the attribute exists and was read successfully, or <code>0</code> otherwise.</p><h2>Returns</h2><p>The value of the given attribute on the given point number, or <code>0</code> if the attribute or point do not exist.</p></body>",
    "pointattribsize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointattribsize\">pointattribsize</a></h1><p class=\"summary\">Returns the size of a geometry point attribute.</p><div class=\"usage\"> <code>int pointattribsize(&lt;geometry&gt;, string attribute_name)</code></div><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribsize\">attribsize</a> for more information.</p><p>Returns <code>0</code> if the attribute cannot be found.</p></body>",
    "pointattribtype": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointattribtype\">pointattribtype</a></h1><p class=\"summary\">Returns the type of a geometry point attribute.</p><div class=\"usage\"> <code>int pointattribtype(&lt;geometry&gt;, string attribute_name)</code></div><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribtype\">attribtype</a> for more information.</p></body>",
    "pointattribtypeinfo": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointattribtypeinfo\">pointattribtypeinfo</a></h1><p class=\"summary\">Returns the type info of a geometry attribute.</p><div class=\"usage\"> <code>string pointattribtypeinfo(&lt;geometry&gt;, string attribute_name)</code></div><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribtypeinfo\">attribtypeinfo</a> for more information.</p></body>",
    "pointedge": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointedge\">pointedge</a></h1><p class=\"summary\">Finds and returns a half-edge with the given endpoints.</p><div class=\"usage\"> <code>int pointedge(&lt;geometry&gt;, int point1, int point2)</code></div><p>Returns <code>-1</code> if no such half-edge exists. Otherwise returns the number of a half-edge that either has <code>point1</code> as source or has <code>point2</code> as desination, or the other way around.</p><div class=\"argument\"><code><code>point1</code>, <code>point2</code></code></div><p>The point numbers in the geometry for the two endpoints of the returned half-edge.  <code>0</code> is the first point.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int edge_count = 0;</code><code class=\"codeline\"></code><code class=\"codeline\">// Determine if there is an edge between points 23 and 25:</code><code class=\"codeline\">int h0 = pointedge(\"defgeo.bgeo\", 23, 25);</code><code class=\"codeline\">if (h0 != -1)</code><code class=\"codeline\">{</code><code class=\"codeline\">// Edge exists!</code><code class=\"codeline\">}</code></div></body>",
    "pointhedge": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointhedge\">pointhedge</a></h1><p class=\"summary\">Finds and returns a half-edge with a given source point or with given source and destination points.</p><div class=\"usage\"> <code>int pointhedge(&lt;geometry&gt;, int point)</code></div><div class=\"usage\"> <code>int pointhedge(&lt;geometry&gt;, int srcpoint, int dstpoint)</code></div><div class=\"argument\"><code><code>point</code></code></div><p>The point number in the geometry for the source point of the returned half-edge.  <code>0</code> is the first point.</p><div class=\"argument\"><code><code>srcpoint</code>, <code>dstpoint</code></code></div><p>The point numbers in the geometry for source and destination of returned half-edge.  <code>0</code> is the first point.</p><h2>Returns</h2><p>The number of a half-edge that has <code>point</code> as source or has <code>srcpoint</code> as source and <code>dstpoint</code> as destination.\n     In the former case, using <code>op:pointhedgenext</code> one can enumerate over all the half-edges that have <code>point</code> as source.\n     Returns <code>-1</code> if the half-edge is not valid.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int edge_count = 0;</code><code class=\"codeline\"></code><code class=\"codeline\">// Count number of *edges* (not half-edges) incident to point number 23.</code><code class=\"codeline\">int hout = pointhedge(\"defgeo.bgeo\", 23);</code><code class=\"codeline\">while ( hout != -1 )</code><code class=\"codeline\">{</code><code class=\"codeline\">    if (hedge_isprimary(\"defgeo.bgeo\", hout))</code><code class=\"codeline\">        edge_count++;</code><code class=\"codeline\">    int hin = hedge_prev(\"defgeo.bgeo\", hout);</code><code class=\"codeline\">    if (hedge_isprimary(\"defgeo.bgeo\", hin))</code><code class=\"codeline\">        edge_count++;</code><code class=\"codeline\">    hout = pointhedgenext(\"defgeo\", hout);</code><code class=\"codeline\">};</code></div></body>",
    "pointhedgenext": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointhedgenext\">pointhedgenext</a></h1><p class=\"summary\">Returns the <strong>next</strong> half-edge with the same source as a given half-edge.</p><div class=\"usage\"> <code>int pointhedgenext(&lt;geometry&gt;, int hedge)</code></div><div class=\"argument\"><code>point</code></div><p>The point number in the geometry.  <code>0</code> is the first point.</p><h2>Returns</h2><p>The next half-edge that has the same source as <code>hedge</code>.</p><p>Successive calls to this function iterate over all outgoing half-edges out of the same point.\n    The iteration order does not necessarily agree with the order of the edges around a point in a manifold setting.</p><p>Returns <code>-1</code> if <code>hedge</code> is not valid, or the there are no more shared vertices with the source vertex of this hedge (same as <code>op:vertexnext</code>).</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int edge_count = 0;</code><code class=\"codeline\"></code><code class=\"codeline\">// Count number of *edges* (not half-edges) incident to point number 23.</code><code class=\"codeline\">int hout = pointhedge(\"defgeo.bgeo\", 23);</code><code class=\"codeline\">while ( hout != -1 )</code><code class=\"codeline\">{</code><code class=\"codeline\">    if (hedge_isprimary(\"defgeo.bgeo\", hout))</code><code class=\"codeline\">        edge_count++;</code><code class=\"codeline\">    int hin = hedge_prev(\"defgeo.bgeo\", hout);</code><code class=\"codeline\">    if (hedge_isprimary(\"defgeo.bgeo\", hin))</code><code class=\"codeline\">        edge_count++;</code><code class=\"codeline\">    hout = pointhedgenext(\"defgeo\", hout);</code><code class=\"codeline\">}</code></div></body>",
    "pointlocaltransforms": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointlocaltransforms\">pointlocaltransforms</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Returns an array of point localtransforms from an array of point indices.</p><div class=\"usage\"> <code>matrix[] pointlocaltransforms(&lt;geometry&gt;, int pnts[])</code></div><p>Returns an array of local transforms associated with the point indices. This function queries the <code>4@localtransform</code> attribute.</p><div class=\"argument\"><code>pnts</code></div><p>The array of point indices to query.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransforms\">pointtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointtransforms\">setpointtransforms</a></div></body>",
    "pointname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointname\">pointname</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the default name of the point plane (as it appears in the\ncompositor preferences).</p><div class=\"usage\"> <code>string pointname()</code></div><p>Returns the default name of the point plane (as it appears in the\ncompositor preferences). Using this instead of hardcoding the default\nmakes your code more portable. Default is P.</p></body>",
    "pointprims": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointprims\">pointprims</a></h1><p class=\"summary\">Returns the list of primitives containing a point.</p><div class=\"usage\"> <code>int [] pointprims(&lt;geometry&gt;, int ptnum)</code></div><div class=\"argument\"><code>ptnum</code></div><p>The point number to get a primitive from.</p><h2>Returns</h2><p>An array of primitive numbers.  These will be in ascending order\n    and not contain duplicates.</p><p>If no primitives own the given point the array will be empty.</p></body>",
    "pointtransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransform\">pointtransform</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Returns a point transform from a point index.</p><div class=\"usage\"> <code>matrix pointtransform(&lt;geometry&gt;, int pnt)</code></div><p>Computes a transform for the point, using the <a href=\"https://www.sidefx.com/docs/houdini/copy/instanceattrs\">standard instancing point attributes</a>.</p><div class=\"argument\"><code>pnt</code></div><p>The point index to query.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransforms\">pointtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransformrigid\">pointtransformrigid</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransformsrigid\">pointtransformsrigid</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointlocaltransforms\">pointlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointtransforms\">setpointtransforms</a></div></body>",
    "pointtransformrigid": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransformrigid\">pointtransformrigid</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Returns a rigid point transform from a point index.</p><div class=\"usage\"> <code>matrix pointtransformrigid(&lt;geometry&gt;, int pnt)</code></div><p>Returns a rigid transform associated with the point index.\nThis function uses the <a href=\"https://www.sidefx.com/docs/houdini/copy/instanceattrs\">standard instancing point attributes</a> to build the matrix, and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/polardecomp\">polar decomposition</a> is performed to make it rigid.</p><div class=\"argument\"><code>pnt</code></div><p>The point index to query.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransform\">pointtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransforms\">pointtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransformsrigid\">pointtransformsrigid</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointlocaltransforms\">pointlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointtransforms\">setpointtransforms</a></div></body>",
    "pointtransforms": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransforms\">pointtransforms</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Returns an array of point transforms from an array of point indices.</p><div class=\"usage\"> <code>matrix[] pointtransforms(&lt;geometry&gt;, int pnts[])</code></div><div class=\"usage\"> <code>matrix[] pointtransforms(&lt;geometry&gt;)</code></div><p>Returns an array of transforms associated with the point indices, using the <a href=\"https://www.sidefx.com/docs/houdini/copy/instanceattrs\">standard instancing point attributes</a>.\nReturns all the point transforms if the point indices argument is omitted.</p><div class=\"argument\"><code>pnts</code></div><p>The array of point indices to query.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransform\">pointtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransformrigid\">pointtransformrigid</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransformsrigid\">pointtransformsrigid</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointlocaltransforms\">pointlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointtransforms\">setpointtransforms</a></div></body>",
    "pointtransformsrigid": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransformsrigid\">pointtransformsrigid</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Returns an array of rigid point transforms from an array of point indices.</p><div class=\"usage\"> <code>matrix[] pointtransformsrigid(&lt;geometry&gt;, int pnts[])</code></div><div class=\"usage\"> <code>matrix[] pointtransformsrigid(&lt;geometry&gt;)</code></div><p>Returns an array of rigid transforms associated with the point indices.\nThis function uses the <a href=\"https://www.sidefx.com/docs/houdini/copy/instanceattrs\">standard instancing point attributes</a> to build the matrix, and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/polardecomp\">polar decomposition</a> is performed to make it rigid.\nReturns all the point transforms if the point indices argument is omitted.</p><div class=\"argument\"><code>pnts</code></div><p>The array of point indices to query.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransform\">pointtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransformrigid\">pointtransformrigid</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointlocaltransforms\">pointlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransforms\">pointtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointtransforms\">setpointtransforms</a></div></body>",
    "pointvertex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointvertex\">pointvertex</a></h1><p class=\"summary\">Returns a linear vertex number of a point in a geometry.</p><div class=\"usage\"> <code>int pointvertex(&lt;geometry&gt;, int point_num)</code></div><p>Use this to find linear vertex number of the first vertex to share this point.\n    Then you can use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexnext\">vertexnext</a> to iterate over the other vertices in the point.</p><h2>Returns</h2><p>Returns the linear vertex number of the first vertex to share this point.\n    Returns <code>-1</code>if no vertices share this point.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int        vtx;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the linear vertex  of point 3</code><code class=\"codeline\">vtx = pointvertex(\"defgeo.bgeo\", 3);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexpoint\">vertexpoint</a></div></body>",
    "pointvertices": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointvertices\">pointvertices</a></h1><p class=\"summary\">Returns the list of vertices connected to a point.</p><div class=\"usage\"> <code>int [] pointvertices(&lt;geometry&gt;, int ptnum)</code></div><div class=\"argument\"><code>ptnum</code></div><p>The point number to get a vertex from.</p><h2>Returns</h2><p>An array of vertices that are wired to the given point. You should not rely on the numbers being in a particular order.</p><p>If the given point contains no vertices, the array will be empty.</p></body>",
    "polardecomp": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/polardecomp\">polardecomp</a></h1><p class=\"summary\">Computes the polar decomposition of a matrix.</p><div class=\"usage\"> <code>matrix3 polardecomp(matrix3 transform)</code></div><p>Computes the stretch matrix (S) and the orthogonal matrix (Q) such that <code>M = S*Q</code>.\nThis is very useful for shape matching or blending of transforms.</p><div class=\"argument\"><code> transform</code></div><p>The matrix (M) to undergo polar decomposition.</p><h2>Returns</h2><p>'Q', the orthogonal matrix that best matches the given transform. </p><div class=\"usage\"> <code>void polardecomp(matrix3 transform; matrix3 &amp;rot; matrix3 &amp;stretch; int check_determinant=1)</code></div><div class=\"argument\"><code> &amp;rot</code></div><p>Returns the orthogonal matrix of the polar decomposition.</p><div class=\"argument\"><code> &amp;stretch</code></div><p>Returns the stretch matrix of the polar decomposition.</p><div class=\"argument\"><code> check_determinant</code></div><p>Whether or not to check if there is a negative determinant (scale). If there is and this is not set to 0, the orthogonal and scale matrices will be negated.</p></body>",
    "polyneighbours": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/polyneighbours\">polyneighbours</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Returns an array of the primitive numbers of the edge-neighbours of a polygon.</p><div class=\"usage\"> <code>int[] polyneighbours(&lt;geometry&gt;, int primnum)</code></div><p>This returns an array of primitive numbers of polygons that share an\nedge with this polygon.  It uses the Half-Edge data structure so will\nwork with geometry that supports that (ie, polygons)</p><h2>Examples</h2><p>This is roughly equivalent to the following code:</p><div class=\"codeblock\"><code class=\"codeline\">int[] polyneighbours(const string opname; const int primnum)</code><code class=\"codeline\">{</code><code class=\"codeline\">    int result[] = {};</code><code class=\"codeline\"></code><code class=\"codeline\">    int start = primhedge(opname, primnum);</code><code class=\"codeline\"></code><code class=\"codeline\">    for (int hedge = start; hedge != -1; )</code><code class=\"codeline\">    {</code><code class=\"codeline\">        for (int nh = hedge_nextequiv(opname, hedge);</code><code class=\"codeline\">             nh != hedge;</code><code class=\"codeline\">             nh = hedge_nextequiv(opname, nh))</code><code class=\"codeline\">        {</code><code class=\"codeline\">            int prim = hedge_prim(opname, nh);</code><code class=\"codeline\">            if (prim != -1 &amp;&amp; prim != primnum)</code><code class=\"codeline\">            {</code><code class=\"codeline\">                append(result, prim);</code><code class=\"codeline\">            }</code><code class=\"codeline\">        }</code><code class=\"codeline\">        hedge = hedge_next(opname, hedge);</code><code class=\"codeline\">        if (hedge == start)</code><code class=\"codeline\">            break;</code><code class=\"codeline\">    }</code><code class=\"codeline\"></code><code class=\"codeline\">    return result;</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/neighbours\">neighbours</a></div></body>",
    "pop": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pop\">pop</a></h1><p class=\"summary\">Removes the last element of an array and returns it.</p><div class=\"usage\"> <code>&lt;type&gt; pop(&lt;type&gt; &amp;array[])</code></div><p>Removes the last item from the array and returns it.</p><div class=\"usage\"> <code>&lt;type&gt; pop(&lt;type&gt; &amp;array[]; int index)</code></div><p>Removes the item at <code>index</code> from the array and returns its value.</p><p>A negative index counts from the end of the list, so <code>pop(array, -2)</code> would remove the second-to-last value.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/len\">len</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/append\">append</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/push\">push</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/resize\">resize</a></div></body>",
    "pow": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pow\">pow</a></h1><p class=\"summary\">Raises the first argument to the power of the second argument.</p><div class=\"usage\"> <code>float pow(float n, float exponent)</code></div><div class=\"usage\"> <code>&lt;vector&gt; pow(&lt;vector&gt; v, float exponent)</code></div><p>Raises <code>n</code> to the power of <code>exponent</code>. For vectors, this is done per-component.</p><p>When <code>n</code> is less than zero, the exponent will be rounded to the closest integer.</p></body>",
    "predicate_incircle": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/predicate_incircle\">predicate_incircle</a></h1><p class=\"summary\">Determines if a point is inside or outside a triangle circumcircle.</p><div class=\"usage\"> <code>float predicate_incircle(vector2 a, vector2 b, vector2 c, vector2 d)</code></div><p>Given 3 points <code>a</code>, <code>b</code>, and <code>c</code> on the plane, return a positive value if <code>d</code> is inside\nthe circumcircle of the triangle <code>abc</code>, a negative value if <code>d</code> is outside, and zero\nif <code>d</code> is exactly on the circumcircle.</p><p>More precisely, this function computes the determinant of the matrix:</p><div class=\"codeblock\"><code class=\"codeline\">[a_x a_y a^2 1; b_x b_y b^2 1; c_x c_y c^2 1; d_x d_y d^2 1]</code></div><p>\u2026with a guaranteed\ncorrect sign, where <code>a^2</code>, <code>b^2</code>, <code>c^2</code>, and <code>d^2</code> are the squared lengths of the\nrespective input vectors.</p></body>",
    "predicate_insphere": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/predicate_insphere\">predicate_insphere</a></h1><p class=\"summary\">Determines if a point is inside or outside a tetrahedron circumsphere.</p><div class=\"usage\"> <code>float predicate_insphere(vector a, vector b, vector c, vector d, vector e)</code></div><p>Given 4 points <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> in 3D space, return a positive value if <code>e</code> is inside\nthe circumsphere of the tetrahedron <code>abcd</code>, a negative value if <code>e</code> is outside, and zero\nif <code>e</code> lies exactly on the circumsphere.</p><p>More precisely, this function computes the determinant of the matrix</p><div class=\"codeblock\"><code class=\"codeline\">[a_x a_y a_z a^2 1; b_x b_y b_z b^2 1; c_x c_y c_z c^2 1; d_x d_y d_z d^2 1; e_x</code><code class=\"codeline\">e_y e_z e^2 1]</code></div><p>\u2026with a guaranteed\ncorrect sign, where <code>a^2</code>, <code>b^2</code>, <code>c^2</code>, <code>d^2</code> and <code>e^2</code> are the squared lengths of the\ncorresponding input vectors.</p></body>",
    "predicate_orient2d": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/predicate_orient2d\">predicate_orient2d</a></h1><p class=\"summary\">Determines the orientation of a point with respect to a line.</p><div class=\"usage\"> <code>float predicate_orient2d(vector2 a, vector2 b, vector2 c)</code></div><p>Given 2 points <code>a</code> and <code>b</code> in the plane, return a positive value if <code>c</code> is on the left\nof the segment <code>(a,b)</code>, a negative value if it is on the right of the segment, and\nzero if <code>a</code>, <code>b</code> and <code>c</code> are colinear.</p><p>More precisely, this function computes the determinant of the matrix:</p><div class=\"codeblock\"><code class=\"codeline\">[a_x a_y 1; b_x b_y 1; c_x c_y 1]</code></div><p>\u2026with a guaranteed correct sign.</p></body>",
    "predicate_orient3d": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/predicate_orient3d\">predicate_orient3d</a></h1><p class=\"summary\">Determines the orientation of a point with respect to a plane.</p><div class=\"usage\"> <code>float predicate_orient3d(vector a, vector b, vector c, vector d)</code></div><p>Given 3 points <code>a</code>, <code>b</code> and <code>c</code> in space, return a negative value if <code>d</code> is behind the\nplane defined by the triangle <code>abc</code> (with right hand rule winding order), a positive value if its in front of\nthe plane, and zero if points <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> are coplanar.</p><p>More precisely, this function computes the determinant of the matrix:</p><div class=\"codeblock\"><code class=\"codeline\">[a_x a_y a_z 1; b_x b_y b_z 1; c_x c_y c_z 1; d_x d_y d_z 1]</code></div><p>\u2026with a guaranteed correct sign.</p></body>",
    "premul": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/premul\">premul</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Pre multiply matrices.</p><div class=\"usage\"> <code>void premul(matrix2 &amp;a, matrix2 b)</code></div><div class=\"usage\"> <code>void premul(matrix &amp;a, matrix b)</code></div><div class=\"usage\"> <code>void premul(matrix3 &amp;a, matrix3 b)</code></div><div class=\"usage\"> <code>void premul(matrix2 &amp;m, matrix2 a, matrix2 b)</code></div><div class=\"usage\"> <code>void premul(matrix &amp;m, matrix a, matrix b)</code></div><div class=\"usage\"> <code>void premul(matrix3 &amp;m, matrix3 a, matrix3 b)</code></div><p>Multiplies two matrices and returns modify the first matrix.</p></body>",
    "prerotate": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prerotate\">prerotate</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Applies a pre rotation to the given matrix.</p><div class=\"usage\"> <code>void prerotate(matrix3 &amp;m, float amount, vector axis)</code></div><div class=\"usage\"> <code>void prerotate(matrix &amp;m, float amount, vector axis)</code></div><div class=\"usage\"> <code>void prerotate(matrix3 &amp;m, vector angles, int xyz)</code></div><div class=\"usage\"> <code>void prerotate(matrix &amp;m, vector angles, int xyz)</code></div><div class=\"usage\"> <code>void prerotate(matrix3 &amp;m, float angle, int axis)</code></div><div class=\"usage\"> <code>void prerotate(matrix &amp;m, float angle, int axis)</code></div><p>Applies a prerotation to the given matrix. The angles must be given in\nradians and the axis must be normalized. The xyz argument is the rotate order.\nThe axis can also be given as an integer where XAXIS=1, YAXIS=2 and ZAXIS=4.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pretranslate\">pretranslate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prescale\">prescale</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/translate\">translate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rotate\">rotate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/scale\">scale</a></div></body>",
    "prescale": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prescale\">prescale</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Prescales the given matrix in three directions simultaneously (X, Y, Z -\ngiven by the components of the scale_vector).</p><div class=\"usage\"> <code>void prescale(matrix &amp;m, vector scale_vector)</code></div><div class=\"usage\"> <code>void prescale(matrix3 &amp;m, vector scale_vector)</code></div><p>Prescales the matrix in three directions simultaneously by the factors in the vector.\n    This modifies the matrix in-place, rather than returning a new matrix.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pretranslate\">pretranslate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prerotate\">prerotate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/translate\">translate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rotate\">rotate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/scale\">scale</a></div></body>",
    "pretranslate": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pretranslate\">pretranslate</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Pretranslates a matrix by a vector.</p><div class=\"usage\"> <code>void pretranslate(matrix &amp;m, vector amount)</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prerotate\">prerotate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prescale\">prescale</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/translate\">translate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rotate\">rotate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/scale\">scale</a></div></body>",
    "prim": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prim\">prim</a></h1><p class=\"summary\">Reads a primitive attribute value from a geometry.</p><div class=\"usage\"> <code>&lt;type&gt; prim(&lt;geometry&gt;, string attribute_name, int primnumber)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] prim(&lt;geometry&gt;, string attribute_name, int primnumber)</code></div><div class=\"argument\"><code>primnumber</code></div><p>The primitive number to read the attribute on.</p><h2>Returns</h2><p>The value of the given attribute on the given point number, or <code>0</code> if the attribute or point do not exist.</p></body>",
    "primarclen": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primarclen\">primarclen</a></h1><p class=\"summary\">Evaluates the length of an arc on a primitive using parametric uv coordinates.</p><div class=\"usage\"> <code>float primarclen(&lt;geometry&gt;; vector2 uv1; vector2 uv2; int prim_num)</code></div><div class=\"usage\"> <code>float primarclen(&lt;geometry&gt;; vector2 uv1; vector2 uv2; int prim_num; int divs)</code></div><div class=\"usage\"> <code>float primarclen(&lt;geometry&gt;; vector2 uv1; vector2 uv2; int prim_num; int divs; int primuvmode)</code></div><div class=\"usage\"> <code>float primarclen(&lt;geometry&gt;; vector2 uv1; vector2 uv2; int prim_num; int divs; int primuvmode; float primuvtol)</code></div><p>Returns the arc length between two parametric UV coordinates on a given primitive. This lets you measure the distance across a polygon face or along a curve.</p><div class=\"argument\"><code>uv1</code></div><p>The start coordinate in the primitive\u2019s parametric space to measure between.</p><div class=\"argument\"><code>uv2</code></div><p>The end coordinate in the primitive\u2019s parametric space to measure between.</p><div class=\"argument\"><code>prim_num</code></div><p>The number of the primitive across which to measure the distance.</p><div class=\"argument\"><code>divs</code></div><p>The number of divisions per segment to use or 10 if not supplied.</p><div class=\"argument\"><code>primuvmode</code></div><p>Define the uv1 and uv2 coordinates units. See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primuvconvert\">primuvconvert</a> for the list of modes.</p><div class=\"argument\"><code>primuvtol</code></div><p>A tolerance used when computing the curve length to do uv coordinates conversions.</p><h2>Tip</h2><p>You can also read the <code>arclength</code> primitive intrinsic attribute to get a curve\u2019s total arc length.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/curvearclen\">curvearclen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primuvconvert\">primuvconvert</a></div></body>",
    "primattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primattrib\">primattrib</a></h1><p class=\"summary\">Reads a primitive attribute value from a geometry, outputting a success flag.</p><div class=\"usage\"> <code>&lt;type&gt; primattrib(&lt;geometry&gt;, string attribute_name, int prim, int &amp;success)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] primattrib(&lt;geometry&gt;, string attribute_name, int prim, int &amp;success)</code></div><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>&amp;success</code></div><p>Set to <code>1</code> if the import was successful,\n    <code>0</code> on error (for example, the attribute or primitive number don\u2019t exist).</p></body>",
    "primattribsize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primattribsize\">primattribsize</a></h1><p class=\"summary\">Returns the size of a geometry prim attribute.</p><div class=\"usage\"> <code>int primattribsize(&lt;geometry&gt;, string attribute_name)</code></div><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribsize\">attribsize</a> for more information.</p><p>Returns <code>0</code> if the attribute cannot be found.</p></body>",
    "primattribtype": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primattribtype\">primattribtype</a></h1><p class=\"summary\">Returns the type of a geometry prim attribute.</p><div class=\"usage\"> <code>int primattribtype(&lt;geometry&gt;, string attribute_name)</code></div><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribtype\">attribtype</a> for more information.</p></body>",
    "primattribtypeinfo": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primattribtypeinfo\">primattribtypeinfo</a></h1><p class=\"summary\">Returns the type info of a geometry attribute.</p><div class=\"usage\"> <code>string primattribtypeinfo(&lt;geometry&gt;, string attribute_name)</code></div><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribtypeinfo\">attribtypeinfo</a> for more information.</p></body>",
    "primduv": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primduv\">primduv</a></h1><p class=\"summary\">Returns position derivative on a primitive at a certain parametric (u, v) position.</p><div class=\"usage\"> <code>vector primduv(string geometry, int prim_number, vector2 uv, int du, int dv)</code></div><div class=\"argument\"><code>prim_number</code></div><p>The number of the primitive on which to measure the derivative.</p><div class=\"argument\"><code>uv</code></div><p>The parametric coordinates on the primitive at which to measure the derivative.</p><div class=\"argument\"><code><code>du</code>, <code>dv</code></code></div><p>Represent the derivative order to query.</p><p>On a curve, the curve direction is given by <code>du==1</code> and the curvature is given by <code>du==2</code>.</p><p>This only works on NURBS and Bezier curve primitives.</p><p><code class=\"var\">du</code> is currently ignored as it is meant to work with parametric surfaces.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getderiv\">getderiv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Du\">Du</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dv\">Dv</a></div></body>",
    "primfind": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primfind\">primfind</a></h1><p class=\"summary\">Returns a list of primitives potentially intersecting a given bounding box.</p><div class=\"usage\"> <code>int[] primfind(&lt;geometry&gt;, vector min, vector max)</code></div><p>Find all the primitives whose bounding boxes overlap the given box.</p><div class=\"usage\"> <code>int[] primfind(&lt;geometry&gt;, string group, vector min, vector max)</code></div><p>Find all primitives in a group whose bounding boxes overlap the given box.</p><div class=\"argument\"><code><code>min</code>, <code>max</code></code></div><p>These vectors define the minimum and maximum corners of the bounding box to search.</p><div class=\"argument\"><code><code>group</code></code></div><p>If given, only match primitives in this group.\n    An empty group string will include all primitives.\n    The string supports Ad-hoc patterns like <code>0-10</code> and <code>@Cd.x&gt;0</code>.</p><h2>Returns</h2><p>An array of primitive numbers.</p><h2>Note</h2><p>These functions are intended to be used as an optimization to finding primitives\n    in a particular area for processing.  For instance, to find all the curves\n    from one input intersecting polygons on another input, we may naively iterate\n    over all polygons for each curve to determine their intersection.  To speed this\n    process, we may find which primitives may intersect a particular curve using\n    these functions, and iterate solely over the potentially intersecting\n    primitives.  This significantly improves performance since <code>primfind</code> uses an\n    underlying tree structure to speed up search.</p><h2>Examples</h2><p>Remove primitives that may be intersecting the unit box centered at the origin:</p><div class=\"codeblock\"><code class=\"codeline\">int[] prims = primfind(geometry, {-0.5, -0.5, -0.5}, {0.5, 0.5, 0.5});</code><code class=\"codeline\">foreach ( int prim; prims )</code><code class=\"codeline\">{</code><code class=\"codeline\">    removeprim(\"primitives.bgeo\", prim, 1);</code><code class=\"codeline\">}</code></div><p>Alternatively, we can use a query bounding box from an auxiliary source:</p><div class=\"codeblock\"><code class=\"codeline\">vector min, max;</code><code class=\"codeline\">getbbox(\"bbox.bgeo\", min, max);</code><code class=\"codeline\">int[] prims = primfind(geometry, min, max);</code><code class=\"codeline\">foreach ( int prim; prims )</code><code class=\"codeline\">{</code><code class=\"codeline\">    removeprim(\"primitives.bgeo\", prim, 1);</code><code class=\"codeline\">}</code></div><p>To see the performance benefit of <code>primfind</code>, compare it to the following equivalent\nimplementation of the function above:</p><div class=\"codeblock\"><code class=\"codeline\">float tol = 1e-5;</code><code class=\"codeline\">vector min, max;</code><code class=\"codeline\">getbbox(\"bbox.bgeo\",min,max);</code><code class=\"codeline\">int n = nprimitives(0);</code><code class=\"codeline\">for ( int prim = 0; prim &lt; n; ++prim )</code><code class=\"codeline\">{</code><code class=\"codeline\">    int[] verts = primvertices(\"primitives.bgeo\", prim);</code><code class=\"codeline\">    </code><code class=\"codeline\">    // compute primitive bounding box and store it in prim_min and prim_max</code><code class=\"codeline\">    vector vert_pos = point(\"primitives.bgeo\", \"P\", vertexpoint(\"primitives.bgeo\", verts[0]));</code><code class=\"codeline\">    vector prim_min = vert_pos, prim_max = vert_pos;</code><code class=\"codeline\">    for ( int v = 1; v &lt; len(verts); ++v )</code><code class=\"codeline\">    {</code><code class=\"codeline\">        vert_pos = point(\"primitives.bgeo\", \"P\", vertexpoint(\"primitives.bgeo\", verts[v]));</code><code class=\"codeline\">        prim_min = min(prim_min, vert_pos);</code><code class=\"codeline\">        prim_max = max(prim_max, vert_pos);</code><code class=\"codeline\">    }</code><code class=\"codeline\">    </code><code class=\"codeline\">    // bounding box intersection test</code><code class=\"codeline\">    if ( prim_max.x - min.x &lt; -tol ) continue;</code><code class=\"codeline\">    if ( prim_max.y - min.y &lt; -tol ) continue;</code><code class=\"codeline\">    if ( prim_max.z - min.z &lt; -tol ) continue;</code><code class=\"codeline\">    if ( prim_min.x - max.x &gt; tol ) continue;</code><code class=\"codeline\">    if ( prim_min.y - max.y &gt; tol ) continue;</code><code class=\"codeline\">    if ( prim_min.z - max.z &gt; tol ) continue;</code><code class=\"codeline\">    removeprim(\"primitives.bgeo\", prim, 1);</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getbbox\">getbbox</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pcfind\">pcfind</a></div></body>",
    "primhedge": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primhedge\">primhedge</a></h1><p class=\"summary\">Returns <strong>one</strong> of the half-edges contained in a primitive.</p><div class=\"usage\"> <code>int primhedge(&lt;geometry&gt;, int prim)</code></div><div class=\"argument\"><code>prim</code></div><p>The primitive number in the geometry.  <code>0</code> is the first primitive.</p><h2>Returns</h2><p>The number of an arbitrary half-edge contained in <code>prim</code>.\n    Returns <code>-1</code> if the primitive number is not valid.</p></body>",
    "priminteriorweights": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/priminteriorweights\">priminteriorweights</a></h1><p class=\"summary\">Finds the indices and weightings of the vertices that will compute an\ninterior point given the UVW coordinates.</p><div class=\"usage\"> <code>int priminteriorweights( &lt;geometry&gt;; int prim_num; vector uvw; int &amp;verts[]; float &amp;weights[])</code></div><div class=\"argument\"><code>prim_num</code></div><p>The primitive number to read the attribute from.</p><div class=\"argument\"><code>uvw</code></div><p>The primitive UVW coordinates at which to read the attribute.</p><p>Finds the indices and weightings of the vertices that will compute an interior\npoint given the UVW coordinates. The indices are linear vertex indices.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primuv\">primuv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prim_attribute\">prim_attribute</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uvsample\">uvsample</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xyzdist\">xyzdist</a></div></body>",
    "primintrinsic": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primintrinsic\">primintrinsic</a></h1><p class=\"summary\">Reads a primitive intrinsic from a geometry.</p><div class=\"usage\"> <code>&lt;type&gt; primintrinsic(&lt;geometry&gt;, string intrinsic_name, int prim_num)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] primintrinsic(&lt;geometry&gt;, string intrinsic_name, int prim_num)</code></div><div class=\"argument\"><code>prim_num</code></div><p>The number of the primitive to read the given intrinsic attribute for.</p><h2>Returns</h2><p>The value of the intrinsic attribute, or <code>0</code> if the intrinsic does not exist.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/detailintrinsic\">detailintrinsic</a></div></body>",
    "primpoint": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primpoint\">primpoint</a></h1><p class=\"summary\">Converts a primitive/vertex pair into a point number.</p><div class=\"usage\"> <code>int primpoint(&lt;geometry&gt;, int primnum, int vertex)</code></div><div class=\"argument\"><code>primnum</code></div><p>The primitive number to get a vertex from.</p><div class=\"argument\"><code>vertex</code></div><p>The vertex number inside of a primitive.  0 is the first vertex.</p><h2>Returns</h2><p>The point number the vertex is wired to.\n    Returns <code>-1</code> if failed to find the corresponding point.</p></body>",
    "primpoints": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primpoints\">primpoints</a></h1><p class=\"summary\">Returns the list of points on a primitive.</p><div class=\"usage\"> <code>int [] primpoints(&lt;geometry&gt;, int primnum)</code></div><div class=\"argument\"><code>primnum</code></div><p>The primitive number to get the points of.</p><h2>Returns</h2><p>An array of points, in the same order as stored on the primitive itself.\n    If the primitive number is not valid, the array will be empty.</p></body>",
    "primuv": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primuv\">primuv</a></h1><p class=\"summary\">Interpolates the value of an attribute at a certain parametric (uvw) position.</p><p>This function specifies the position using <em>intrinsic primitive UVs</em>. To use UVs stored in UV attribute, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uvsample\">uvsample</a> instead.</p><div class=\"usage\"> <code>&lt;type&gt; primuv( &lt;geometry&gt;; string attribute_name; int prim_num; vector uvw)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] primuv( &lt;geometry&gt;; string attribute_name; int prim_num; vector uvw)</code></div><div class=\"argument\"><code>attribute_name</code></div><p>The name of the attribute to read. <strong>For point and vertex attributes, the value will at the given UV coordinates will be interpolated</strong> from the surrounding points/vertices.</p><div class=\"argument\"><code>prim_num</code></div><p>The primitive number to read the attribute from.</p><div class=\"argument\"><code>uvw</code></div><p>The primitive UVW coordinates at which to read the attribute.</p><div class=\"related\">Returns the (possibly interpolated) value of the attribute at the given coordinates. If the attribute or primitive number don\u2019t exist, returns <code>0</code>.</div><div class=\"related\">If you need to test for errors, you can use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prim_attribute\">prim_attribute</a> instead.</div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prim_attribute\">prim_attribute</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uvsample\">uvsample</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xyzdist\">xyzdist</a></div></body>",
    "primuvconvert": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primuvconvert\">primuvconvert</a></h1><p class=\"summary\">Convert parametric UV locations on curve primitives between different spaces.</p><div class=\"usage\"> <code>vector2 primuvconvert(&lt;geometry&gt;, vector2 uv, int prim_num, int mode)</code></div><div class=\"usage\"> <code>vector2 primuvconvert(&lt;geometry&gt;, vector2 uv, int prim_num, int mode, float tolerance)</code></div><div class=\"usage\"> <code>float primuvconvert(&lt;geometry&gt;, float uv, int prim_num, int mode)</code></div><div class=\"usage\"> <code>float primuvconvert(&lt;geometry&gt;, float uv, int prim_num, int mode, float tolerance)</code></div><div class=\"argument\"><code>uv</code></div><p>Curve coordinates to convert. Can be a float or a vector2. The function returns the converted coordinates.</p><div class=\"argument\"><code>prim_num</code></div><p>The primitive number of the curve on which to convert the coordinates.</p><div class=\"argument\"><code>mode</code></div><p>One of the <code>PRIMUV_<code class=\"var\">space</code>_TO_<code class=\"var\">space</code></code> constants listed below. You can import the constants from <code>$HFS/houdini/vex/include/math.h</code>.</p><p>REAL domain is based on the number of curve segments (0 to <code>nSegments</code>). A segment can hold multiple control points based on the curve degree. <code>UNIT</code> domain is the REAL domain normalized to fit in 0 to 1. <code>UNITLEN</code> domain maps the curve based on its length but normalized (0..1). <code>LEN</code> domain maps the curve based on its length (0..<code>CurveLength</code>).</p><span>Constant name </span><span>Int value </span><span>PRIMUV_REAL_TO_UNIT </span><p>0</p><span>PRIMUV_REAL_TO_UNITLEN </span><p>1</p><span>PRIMUV_REAL_TO_LEN </span><p>2</p><span>PRIMUV_UNIT_TO_REAL </span><p>3</p><span>PRIMUV_UNIT_TO_UNITLEN </span><p>4</p><span>PRIMUV_UNIT_TO_LEN </span><p>5</p><span>PRIMUV_UNITLEN_TO_REAL </span><p>6</p><span>PRIMUV_UNITLEN_TO_UNIT </span><p>7</p><span>PRIMUV_UNITLEN_TO_LEN </span><p>8</p><span>PRIMUV_LEN_TO_REAL </span><p>9</p><span>PRIMUV_LEN_TO_UNIT </span><p>10</p><span>PRIMUV_LEN_TO_UNITLEN </span><p>11</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/curvearclen\">curvearclen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primarclen\">primarclen</a></div></body>",
    "primvertex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primvertex\">primvertex</a></h1><p class=\"summary\">Converts a primitive/vertex pair into a linear vertex.</p><div class=\"usage\"> <code>int primvertex(&lt;geometry&gt;, int primnum, int vertex)</code></div><div class=\"argument\"><code>primnum</code></div><p>The primitive number to get a vertex from.</p><div class=\"argument\"><code>vertex</code></div><p>The vertex number inside the primitive.  0 is the first vertex.</p><h2>Returns</h2><p>The linear vertex index corresponding to the given primitive vertex.\n    Returns <code>-1</code> if the function cannot find the linear vertex index.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int linearvtx;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the linear vertex value of vertex 2 of primitive 3.</code><code class=\"codeline\">linearvtx = primvertex(\"defgeo.bgeo\", 3, 2);</code></div></body>",
    "primvertexcount": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primvertexcount\">primvertexcount</a></h1><p class=\"summary\">Returns number of vertices in a primitive in a geometry.</p><div class=\"usage\"> <code>int primvertexcount(&lt;geometry&gt;, int prim_num)</code></div><div class=\"argument\"><code>prim_num</code></div><p>The primitive number of the primitive to count vertices on.</p><h2>Returns</h2><p>The number of vertices in the given primitive, or <code>-1</code> if the primitive does not exist.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int        nvtx;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the number of vertices of primitive 3</code><code class=\"codeline\">nvtx = primvertexcount(\"defgeo.bgeo\", 3);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexindex\">vertexindex</a></div></body>",
    "primvertices": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primvertices\">primvertices</a></h1><p class=\"summary\">Returns the list of vertices on a primitive.</p><div class=\"usage\"> <code>int [] primvertices(&lt;geometry&gt;, int primnum)</code></div><div class=\"argument\"><code>primnum</code></div><p>The primitive number to get a vertex from.</p><h2>Returns</h2><p>An array of linear vertex indices, in the same order as stored on the primitive itself.\n    If the primitive number is not valid, the array will be empty.</p></body>",
    "prim_attribute": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prim_attribute\">prim_attribute</a></h1><p class=\"summary\">Interpolates the value of an attribute at a certain parametric (u, v) position and copies it into a variable.</p><p>This function specifies the position using <em>intrinsic primitive UVs</em>. To use UVs stored in UV attribute, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uvsample\">uvsample</a> instead.</p><div class=\"usage\"> <code>int prim_attribute(&lt;geometry&gt;, &lt;type&gt; &amp;value, string attribute_name, int prim_number, float u, float v)</code></div><div class=\"usage\"> <code>int prim_attribute(&lt;geometry&gt;, &lt;type&gt; &amp;value[], string attribute_name, int prim_number, float u, float v)</code></div><p>Samples the attribute value at the given UV coordinates on the primitive.</p><div class=\"usage\"> <code>int prim_attribute(&lt;geometry&gt;, &lt;type&gt; &amp;value, string attribute_name, int prim_number, vector uvw)</code></div><div class=\"usage\"> <code>int prim_attribute(&lt;geometry&gt;, &lt;type&gt; &amp;value[], string attribute_name, int prim_number, vector uvw)</code></div><p>Specify the UVW coordinates using a vector instead of two floats.</p><p>If you don\u2019t need to test for errors, you can use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primuv\">primuv</a> instead.\nThis function does not work with certain primitive types such as tetrahedra and polysoups.</p><div class=\"argument\"><code>value</code></div><p>The function overwrites this variable with the interpolated value from the primitive.</p><div class=\"argument\"><code>attribute_name</code></div><p>The name of the attribute to read. <strong>For point and vertex attributes, the value will at the given UV coordinates will be interpolated</strong> from the surrounding points/vertices.</p><div class=\"argument\"><code>prim_number</code></div><p>The primitive number to read the attribute from.</p><div class=\"argument\"><code><code>u</code>, <code>v</code></code></div><p>The primitive UV coordinates at which to read the attribute.</p><h2>Returns</h2><p>Returns <code>1</code> on success or <code>0</code> on an error (for example, the attribute doesn\u2019t exist).</p><p>Returns <code>0</code> if the type of <code>value</code> is larger than the primitive type. For example, you can\u2019t read a vector attribute into a matrix variable.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primuv\">primuv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uvsample\">uvsample</a></div></body>",
    "prim_normal": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prim_normal\">prim_normal</a></h1><p class=\"summary\">Returns the normal of the primitive (prim_number) at parametric location u, v.</p><div class=\"usage\"> <code>vector prim_normal(&lt;geometry&gt;, int prim_number, vector uvw)</code></div><div class=\"usage\"> <code>vector prim_normal(&lt;geometry&gt;, int prim_number, float u, float v)</code></div><div class=\"usage\"> <code>vector prim_normal(&lt;geometry&gt;, int prim_number, float u, float v, float w)</code></div><div class=\"argument\"><code><code>uvw</code>, <code>u</code>, <code>v</code>, <code>w</code></code></div><p>When <code class=\"var\">w</code> is not given, it is treated as zero.</p><h2>Returns</h2><p>The normal of the primitive (prim_number) at parametric location <code class=\"var\">u</code>, <code class=\"var\">v</code>, <code class=\"var\">w</code>. </p></body>",
    "printf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/printf\">printf</a></h1><p class=\"summary\">Prints values to the console which started the VEX program.</p><div class=\"usage\"> <code>void printf(string format, ...)</code></div><p>The format string is a simpler version of the C <code>printf</code> format string.\nWhen a <code>%</code> symbol is found in the string, an argument will be printed\nout in a format specified by the characters following the <code>%</code> symbol.\nThe conversion of the argument is specified by a single letter: <code>g</code>, <code>f</code>,\n<code>s</code>, <code>d</code>, <code>x</code>, <code>c</code>, <code>p</code>.</p><p>You can prefix the format option with an optional prefix characters to control\nthe formatting of the output.  The general form of a prefix is\n<code>[flags][width][.precision][format]</code>, where Flags can be:</p><div class=\"related\"><code>-</code>: The result will be left justified in the field</div><div class=\"related\"><code>+</code>: A numeric value will be prefixed with either <code>+</code> for positive\nvalues.  A non-standard behavior of this flag is that string\narguments will be quoted when the <code>+</code> flag is set.</div><div class=\"related\"><code>0</code>: For numeric values, leading zeros are used to pad the field.</div><div class=\"argument\"><code>Width</code></div><p>The width can be specified by one or more decimal digits.  Alternately, if\n    an asterisk (<code>*</code>) is given, the width will be taken from the next value\n    in the <code>printf</code> argument list.</p><div class=\"argument\"><code>Precision</code></div><p>The precision can be specified by one or more decimal digits.  Alternately,\n    if an asterisk (<code>*</code>) is given, the width will be taken from the next value\n    in the <code>printf</code> argument list.</p><p>The different format characters supported are</p><div class=\"argument\"><code><code>%g</code>, <code>%p</code>, <code>%c</code> </code></div><p>Print an integer float, vector, vector4, matrix3, matrix or string\n    in general form.</p><div class=\"argument\"><code><code>%f</code>, <code>%e</code>, <code>%E</code> </code></div><p>Print a float, vector, vector4, matrix3 or matrix in floating point\n    form.</p><div class=\"argument\"><code><code>%s</code> </code></div><p>Print a string.</p><div class=\"argument\"><code><code>%d</code>, <code>%i</code> </code></div><p>Print an integer variable in decimal.</p><div class=\"argument\"><code><code>%x</code>, <code>%X</code> </code></div><p>Print an integer variable in hexidecimal.  The value will be prefixed with\n    0x (i.e. 0\u00d742).</p><div class=\"argument\"><code><code>%o</code></code></div><p>Print an integer variable in octal.</p><div class=\"argument\"><code><code>%%</code> </code></div><p>Print a percent sign (%).</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">printf(\"P = %g, dot(N, P) = %g, %d = %x\\n\", P, dot(N, P), ptnum, ptnum);</code><code class=\"codeline\">printf(\"RGB = {%g,%g,%g}\\n\", clr.r, clr.g, clr.b);</code><code class=\"codeline\">printf(\"P = %20s\\n\", \"20 chars\");</code><code class=\"codeline\">printf(\"%-+20s\\n\", \"Left justified and quoted\");</code><code class=\"codeline\">printf(\"%+08.3g\\n\", velocity);</code><code class=\"codeline\">printf(\"%*.*g\\n\", width, precision, value);</code><code class=\"codeline\">Cf = texture(sprintf(\"/maps/map%d.rat\", i));</code><code class=\"codeline\">Cf = texture(sprintf(\"/maps/map%04d.rat\", i));</code></div></body>",
    "print_once": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/print_once\">print_once</a></h1><p class=\"summary\">Prints a message only once, even in a loop.</p><div class=\"usage\"> <code>void print_once(string msg, ...)</code></div><p>Prints the string passed to the function exactly one time, even in a loop.\nThis is useful to print a message before the first iteration of a loop, without having to count iterations.</p><div class=\"argument\"><code>msg</code></div><p>The string to print. This string does support interpolating values.\n    Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sprintf\">sprintf</a> to generate the <code class=\"var\">msg</code> string if you need to include values.</p><div class=\"argument\"><code>global</code></div><span class=\"padder\"><span class=\"pillow\">int</span></span><span class=\"padder\"><span class=\"pillow\">0</span></span><p>Normally, multiple instances of <code>print_once()</code> call sites\n    will work independently of each other.  That is, if two separate\n    call sites to <code>print_once()</code> are passed the same string, the string will be\n    printed twice (once per call site).  With the global flag turned on, strings\n    are checked across all instances of the <code>print_once()</code> functions.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Only print \"Hello world\" one time</code><code class=\"codeline\">for (int i = 0; i &lt; 100; ++i)</code><code class=\"codeline\">    print_once(\"Hello world\\n\");</code><code class=\"codeline\"></code><code class=\"codeline\">// Print a missing texture warning, just one time across all shaders</code><code class=\"codeline\">print_once( sprintf(\"Missing texture map: %s\\n\", texture_map), \"global\", 1);</code></div></body>",
    "product": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/product\">product</a></h1><p class=\"summary\">Returns the product of a list of numbers.</p><div class=\"usage\"> <code>float product(float n)</code></div><div class=\"usage\"> <code>int product(int n)</code></div><p>Returns the argument.</p><div class=\"usage\"> <code>float product(vector2 v)</code></div><div class=\"usage\"> <code>float product(vector v)</code></div><div class=\"usage\"> <code>float product(vector4 v)</code></div><p>Returns the product of the vector\u2019s components.</p><div class=\"usage\"> <code>int product(int arr[])</code></div><div class=\"usage\"> <code>float product(float arr[])</code></div><p>Returns the product of the items of the array.</p><div class=\"usage\"> <code>&lt;vector&gt; product(&lt;vector&gt; arr[])</code></div><p>Returns a vector where the components are the products of the corresponding components in the vectors in the array.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sum\">sum</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/outerproduct\">outerproduct</a></div></body>",
    "ptexture": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptexture\">ptexture</a></h1><p class=\"summary\">Computes a filtered sample from a ptex texture map. Use texture instead.</p><div class=\"usage\"> <code>&lt;type&gt; ptexture(string map, int face_id, ...)</code></div><div class=\"usage\"> <code>&lt;type&gt; ptexture(string map, int face_id, float s, float t, ...)</code></div><p>This function is deprecated since ptex support has been integrated into the <code>texture()</code> function.</p><h2>Optional arguments</h2><p><code>channel</code>\n        td&gt;&gt;\n        An integer value indicating which channel of the ptex image to use.</p><p><code>filter</code>\n        td&gt;&gt;</p><p>The texture filter to use when filtering the texture.  Choices for the filter are:</p><div class=\"related\"><code>point</code>: Point Filter (no filtering)</div><div class=\"related\"><code>bilinear</code>:  Bilinear Texture Filter</div><div class=\"related\"><code>box</code>:  Box Texture Filter</div><div class=\"related\"><code>gaussian</code>:  Gaussian Texture Filter (default)</div><div class=\"related\"><code>bicubic</code>:  Bicubic Texture Filter</div><div class=\"related\"><code>catmullrom</code>:  Catmull-Rom Texture Filter</div><div class=\"related\"><code>mitchell</code>:  Mitchell Texture Filter</div><p><code>filtersharp</code></p><p>A floating point value indicating the filter sharpness.  This is only valid for the bicubic filter.  The range is 0-1 (the default is 1.0).</p><p><code>lerp</code></p><p>An boolean value indicating whether to interpolate between Mip maps.  The default is true.</p><p><code>blur</code></p><p>The texture blur value used for evaluation (default 0).</p><p><code>width</code></p><p>The texture width value used for evaluation (default 1).</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texture\">texture</a></div></body>",
    "ptlined": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptlined\">ptlined</a></h1><p class=\"summary\">This function returns the closest distance between the point Q and a\nfinite line segment between points P0 and P1.</p><div class=\"usage\"> <code>float ptlined(vector P0, vector P1, vector Q)</code></div><p>This function returns the closest distance between the point <code class=\"var\">Q</code> and a\nfinite line segment between points <code class=\"var\">P0</code> and <code class=\"var\">P1</code>.</p></body>",
    "ptransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a></h1><p class=\"summary\">Transforms a vector from one space to another.</p><div class=\"usage\"> <code>vector ptransform(vector vec, matrix transform)</code></div><div class=\"usage\"> <code>vector4 ptransform( vector4 vec; matrix transform)</code></div><p>Transforms the vector using the given transform matrix.</p><div class=\"usage\"> <code>vector ptransform(string tospace, vector vec)</code></div><div class=\"usage\"> <code>vector4 ptransform(string tospace, vector4 vec)</code></div><p>Transforms from <code>\"space:current\"</code>.</p><div class=\"usage\"> <code>vector ptransform(string fromspace, string tospace, vector vec)</code></div><div class=\"usage\"> <code>vector4 ptransform(string fromspace, string tospace, vector4 vec)</code></div><p>Transforms the vector from <code>fromspace</code> into <code>tospace</code>.</p><div class=\"argument\"><code><code>fromspace</code>, <code>tospace</code></code></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a> interprets the vector as a position.</div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vtransform\">vtransform</a> interprets the vector as a direction\nvector, and so doesn\u2019t apply the translations from the matrix.</div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ntransform\">ntransform</a> interprets the vector as a normal vector,\nand so multiplies by the inverse transpose of the matrix (ignoring the\ntranslations).</div><h2>Examples</h2><p>The version with only a <code class=\"var\">tospace</code> argument assumes <code class=\"var\">fromspace</code> is\n<code>\"space:current\"</code>. For example:</p><div class=\"codeblock\"><code class=\"codeline\">Pworld = ptransform(\"space:world\", P);</code></div><p>\u2026is equivalent to:</p><div class=\"codeblock\"><code class=\"codeline\">Pworld = ptransform(\"space:current\", \"space:world\", P);</code></div><p>Transform a vector from its current space to object space:</p><div class=\"codeblock\"><code class=\"codeline\">ospace = ptransform(\"space:object\", P)</code></div><p>Transform a vector from object space to mantra\u2019s natural coordinate\nspace (camera space):</p><div class=\"codeblock\"><code class=\"codeline\">ospace = ptransform(\"space:object\", \"space:current\", P)</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ntransform\">ntransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vtransform\">vtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getspace\">getspace</a></div></body>",
    "push": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/push\">push</a></h1><p class=\"summary\">Adds an item to an array.</p><div class=\"usage\"> <code>void push(&lt;type&gt; &amp;array[]; &lt;type&gt; value)</code></div><p>Appends the given value to the end of the array. Increases the size of <code>array</code> by 1. This is the same as <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/append\">append(array, value)</a>.</p><div class=\"usage\"> <code>void push(&lt;type&gt; &amp;array[]; &lt;type&gt; values[])</code></div><p>Concatenates the values from the <code>values</code> array to the end of <code>array</code>. Increases the size of <code>array</code> by <code>len(values)</code>. This is the same as <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/append\">append(array, values)</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/len\">len</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/append\">append</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/resize\">resize</a></div></body>",
    "pxnoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xnoise\">xnoise</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid.  This results in less grid artifacts.  It also uses a higher order bspline to provide better derivatives. This is the periodic simplex noise</p><div class=\"usage\"> <code>float|vector pxnoise(float x, int xp)</code></div><div class=\"usage\"> <code>float|vector pxnoise(float x, float y, int xp, int yp)</code></div><div class=\"usage\"> <code>float|vector pxnoise(vector xyz, int xp, int yp, int zp)</code></div><div class=\"usage\"> <code>float|vector pxnoise(vector4 xyzt, int xp, int yp, int zp, int wp)</code></div><p>Simplex noise is very close to Perlin noise, except with the samples on a\nsimplex mesh rather than a grid.  This results in less grid artifacts.  It also\nuses a higher order <code>bspline</code> to provide better derivatives.</p><p>The various functions return the noise value at a 4D (vector4 argument),\n3D (vector argument), 2D (two float arguments) or 1D (float argument)\nposition. You can get a random float value or a vector of three random\nvalues.</p><p>The noise is in the range 0-1 with a median of 0.5. The distribution of\nthe noise depends on the dimension, with higher dimensions approaching a\nGaussian distribution of noise values.</p><p>The p int or vector arguments specify the range of periodicity, but\nthis periodicity is not an integer. For non-periodic simplex noise, see\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xnoise\">xnoise</a></p><h2>Related</h2></body>",
    "pxnoised": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pxnoised\">pxnoised</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Periodic derivatives of Simplex Noise.</p><div class=\"usage\"> <code>void pxnoised(float x, int px, float &amp;v, float &amp;dvdx)</code></div><div class=\"usage\"> <code>void pxnoised(float x, int px, vector &amp;v, vector &amp;dvdx)</code></div><div class=\"usage\"> <code>void pxnoised(float x, float y, int px, int py, float &amp;v, float &amp;dvdx, float &amp;dvdy)</code></div><div class=\"usage\"> <code>void pxnoised(float x, float y, int px, int py, vector &amp;v, vector &amp;dvdx, vector &amp;dvdy)</code></div><div class=\"usage\"> <code>void pxnoised(vector xyz, int px, int py, int pz, float &amp;v, float &amp;dvdx, float &amp;dvdy, float &amp;dvdz)</code></div><div class=\"usage\"> <code>void pxnoised(vector xyz, int px, int py, int pz, vector &amp;v, vector &amp;dvdx, vector &amp;dvdy, vector &amp;dvdz)</code></div><div class=\"usage\"> <code>void pxnoised(vector4 xyzw, int px, int py, int pz, int pw, float &amp;v, float &amp;dvdx, float &amp;dvdy, float &amp;dvdz, float &amp;dvdw)</code></div><div class=\"usage\"> <code>void pxnoised(vector4 xyzw, int px, int py, int pz, int pw, vector &amp;v, vector &amp;dvdx, vector &amp;dvdy, vector &amp;dvdz, vector &amp;dvdw)</code></div><p>This computes both the simplex noise value, and the derivatives of the\nnoise along each axis. This can be performed quite efficiently as\nthere are analytic derivatives available. </p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xnoise\">xnoise</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pxnoise\">pxnoise</a> for other versions of xnoise.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/random\">noise and randomness</a>  in the VEX language\nguide for more information.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xnoised\">xnoised</a></div></body>",
    "qconvert": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/qconvert\">qconvert</a></h1><p class=\"summary\">Converts a quaternion represented by a vector4 to a matrix3 representation.</p><div class=\"usage\"> <code>matrix3 qconvert(vector4 quaternion)</code></div><p>Converts a quaternion represented by a vector4 to a matrix3 representation.</p><div class=\"usage\"> <code>matrix qconvert(vector4 quaternion; vector offset)</code></div><p>Converts a quaternion represented by a vector4 to a matrix representation.\nApplies the offset as a post-translation, so the resulting matrix will\nfirst rotate a point by the quaternion and then add the offset.</p><div class=\"usage\"> <code>vector qconvert(vector4 quaternion)</code></div><p>Converts a quaternion represented by a vector4 into a angle/axis vector.</p></body>",
    "qdistance": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/qdistance\">qdistance</a></h1><p class=\"summary\">Finds distance between two quaternions.</p><div class=\"usage\"> <code>float qdistance(vector4 q1, vector4 q2)</code></div><p>Returns the approximate angle, in radians, between two quaternions.</p></body>",
    "qinvert": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/qinvert\">qinvert</a></h1><p class=\"summary\">Inverts a quaternion rotation.</p><div class=\"usage\"> <code>vector4 qinvert(vector4 quaternion)</code></div><p>Creates the inverse quaternion to the supplied one.  This will rotate points\nin the opposite direction.</p></body>",
    "qmultiply": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/qmultiply\">qmultiply</a></h1><p class=\"summary\">Multiplies two quaternions and returns the result.</p><div class=\"usage\"> <code>vector4 qmultiply(vector4 q1, vector4 q2)</code></div><p>Multiplies two quaternions and returns the result.</p></body>",
    "qrotate": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/qrotate\">qrotate</a></h1><p class=\"summary\">Rotates a vector by a quaternion.</p><div class=\"usage\"> <code>vector qrotate(vector4 quaternion, vector v)</code></div><p>Returns the vector <code>v</code> rotated by the given <a href=\"https://en.wikipedia.org/wiki/Quaternion\">quaternion</a>.</p></body>",
    "quaternion": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/quaternion\">quaternion</a></h1><p class=\"summary\">Creates a vector4 representing a quaternion.</p><div class=\"usage\"> <code>vector4 quaternion(matrix3 rotations)</code></div><p>Creates a vector4 representing a quaternion from a 3\u00d73 rotational matrix.</p><div class=\"usage\"> <code>vector4 quaternion(float angle, vector axis)</code></div><p>Creates a vector4 representing a quaternion from an <code class=\"var\">angle</code> and <code class=\"var\">axis</code>. The <code class=\"var\">angle</code> is specified in radians.</p><div class=\"usage\"> <code>vector4 quaternion(vector angleaxis)</code></div><p>Creates a vector4 representing a quaternion from a combined angle/axis. This is the normalized rotation axis multiplied by the rotation angle in radians.</p><p>There used to be a fourth form that took a rotation vector.  It has been renamed to <code>eulertoquaternion</code> and now takes radians.</p><p>For more information, see <a href=\"https://www.sidefx.com/docs/houdini/vex/lang#data-types\">Data types</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/lang#dot-operator\">Dot operator</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/dihedral\">dihedral</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/qconvert\">qconvert</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/eulertoquaternion\">eulertoquaternion</a></div></body>",
    "quaterniontoeuler": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/quaterniontoeuler\">quaterniontoeuler</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Creates a euler angle representing a quaternion.</p><div class=\"usage\"> <code>vector quaterniontoeuler(vector4 orient, int order)</code></div><p>Creates a vector representing euler angles from a vector4 representing a quaternion.</p><p>The angles are in radians.  Use the <code>degrees()</code> function to convert radians into degrees.</p><p>Specify the rotation order with the <code class=\"var\">order</code> integer. Use the constants defined in <code>$HH/vex/include/math.h</code> (for example, <code>XFORM_XYZ</code>).</p><p>For more information, see <a href=\"https://www.sidefx.com/docs/houdini/vex/lang#data-types\">Data types</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/lang#dot-operator\">Dot operator</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/dihedral\">dihedral</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/qconvert\">qconvert</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/quaternion\">quaternion</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/eulertoquaternion\">quaternion</a></div></body>",
    "radians": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/radians\">radians</a></h1><p class=\"summary\">Converts the argument from degrees into radians.</p><div class=\"usage\"> <code>float radians(float num_in_degs)</code></div><p>Converts the number of degrees in the argument to radians.</p><div class=\"usage\"> <code>&lt;vector&gt; radians(&lt;vector&gt; nums_in_degs)</code></div><p>Returns a new vector with <code>atan()</code> applied to each component.</p><h2>Tip</h2><p>The VEX trig functions work with radians, but most users are more comfortable with degrees. You may want to convert from radians for internal use to degrees in the UI.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/degrees\">degrees</a></div></body>",
    "ramp_lookup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ramp_lookup\">ramp_lookup</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Evaluates a Houdini-style ramp at a specific location.</p><div class=\"usage\"> <code>float ramp_lookup(float pos, string ramp)</code></div><div class=\"usage\"> <code>vector ramp_lookup(float pos, string ramp)</code></div><div class=\"usage\"> <code>float ramp_lookup(float pos, string basis[], float key[], float val[])</code></div><div class=\"usage\"> <code>vector ramp_lookup(float pos, string basis[], float key[], vector val[])</code></div><p>Evaluates a provided ramp at the given position.  The ramp can be an encoded string or a triple of basis, key, and value arrays.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/spline\">spline</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ramp_pack\">ramp_pack</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ramp_unpack\">ramp_unpack</a></div></body>",
    "ramp_pack": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ramp_pack\">ramp_pack</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Packs a set of arrays into a string-encoded ramp.</p><div class=\"usage\"> <code>string ramp_pack(string basis[], float pos[], float value[] )</code></div><div class=\"usage\"> <code>string ramp_pack(string basis[], float pos[], vector value[] )</code></div><div class=\"usage\"> <code>string ramp_pack(string basis[], float pos[], vector4 value[] )</code></div><p>Ramps are commonly packed as JSON formatted strings by Houdini operations.\nThis will pack them three arrays of basis, position, and value into the\ncorresponding string.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/spline\">spline</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ramp_lookup\">ramp_lookup</a></div></body>",
    "ramp_unpack": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ramp_unpack\">ramp_unpack</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Unpacks a string-encoded ramp into a set of arrays.</p><div class=\"usage\"> <code>void ramp_unpack(string ramp, string &amp;basis[], float &amp;pos[], float &amp;value[] )</code></div><div class=\"usage\"> <code>void ramp_unpack(string ramp, string &amp;basis[], float &amp;pos[], vector &amp;value[] )</code></div><div class=\"usage\"> <code>void ramp_unpack(string ramp, string &amp;basis[], float &amp;pos[], vector4 &amp;value[] )</code></div><p>Ramps are commonly packed as JSON formatted strings by Houdini operations.\nThis will unpack them into three arrays of basis, position, and value, which\ncan then be used by the spline or ramp_lookup functions.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/spline\">spline</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ramp_lookup\">ramp_lookup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ramp_pack\">ramp_pack</a></div></body>",
    "rand": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rand\">rand</a></h1><p class=\"summary\">Creates a random number between 0 and 1 from a seed.</p><div class=\"usage\"> <code>float rand(float seed)</code></div><div class=\"usage\"> <code>vector2 rand(float seed)</code></div><div class=\"usage\"> <code>vector rand(float seed)</code></div><div class=\"usage\"> <code>vector4 rand(float seed)</code></div><div class=\"usage\"> <code>float rand(float seed, float seed2)</code></div><div class=\"usage\"> <code>vector2 rand(float seed, float seed2)</code></div><div class=\"usage\"> <code>vector rand(float seed, float seed2)</code></div><div class=\"usage\"> <code>vector4 rand(float seed, float seed2)</code></div><div class=\"usage\"> <code>float rand(vector2 seed)</code></div><div class=\"usage\"> <code>vector2 rand(vector2 seed)</code></div><div class=\"usage\"> <code>vector rand(vector2 seed)</code></div><div class=\"usage\"> <code>vector4 rand(vector2 seed)</code></div><div class=\"usage\"> <code>float rand(vector seed)</code></div><div class=\"usage\"> <code>vector2 rand(vector seed)</code></div><div class=\"usage\"> <code>vector rand(vector seed)</code></div><div class=\"usage\"> <code>vector4 rand(vector seed)</code></div><div class=\"usage\"> <code>float rand(vector4 seed)</code></div><div class=\"usage\"> <code>vector2 rand(vector4 seed)</code></div><div class=\"usage\"> <code>vector rand(vector4 seed)</code></div><div class=\"usage\"> <code>vector4 rand(vector4 seed)</code></div><p>Creates a random number based on the provided seed.  The number will\nbe in the range of 0 to 1.  In particular, it will be in the half-open interval [0, 1).  The same number is produced for the same\nseed, so to vary the random number the seed should be varied.</p><p>Note that even the smallest changes in the seed value will produce\ncompletely different numbers, so it may produce different results\non different operating systems or compilers.</p><p>If the result is a vector2, vector, or vector4, each component will be a\ndifferent random number.  Thus, if you have the code:</p><div class=\"codeblock\"><code class=\"codeline\">vector        pos = 1;</code><code class=\"codeline\">float        seed = 0;</code><code class=\"codeline\"></code><code class=\"codeline\">pos *= rand(seed);</code></div><p><code>pos</code> will get different values in its <code>.x</code>, <code>.y</code>, and <code>.z</code> components.  If you wish a uniform scale, use the <code>float()</code> cast:</p><div class=\"codeblock\"><code class=\"codeline\">vector        pos = 1;</code><code class=\"codeline\">float        seed = 0;</code><code class=\"codeline\"></code><code class=\"codeline\">pos *= float(rand(seed));</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/random_fhash\">random_fhash</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/random_ihash\">random_ihash</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/random_shash\">random_shash</a></div></body>",
    "random": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/random\">random</a></h1><p class=\"summary\">Generate a random number based on the integer position in 1-4D space.</p><div class=\"usage\"> <code>float random(int|float position)</code></div><div class=\"usage\"> <code>vector random(int|float position)</code></div><div class=\"usage\"> <code>vector2 random(int position)</code></div><div class=\"usage\"> <code>vector4 random(int|float position)</code></div><p>Generate 1D, 2D, 3D, or 4D noise based on a 1D position.</p><div class=\"usage\"> <code>float random(int|float xpos, int|float ypos)</code></div><div class=\"usage\"> <code>vector random(int|float xpos, int|float ypos)</code></div><div class=\"usage\"> <code>vector4 random(int|float xpos, int|float ypos)</code></div><p>Specify a 2D position in the noise field using two numbers.</p><div class=\"usage\"> <code>float random(vector position)</code></div><div class=\"usage\"> <code>vector random(vector position)</code></div><div class=\"usage\"> <code>vector4 random(vector position)</code></div><p>Specify a 3D position in the noise field using a vector.</p><div class=\"usage\"> <code>float random(vector4 position)</code></div><div class=\"usage\"> <code>vector random(vector4 position)</code></div><div class=\"usage\"> <code>vector4 random(vector4 position)</code></div><p>Specify a 4D position in the noise field using a vector4.</p><p>Generate a random number based on the integer position in <code>N</code> dimensional space\n(where N is 1 to 4 dimensions). Unlike the noise functions, the random\nfunctions do not smoothly interpolate the random values between integer\nlattice points. The <code>random()</code> functions are very efficient ways of doing\nsomething like <code>noise(floor(position))</code>.</p><p>While <code>random()</code> takes floats, it only varies the random effect for\ninteger changes.  To have a random result that varies with even the\nsmallest float changes, use <code>rand()</code>.</p><p>The result of this is in the half-open interval [0, 1).</p></body>",
    "random_brj": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/random_brj\">random_brj</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Generate a uniformly distributed random number.</p><div class=\"usage\"> <code>float random_brj( float seed; int offset)</code></div><div class=\"usage\"> <code>float random_brj( int seed; int offset)</code></div><div class=\"usage\"> <code>float random_brj( vector4 seed; int offset)</code></div><div class=\"usage\"> <code>float random_brj( vector seed; int offset)</code></div><div class=\"usage\"> <code>vector2 random_brj( float seed; int offset)</code></div><div class=\"usage\"> <code>vector2 random_brj( int seed; int offset)</code></div><div class=\"usage\"> <code>vector2 random_brj( vector4 seed; int offset)</code></div><div class=\"usage\"> <code>vector2 random_brj( vector seed; int offset)</code></div><div class=\"usage\"> <code>vector random_brj( float seed; int offset)</code></div><div class=\"usage\"> <code>vector random_brj( int seed; int offset)</code></div><div class=\"usage\"> <code>vector random_brj( vector4 seed; int offset)</code></div><div class=\"usage\"> <code>vector random_brj( vector seed; int offset)</code></div><p>When generating a sequence of random numbers you will notice that it tends to\nclump.  However, sometimes you want a bunch of samples that are better distributed.  A binary random jittered (BRJ) sample is a series of random numbers which are relatively evenly distributed, similar to <code>random_sobol()</code>.</p><p>The seed allows you to generate different sequences.  If it is a floating point seed, note very small differences will select very different sequences.</p><p>The offset is which entry in the sequence to extract.  This should be an integer sequence, like <code>ptnum</code>, in order for the distribution property to work.</p><p>Each number is in the <code>[0..1)</code> range.</p></body>",
    "random_fhash": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/random_fhash\">random_fhash</a></h1><p class=\"summary\">Hashes floating point numbers to integers.</p><div class=\"usage\"> <code>int random_fhash(float seed)</code></div><div class=\"usage\"> <code>int random_fhash(float seed, float seed2)</code></div><div class=\"usage\"> <code>int random_fhash(vector seed)</code></div><div class=\"usage\"> <code>int random_fhash(vector4 seed)</code></div><div class=\"usage\"> <code>int random_fhash(vector2 seed)</code></div><p>Hashes the given number into an integer value.  The hash may vary\nfor even the smallest differences in inputs.</p></body>",
    "random_ihash": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/random_ihash\">random_ihash</a></h1><p class=\"summary\">Hashes integer numbers to integers.</p><div class=\"usage\"> <code>int random_ihash(int seed)</code></div><p>Hashes the given number into an integer value.</p></body>",
    "random_poisson": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/random_poisson\">random_poisson</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Generates a random Poisson variable given the mean to the distribution and a seed.</p><div class=\"usage\"> <code>int random_poisson(int seed, float mean)</code></div><div class=\"usage\"> <code>int random_poisson(int seed, float mean, int minvalue, int maxvalue)</code></div><p>Creates a random number given the mean of the Poisson distribution. The seed is given to allow for the generation of different numbers with the same mean.</p><p>When <code>minvalue</code> and <code>maxvalue</code> are specified the numbers generated will be limited to the specified range.</p><h2>Warning</h2><p>The specified range should not be farther apart from the mean than 3 standard deviations, which in the case of Poisson distribution is equal to <code>sqrt(mean)</code>.</p></body>",
    "random_shash": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/random_shash\">random_shash</a></h1><p class=\"summary\">Hashes a string to an integer.</p><div class=\"usage\"> <code>int random_shash(string seed)</code></div><p>Hashes the given string into an integer value.</p><h2>Note</h2><p>Two different strings may hash to the same value.</p><h2>Note</h2><p>The returned value may be very large and can cause an overflow when further multiplied or is cast to float.</p></body>",
    "random_sobol": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/random_sobol\">random_sobol</a></h1><p class=\"summary\">Generate a uniformly distributed random number.</p><div class=\"usage\"> <code>float random_sobol( float seed; int offset)</code></div><div class=\"usage\"> <code>float random_sobol( int seed; int offset)</code></div><div class=\"usage\"> <code>float random_sobol( vector4 seed; int offset)</code></div><div class=\"usage\"> <code>float random_sobol( vector seed; int offset)</code></div><div class=\"usage\"> <code>vector4 random_sobol( float seed; int offset)</code></div><div class=\"usage\"> <code>vector4 random_sobol( int seed; int offset)</code></div><div class=\"usage\"> <code>vector4 random_sobol( vector4 seed; int offset)</code></div><div class=\"usage\"> <code>vector4 random_sobol( vector seed; int offset)</code></div><div class=\"usage\"> <code>vector random_sobol( float seed; int offset)</code></div><div class=\"usage\"> <code>vector random_sobol( int seed; int offset)</code></div><div class=\"usage\"> <code>vector random_sobol( vector4 seed; int offset)</code></div><div class=\"usage\"> <code>vector random_sobol( vector seed; int offset)</code></div><p>When generating a sequence of random numbers you will notice that it tends to\nclump.  Sometimes you want a bunch of samples that are better distributed,\nhowever.  A sobol sequence is a series of random numbers which are relatively\nevenly distributed.</p><p>The seed allows you to select different sobol sequences.  If it is a floating\npoint seed, note very small differences will select very different sequences.</p><p>The offset is which entry in the sequence to extract.  This should be an\ninteger sequence, like <code>ptnum</code>, in order for the distribution property to work.</p><p>Each number is in the <code>[0..1)</code> range.</p></body>",
    "rawbumpmap": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rawbumpmap\">rawbumpmap</a></h1></body>",
    "rawbumpmapA": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rawbumpmapA\">rawbumpmapA</a></h1></body>",
    "rawbumpmapB": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rawbumpmapB\">rawbumpmapB</a></h1></body>",
    "rawbumpmapG": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rawbumpmapG\">rawbumpmapG</a></h1></body>",
    "rawbumpmapL": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rawbumpmapL\">rawbumpmapL</a></h1></body>",
    "rawbumpmapR": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rawbumpmapR\">rawbumpmapR</a></h1></body>",
    "rawcolormap": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rawcolormap\">rawcolormap</a></h1><p class=\"summary\">Looks up an unfiltered color from a texture file.</p><div class=\"usage\"> <code>vector|vector4 rawcolormap(string filename, vector uvw, ...)</code></div><div class=\"usage\"> <code>vector|vector4 rawcolormap(string filename, float u, float v, ...)</code></div><div class=\"usage\"> <code>vector|vector4 rawcolormap(string filename, vector uv, vector du, vector dv, int samples, ...)</code></div><div class=\"usage\"> <code>vector|vector4 rawcolormap(string filename, vector uv0, vector uv1, vector uv2, vector uv3, ...)</code></div><div class=\"usage\"> <code>vector|vector4 rawcolormap(string filename, vector uv0, vector uv1, vector uv2, vector uv3, int samples, ...)</code></div><div class=\"usage\"> <code>vector|vector4 rawcolormap(string filename, float u0, float v0, float u1, float v1, float u2, float v2, float u3, float v3, int samples, ...)</code></div><p>This function has the same arguments as <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/colormap\">colormap</a>, but does not do bilinear interpolation of the pixel values. See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/colormap\">colormap</a> for information on the arguments.</p><p>If you call the function with a <code>vector4</code> return type, the fourth component is the alpha channel of the texture. If the image does not have alpha, the fourth component is always <code>1</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/colormap\">colormap</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texture\">texture</a></div></body>",
    "rayhittest": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rayhittest\">rayhittest</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Sends a ray from the position P along the direction D.</p><div class=\"usage\"> <code>float rayhittest( vector P; vector D; float bias; ... )</code></div><div class=\"usage\"> <code>float rayhittest( vector P; vector D; vector &amp;pHit; vector &amp;nHit; float bias; ... )</code></div><p>Sends a ray from the position <code class=\"var\">P</code> along the direction <code class=\"var\">D</code>. The\nlength of the <code class=\"var\">D</code> vector represents the farthest distance considered\nwhen check for occlusion.</p><p>Returns the distance to the object intersected. If no object is hit,\nreturns less than 0.</p><p>If you specify <code class=\"var\">pHit</code> and <code class=\"var\">nHit</code>, they get the position and normal\nof the hit surface.</p><p>In many cases, the area sampling features will not produce usable\nresults with the <code>rayhittest()</code> function.</p><h2>Tip</h2><p>When hit testing polygons you can get lots of rays missing.\n    In these cases triangulating the geometry can improves hits.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/trace\">trace</a></div></body>",
    "rayimport": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rayimport\">rayimport</a></h1><span class=\"padder\"><span class=\"pillow\">fog</span></span><span class=\"padder\"><span class=\"pillow\">light</span></span><span class=\"padder\"><span class=\"pillow\">shadow</span></span><span class=\"padder\"><span class=\"pillow\">surface</span></span><p class=\"summary\">Imports a value sent by a shader in a gather loop.</p><div class=\"usage\"> <code>int rayimport(string name, &lt;type&gt; &amp;value)</code></div><div class=\"usage\"> <code>int rayimport(string name, &lt;type&gt;[] &amp;value)</code></div><p>Extracts information any passed when the surface is hit by a ray fired by the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gather\">gather</a>.</p><div class=\"argument\"><code>name</code></div><p>The variable name, as passed using a <code>\"send:<code class=\"var\">name</code>\", value</code> argument pair in <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gather\">gather</a> (without the <code>send:</code> prefix).</p><div class=\"argument\"><code>value</code></div><p>If the function can import the named variable, it overwrites this variable with the value.</p><h2>Returns</h2><p><code>1</code> if a value by the given name was successfully imported, or <code>0</code> otherwise.</p><h2>Built-in queryable names</h2><p>You can pass the following values to <code>name</code> to query built-in ray information (not sent from <code>gather()</code>).</p><div class=\"argument\"><code><code>ray:P</code> (<code>vector</code>)</code></div><p>The origin of the ray.</p><div class=\"argument\"><code><code>ray:D</code> (<code>vector</code>)</code></div><p>The direction vector of the ray.</p><div class=\"argument\"><code><code>ray:time</code> (<code>float</code>)</code></div><p>The shutter time associated with the ray.</p><div class=\"argument\"><code><code>ray:hitstack</code> (<code>int[]</code>)</code></div><p>The hit-stack provided by the intersector.</p><div class=\"argument\"><code><code>ray:element</code> (<code>int</code>)</code></div><p>The element provided by the intersector.</p><div class=\"argument\"><code><code>ray:hituv</code> (<code>vector</code>)</code></div><p>The parametric coordinates provided by the intersector.</p><div class=\"argument\"><code><code>ray:Ng</code> (<code>vector</code>)</code></div><p>The geometric normal from the intersector.</p><h2>Note</h2><p>Data provided by the Mantra 3 intersector is raw data and may not be meaningful, or may be different across platforms or versions.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gather\">gather</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/simport\">simport</a></div></body>",
    "reflect": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/reflect\">reflect</a></h1><p class=\"summary\">Returns the vector representing the reflection of the direction\nagainst the normal.</p><div class=\"usage\"> <code>vector reflect(vector direction, vector normal)</code></div><p>Returns the vector representing the reflection of the <code class=\"var\">direction</code>\nagainst the <code class=\"var\">normal</code>.</p></body>",
    "reflectlight": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/reflectlight\">reflectlight</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Computes the amount of reflected light which hits the surface.</p><div class=\"usage\"> <code>vector reflectlight(float bias, float max_contrib, ...)</code></div><p><code class=\"var\">bias</code> is typically a small number (for example 0.005) used to help\n    eliminate self-reflection.  If <code class=\"var\">bias</code> is less than 0, the default\n    ray tracing bias specified with the <code>vm_raybias</code> setting will be used\n    instead.</p><p><code class=\"var\">max_contrib</code> tells the renderer how much the reflected light will\n    contribute to the final color of the pixel. This is typically the\n    maximum of the reflection component of a lighting model. This has no\n    effect on the resultant color. This value should typically be less than\n    1.</p><div class=\"usage\"> <code>vector reflectlight(vector P, vector D, float bias, float max_contrib, ...)</code></div><p>A general form which takes a position <code class=\"var\">P</code> and a direction <code class=\"var\">D</code>.</p><div class=\"usage\"> <code>vector reflectlight(vector P, vector N, vector I, float bias, float max_contrib, ...)</code></div><p>A general form which takes a position <code class=\"var\">P</code>, direction <code class=\"var\">D</code>, and\n    incident angle <code class=\"var\">I</code> and returns the reflection vector.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">surface mirror(vector refl_color=1; float bias=.005)</code><code class=\"codeline\">{</code><code class=\"codeline\">    Cf = refl_color * reflectlight(bias, max(refl_color));</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/refractlight\">refractlight</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gather\">gather</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/trace\">trace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/irradiance\">irradiance</a></div></body>",
    "refract": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/refract\">refract</a></h1><p class=\"summary\">Returns the refraction ray given an incoming direction, the\nnormalized normal and an index of refraction.</p><div class=\"usage\"> <code>vector refract(vector direction, vector normal, float index)</code></div><p>Returns the refraction ray given an incoming <code class=\"var\">direction</code>, the\nnormalized <code class=\"var\">normal</code> and an <code class=\"var\">index</code> of refraction.</p><p>The <code class=\"var\">index</code> is a relative index of refraction, the ratio between\nthe interior and exterior index of refraction, where the exterior\nis defined by the direction of the normals (normals point away from\nthe interior).</p><p>In the case of total internal reflection, this function returns the\nreflection vector.</p><p>For example:</p><div class=\"codeblock\"><code class=\"codeline\">refract(normalize(I), normalize(N), outside_to_inside_ior)</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fresnel\">fresnel</a></div></body>",
    "refractlight": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/refractlight\">refractlight</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Computes the illumination of surfaces refracted by the current\nsurface.</p><div class=\"usage\"> <code>void refractlight(vector &amp;cf, vector &amp;of, float &amp;af, vector P, vector D, float bias, float max_contrib, ...)</code></div><div class=\"usage\"> <code>void refractlight(vector &amp;cf, vector &amp;of, float &amp;af, vector P, vector N, vector I, float eta, float bias, float max_contrib, ...)</code></div><p>Computes the illumination of surfaces refracted by the current surface.\nComputes and outputs the output color (<code class=\"var\">cf</code>), opacity (<code class=\"var\">of</code>) and\nalpha (<code class=\"var\">af</code>). See <a href=\"https://www.sidefx.com/docs/houdini/vex/contexts/shading_contexts#opacity\">opacity vs. alpha</a> .</p><p><code class=\"var\">bias</code> is typically a small number (for example 0.005) used to help\neliminate self-reflection.</p><p><code class=\"var\">max_contrib</code> tells the renderer how much the reflected light will\ncontribute to the final color of the pixel. This has no effect on the\nresultant color.</p><p>The first form of the refractlight() function takes a position and\ndirection, typically computed by the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/refract\">refract</a> or\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/fresnel\">fresnel</a> functions.</p><p>To prevent the renderer from computing standard transparency (i.e.\nnon-refracted transparency), the Of variable must be set to {1,1,1} to\nmake the surface opaque. The Af variable can be set to any arbitrary\nvalue.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">surface</code><code class=\"codeline\">glass(float eta=1.3, bias = 0.005)</code><code class=\"codeline\">{</code><code class=\"codeline\">    float    Kr, Kt;</code><code class=\"codeline\">    vector    R, T;</code><code class=\"codeline\">    vector    cf, of;</code><code class=\"codeline\">    float    af;</code><code class=\"codeline\">    frensel(normalize(I), normalize(N), eta, Kr, Kt, R, T);</code><code class=\"codeline\">    Cf  = Kr * reflectlight(P, R, bias, Kr);</code><code class=\"codeline\">    refractlight(cf, of, af, P, T, bias, Kt);</code><code class=\"codeline\">    Cf += Kt * cf;</code><code class=\"codeline\">    Af = clamp(Kr + af*Kt, 0, 1);</code><code class=\"codeline\">    Of = 1;</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/reflectlight\">reflectlight</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gather\">gather</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/trace\">trace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/irradiance\">irradiance</a></div></body>",
    "relativepath": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/relativepath\">relativepath</a></h1><p class=\"summary\">Computes the relative path for two full paths.</p><div class=\"usage\"> <code>string relativepath(string src, string dest)</code></div><p>Computes the relative path required to get from the <code>src</code> path to the <code>dest</code> path.</p><h2>Examples</h2><div class=\"related\"><code>relativepath(\"/obj/geo1/box\", \"/obj/ropnet1/mantra1\")</code> - returns <code>../../ropnet1/mantra1</code></div></body>",
    "relbbox": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/relbbox\">relbbox</a></h1><p class=\"summary\">Returns the relative position of the point given with respect to the bounding box of the geometry.</p><div class=\"usage\"> <code>vector relbbox(&lt;geometry&gt;, vector position)</code></div><p>Returns the relative position of the point given with respect to the\n    bounding box of the primitives in the geometry.</p><div class=\"usage\"> <code>vector relbbox(&lt;geometry&gt;, string primgroup, vector position)</code></div><p>Use the bounding box of the primitives in the named primitive group.</p><div class=\"usage\"> <code>vector relbbox(vector position)</code></div><h2>Warning</h2><p>This form of <code>relbbox</code> is deprecated and may be removed in the future. \n        Use the other forms as needed.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/relpointbbox\">relpointbbox</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointbbox\">pointbbox</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/bbox\">bbox</a></div></body>",
    "relpath": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/relpath\">relpath</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the relative path to a file.</p><div class=\"usage\"> <code>string relpath(string abspath)</code></div><p>Returns the supplied path converted to a relative path, expressed as\nrelative to Houdini\u2019s current working directory. The file does not need to\nexist.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/abspath\">abspath</a></div></body>",
    "relpointbbox": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/relpointbbox\">relpointbbox</a></h1><p class=\"summary\">Returns the relative position of the point given with respect to the bounding box of the geometry.</p><div class=\"usage\"> <code>vector relpointbbox(&lt;geometry&gt;, vector position)</code></div><p>Returns the relative position of the point given with respect to the\n    bounding box of the points in the geometry.</p><div class=\"usage\"> <code>vector relpointbbox(&lt;geometry&gt;, string pointgroup, vector position)</code></div><p>Use the bounding box of the primitives in the named point group.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/relbbox\">relbbox</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointbbox\">pointbbox</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/bbox\">bbox</a></div></body>",
    "removeattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeattrib\">removeattrib</a></h1><p class=\"summary\">Removes an attribute or group from the geometry.</p><div class=\"usage\"> <code>int removeattrib(int geohandle, string attribclass, string name)</code></div><div class=\"argument\"><code>name</code></div><p>The name of the attribute or group to remove.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeattrib\">removeattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removedetailattrib\">removedetailattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointattrib\">removepointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointgroup\">removepointgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexattrib\">removevertexattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexgroup\">removevertexgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimattrib\">removeprimattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimgroup\">removeprimgroup</a></div></body>",
    "removedetailattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removedetailattrib\">removedetailattrib</a></h1><p class=\"summary\">Removes a detail attribute from a geometry.</p><p>If you don\u2019t know the class of attribute until runtime, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeattrib\">removeattrib</a>.</p><div class=\"usage\"> <code>int removedetailattrib(int geohandle, string name)</code></div><p>Removes a detail attribute from the given geometry.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeattrib\">removeattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removedetailattrib\">removedetailattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointattrib\">removepointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointgroup\">removepointgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexattrib\">removevertexattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexgroup\">removevertexgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimattrib\">removeprimattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimgroup\">removeprimgroup</a></div></body>",
    "removegroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removegroup\">removegroup</a></h1><span class=\"padder\"><span class=\"pillow\">sop</span></span><h2>Warning</h2><p>This function has been deprecated. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointgroup\">setpointgroup</a> instead.</p></body>",
    "removeindex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeindex\">removeindex</a></h1><p class=\"summary\">Removes an item at the given index from an array.</p><div class=\"usage\"> <code>&lt;type&gt; removeindex(&lt;type&gt; &amp;array[]; int index)</code></div><p>Removes the item at <code>index</code> from <code>array</code> and returns its value. This is the same as <code>pop(array, index)</code> but has a slightly clearer name.</p><p>A negative index counts from the end of the array, so <code>removeindex(array, -2)</code> removes the second-to-last item.</p><div class=\"usage\"> <code>int removeindex(dict &amp;dictionary; string index)</code></div><p>Removes the dictionary entry of <code>index</code> from <code>dictionary</code>.</p><p>Returns <code>0</code> if no such entry was present, <code>1</code> if something was\n    removed.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pop\">pop</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevalue\">removevalue</a></div></body>",
    "removepoint": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepoint\">removepoint</a></h1><p class=\"summary\">Removes a point from the geometry.</p><div class=\"usage\"> <code>int removepoint(int geohandle, int point_number)</code></div><div class=\"usage\"> <code>int removepoint(int geohandle, int point_number, int and_prims)</code></div><div class=\"argument\"><code>point_number</code></div><p>If this is <code>-1</code>, the function has no effect.</p><div class=\"argument\"><code>and_prims</code></div><p>If this is <code>1</code>, the function deletes any <em>degenerate</em> primitives that referred to the removed point (for example, closed polygons with fewer than 3 vertices or open polygons with fewer than 2 vertices).</p><p>If this is <code>0</code>, the function only deletes primitives that become invalid because of the removed point (for example, tetrahedra with fewer than 4 vertices, or volumes with zero vertices).</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addpoint\">addpoint</a></div></body>",
    "removepointattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointattrib\">removepointattrib</a></h1><p class=\"summary\">Removes a point attribute from a geometry.</p><p>If you don\u2019t know the class of attribute until runtime, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeattrib\">removeattrib</a>.</p><div class=\"usage\"> <code>int removepointattrib(int geohandle, string name)</code></div><p>Removes a point attribute from the given geometry.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeattrib\">removeattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removedetailattrib\">removedetailattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointattrib\">removepointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointgroup\">removepointgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexattrib\">removevertexattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexgroup\">removevertexgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimattrib\">removeprimattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimgroup\">removeprimgroup</a></div></body>",
    "removepointgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointgroup\">removepointgroup</a></h1><p class=\"summary\">Removes a point group from a geometry.</p><p>If you don\u2019t know the class of group until runtime, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeattrib\">removeattrib</a>.</p><div class=\"usage\"> <code>int removepointgroup(int geohandle, string name)</code></div><p>Removes a point group from the given geometry.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeattrib\">removeattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removedetailattrib\">removedetailattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointattrib\">removepointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointgroup\">removepointgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexattrib\">removevertexattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexgroup\">removevertexgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimattrib\">removeprimattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimgroup\">removeprimgroup</a></div></body>",
    "removeprim": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprim\">removeprim</a></h1><p class=\"summary\">Removes a primitive from the geometry.</p><div class=\"usage\"> <code>int removeprim(int geohandle, int prim_number, int andpoints)</code></div><div class=\"argument\"><code>prim_number</code></div><p>The index of the primitive to remove. If this is <code>-1</code>, the function does nothing.</p><div class=\"argument\"><code>andpoints</code></div><p>If this is <code>1</code>, the function will also delete any points associated with the primitive that are not associated with any other primitives.</p><h2>Note</h2><p>If some primitives are being removed with <code>andpoints</code> set to <code>0</code> and some are being removed with <code>andpoints</code> set to <code>1</code>, all of the primitives with <code>andpoints</code> set to <code>0</code> will be deleted before all of the primitives with <code>andpoints</code> set to <code>1</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addprim\">addprim</a></div></body>",
    "removeprimattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimattrib\">removeprimattrib</a></h1><p class=\"summary\">Removes a primitive attribute from a geometry.</p><p>If you don\u2019t know the class of attribute until runtime, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeattrib\">removeattrib</a>.</p><div class=\"usage\"> <code>int removeprimattrib(int geohandle, string name)</code></div><p>Removes a primitive attribute from the given geometry.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeattrib\">removeattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removedetailattrib\">removedetailattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointattrib\">removepointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointgroup\">removepointgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexattrib\">removevertexattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexgroup\">removevertexgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimattrib\">removeprimattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimgroup\">removeprimgroup</a></div></body>",
    "removeprimgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimgroup\">removeprimgroup</a></h1><p class=\"summary\">Removes a primitive group from a geometry.</p><p>If you don\u2019t know the class of group until runtime, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeattrib\">removeattrib</a>.</p><div class=\"usage\"> <code>int removeprimgroup(int geohandle, string name)</code></div><p>Removes a primitive group from the given geometry.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeattrib\">removeattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removedetailattrib\">removedetailattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointattrib\">removepointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointgroup\">removepointgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexattrib\">removevertexattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexgroup\">removevertexgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimattrib\">removeprimattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimgroup\">removeprimgroup</a></div></body>",
    "removevalue": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevalue\">removevalue</a></h1><p class=\"summary\">Removes an item from an array.</p><div class=\"usage\"> <code>int removevalue(&lt;type&gt; &amp;array[]; &lt;type&gt; value)</code></div><p>Removes the first instance of <code>value</code> found from the array. Returns <code>1</code> if an item was removed, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">float nums[] = {0, 1, 2, 3, 1, 2, 3};</code><code class=\"codeline\">removevalue(nums; 2);  // == 1</code><code class=\"codeline\">// nums == {0, 1, 3, 1, 2, 3}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/push\">push</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/find\">find</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/append\">append</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/resize\">resize</a></div></body>",
    "removevertex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertex\">removevertex</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Removes a vertex from the geometry.</p><div class=\"usage\"> <code>int removevertex(int geohandle, int linear_vertex_index)</code></div><div class=\"argument\"><code>linear_vertex_index</code></div><p>If this is <code>-1</code>, the function has no effect.  This is a linear\n    vertex index, so <code>vertexindex</code> may be needed to convert from\n    a primitive and vertex number.</p><p>This removes the given vertex from the geometry.  Note: This is done as\na post process, not immediately when invoked.</p><p>Only polygons currently support the removal of vertices.</p><p>This can result in degenerate (0 vertex) polygons, as the primitive\nis not deleted.  </p><p>Removing many vertices from polygons with high vertex counts can be slow.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/addvertex\">addvertex</a></div></body>",
    "removevertexattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexattrib\">removevertexattrib</a></h1><p class=\"summary\">Removes a vertex attribute from a geometry.</p><p>If you don\u2019t know the class of attribute until runtime, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeattrib\">removeattrib</a>.</p><div class=\"usage\"> <code>int removevertexattrib(int geohandle, string name)</code></div><p>Removes a vertex attribute from the given geometry.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeattrib\">removeattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removedetailattrib\">removedetailattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointattrib\">removepointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointgroup\">removepointgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexattrib\">removevertexattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexgroup\">removevertexgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimattrib\">removeprimattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimgroup\">removeprimgroup</a></div></body>",
    "removevertexgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexgroup\">removevertexgroup</a></h1><p class=\"summary\">Removes a vertex group from a geometry.</p><p>If you don\u2019t know the class of group until runtime, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeattrib\">removeattrib</a>.</p><div class=\"usage\"> <code>int removevertexgroup(int geohandle, string name)</code></div><p>Removes a vertex group from the given geometry.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeattrib\">removeattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removedetailattrib\">removedetailattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointattrib\">removepointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removepointgroup\">removepointgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexattrib\">removevertexattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removevertexgroup\">removevertexgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimattrib\">removeprimattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/removeprimgroup\">removeprimgroup</a></div></body>",
    "renderstate": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/renderstate\">renderstate</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Queries the renderer for a named property.</p><div class=\"usage\"> <code>int renderstate(string query, &lt;type&gt; &amp;value)</code></div><div class=\"usage\"> <code>int renderstate(string query, &lt;type&gt;[] &amp;value)</code></div><div class=\"usage\"> <code>int renderstate(material mat, string query, &lt;type&gt; &amp;value)</code></div><p>Returns a non-zero value and sets <code class=\"var\">value</code> on success, or returns <code>0</code>\nif the renderer cannot evaluate the query.</p><p>The two-argument variations look up the property on the current object.\nIf you pass a <code>material</code> as the first argument,\nthe function looks up the property on the material instead of the current object.</p><p>See the <a href=\"https://www.sidefx.com/docs/houdini/props/mantra\">list of IFD properties</a> you can query. Use\nthe <strong>IFD</strong> name (e.g. <code>image:samples</code>),\nnot the Houdini name (e.g. <code>vm_samples</code>).</p><h2>Useful properties</h2><p>The following properties are commonly useful and are reproduced here\nfor convenience, but you can query any property from the\n<a href=\"https://www.sidefx.com/docs/houdini/props/mantra\">the full list of IFD properties</a>.</p><div class=\"argument\"><code><code>image:name</code></code></div><p>(string) The name of the image being rendered.</p><div class=\"argument\"><code><code>image:pixelaspect</code></code></div><p>(float) The pixel aspect ratio (X/Y) of the image.</p><div class=\"argument\"><code><code>image:resolution</code></code></div><p>(vector) Gives the resolution as {<code class=\"var\">x_res</code>, <code class=\"var\">y_res</code>, <code class=\"var\">samples_per_pixel</code>}.</p><div class=\"argument\"><code><code>image:samples</code></code></div><p>(vector) Gives samples as {<code class=\"var\">x_samples</code>, <code class=\"var\">y_samples</code>, 0}.</p><div class=\"argument\"><code><code>image:raysamples</code></code></div><p>(vector) Gives the raytracing samples as {<code class=\"var\">x_samples</code>, <code class=\"var\">y_samples</code>, 0}.</p><div class=\"argument\"><code><code>light:name</code></code></div><p>(string) The name of the light object which is currently active in the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a> loop.</p><div class=\"argument\"><code><code>light:shadowscope</code></code></div><p>(string) The list of objects casting shadows from a light.</p><div class=\"argument\"><code><code>object:name</code></code></div><p>(string) The name of the object being shaded. This is valid within light and shadow shaders and can be used to query which object is being lit (or shadowed) by the light source.</p><div class=\"argument\"><code><code>object:reflectscope</code></code></div><p>(string) The default reflection scope pattern for the object being shaded.</p><div class=\"argument\"><code><code>object:refractscope</code></code></div><p>(string) The default refraction scope pattern for the object being shaded.</p><div class=\"argument\"><code><code>object:reflectlimit</code></code></div><p>(float or int) The hard limit for maximum refraction bounces for the object being shaded.</p><div class=\"argument\"><code><code>object:shadingquality</code></code></div><p>(float) The shading quality for the object being shaded.</p><div class=\"argument\"><code><code>object:lightmask</code></code></div><p>(string) The object\u2019s light mask string.</p><div class=\"argument\"><code><code>object:area</code></code></div><p>(float) The object\u2019s surface area.</p><div class=\"argument\"><code><code>object:materialname</code></code></div><div class=\"argument\"><code>(string) Path to the material that\u2019s assigned to the object being shaded. \n    NOTE</code></div><p>This is for informational purpose only and has no effect on material assignment or appearance.</p><div class=\"argument\"><code><code>renderer:name</code></code></div><p>(string) The name of the renderer.</p><div class=\"argument\"><code><code>renderer:version</code></code></div><p>As a string, gives the renderer version as <code class=\"var\">major</code>.<code class=\"var\">minor</code>.<code class=\"var\">build</code>\n    As a vector, gives the renderer version as {<code class=\"var\">major</code>, <code class=\"var\">minor</code>, <code class=\"var\">build</code>}.</p><div class=\"argument\"><code><code>renderer:renderengine</code></code></div><p>(string) The render method in use, such as <code>micropoly</code> or <code>raytrace</code>. \n    See the <a href=\"https://www.sidefx.com/docs/houdini/props/mantra\">properties list</a> for the full list of possible values.</p><div class=\"argument\"><code><code>shader:name</code></code></div><p>(string) The name of the current shader being run.</p><h2>Packed Primitives</h2><p>When mantra renders packed primitives, the geometry gets unpacked before rendering.  This means primitive attributes on the packed primitive aren\u2019t available to shaders (since they aren\u2019t passed down to the unpacked geometry).</p><p>Before unpacking, mantra will automatically convert the primitive attributes to custom object properties (see <code>ray_declare</code> on the <a href=\"https://www.sidefx.com/docs/houdini/render/ifd\">IFD file format</a> page).  The property will be named <code>packed:ATTRIBNAME</code> (where <code>ATTRIBNAME</code> is the name of the attribute).  The <code>renderstate()</code> function can be used to access these properties, just like any other object property.</p><p>For example:</p><div class=\"codeblock\"><code class=\"codeline\">vector Cd;</code><code class=\"codeline\">    if (!renderstate(\"packed:Cd\", Cd))</code><code class=\"codeline\">        Cd = 1;   // There was no Cd attribute on packed geometry</code></div><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">surface showversion() </code><code class=\"codeline\">{</code><code class=\"codeline\">    string    rname, rversion;</code><code class=\"codeline\">    if (!renderstate(\"renderer:name\", rname))</code><code class=\"codeline\">        rname = \"Unknown renderer\";</code><code class=\"codeline\">    if (!renderstate(\"renderer:version\", rversion))</code><code class=\"codeline\">        rversion = \"Unknown version\";</code><code class=\"codeline\">    printf(\"Image rendered by %s (%s)\\n\", rname, rversion);</code><code class=\"codeline\">}</code><code class=\"codeline\"></code><code class=\"codeline\">vector mapToScreen(vector NDC_P)</code><code class=\"codeline\">{</code><code class=\"codeline\">    // Given a point in NDC space, find out which pixel it</code><code class=\"codeline\">    // maps to.</code><code class=\"codeline\">    vector    result;</code><code class=\"codeline\">    if (!renderstate(\"image:resolution\", result))</code><code class=\"codeline\">        result = {640, 486, 0};</code><code class=\"codeline\">    return result * NDC_P;</code><code class=\"codeline\">}</code></div></body>",
    "reorder": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/reorder\">reorder</a></h1><p class=\"summary\">Reorders items in an array or string.</p><div class=\"usage\"> <code>string reorder(string value; int indices[])</code></div><p>Returns a reordered version of the <em>characters</em> (not bytes) in the UTF-8 string <code>value</code> according to the positions in <code>indices</code>. The result is a UTF-8 encoded string.</p><div class=\"usage\"> <code>&lt;type&gt;[] reorder(&lt;type&gt; values[]; int indices[])</code></div><p>Returns a reordered version of the items in <code>values</code> according to the positions in <code>indices</code>.</p><p>This usually uses a list of indices generated by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/argsort\">argsort</a>. See the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/argsort\">argsort</a> page for an example.</p><div class=\"related\">Negative numbers in the index list will read from the end of the array.</div><div class=\"related\">The length of the resulting array/string is the same as the length of the <code>indices</code>. </div><div class=\"related\">Out of bound values will insert zeros, but this should be considered an error.</div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/argsort\">argsort</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/reverse\">reverse</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sort\">sort</a></div></body>",
    "replace": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/replace\">replace</a></h1><p class=\"summary\">Replaces occurrences of a substring.</p><div class=\"usage\"> <code>string replace(string str, string old, string new)</code></div><div class=\"usage\"> <code>string replace(string str, string old, string new, int count)</code></div><p>Returns a copy of the string with all occurrences of the string <code>old</code> replaced with the string <code>new</code>.</p><div class=\"argument\"><code> count</code></div><p>If specified, only the first <code>count</code> occurrences are replaced.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">string str = \"abcdef abcdef abcdef\";</code><code class=\"codeline\"></code><code class=\"codeline\">// Returns \"abcghi abcghi abcghi\"</code><code class=\"codeline\">string new_str = replace(str, \"def\", \"ghi\");</code><code class=\"codeline\"></code><code class=\"codeline\">// Replaces up to 2 occurrences of the string \"def\".</code><code class=\"codeline\">// Returns \"abcghi abcghi abcdef\"</code><code class=\"codeline\">new_str = replace(str, \"def\", \"ghi\", 2);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_replace\">re_replace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/replace_match\">replace_match</a></div></body>",
    "replace_match": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/replace_match\">replace_match</a></h1><p class=\"summary\">Replaces the matched string pattern with another pattern.</p><div class=\"usage\"> <code>string replace_match(string str, string pattern_from, string pattern_to)</code></div><p>If the string matches <code>pattern_from</code>, it is replaced with <code>pattern_to</code> with the matching wildcards substituted in.</p><p>The pattern can use wildcards such as <code>str*</code> or <code>str?</code>, similar to the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/match\">match</a> function.\nThe wildcards may also be referred to with an index (e.g. <code>(2)</code>) to allow reordering.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Returns \"carol is my name\";</code><code class=\"codeline\">string s = replace_match(\"bob is my name\", \"bob*\", \"carol*\");</code><code class=\"codeline\"></code><code class=\"codeline\">// Returns \"a-b\";</code><code class=\"codeline\">s = replace_match(\"a_to_b\", \"*_to_*\", \"*-*\");</code><code class=\"codeline\"></code><code class=\"codeline\">// Swaps the matched wildcards, returning \"b_to_a\";</code><code class=\"codeline\">s = replace_match(\"a_to_b\", \"*_to_*\", \"*(1)_to_*(0)\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/match\">match</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/replace\">replace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_replace\">re_replace</a></div></body>",
    "resample_linear": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/resample_linear\">resample_linear</a></h1><div class=\"usage\"> <code>float[] resample_linear(const float input[], int new_length)</code></div><div class=\"usage\"> <code>vector[] resample_linear(const vector input[], int new_length)</code></div><div class=\"usage\"> <code>vector2[] resample_linear(const vector2 input[], int new_length)</code></div><div class=\"usage\"> <code>vector4[] resample_linear(const vector4 input[], int new_length)</code></div><p>Returns a new array of size new_length, uniformly sampled from the input array. Array elements are linearly interpolated from the input array.</p></body>",
    "resize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/resize\">resize</a></h1><p class=\"summary\">Sets the length of an array.</p><div class=\"usage\"> <code>void resize(&lt;type&gt; &amp;array[]; int size)</code></div><p>Changes the size of the given array. If <code>size</code> is greater than the current length of the array, the extra items at the end of the array will be initialized to default values of the given type (for example, <code>0</code>, empty string, <code>{0,0,0}</code>, etc.).</p><div class=\"usage\"> <code>void resize(&lt;type&gt; &amp;array[]; int size; &lt;type&gt; val)</code></div><p>Changes the size of the given array. If <code>size</code> is greater than the current length of the array, the extra items at the end of the array will be initialized to <code>val</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/append\">append</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/push\">push</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/len\">len</a></div></body>",
    "resolvemissedray": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/resolvemissedray\">resolvemissedray</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Returns the background color for rays that exit the scene.</p><div class=\"usage\"> <code>vector resolvemissedray(vector dir, float time, int mask, ...)</code></div><p>Returns the color of the background environment for rays that exit the\nscene.  When no environment or background color is specified, any\nenvironment lights in the scene using the mode Ray Tracing Background\nwill be used to look up the environment color.  <code class=\"var\">mask</code> indicates the type\nof ray that is being resolved as an integer mask.</p><p>To use the default background (environment light) for a reflection ray:</p><div class=\"codeblock\"><code class=\"codeline\">resolvemissedray(I, 0.0, PBR_REFLECT_MASK);</code></div><p>To define your own background:</p><div class=\"codeblock\"><code class=\"codeline\">resolvemissedray(I, 0.0, PBR_ALL_MASK, \"environment\", \"Mandril.rat\", \"envtint\", {1,2,1});</code><code class=\"codeline\">resolvemissedray(I, 0.0, PBR_ALL_MASK, \"background\", {1,1,1});</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/nodes/obj/envlight\">envlight</a></div></body>",
    "reverse": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/reverse\">reverse</a></h1><p class=\"summary\">Returns an array or string in reverse order.</p><div class=\"usage\"> <code>string reverse(string str)</code></div><p>Returns a UTF-8 encoded string with the reversed <em>characters</em> (not bytes) from <code>str</code>. This is different from what <code>str[::-1]</code> returns.</p><div class=\"usage\"> <code>&lt;type&gt;[] reverse(&lt;type&gt; values[])</code></div><p>Returns a reversed copy of the given array.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">reverse(\"hello\") == \"olleh\";</code><code class=\"codeline\">reverse({1,2,3,4}) == {4, 3, 2, 1};</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/reorder\">reorder</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sort\">sort</a></div></body>",
    "re_find": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_find\">re_find</a></h1><p class=\"summary\">Matches a regular expression in a string</p><div class=\"usage\"> <code>int re_find(const string regex, const string input)</code></div><div class=\"usage\"> <code>int re_find(const string regex, const string input, const int start)</code></div><div class=\"usage\"> <code>int re_find(const string regex, const string input, const int start, const int end)</code></div><p>Returns <code>1</code> if <code>regex</code> matches in <code>input</code>, or <code>0</code> otherwise.</p><div class=\"usage\"> <code>string re_find(const string regex, const string input)</code></div><div class=\"usage\"> <code>string re_find(const string regex, const string input, const int start)</code></div><div class=\"usage\"> <code>string re_find(const string regex, const string input, const int start, const int end)</code></div><p>Returns the first substring that matches <code>regex</code> in <code>input</code>.</p><div class=\"usage\"> <code>int re_find(int &amp;start_pos[], int &amp;end_pos[], const string regex, const string input)</code></div><div class=\"usage\"> <code>int re_find(int &amp;start_pos[], int &amp;end_pos[], const string regex, const string input, const int start)</code></div><div class=\"usage\"> <code>int re_find(int &amp;start_pos[], int &amp;end_pos[], const string regex, const string input, const int start, const int end)</code></div><p>Returns <code>1</code> if <code>regex</code> matches in input, or <code>0</code> otherwise. Fills the <code>start_pos</code> and <code>end_pos</code> array variables with the start and end positions of each match.</p><div class=\"usage\"> <code>string[] re_find(const string regex, const string input)</code></div><div class=\"usage\"> <code>string[] re_find(const string regex, const string input, const int start)</code></div><div class=\"usage\"> <code>string[] re_find(const string regex, const string input, const int start, const int end)</code></div><p>Returns an array of substrings that match <code>regex</code> in <code>input</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_match\">re_match</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_findall\">re_findall</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_replace\">re_replace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_split\">re_split</a></div></body>",
    "re_findall": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_findall\">re_findall</a></h1><p class=\"summary\">Finds all instances of the given regular expression in the string</p><div class=\"usage\"> <code>string[] re_findall(const string regex, const string input)</code></div><div class=\"usage\"> <code>string[] re_findall(const string regex, const string input, const int start)</code></div><div class=\"usage\"> <code>string[] re_findall(const string regex, const string input, const int start, const int end)</code></div><p>Returns an array of all strings that match the entire <code>regex</code> expression (no capture groups). </p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_find\">re_find</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_match\">re_match</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_replace\">re_replace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_split\">re_split</a></div></body>",
    "re_match": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_match\">re_match</a></h1><p class=\"summary\">Returns 1 if the entire input string matches the expression</p><div class=\"usage\"> <code>int re_match(const string regex, const string input)</code></div><p>Returns <code>1</code> if the entire <code>input</code> string matches the <code>regex</code>, or <code>0</code> if it doesn\u2019t match.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_find\">re_find</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_findall\">re_findall</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_replace\">re_replace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_split\">re_split</a></div></body>",
    "re_replace": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_replace\">re_replace</a></h1><p class=\"summary\">Replaces instances of regex_find with regex_replace</p><div class=\"usage\"> <code>string re_replace(string regex, string replacement, string input, int maxreplace=0)</code></div><p>Returns a string where each non-overlapping match of <code>regex</code> is replaced with <code>replacement</code>. The <code>replacement</code> string can reference captured groups from the regex using <code>$1</code> syntax.</p><p>If <code>maxreplace</code> is given and not 0, it specifies the maximum number of replacements to do.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_match\">re_match</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_find\">re_find</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_findall\">re_findall</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_split\">re_split</a></div></body>",
    "re_split": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_split\">re_split</a></h1><p class=\"summary\">Splits the given string based on regex match.</p><div class=\"usage\"> <code>string[] re_split(const string regex, const string input, const int maxsplits=0)</code></div><p>Splits the <code>input</code> string into substrings between matches of <code>regex</code>.</p><p>If <code>maxsplits</code> is given and not 0, it specifies the maximum number of splits to do.</p><p>NOTE: This does not match Python and other split methods as it behaves\ndifferently with trailing delimiters.  <code>a,b,</code> will only split into two\nstrings.  The regex string can be augmented with <code>|($(?!\\s))</code> to split\nthree tokens.  In VEX you frequently will need \\\\s.  In a wrangle another\nescape is needed and \\\\\\\\s is required.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/split\">split</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_match\">re_match</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_find\">re_find</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_findall\">re_findall</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/re_replace\">re_replace</a></div></body>",
    "rgbtohsv": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rgbtohsv\">rgbtohsv</a></h1><p class=\"summary\">Convert RGB color space to HSV color space.</p><div class=\"usage\"> <code>vector rgbtohsv(vector rgb)</code></div><div class=\"usage\"> <code>vector rgbtohsv(float r, float g, float b)</code></div><p>Convert RGB color space to HSV color space. A vector representing the\nHSV color is returned. The hue will be in the range 0 to 1.</p></body>",
    "rgbtoxyz": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rgbtoxyz\">rgbtoxyz</a></h1><p class=\"summary\">Convert a linear sRGB triplet to CIE XYZ tristimulus values.</p><div class=\"usage\"> <code>vector rgbtoxyz(vector rgb)</code></div><p>Convert a linear sRGB (Rec. 709) triplet to CIE XYZ tristimulus values.\nXYZ can be thought of as a 'universal color space'.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xyztorgb\">xyztorgb</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/blackbody\">blackbody</a></div></body>",
    "rint": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rint\">rint</a></h1><p class=\"summary\">Rounds the number to the closest whole number.</p><div class=\"usage\"> <code>float rint(float n)</code></div><div class=\"usage\"> <code>&lt;vector&gt; rint(&lt;vector&gt; v)</code></div><p>Returns the closest whole number to <code>n</code>. For vectors, this is done per-component.</p></body>",
    "rotate": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rotate\">rotate</a></h1><p class=\"summary\">Applies a rotation to the given matrix.</p><div class=\"usage\"> <code>void rotate(matrix2 &amp;m, float amount)</code></div><div class=\"usage\"> <code>void rotate(matrix3 &amp;m, float amount, vector axis)</code></div><div class=\"usage\"> <code>void rotate(matrix &amp;m, float amount, vector axis)</code></div><div class=\"usage\"> <code>void rotate(matrix3 &amp;m, vector angles, int xyz)</code></div><div class=\"usage\"> <code>void rotate(matrix &amp;m, vector angles, int xyz)</code></div><div class=\"usage\"> <code>void rotate(matrix3 &amp;m, float angle, int axis)</code></div><div class=\"usage\"> <code>void rotate(matrix &amp;m, float angle, int axis)</code></div><p>Applies a rotation to the given matrix. The angles must be given in\nradians and the axis must be normalized. The xyz argument is the rotate order.\nThe axis can also be given as an integer where XAXIS=1, YAXIS=2 and ZAXIS=4.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pretranslate\">pretranslate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prerotate\">prerotate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prescale\">prescale</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/translate\">translate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/scale\">scale</a></div></body>",
    "rotate_x_to": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rotate_x_to\">rotate_x_to</a></h1><p class=\"summary\">Rotates a vector by a rotation that would bring the x-axis to a given direction.</p><div class=\"usage\"> <code>vector2 rotate_x_to(vector2 direction, vector2 v)</code></div><div class=\"usage\"> <code>vector  rotate_x_to(vector  direction, vector  v)</code></div><div class=\"usage\"> <code>vector4 rotate_x_to(vector4 direction, vector4 v)</code></div><div class=\"argument\"><code>direction</code></div><p>Direction to which a vector along the positive x-axis, e.g. (1,0,0),\n    would be rotated.  This does not need to be normalized.</p><div class=\"argument\"><code>v</code></div><p>Vector to which to apply the rotation.</p><p>Applies to <code>v</code>, the rotation that would move (1,0), (1,0,0), or (1,0,0,0) to\n<code>direction</code> most directly.</p><p>In the case of <code>direction</code> being (-1,0,0), there are multiple distinct\nrotations that would move (1,0,0) to (-1,0,0) with a\nhalf turn rotation, so one is chosen arbitrarily, negating <code>v.x</code> and <code>v.z</code>.\nIn 2D, there is only one distinct rotation that moves (1,0) to (-1,0),\nequivalent to negating <code>v</code>.  In 4D, the rotation where <code>v</code> is negated\nis also chosen.</p><p>This is used by functions like <code>sample_direction_cone</code> and <code>sample_sphere_cone</code>\nto rotate the cone centre from (1,0,0) to a given direction vector.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_arc\">sample_circle_arc</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_cone\">sample_direction_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_cone\">sample_orientation_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_slice\">sample_circle_slice</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_cone\">sample_sphere_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_cone\">sample_hypersphere_cone</a></div></body>",
    "rstrip": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rstrip\">rstrip</a></h1><p class=\"summary\">Strips trailing whitespace from a string.</p><div class=\"usage\"> <code>string rstrip(string value)</code></div><div class=\"usage\"> <code>string rstrip(string value, string whitespace)</code></div><p>Returns a string with the trailing whitespace removed.  If\nwhitespace is provided, it is a string of characters that will be stripped.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/strip\">strip</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lstrip\">lstrip</a></div></body>",
    "sampledisk": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sampledisk\">sampledisk</a></h1><p class=\"summary\">Warps uniform random samples to a disk.</p><div class=\"usage\"> <code>void sampledisk(float &amp;x, float &amp;y, float sx, float sy)</code></div><p>This function warps uniform sample values so that they are equally\ndistributed on a disk. The transformation attempts to preserve\nstratification properties from the original samples.</p><div class=\"argument\"><code><code>x</code>, <code>y</code></code></div><p>The function overwrites these variables with uniform distributed points within the unit disk.</p><div class=\"argument\"><code><code>sx</code>, <code>sy</code></code></div><p>Uniform random values in the range <a href=\"https://www.sidefx.com/docs/houdini0,1\">0,1</a>, such as generated by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nextsample\">nextsample</a>.</p></body>",
    "sample_bsdf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_bsdf\">sample_bsdf</a></h1><p class=\"summary\">Samples a BSDF.</p><div class=\"usage\"> <code>void sample_bsdf(bsdf F, vector viewer_u, vector &amp;dir, vector &amp;eval, int &amp;type, float sx, float sy, ...)</code></div><div class=\"usage\"> <code>void sample_bsdf(bsdf F, vector viewer_u, vector &amp;dir, vector &amp;eval, int &amp;type, float sx, float sy, int mask, ...)</code></div><div class=\"usage\"> <code>void sample_bsdf(bsdf F; vector viewer_u; vector &amp;dir; vector &amp;eval; float &amp;pdf; int &amp;type; float sx, float sy; ... )</code></div><div class=\"usage\"> <code>void sample_bsdf(bsdf F, vector viewer_u, vector &amp;dir, vector &amp;eval, float &amp;pdf, int &amp;type, float sx, float sy, int mask, ...)</code></div><div class=\"usage\"> <code>void sample_bsdf(bsdf b; vector viewer_u; vector normal_v; int &amp;flags; vector &amp;dir; vector &amp;eval; float &amp;pdf; int &amp;type; float sx; float sy; int mask; ... )</code></div><div class=\"argument\"><code>F</code></div><p>The BSDF to sample.</p><div class=\"argument\"><code>viewer_u</code></div><p>The U vector (input viewer direction).</p><div class=\"argument\"><code>normal_v</code></div><p>The V vector (input surface normal).</p><div class=\"argument\"><code>&amp;flags</code></div><p>A bitfield of flags for the BSDF, defined in <code>pbr.h</code>. The function may set flags like <code>PBR_BSDF_REVERSE</code> or <code>PBR_BSDF_O_EVENT_EXIT</code>.</p><div class=\"argument\"><code>&amp;dir</code></div><p>The function overwrites this variable with the outgoing ray direction.</p><div class=\"argument\"><code>&amp;eval</code></div><p>The function overwrites this variable with the outgoing ray color, scaled by albedo.</p><p>This is not the same as the evaluated vector returned by the <code>eval_bsdf</code> operation. Here, <code>&amp;eval</code> will not vary with the outgoing sample direction.</p><div class=\"argument\"><code>&amp;pdf</code></div><p>The function overwrites this variable with the computed PDF of the BSDF.</p><div class=\"argument\"><code>&amp;type</code></div><p>In a compound BSDF, this returns the bounce type that was sampled.</p><div class=\"argument\"><code><code>sx</code> and <code>sy</code></code></div><p>Random values, such as generated by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nextsample\">nextsample</a>. Different values of <code>sx</code> and <code>sy</code> represent different random directions to sample.</p><div class=\"argument\"><code>&amp;eval</code></div><p>Overwritten with the color, scaled by albedo, of the sampled component.</p><div class=\"argument\"><code>&amp;pdf</code></div><p>The sampling pdf for the sampled component.</p><div class=\"argument\"><code>bounces</code></div><p>A bitmask representing bounce types allowed.</p><p>The <code>sample_bsdf</code> function passes keyword arguments to the BSDF being\nevaluated.  For custom BSDFs these keyword arguments are bound to shader\narguments (e.g. indicating whether the BSDF is being evaluated for direct or\nindirect illumination).  It\u2019s also possible for a BSDF to pass information back\nto <code>sample_bsdf</code>.  To indicate that a keyword argument value should be imported\nfrom the BSDF prefix the keyword with import:.  For example:</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">sample_bsdf(F, inI, outI, eval, type, sx, sy,</code><code class=\"codeline\">    \"direct\", 0,                        // Specify indirect illumination</code><code class=\"codeline\">    \"import:sssmfp\", sssmfp,        // Read the exported sssmfp parameter</code><code class=\"codeline\">    ...</code><code class=\"codeline\">);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/albedo\">albedo</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/eval_bsdf\">eval_bsdf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/emission_bsdf\">emission_bsdf</a></div></body>",
    "sample_cauchy": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_cauchy\">sample_cauchy</a></h1><p class=\"summary\">Samples the Cauchy (Lorentz) distribution.</p><div class=\"usage\"> <code>float sample_cauchy(float u)</code></div><div class=\"usage\"> <code>float sample_cauchy(float scale, float u)</code></div><div class=\"usage\"> <code>vector2 sample_cauchy(float scale, vector2 u)</code></div><div class=\"usage\"> <code>float sample_cauchy(float origscale, float minvalue, float maxvalue, float u)</code></div><div class=\"usage\"> <code>&lt;vector&gt; sample_cauchy(&lt;vector&gt; u)</code></div><p>Sample multivariate Cauchy distributions with median 0 and scale 1.  The\n    distribution of these vectors is forced to be isotropic, i.e. rotating\n    the distribution won\u2019t change it, which can be useful in simulations.\n    This wouldn\u2019t be the case if one generated components of the vectors as\n    independent samples of the univariate Cauchy distribution.</p><div class=\"argument\"><code>u</code></div><p>A number, or multiple numbers, in the range [0,1).</p><div class=\"argument\"><code>scale</code></div><p>The scale of the distribution, or 1 if not specified.\n    This is the difference between the 50th percentile and the 75th percentile.</p><div class=\"argument\"><code>origscale</code></div><p>The scale the distribution would have, were it not for <code>minvalue</code>\n    and <code>maxvalue</code>, limiting the range.</p><div class=\"argument\"><code><code>minvalue</code>,<code>maxvalue</code></code></div><p>When given, instead of sampling the full Cauchy distribution,\n    the distribution with its range limited to <a href=\"https://www.sidefx.com/docs/houdini`minvalue`,`maxvalue`\">`minvalue`,`maxvalue`</a> will be\n    sampled.</p><h2>Returns</h2><p>Monotonically increasing value with respect to <code>u</code>.</p><p>Samples the Cauchy distribution with median zero and the specified <code>scale</code>,\noptionally with a <code>minvalue</code> and <code>maxvalue</code>.\nGiven uniform random <code>u</code> values in [0,1), this will return Cauchy\ndistributed random numbers.</p><p>Note that without limits, the Cauchy distribution has\nno defined mean or variance, which can cause statistical problems if not\ndealt with carefully.</p><p>To add a maximum distance from the origin, while keeping the distribution\nisotropic, use:</p><div class=\"codeblock\"><code class=\"codeline\">!vex</code><code class=\"codeline\">sample_cauchy(1,0,maxdist,u.x) * sample_direction_uniform(set(u.y,u.z))</code></div><p>The 2D Cauchy distribution is the distribution of photons hitting a plane,\ncoming from a point light that is distance <code>scale</code> from the plane.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rand\">rand</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_exponential\">sample_exponential</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_normal\">sample_normal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_lognormal\">sample_lognormal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_lognormal_by_median\">sample_lognormal_by_median</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_discrete\">sample_discrete</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div></body>",
    "sample_cdf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_cdf\">sample_cdf</a></h1><p class=\"summary\">Samples a cumulative distribution function (CDF).</p><h2>Overview</h2><p>Use this function to sample values from a CDF array created with the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/create_cdf\">create_cdf</a> function. See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/create_cdf\">create_cdf</a> for more information.</p><p>See the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/create_cdf\">create_cdf</a> function docs for example code.</p><h2>Usage</h2><div class=\"usage\"> <code>int sample_cdf(float cdf[], float uniform_rand)</code></div><p>Returns the index of the sampled CDF.</p><div class=\"usage\"> <code>void sample_cdf(float cdf[], float uniform_rand, int &amp;index, float &amp;x)</code></div><p>Writes the index of the sampled CDF and value to output arguments.</p><div class=\"usage\"> <code>void sample_cdf(float cdf[], float uniform_rand, int &amp;index, float &amp;x, float &amp;pdf)</code></div><p>Writes the index of the sampled CDF, the sampled value, and the corresponding PDF to output arguments.</p><div class=\"argument\"><code>cdf</code></div><p>The CDF to sample from (create this using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/create_cdf\">create_cdf</a>).</p><div class=\"argument\"><code>uniform_rand</code></div><p>A uniform random variable (must be in range 0 to 1).</p><div class=\"argument\"><code>&amp;index</code></div><p>Outputs the index of the sampled CDF element.</p><div class=\"argument\"><code>&amp;x</code></div><p>Outputs the value of the sampled CDF element.</p><div class=\"argument\"><code>&amp;pdf</code></div><p>Outputs the PDF of the sampled CDF element.</p><h2>Returns</h2><p>The first form returns the index of the sampled value. The other forms write the index to an output argument instead.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/create_cdf\">create_cdf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/create_pdf\">create_pdf</a></div></body>",
    "sample_circle_arc": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_arc\">sample_circle_arc</a></h1><p class=\"summary\">Generates a uniform unit vector2, within maxangle of center, given a uniform number between 0 and 1.</p><div class=\"usage\"> <code>vector2 sample_circle_arc(vector2 center, float maxangle, float u)</code></div><div class=\"argument\"><code>center</code></div><p>Direction in the center of the arc.  This does not need to be normalized.</p><div class=\"argument\"><code>maxangle</code></div><p>Maximum angle, in radians, away from <code>center</code> that any sample of the arc\n    will be, so long as <code>u</code> is between 0 and 1.</p><div class=\"argument\"><code>u</code></div><p>Number between 0 and 1.</p><p>Returns a unit vector2, i.e. a vector2 of length 1, based on <code>u</code>.\nGiven uniform random <code>u</code> values in [0,1), the returned unit vectors will be\nuniform random and continuous with respect to <code>u</code> on the edge of the unit circle,\nin the arc within <code>maxangle</code> of the direction indicated by <code>center</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_edge_uniform\">sample_circle_edge_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_uniform\">sample_orientation_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_uniform\">sample_circle_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_uniform\">sample_sphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_uniform\">sample_hypersphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_cone\">sample_direction_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_cone\">sample_orientation_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_slice\">sample_circle_slice</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_cone\">sample_sphere_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_cone\">sample_hypersphere_cone</a></div></body>",
    "sample_circle_edge_uniform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_edge_uniform\">sample_circle_edge_uniform</a></h1><p class=\"summary\">Generates a uniform unit vector2, given a uniform number between 0 and 1.</p><div class=\"usage\"> <code>vector2 sample_circle_edge_uniform(float u)</code></div><div class=\"argument\"><code>u</code></div><p>Number between 0 and 1.</p><p>Returns a unit vector2, i.e. a vector2 of length 1, based on <code>u</code>.\nGiven uniform random <code>u</code> values in [0,1), the returned unit vectors will be\nuniform random and continuous with respect to <code>u</code> on the edge of the unit circle.\nSpecifically, it returns <code>(cos(angle),sin(angle))</code>, where <code>angle</code> is <code>2*pi*u</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_uniform\">sample_orientation_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_uniform\">sample_circle_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_uniform\">sample_sphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_uniform\">sample_hypersphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_arc\">sample_circle_arc</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_cone\">sample_direction_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_cone\">sample_orientation_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_slice\">sample_circle_slice</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_cone\">sample_sphere_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_cone\">sample_hypersphere_cone</a></div></body>",
    "sample_circle_ring_uniform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_ring_uniform\">sample_circle_ring_uniform</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Generates a uniform vector2 with alpha &lt; length &lt; 1, where 0 &lt; alpha &lt; 1, given a vector2 of uniform numbers between 0 and 1.</p><div class=\"usage\"> <code>vector2 sample_circle_ring_uniform(vector2 u, float alpha)</code></div><div class=\"argument\"><code>u</code></div><p>Pair of numbers between 0 and 1.</p><div class=\"argument\"><code>alpha</code></div><p>The inner radius to be bounded by. A number between 0 and 1.</p><p>Returns a vector2 of length &lt; 1, based on <code>u</code>.\nGiven uniform random <code>u</code> pairs of values in <a href=\"https://www.sidefx.com/docs/houdini0,1), and value `alpha` in [0,1\">0,1), and value `alpha` in [0,1</a>, the returned vectors will be\nuniform random and continuous with respect to <code>u</code> inside the unit circle ring with inner radius of <code>alpha</code>.\nSpecifically, it returns <code>scale*(cos(angle),sin(angle))</code>, where <code>angle</code> is <code>2*pi*u.x</code>\nand <code>scale</code> is <code>sqrt((1-alpha^2)*u.y+alpha^2)</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_uniform\">sample_circle_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_edge_uniform\">sample_circle_edge_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_uniform\">sample_orientation_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_uniform\">sample_sphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_uniform\">sample_hypersphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_arc\">sample_circle_arc</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_cone\">sample_direction_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_cone\">sample_orientation_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_slice\">sample_circle_slice</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_cone\">sample_sphere_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_cone\">sample_hypersphere_cone</a></div></body>",
    "sample_circle_slice": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_slice\">sample_circle_slice</a></h1><p class=\"summary\">Generates a uniform vector2 with length &lt; 1, within maxangle of center, given a vector2 of uniform numbers between 0 and 1.</p><div class=\"usage\"> <code>vector2 sample_circle_slice(vector2 center, float maxangle, vector2 u)</code></div><div class=\"argument\"><code>center</code></div><p>Direction in the center of the slice.  This does not need to be normalized.</p><div class=\"argument\"><code>maxangle</code></div><p>Maximum angle, in radians, away from <code>center</code> that any sample of the slice\n    will be, so long as all <code>u</code> values are between 0 and 1.</p><div class=\"argument\"><code>u</code></div><p>Pair of numbers between 0 and 1.</p><p>Returns a vector2 of length &lt; 1, based on <code>u</code>.\nGiven uniform random <code>u</code> pairs of values in [0,1), the returned vectors will be\nuniform random and continuous with respect to <code>u</code> inside the unit circle,\nin the slice within <code>maxangle</code> of the direction indicated by <code>center</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_edge_uniform\">sample_circle_edge_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_uniform\">sample_orientation_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_uniform\">sample_circle_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_uniform\">sample_sphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_uniform\">sample_hypersphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_arc\">sample_circle_arc</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_cone\">sample_direction_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_cone\">sample_orientation_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_cone\">sample_sphere_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_cone\">sample_hypersphere_cone</a></div></body>",
    "sample_circle_uniform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_uniform\">sample_circle_uniform</a></h1><p class=\"summary\">Generates a uniform vector2 with length &lt; 1, given a vector2 of uniform numbers between 0 and 1.</p><div class=\"usage\"> <code>vector2 sample_circle_uniform(vector2 u)</code></div><div class=\"argument\"><code>u</code></div><p>Pair of numbers between 0 and 1.</p><p>Returns a vector2 of length &lt; 1, based on <code>u</code>.\nGiven uniform random <code>u</code> pairs of values in [0,1), the returned vectors will be\nuniform random and continuous with respect to <code>u</code> inside the unit circle.\nSpecifically, it returns <code>scale*(cos(angle),sin(angle))</code>, where <code>angle</code> is <code>2*pi*u.x</code>\nand <code>scale</code> is <code>sqrt(u.y)</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_edge_uniform\">sample_circle_edge_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_uniform\">sample_orientation_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_uniform\">sample_sphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_uniform\">sample_hypersphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_arc\">sample_circle_arc</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_cone\">sample_direction_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_cone\">sample_orientation_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_slice\">sample_circle_slice</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_cone\">sample_sphere_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_cone\">sample_hypersphere_cone</a></div></body>",
    "sample_direction_cone": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_cone\">sample_direction_cone</a></h1><p class=\"summary\">Generates a uniform unit vector, within maxangle of center, given a vector2 of uniform numbers between 0 and 1.</p><div class=\"usage\"> <code>vector sample_direction_cone(vector center, float maxangle, vector2 u)</code></div><div class=\"argument\"><code>center</code></div><p>Direction in the center of the cone.  This does not need to be normalized.</p><div class=\"argument\"><code>maxangle</code></div><p>Maximum angle, in radians, away from <code>center</code> that any sample of the cone\n    will be, so long as all <code>u</code> values are between 0 and 1.</p><div class=\"argument\"><code>u</code></div><p>Pair of numbers between 0 and 1.</p><p>Returns a unit vector, i.e. a vector of length 1, based on <code>u</code>.\nGiven uniform random <code>u</code> pairs of values in [0,1), the returned unit vectors will be\nuniform random and continuous with respect to <code>u</code> on the surface of the unit sphere,\nin the area within <code>maxangle</code> of the direction indicated by <code>center</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_edge_uniform\">sample_circle_edge_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_uniform\">sample_orientation_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_uniform\">sample_circle_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_uniform\">sample_sphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_uniform\">sample_hypersphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_arc\">sample_circle_arc</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_cone\">sample_orientation_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_slice\">sample_circle_slice</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_cone\">sample_sphere_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_cone\">sample_hypersphere_cone</a></div></body>",
    "sample_direction_uniform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></h1><p class=\"summary\">Generates a uniform unit vector, given a vector2 of uniform numbers between 0 and 1.</p><div class=\"usage\"> <code>vector sample_direction_uniform(vector2 u)</code></div><div class=\"argument\"><code>u</code></div><p>Pair of numbers between 0 and 1.</p><p>Returns a unit vector, i.e. a vector of length 1, based on <code>u</code>.\nGiven uniform random <code>u</code> pairs of values in [0,1), the returned unit vectors will be\nuniform random and continuous with respect to <code>u</code> on the surface of the unit sphere.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_edge_uniform\">sample_circle_edge_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_uniform\">sample_orientation_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_uniform\">sample_circle_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_uniform\">sample_sphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_uniform\">sample_hypersphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_arc\">sample_circle_arc</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_cone\">sample_direction_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_cone\">sample_orientation_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_slice\">sample_circle_slice</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_cone\">sample_sphere_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_cone\">sample_hypersphere_cone</a></div></body>",
    "sample_discrete": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_discrete\">sample_discrete</a></h1><p class=\"summary\">Returns an integer, either uniform or weighted, given a uniform number between 0 and 1.</p><div class=\"usage\"> <code>int sample_discrete(int nvalues, float u)</code></div><div class=\"usage\"> <code>int sample_discrete(float weights[], float u)</code></div><div class=\"argument\"><code>nvalues</code></div><p>The returned integer will be uniform in the range <code>[0,nvalues-1]</code>,\n    returning 0 if <code>u==0</code>, and returning <code>nvalues-1</code> if <code>u==1</code>.  The\n    output will be clamped to that range in case <code>u</code> is out of the range\n    [0,1), to reduce the risk of roundoff on <code>u</code> causing problems.</p><div class=\"argument\"><code>weights</code></div><p>Relative weights, (the sum does not need to be 1), of each integer\n    value in the range <code>[0,len(weights)-1]</code>.</p><div class=\"argument\"><code>u</code></div><p>A number between 0 and 1.</p><p>Returns an integer, based on <code>u</code>, either uniformly weighted from 0 to\n<code>nvalues-1</code>, or weighted based on the <code>weights</code> array from 0 to\n<code>len(weights)-1</code>.\nGiven uniform random <code>u</code> values in [0,1), the version taking <code>nvalues</code>\nwill return uniform random integers in <code>[0,nvalues-1]</code>, and the version\ntaking <code>weights</code> will return random integers in <code>[0,len(weights)-1]</code>, where\nthe probability of <code>i</code> is <code>weights[i]/sum_of_weights</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rand\">rand</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_normal\">sample_normal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_exponential\">sample_exponential</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_cauchy\">sample_cauchy</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_lognormal\">sample_lognormal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_lognormal_by_median\">sample_lognormal_by_median</a></div></body>",
    "sample_exponential": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_exponential\">sample_exponential</a></h1><p class=\"summary\">Samples the exponential distribution.</p><div class=\"usage\"> <code>float sample_exponential(float u)</code></div><div class=\"usage\"> <code>float sample_exponential(float mean, float u)</code></div><div class=\"usage\"> <code>float sample_exponential(float origmean, float maxvalue, float u)</code></div><div class=\"argument\"><code>u</code></div><p>A number in the range [0,1).</p><div class=\"argument\"><code>mean</code></div><p>The mean of the distribution, or 1 if not specified.</p><div class=\"argument\"><code>origmean</code></div><p>The mean the distribution would have, were it not for <code>maxvalue</code>,\n    limiting the range.</p><div class=\"argument\"><code>maxvalue</code></div><p>When given, instead of sampling the full exponential distribution,\n    the distribution with its range limited to <code>[0,maxvalue]</code> will be\n    sampled.</p><p>Samples the exponential distribution with the specified <code>mean</code>, optionally\nwith a <code>maxvalue</code>.\nGiven uniform random <code>u</code> values in [0,1), this will return exponentially\ndistributed random numbers.  The return value will be monotone increasing\nwith respect to <code>u</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rand\">rand</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_normal\">sample_normal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_cauchy\">sample_cauchy</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_lognormal\">sample_lognormal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_lognormal_by_median\">sample_lognormal_by_median</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_discrete\">sample_discrete</a></div></body>",
    "sample_geometry": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_geometry\">sample_geometry</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Samples geometry in the scene and returns information from the shaders of surfaces that were sampled.</p><div class=\"usage\"> <code>int sample_geometry(vector origin, vector sample, float time, ...)</code></div><p>The sample_geometry operation in VEX is used to distribute a single sample\npoint on geometry objects in the scene, and to execute the surface shader\nat that point.  The operation is similar to the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/trace\">trace</a> and\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gather\">gather</a> functions in that it accepts a variadic argument list of\nshader outputs to be exported by the operation.  However, <code>sample_geometry</code>\nis different from raytracing functions in that it does not actually send a\nray into the scene to determine where shaders should be run.  The <code class=\"var\">origin</code>\nand <code class=\"var\">sample</code> parameters have different meanings depending on the\ntype of distribution.  <code class=\"var\">time</code> can be used with motion blur to distribute\nsample points in time as well as in space.</p><h2>Area Distribution</h2><p>In this mode, points will be distributed over multiple primitives according to\ntheir area.  More samples will be placed on primitives with large surface\nareas than on primitives with small surface areas.  The <code class=\"var\">sample</code> parameter\nshould contain uniform random variables in the range of 0 to 1.  The\n<code class=\"var\">origin</code> parameter has no effect.</p><h2>Parametric Distribution</h2><p>In this mode, primitive and subdivision IDs along with parametric surface\ncoordinates are mapped to surface positions.  This mode is useful when trying\nto maintain a coherent set of surface positions (for example, in a point cloud) across multiple frames because the same primitive ID, subdivision ID, s, and t coordinates map to similar surface positions even when a mesh is deforming.\nThe <code class=\"var\">sample</code> parameter contains the s and t coordinates (in the first and\nsecond components), while the <code class=\"var\">origin</code> parameter contains the primitive and\nsubdivision IDs (again, in the first and second components).</p><h2>Solid Angle Distribution</h2><p>This mode is similar to the area mode, except that points on a particular\nprimitive are distributed according to solid angle rather than area.  More\nspecifically, samples will be distributed according to hemispherical coverage\nrelative to <code class=\"var\">origin</code>.  The <code class=\"var\">sample</code> parameter should contain uniform\nrandom variables in the range of 0 to 1.</p><h2>Details</h2><h2>Examples</h2><p>The following example demonstrates how <code>sample_geometry</code> can be used to\nilluminate one surface from another.  Rather than using a light source,\nillumination is gathered from other surfaces in the scene named\n<code>/obj/sphere_object*</code> and will illuminate any surfaces with the geolight\nsurface shader assigned.</p><p>A few observations about the shader:</p><div class=\"related\">The <code>ray:solidangle</code> output is used to scale back geometry sample contributions by the solid angle subtended by the hit surface.  This ensures that the result of using sample_geometry will match physically based irradiance.</div><div class=\"related\">The <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/trace\">trace</a> instruction is used for shadowing</div><div class=\"related\">High-quality sampling patterns from <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/newsampler\">newsampler</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nextsample\">nextsample</a> are used for antialiasing</div><div class=\"codeblock\"><code class=\"codeline\">surface</code><code class=\"codeline\">geolight(int nsamples = 64)</code><code class=\"codeline\">{</code><code class=\"codeline\">    vector        sam;</code><code class=\"codeline\">    vector        clr, pos;</code><code class=\"codeline\">    float        angle, sx, sy;</code><code class=\"codeline\">    int                sid;</code><code class=\"codeline\">    int                i;</code><code class=\"codeline\"></code><code class=\"codeline\">    sid = newsampler();</code><code class=\"codeline\"></code><code class=\"codeline\">    Cf = 0;</code><code class=\"codeline\">    for (i = 0; i &lt; nsamples; i++)</code><code class=\"codeline\">    {</code><code class=\"codeline\">        nextsample(sid, sx, sy, \"mode\", \"qstrat\");</code><code class=\"codeline\">        sam = set(sx, sy, 0.0);</code><code class=\"codeline\">        if (sample_geometry(P, sam, Time,</code><code class=\"codeline\">            \"distribution\", \"solidangle\",</code><code class=\"codeline\">            \"scope\", \"/obj/sphere_object*\",</code><code class=\"codeline\">            \"ray:solidangle\", angle, \"P\", pos, \"Cf\", clr))</code><code class=\"codeline\">        {</code><code class=\"codeline\">            if (!trace(P, normalize(pos-P), Time,</code><code class=\"codeline\">                \"scope\", \"/obj/sphere_object*\",</code><code class=\"codeline\">                \"maxdist\", length(pos-P)-0.01))</code><code class=\"codeline\">            {</code><code class=\"codeline\">                clr *= angle / (2*PI);</code><code class=\"codeline\">                clr *= max(dot(normalize(pos-P), normalize(N)), 0);</code><code class=\"codeline\">            }</code><code class=\"codeline\">            else</code><code class=\"codeline\">                clr = 0;</code><code class=\"codeline\">        }</code><code class=\"codeline\">        Cf += clr;</code><code class=\"codeline\">    }</code><code class=\"codeline\">    Cf /= nsamples;</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gather\">gather</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/trace\">trace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/newsampler\">newsampler</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nextsample\">nextsample</a></div></body>",
    "sample_hemisphere": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hemisphere\">sample_hemisphere</a></h1><p class=\"summary\">Generates a unit vector, optionally biased, within a hemisphere, given a vector2 of uniform numbers between 0 and 1.</p><div class=\"usage\"> <code>vector sample_hemisphere(vector2 u)</code></div><div class=\"usage\"> <code>vector sample_hemisphere(vector center, vector2 u)</code></div><div class=\"usage\"> <code>vector sample_hemisphere(float bias, vector2 u)</code></div><div class=\"usage\"> <code>vector sample_hemisphere(vector center, float bias, vector2 u)</code></div><div class=\"argument\"><code>center</code></div><p>Direction in the center of the hemisphere.  This does not need to be normalized.\n    If not specified, the center direction is (1,0,0), along the x-axis.</p><div class=\"argument\"><code>bias</code></div><p>Bias toward the center direction, between -1 and infinity, with 0 being unbiased,\n    -1 forcing all points to the horizon, and infinity forcing all points to center.\n    When supplied, <code>u.y</code> is simply replaced with <code>1-pow(1-u.y, 1.0/(bias+1.0))</code>.  To\n    get a bias similar to this when using the more general <code>sample_direction_cone</code>,\n    <code>sample_sphere_cone</code>, and related functions, apply the same change to <code>u.x</code>\n    before calling those functions.</p><div class=\"argument\"><code>u</code></div><p>Pair of numbers between 0 and 1.</p><p>Returns a unit vector, i.e. a vector of length 1, based on <code>u</code>.\nGiven uniform random <code>u</code> pairs of values in [0,1), if <code>bias</code> is 0, the\nreturned unit vectors will be uniform random and continuous with respect to\n<code>u</code> on the surface of the unit hemisphere centered at <code>center</code>.  If bias is\ngreater than zero, the unit vectors will be smoothly biased toward <code>center</code>.\nIf bias is between -1 and 0, the unit vectors will be biased away from\n<code>center</code>, toward the horizon.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_cone\">sample_direction_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_uniform\">sample_sphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_cone\">sample_sphere_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rand\">rand</a></div></body>",
    "sample_hypersphere_cone": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_cone\">sample_hypersphere_cone</a></h1><p class=\"summary\">Generates a uniform vector4 with length &lt; 1, within maxangle of center, given a vector4 of uniform numbers between 0 and 1.</p><div class=\"usage\"> <code>vector4 sample_hypersphere_cone(vector4 center, float maxangle, vector4 u)</code></div><div class=\"argument\"><code>center</code></div><p>Direction in the center of the cone.  This does not need to be normalized.</p><div class=\"argument\"><code>maxangle</code></div><p>Maximum angle, in radians, away from <code>center</code> that any sample of the cone\n    will be, so long as all <code>u</code> values are between 0 and 1.</p><div class=\"argument\"><code>u</code></div><p>Four numbers between 0 and 1.</p><p>Returns a vector4 of length &lt; 1, based on <code>u</code>.\nGiven uniform random <code>u</code> vectors of four values in [0,1), the returned vectors will be\nuniform random and continuous with respect to <code>u</code> inside the unit hypersphere,\nin the hypervolume within <code>maxangle</code> of the direction indicated by <code>center</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_edge_uniform\">sample_circle_edge_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_uniform\">sample_orientation_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_uniform\">sample_circle_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_uniform\">sample_sphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_uniform\">sample_hypersphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_arc\">sample_circle_arc</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_cone\">sample_direction_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_cone\">sample_orientation_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_slice\">sample_circle_slice</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_cone\">sample_sphere_cone</a></div></body>",
    "sample_hypersphere_uniform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_uniform\">sample_hypersphere_uniform</a></h1><p class=\"summary\">Generates a uniform vector4 with length &lt; 1, given a vector4 of uniform numbers between 0 and 1.</p><div class=\"usage\"> <code>vector4 sample_hypersphere_uniform(vector4 u)</code></div><div class=\"argument\"><code>u</code></div><p>Four numbers between 0 and 1.</p><p>Returns a vector4 of length &lt; 1, based on <code>u</code>.\nGiven uniform random <code>u</code> vectors of four values in [0,1), the returned vectors will be\nuniform random and continuous with respect to <code>u</code> inside the unit hypersphere.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_edge_uniform\">sample_circle_edge_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_uniform\">sample_orientation_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_uniform\">sample_circle_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_uniform\">sample_sphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_arc\">sample_circle_arc</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_cone\">sample_direction_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_cone\">sample_orientation_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_slice\">sample_circle_slice</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_cone\">sample_sphere_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_cone\">sample_hypersphere_cone</a></div></body>",
    "sample_light": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_light\">sample_light</a></h1><span class=\"padder\"><span class=\"pillow\">displace</span></span><span class=\"padder\"><span class=\"pillow\">fog</span></span><span class=\"padder\"><span class=\"pillow\">surface</span></span><p class=\"summary\">Samples a 3D position on a light source and runs the light shader at that point.</p><div class=\"usage\"> <code>int sample_light(int lightid, vector pos, vector sam, float time, vector &amp;pos, vector &amp;clr, float &amp;scale, ...)</code></div><div class=\"argument\"><code>lightid</code></div><p>An integer identifying a light. You can get a list of light IDs for lights affecting the currently shaded surface with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlights\">getlights</a>.</p><div class=\"argument\"><code>pos</code></div><p>The surface point from which lights should be sampled.  Area light sources will attempt to distribute samples by solid angle from the position - that is, light geometry that is closer to the position will receive more samples.</p><div class=\"argument\"><code>sam</code></div><p>A vector of random values, such as those generated by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nextsample\">nextsample</a>. Currently only the first 2 components of <code>sam</code> are used.  Different values of <code>sam</code> translate into different random positions on the geometry of the light source.</p><div class=\"argument\"><code>time</code></div><p>Time to shade at.</p><p>The function modifies the values of the following arguments:</p><div class=\"argument\"><code>pos</code></div><p>The sampled position on the light source.</p><div class=\"argument\"><code>clr</code></div><p>The light color set by the light shader.</p><div class=\"argument\"><code>scale</code></div><p>The light average hemispherical intensity (for area lights).</p><h2>Returns</h2><p>A <a href=\"https://www.sidefx.com/docs/houdinibouncemask\">component bitmask</a> indicating what types of component bounces the light affects.</p><h2>Tip</h2><p>If you are using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_light\">sample_light</a> to generate light colors, for example\n    to reproduce the <code>Cl</code> values that would be produced by a <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a>\n    loop, you will need to normalize <code>clr</code> to <code>scale</code>:</p><div class=\"codeblock\"><code class=\"codeline\">clr *= scale / luminance(clr);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlights\">getlights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/intersect_lights\">intersect_lights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nextsample\">nextsample</a></div></body>",
    "sample_lognormal": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_lognormal\">sample_lognormal</a></h1><p class=\"summary\">Samples the log-normal distribution based on parameters of the underlying normal distribution.</p><div class=\"usage\"> <code>float sample_lognormal(float mu, float sigma, float u)</code></div><div class=\"usage\"> <code>float sample_lognormal(float mu, float sigma, float minvalue, float maxvalue, float u)</code></div><div class=\"argument\"><code>mu</code></div><p>The mean of the underlying normal distribution.</p><div class=\"argument\"><code>sigma</code></div><p>The standard deviation of the underlying normal distribution.</p><div class=\"argument\"><code>u</code></div><p>A number in the range [0,1).</p><div class=\"argument\"><code><code>minvalue</code>,<code>maxvalue</code></code></div><p>When given, instead of sampling the full log-normal distribution,\n    the distribution with its range limited to <a href=\"https://www.sidefx.com/docs/houdini`minvalue`,`maxvalue`\">`minvalue`,`maxvalue`</a> will be\n    sampled.</p><p>Samples the log-normal distribution with the specified <code>mu</code> and <code>sigma</code>, optionally\nwith a <code>minvalue</code> and <code>maxvalue</code>.  To use parameters that are more understandable,\n<code>median</code> and <code>stddev</code>, please use <code>sample_lognormal_by_median</code>.\nGiven uniform random <code>u</code> values in [0,1), this will return log-normally\ndistributed random numbers.  The return value will be monotone increasing\nwith respect to <code>u</code>.</p><p>The log-normal distribution is sampled by sampling a normal distribution\nand exponentiating the result, giving a value that is always positive, so\nthis distribution is often used for generating random point scales.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_lognormal_by_median\">sample_lognormal_by_median</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_normal\">sample_normal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rand\">rand</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_exponential\">sample_exponential</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_cauchy\">sample_cauchy</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_discrete\">sample_discrete</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/log\">log</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/exp\">exp</a></div></body>",
    "sample_lognormal_by_median": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_lognormal_by_median\">sample_lognormal_by_median</a></h1><p class=\"summary\">Samples the log-normal distribution based on median and standard deviation.</p><div class=\"usage\"> <code>float sample_lognormal_by_median(float median, float stddev, float u)</code></div><div class=\"usage\"> <code>float sample_lognormal_by_median(float origmedian, float origstddev, float minvalue, float maxvalue, float u)</code></div><div class=\"argument\"><code>median</code></div><p>The median of the distribution.</p><div class=\"argument\"><code>origmedian</code></div><p>The median the distribution would have, were it not for <code>minvalue</code>\n    and <code>maxvalue</code>, limiting the range.</p><div class=\"argument\"><code>stddev</code></div><p>The standard deviation of the distribution.</p><div class=\"argument\"><code>origstddev</code></div><p>The standard deviation (scale) the distribution would have, were it\n    not for <code>minvalue</code> and <code>maxvalue</code>, limiting the range.</p><div class=\"argument\"><code>u</code></div><p>A number in the range [0,1).</p><div class=\"argument\"><code><code>minvalue</code>,<code>maxvalue</code></code></div><p>When given, instead of sampling the full log-normal distribution,\n    the distribution with its range limited to <a href=\"https://www.sidefx.com/docs/houdini`minvalue`,`maxvalue`\">`minvalue`,`maxvalue`</a> will be\n    sampled.</p><p>Samples the log-normal distribution with the specified <code>median</code> and <code>stddev</code>,\noptionally with a <code>minvalue</code> and <code>maxvalue</code>.  To use parameters <code>mu</code> and <code>sigma</code>\nof the underlying normal distribution instead of <code>median</code> and <code>stddev</code>,\nuse <code>sample_lognormal</code>.\nGiven uniform random <code>u</code> values in [0,1), this will return log-normally\ndistributed random numbers.  The return value will be monotone increasing\nwith respect to <code>u</code>.</p><p>The log-normal distribution is sampled by sampling a normal distribution\nand exponentiating the result, giving a value that is always positive, so\nthis distribution is often used for generating random point scales.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_lognormal\">sample_lognormal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_normal\">sample_normal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rand\">rand</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_exponential\">sample_exponential</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_cauchy\">sample_cauchy</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_discrete\">sample_discrete</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/log\">log</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/exp\">exp</a></div></body>",
    "sample_normal": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_normal\">sample_normal</a></h1><p class=\"summary\">Samples the normal (Gaussian) distribution.</p><div class=\"usage\"> <code>float sample_normal(float u)</code></div><div class=\"usage\"> <code>float sample_normal(float mean, float stddev, float u)</code></div><div class=\"usage\"> <code>float sample_normal(float origmean, float origstddev, float minvalue, float maxvalue, float u)</code></div><div class=\"usage\"> <code>vector2 sample_normal(vector2 u)</code></div><div class=\"usage\"> <code>vector  sample_normal(vector  u)</code></div><div class=\"usage\"> <code>vector4 sample_normal(vector4 u)</code></div><div class=\"argument\"><code>u</code></div><p>A number, or multiple numbers, in the range [0,1).</p><div class=\"argument\"><code>mean</code></div><p>The mean of the distribution, or 0 if not specified.</p><div class=\"argument\"><code>origmean</code></div><p>The mean the distribution would have, were it not for <code>minvalue</code>\n    and <code>maxvalue</code>, limiting the range.</p><div class=\"argument\"><code>stddev</code></div><p>The standard deviation (scale) of the distribution, or 1 if not specified.</p><div class=\"argument\"><code>origstddev</code></div><p>The standard deviation (scale) the distribution would have, were it\n    not for <code>minvalue</code> and <code>maxvalue</code>, limiting the range.</p><div class=\"argument\"><code><code>minvalue</code>,<code>maxvalue</code></code></div><p>When given, instead of sampling the full normal distribution,\n    the distribution with its range limited to <a href=\"https://www.sidefx.com/docs/houdini`minvalue`,`maxvalue`\">`minvalue`,`maxvalue`</a> will be\n    sampled.</p><p>Samples the normal distribution with the specified <code>mean</code> and <code>stddev</code>, optionally\nwith a <code>minvalue</code> and <code>maxvalue</code>.\nGiven uniform random <code>u</code> values in [0,1), this will return normally\ndistributed random numbers.  The return value will be monotone increasing\nwith respect to <code>u</code>.</p><p>The <code>vector2</code>, <code>vector</code>, and <code>vector4</code> versions\nreturn multiple samples with mean 0 and standard deviation 1.  The\ndistribution of these vectors is naturally isotropic, i.e. rotating\nthe distribution won\u2019t change it, which can be useful in simulations.\nTo add a maximum distance from the origin, while keeping the distribution\nisotropic, use:</p><p><code>sample_normal(0,1,0,maxdist,u.x) * sample_direction_uniform(set(u.y,u.z))</code></p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rand\">rand</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_exponential\">sample_exponential</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_cauchy\">sample_cauchy</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_lognormal\">sample_lognormal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_lognormal_by_median\">sample_lognormal_by_median</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_discrete\">sample_discrete</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div></body>",
    "sample_orientation_cone": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_cone\">sample_orientation_cone</a></h1><p class=\"summary\">Generates a uniform unit vector4, within maxangle of center, given a vector of uniform numbers between 0 and 1.</p><div class=\"usage\"> <code>vector4 sample_orientation_cone(vector4 center, float maxangle, vector u)</code></div><div class=\"argument\"><code>center</code></div><p>Orientation in the center of the cone.  This does not need to be normalized.</p><div class=\"argument\"><code>maxangle</code></div><p>Maximum angle, in radians, away from <code>center</code> that any sample of the cone\n    will be, so long as all <code>u</code> values are between 0 and 1.</p><h2>Note</h2><p>This angle is the maximum quaternion rotation angle between the orientation quaternion that the output represents and <code>center</code>, which is twice the Euclidean cone angle of the unit 4D hypersphere being sampled. A <code>maxangle</code> of \u03c0 would sample all orientations, but only half of all 4D unit vectors; a <code>maxangle</code> of 2\u03c0 would sample all 4D unit vectors.</p><div class=\"argument\"><code>u</code></div><p>Three numbers between 0 and 1.</p><p>Returns a unit vector4, i.e. a vector4 of length 1, based on <code>u</code>.\nGiven uniform random <code>u</code> vectors of three values in [0,1), the returned quaternion\norientations will be uniform random and continuous with respect to <code>u</code>,\nin the region of orientations within <code>maxangle</code> of <code>center</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_edge_uniform\">sample_circle_edge_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_uniform\">sample_orientation_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_uniform\">sample_circle_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_uniform\">sample_sphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_uniform\">sample_hypersphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_arc\">sample_circle_arc</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_cone\">sample_direction_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_slice\">sample_circle_slice</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_cone\">sample_sphere_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_cone\">sample_hypersphere_cone</a></div></body>",
    "sample_orientation_uniform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_uniform\">sample_orientation_uniform</a></h1><p class=\"summary\">Generates a uniform unit vector4, given a vector of uniform numbers between 0 and 1.</p><div class=\"usage\"> <code>vector4 sample_orientation_uniform(vector u)</code></div><div class=\"argument\"><code>u</code></div><p>Three numbers between 0 and 1.</p><p>Returns a unit vector4, i.e. a vector4 of length 1, based on <code>u</code>.\nGiven uniform random <code>u</code> vectors of three values in [0,1), the returned unit vectors will be\nuniform random and continuous with respect to <code>u</code> on the surface of the unit hypersphere.\nIn other words, they will be uniform random orientation quaternions.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_edge_uniform\">sample_circle_edge_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_uniform\">sample_circle_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_uniform\">sample_sphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_uniform\">sample_hypersphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_arc\">sample_circle_arc</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_cone\">sample_direction_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_cone\">sample_orientation_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_slice\">sample_circle_slice</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_cone\">sample_sphere_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_cone\">sample_hypersphere_cone</a></div></body>",
    "sample_photon": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_photon\">sample_photon</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Samples a 3D position on a light source and runs the light shader at that point.</p><div class=\"usage\"> <code>int sample_photon(light lp, vector &amp;pos, vector &amp;dir, float &amp;scale, float time)</code></div><p>Spawns a photon from the given light source and returns the information for the\nfirst intersection in the scene.  The <code>pos</code>, <code>dir</code> and <code>scale</code> are filled out\nwith the information about where the photon hit in the scene.</p><p>The returned integer represents the bounce type mask (this is determined by the\ntypes of illumination labels on the light source).</p><p>The function returns 0 if the photon didn\u2019t intersect any geometry.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlight\">getlight</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/photonmap\">photonmap</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getphotonlight\">getphotonlight</a></div></body>",
    "sample_sphere_cone": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_cone\">sample_sphere_cone</a></h1><p class=\"summary\">Generates a uniform vector with length &lt; 1, within maxangle of center, given a vector of uniform numbers between 0 and 1.</p><div class=\"usage\"> <code>vector sample_sphere_cone(vector center, float maxangle, vector u)</code></div><div class=\"argument\"><code>center</code></div><p>Direction in the center of the cone.  This does not need to be normalized.</p><div class=\"argument\"><code>maxangle</code></div><p>Maximum angle, in radians, away from <code>center</code> that any sample of the cone\n    will be, so long as all <code>u</code> values are between 0 and 1.</p><div class=\"argument\"><code>u</code></div><p>Three numbers between 0 and 1.</p><p>Returns a vector of length &lt; 1, based on <code>u</code>.\nGiven uniform random <code>u</code> vectors of three values in [0,1), the returned vectors will be\nuniform random and continuous with respect to <code>u</code> inside the unit sphere,\nin the volume within <code>maxangle</code> of the direction indicated by <code>center</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_edge_uniform\">sample_circle_edge_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_uniform\">sample_orientation_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_uniform\">sample_circle_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_uniform\">sample_sphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_uniform\">sample_hypersphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_arc\">sample_circle_arc</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_cone\">sample_direction_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_cone\">sample_orientation_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_slice\">sample_circle_slice</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_cone\">sample_hypersphere_cone</a></div></body>",
    "sample_sphere_shell_uniform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_shell_uniform\">sample_sphere_shell_uniform</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Generates a uniform vector with alpha &lt; length &lt; 1, where 0 &lt; alpha &lt; 1, given a vector of uniform numbers between 0 and 1.</p><div class=\"usage\"> <code>vector sample_sphere_shell_uniform(vector u, float alpha)</code></div><div class=\"argument\"><code>u</code></div><p>Three numbers between 0 and 1.</p><div class=\"argument\"><code>alpha</code></div><p>The inner radius to be bounded by. A number between 0 and 1.</p><p>Returns a vector of length &lt; 1, based on <code>u</code>.\nGiven uniform random <code>u</code> vectors of three values in <a href=\"https://www.sidefx.com/docs/houdini0,1), and a number in [0,1\">0,1), and a number in [0,1</a>, the returned vectors will be\nuniform random and continuous with respect to <code>u</code> inside the unit sphere shell with the inner raidus alpha.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_edge_uniform\">sample_circle_edge_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_uniform\">sample_orientation_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_uniform\">sample_circle_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_uniform\">sample_hypersphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_arc\">sample_circle_arc</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_cone\">sample_direction_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_cone\">sample_orientation_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_slice\">sample_circle_slice</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_cone\">sample_sphere_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_uniform\">sample_sphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_cone\">sample_hypersphere_cone</a></div></body>",
    "sample_sphere_uniform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_uniform\">sample_sphere_uniform</a></h1><p class=\"summary\">Generates a uniform vector with length &lt; 1, given a vector of uniform numbers between 0 and 1.</p><div class=\"usage\"> <code>vector sample_sphere_uniform(vector u)</code></div><div class=\"argument\"><code>u</code></div><p>Three numbers between 0 and 1.</p><p>Returns a vector of length &lt; 1, based on <code>u</code>.\nGiven uniform random <code>u</code> vectors of three values in [0,1), the returned vectors will be\nuniform random and continuous with respect to <code>u</code> inside the unit sphere.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_edge_uniform\">sample_circle_edge_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_uniform\">sample_direction_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_uniform\">sample_orientation_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_uniform\">sample_circle_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_uniform\">sample_hypersphere_uniform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_arc\">sample_circle_arc</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_direction_cone\">sample_direction_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_orientation_cone\">sample_orientation_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_circle_slice\">sample_circle_slice</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_sphere_cone\">sample_sphere_cone</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_hypersphere_cone\">sample_hypersphere_cone</a></div></body>",
    "scale": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/scale\">scale</a></h1><p class=\"summary\">Scales the given matrix in three directions simultaneously (X, Y, Z -\ngiven by the components of the scale_vector).</p><div class=\"usage\"> <code>void scale(matrix2 &amp;m, vector2 scale_vector)</code></div><div class=\"usage\"> <code>void scale(matrix &amp;m, vector scale_vector)</code></div><div class=\"usage\"> <code>void scale(matrix3 &amp;m, vector scale_vector)</code></div><p>Scales the matrix in three directions simultaneously by the factors in the vector.\n    This modifies the matrix in-place, rather than returning a new matrix.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pretranslate\">pretranslate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prerotate\">prerotate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prescale\">prescale</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/translate\">translate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rotate\">rotate</a></div></body>",
    "scatter": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/scatter\">scatter</a></h1><span class=\"padder\"><span class=\"pillow\">shading contexts</span></span><p class=\"summary\">Evaluates a scattering event through the domain of a geometric object.</p><div class=\"usage\"> <code>int scatter(vector ipoint, vector inormal, vector idirection, vector idistribution, float time, float maxdist, vector &amp;opoint, vector &amp;onormal, vector &amp;odirection)</code></div><p>Evaluates a single scattering event through geometry. A return value of 1 means the scattering was successful.</p><div class=\"argument\"><code>ipoint</code></div><p>Entry point of scattering.</p><div class=\"argument\"><code>inormal</code></div><p>Surface normal at the entry point (surfaces only). Required to orient the scattering plane.</p><div class=\"argument\"><code>idirection</code></div><p>Primary scattering direction at the entry point. Required to orient the scattering plane.</p><div class=\"argument\"><code>idistribution</code></div><p>Initial scatter distribution at the entry point. If a zero-valued vector is passed a random scatter distribution will be used.</p><div class=\"argument\"><code>maxdist</code></div><p>Maximum distance to scatter.</p><div class=\"argument\"><code>opoint</code></div><p>Exit point of scattering.</p><div class=\"argument\"><code>onormal</code></div><p>Normal at the scattering exit point (surfaces only).</p><div class=\"argument\"><code>odirection</code></div><p>Outgoing direction at the scattering exit point (surfaces only).</p><div class=\"codeblock\"><code class=\"codeline\">// Trace for intersection with scene</code><code class=\"codeline\">vector hitP = 0;</code><code class=\"codeline\">vector hitN = 0;</code><code class=\"codeline\">int hit = trace(P, I, Time, \"P\", hitP, \"N\", hitN);</code><code class=\"codeline\"></code><code class=\"codeline\">// Scatter a random distance from the intersection</code><code class=\"codeline\">vector idistribution = 0;</code><code class=\"codeline\">int sid = israytrace ? SID : newsampler();</code><code class=\"codeline\">vector s;</code><code class=\"codeline\">nextsample(sid, s.x, s.y, \"mode\", \"nextpixel\");</code><code class=\"codeline\">float maxdist = 2.0 * s.x;</code><code class=\"codeline\">vector opoint = 0;</code><code class=\"codeline\">vector onormal = 0;</code><code class=\"codeline\">vector odirection = 0;</code><code class=\"codeline\">hit = scatter(hitP, hitN, I, idistribution, Time, maxdist, opoint, onormal, odirection);</code><code class=\"codeline\"></code><code class=\"codeline\">// Trace again from the exit point of the scattering</code><code class=\"codeline\">hit = trace(opoint, odirection, Time, \"P\", hitP, \"N\", hitN);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_geometry\">sample_geometry</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/trace\">trace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gather\">gather</a></div></body>",
    "select": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/select\">select</a></h1><p class=\"summary\">Returns one of two parameters based on a conditional.</p><div class=\"usage\"> <code>&lt;type&gt; select(int conditional, &lt;type&gt; a, &lt;type&gt; b)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] select(int conditional, &lt;type&gt; a[], &lt;type&gt; b[])</code></div><p>Returns <code>a</code> if the conditional is true, and returns <code>b</code> if it is false.</p><p>The difference between select and an <code>if</code> statement is that select will\nevaluate both a and b, regardless of the value of the conditional.  Judicious\nuse of <code>select</code> can avoid comparisons, allowing larger sections of code to be\nconverted to native code.</p></body>",
    "sensor_panorama_create": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sensor_panorama_create\">sensor_panorama_create</a></h1><p class=\"summary\">Sensor function to render GL scene and query the result.</p><div class=\"usage\"> <code>int sensor_panorama_create(float time, vector pos, int size, float near, float far, string candidateobj, string includeobj, string excludeobj, int uselit)</code></div><p>This function will render the surrounding environment using the GL render and\nprovides a handle to use for querying the results.</p><h2>Note</h2><p>Because this needs to render the scene, it only works in interactive sessions of Houdini.</p><div class=\"argument\"><code>time</code></div><p>The period in time when the render should be performed.</p><div class=\"argument\"><code>pos</code></div><p>The location in world space coordinates where the render should be performed.</p><div class=\"argument\"><code>size</code></div><p>The resolution of the performed render.</p><div class=\"argument\"><code>near</code></div><p>The near plane restriction.</p><div class=\"argument\"><code>far</code></div><p>The far plane restriction.</p><div class=\"argument\"><code>candidateobj</code></div><p>A bundle, group, or expression that represents what objects will be displayed if their display setting is enabled.</p><div class=\"argument\"><code>includeobj</code></div><p>A bundle, group, or expression that represents what objects will always be displayed.</p><div class=\"argument\"><code>excludeobj</code></div><p>A bundle, group, or expression that represents what objects will never be displayed.</p><div class=\"argument\"><code>uselit</code></div><p>Usually for AI purposes you want to not have any lighting as you are using\n    color as a key to differentiate actors.  However, if you want to display\n    what a creature sees, lighting makes things more visually accurate.</p></body>",
    "sensor_panorama_getcolor": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sensor_panorama_getcolor\">sensor_panorama_getcolor</a></h1><p class=\"summary\">Sensor function query a rendered GL scene.</p><div class=\"usage\"> <code>vector sensor_panorama_getcolor(int handle, vector dir)</code></div><p>This function will return the color in the given direction from the\nscene rendered previously with <code>sensor_panorama_create</code>.</p></body>",
    "sensor_panorama_getcone": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sensor_panorama_getcone\">sensor_panorama_getcone</a></h1><p class=\"summary\">Sensor function to query average values from rendered GL scene.</p><div class=\"usage\"> <code>void sensor_panorama_getcone(int handle, vector lookodir, float angle, vector colormin, vector colormax, float depthmin, float depthmax, float &amp;strength, vector &amp;dir, vector &amp;color, float &amp;depth)</code></div><p>This function will render the surrounding environment using the GL render and\nprovides a handle to use for querying the results.</p><p>It averages out all rendered pixels in a cone shaped area.  The <code>colormin</code> and\n<code>colormax</code> can be used to mask out only pixels that lie in this range, useful\nfor color-coding different regions of interest.  The resulting dir and strength\ninform the weighted center of all matching pixels, and the relative amount that\npassed the color and depth filters.  The color and depth are the average of all\nmatched pixels.</p></body>",
    "sensor_panorama_getdepth": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sensor_panorama_getdepth\">sensor_panorama_getdepth</a></h1><p class=\"summary\">Sensor function query a rendered GL scene.</p><div class=\"usage\"> <code>float sensor_panorama_getdepth(int handle, vector dir)</code></div><p>This function will return the depth in the given direction from the\nscene rendered previously with <code>sensor_panorama_create</code>.</p></body>",
    "sensor_save": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sensor_save\">sensor_save</a></h1><p class=\"summary\">Sensor function to save a rendered GL scene.</p><div class=\"usage\"> <code>int sensor_save(int handle, string colorfile, string depthfile)</code></div><p>This will save to disk the image maps corresponding to the color and depth\ninformation recorded in the given sensor handle.</p><p>Returns 1 if successfully saved, otherwise 0.</p></body>",
    "serialize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/serialize\">serialize</a></h1><p class=\"summary\">Flattens an array of vector or matrix types into an array of floats.</p><div class=\"usage\"> <code>float[] serialize(&lt;vector&gt; vectors[])</code></div><div class=\"usage\"> <code>float[] serialize(&lt;matrix&gt; matrices[])</code></div><p>These functions will serialize the arrays of tuple values.\nThat is, the values of the tuples are extracted one by one into a\nflat floating point array.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">vector v[] = { {1,2,3}, {7,8,9} }; // A vector[] of length 2</code><code class=\"codeline\">float  f[];</code><code class=\"codeline\"></code><code class=\"codeline\">f = serialize(v);</code><code class=\"codeline\">// Now f[] has a length of 6 and equals { 1,2,3,7,8,9 }</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/unserialize\">unserialize</a></div></body>",
    "set": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/set\">set</a></h1><p class=\"summary\">Creates a new value based on its arguments, such as creating a vector from its components.</p><p>The <code>set()</code> function has a <strong>wide variety</strong> of forms allowing you to perform many different types of conversions.</p><h2>Tip</h2><p>When filling a matrix in Houdini, the numbers go across the first row, then across the second row, and so on (row-major).</p><div class=\"usage\"> <code>vector2 set( float v1; float v2 )</code></div><div class=\"usage\"> <code>vector set( float v1; float v2; float v3 )</code></div><div class=\"usage\"> <code>vector4 set( float v1; float v2; float v3; float v4 )</code></div><div class=\"usage\"> <code>matrix2 set( float v1; float v2; float v3; float v4 )</code></div><div class=\"usage\"> <code>matrix3 set( float v1; float v2; float v4; float v4; float v5; float v6; float v7; float v8; float v9 )</code></div><div class=\"usage\"> <code>matrix set( float v1; float v2; float v3; float v4; float v5; float v6; float v7; float v8; float v9; float v10; float v11; float v12; float v13; float v14; float v15; float v16 )</code></div><p>Create a vector or matrix type from the values in the arguments.</p><div class=\"codeblock\"><code class=\"codeline\">vector4 v = set(1.0, 2.0, 3.0, 4.0);</code><code class=\"codeline\">    matrix3 m = set(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0);</code></div><p>The <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/assign\">assign</a> function performs the opposite of this operation (pulling components out into variables).</p><div class=\"usage\"> <code>&lt;vector&gt; set( float nums[] )</code></div><div class=\"usage\"> <code>&lt;matrix&gt; set( float nums[] )</code></div><p>Creates a vector/matrix from an array of floats.</p><div class=\"codeblock\"><code class=\"codeline\">float[] nums = {1.0, 2.0, 3.0, 4.0};</code><code class=\"codeline\">    vector4 v = set(nums);</code></div><div class=\"usage\"> <code>&lt;vector&gt; set( float|int v )</code></div><div class=\"usage\"> <code>&lt;matrix&gt; set( float|int v )</code></div><p>If you set a vector or matrix type from a single value, the vector/matrix is filled in with that value for all components.</p><div class=\"codeblock\"><code class=\"codeline\">vector4 v = set(2.0);  // -&gt; {2.0, 2.0, 2.0, 2.0}</code></div><div class=\"usage\"> <code>matrix2 set( vector2 row1; vector2 row2 )</code></div><div class=\"usage\"> <code>matrix3 set( vector row1; vector row2; vector row3 )</code></div><div class=\"usage\"> <code>matrix set( vector4 row1; vector4 row2; vector4 row3; vector4 row4 )</code></div><p>Creates a matrix type from a series of vector arguments of the same size representing the rows.</p><div class=\"codeblock\"><code class=\"codeline\">matrix3 m = set({0.0, 1.0, 0.0}, {1.0, 0.0, 1.0}, {0.0, 1.0, 0.0});</code></div><div class=\"usage\"> <code>matrix3 set( vector rows[] )</code></div><div class=\"usage\"> <code>matrix set( vector4 rows[] )</code></div><p>You can also set a matrix type from an array of vectors representing rows. If there are not enough vectors in the array to fill the matrix, the extra rows will contain zeros.</p><div class=\"usage\"> <code>vector[] set( matrix3 m )</code></div><div class=\"usage\"> <code>vector4[] set( matrix m )</code></div><p>Creates an array of vectors from the rows of a matrix of the same size.</p><div class=\"codeblock\"><code class=\"codeline\">matrix3 m3 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};</code><code class=\"codeline\">    vector[] vs = set(m3);  // -&gt; array [ {1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0} ]</code></div><div class=\"usage\"> <code>vector set( vector2 v)</code></div><div class=\"usage\"> <code>vector4 set( vector2 v)</code></div><div class=\"usage\"> <code>vector4 set( vector v)</code></div><div class=\"usage\"> <code>matrix3 set( matrix2 m)</code></div><div class=\"usage\"> <code>matrix set( matrix2 m)</code></div><div class=\"usage\"> <code>matrix set( matrix3 m)</code></div><p>If you set a larger vector or matrix type from a smaller type, the extra components will be zero.</p><div class=\"codeblock\"><code class=\"codeline\">vector2 v2 = {1.0, 2.0};</code><code class=\"codeline\">    vector4 v4 = set(v2);  // -&gt; {1.0, 2.0, 0.0, 0.0}</code></div><div class=\"usage\"> <code>float set( vector v)</code></div><div class=\"usage\"> <code>float set( vector4 v)</code></div><div class=\"usage\"> <code>vector2 set( vector4 v)</code></div><div class=\"usage\"> <code>vector2 set( vector v)</code></div><div class=\"usage\"> <code>vector set( vector4 v)</code></div><p>If you set a smaller vector with a larger vector, the smaller type will take components from the left.</p><div class=\"codeblock\"><code class=\"codeline\">vector4 v4 = {1.0, 2.0, 3.0, 4.0};</code><code class=\"codeline\">    vector2 v2 = set(v4)  // -&gt; {1.0, 2.0}</code></div><div class=\"usage\"> <code>matrix2 set( matrix3 m)</code></div><div class=\"usage\"> <code>matrix2 set( matrix m)</code></div><div class=\"usage\"> <code>matrix3 set( matrix m)</code></div><p>If you set a smaller matrix with a larger matrix, the smaller type will take the top-left corner.</p><div class=\"codeblock\"><code class=\"codeline\">matrix3 m3 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};</code><code class=\"codeline\">    matrix2 m2 = set(m3);  // -&gt; {1.0, 2.0, 4.0, 5.0}</code></div><div class=\"usage\"> <code>float[] set( &lt;vector&gt; v)</code></div><div class=\"usage\"> <code>float[] set( &lt;matrix&gt; m)</code></div><p>Creates an array of floats from the components of a vector or matrix type.</p><div class=\"codeblock\"><code class=\"codeline\">matrix3 m3 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};</code><code class=\"codeline\">    float[] nums = set(m3);  // -&gt; array [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0 ]</code></div><div class=\"usage\"> <code>&lt;vector&gt;[] set( float nums[] )</code></div><div class=\"usage\"> <code>&lt;matrix&gt;[] set( float nums[] )</code></div><p>Creates an array of vector/matrix types by taking one component at a time from an array of floats. This is the same as using the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/unserialize\">unserialize</a> function.</p><div class=\"codeblock\"><code class=\"codeline\">float[] nums = {1.0, 2.0, 3.0, 4.0};</code><code class=\"codeline\">    vector2[] vs = set(nums);  // -&gt; [ {1.0, 2.0}, {3.0, 4.0} ]</code></div><div class=\"usage\"> <code>int set(float v)</code></div><div class=\"usage\"> <code>float set(int v)</code></div><div class=\"usage\"> <code>float[] set( int vs[])</code></div><div class=\"usage\"> <code>int[] set( float vs[])</code></div><p>You can set a float from an int, or an int from a float, or an array of floats from an array of ints, or an array of ints from an array of floats.</p><div class=\"codeblock\"><code class=\"codeline\">float[] fracs = { 1.1, 2.2, 3.3, 4.4, 5.5, 6.6 };</code><code class=\"codeline\">    int[] floored = set(fracs);  // -&gt; array [ 1, 2, 3, 4, 5, 6 ]</code></div><div class=\"usage\"> <code>float[] set( float num )</code></div><p>Sets all the items in an array of float to the same value.</p><div class=\"usage\"> <code>float set( float nums[] )</code></div><p>Returns the first item in the array.</p><div class=\"usage\"> <code>dict set( string key, ...)</code></div><p>Initializes a dictionary with a series of key/value pairs.  Every other parameter should\n    be a string for the key and be followed by the value for that key.</p><div class=\"usage\"> <code>&lt;type&gt; set(&lt;type&gt; v)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] set(&lt;type&gt; v[])</code></div><p>If you call <code>set()</code> with the same argument type and return type, it simply returns the argument value.</p><div class=\"codeblock\"><code class=\"codeline\">string s = set(\"Hello\");  // -&gt; \"Hello\"</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/assign\">assign</a></div></body>",
    "setagentchannelvalue": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentchannelvalue\">setagentchannelvalue</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Overrides the value of an agent primitive\u2019s channel.</p><div class=\"usage\"> <code>int setagentchannelvalue(int geohandle, int prim, float value, int channel)</code></div><div class=\"argument\"><code>geohandle</code></div><p>Handle to the geometry to write to. <code>geoself()</code> can be used to get a handle to the current geometry.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>value</code></div><p>The new value for the channel.</p><div class=\"argument\"><code>index</code></div><p>Index of a channel in the agent\u2019s rig.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipchannel\">agentclipchannel</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelnames\">agentchannelnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelvalue\">agentchannelvalue</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelvalues\">agentchannelvalues</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfindchannel\">agentrigfindchannel</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentchannelvalues\">setagentchannelvalues</a></div></body>",
    "setagentchannelvalues": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentchannelvalues\">setagentchannelvalues</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Overrides the values of an agent primitive\u2019s channels.</p><div class=\"usage\"> <code>void setagentchannelvalues(int geohandle, int prim, float values[])</code></div><p>When modifying a single channel, using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentchannelvalue\">setagentchannelvalue</a> instead can be significantly faster.</p><div class=\"argument\"><code>geohandle</code></div><p>Handle to the geometry to write to. <code>geoself()</code> can be used to get a handle to the current geometry.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>values</code></div><p>The new value of each channel in the agent\u2019s rig.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipchannel\">agentclipchannel</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelnames\">agentchannelnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelvalue\">agentchannelvalue</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentchannelvalues\">agentchannelvalues</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfindchannel\">agentrigfindchannel</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentchannelvalue\">setagentchannelvalue</a></div></body>",
    "setagentclipnames": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipnames\">setagentclipnames</a></h1><p class=\"summary\">Sets the current animation clips for an agent primitive.</p><div class=\"usage\"> <code>void setagentclipnames(int geohandle, int prim, string clipnames[])</code></div><div class=\"argument\"><code>geohandle</code></div><p>Handle to the geometry to write to. <code>geoself()</code> can be used to get a handle to the current geometry.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>clipnames</code></div><p>A list of animation clip names.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">agentclipcatalog</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplength\">agentcliplength</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipnames\">agentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplelocal\">agentclipsamplelocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsampleworld\">agentclipsampleworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptimes\">agentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipweights\">agentclipweights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcliptimes\">setagentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipweights\">setagentclipweights</a></div></body>",
    "setagentclips": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclips\">setagentclips</a></h1><p class=\"summary\">Sets the animation clips that an agent should use to compute its transforms.</p><div class=\"usage\"> <code>int setagentclips(int geohandle, int prim, string clip_names[], float clip_times[], float clip_weights[], string clip_transform_groups[], int clip_layer_ids[], int layer_blend_modes[], float layer_weights[], int layer_parent_ids[])</code></div><div class=\"usage\"> <code>int setagentclips(int geohandle, int prim, int clip_ids[], float clip_times[], float clip_weights[], int clip_transform_group_ids[], int clip_layer_ids[], int layer_blend_modes[], float layer_weights[], int layer_parent_ids[])</code></div><p>This function can provide improved performance compared to using a combination of <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipnames\">setagentclipnames</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcliptimes\">setagentcliptimes</a>, and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipweights\">setagentclipweights</a>, and also modifies the <a href=\"https://www.sidefx.com/docs/houdini/crowds/agents#currentclips\">primitive intrinsics used for layering animation clips</a>.</p><div class=\"argument\"><code>geohandle</code></div><p>Handle to the geometry to write to. <code>geoself()</code> can be used to get a handle to the current geometry.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>clip_names</code></div><p>A list of animation clip names.</p><div class=\"argument\"><code>clip_ids</code></div><p>A list of animation clip indices in the agent definition.\n    A clip\u2019s index can be obtained via <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindclip\">agentfindclip</a>.</p><div class=\"argument\"><code>clip_times</code></div><p>A list of times that the clips should be sampled at.</p><div class=\"argument\"><code>clip_weights</code></div><p>A list of blend weights for the animation clips.</p><div class=\"argument\"><code>clip_transform_groups</code></div><p>A list of transform groups, which specify the joints that each clip should be applied to.</p><div class=\"argument\"><code>clip_transform_group_ids</code></div><p>A list of transform group indices in the agent definition.\n    A transform group\u2019s index can be obtained via <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindtransformgroup\">agentfindtransformgroup</a>.</p><div class=\"argument\"><code>clip_layer_ids</code></div><p>A list containing the layer that each animation clip is an input for.</p><div class=\"argument\"><code>layer_blend_modes</code></div><p>A list of blend modes for each layer. The available blend modes are defined in <code>$HH/vex/include/crowd_cliplayers.h</code>.</p><div class=\"argument\"><code>layer_weights</code></div><p>A list of blend weights for each layer. The blend weight is not used for the topmost layer.</p><div class=\"argument\"><code>layer_parent_ids</code></div><p>A list containing the parent layer for each layer (or -1 for the topmost layer). This specifies a tree of animation layers.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipnames\">setagentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcliptimes\">setagentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipweights\">setagentclipweights</a></div></body>",
    "setagentcliptimes": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcliptimes\">setagentcliptimes</a></h1><p class=\"summary\">Sets the current times for an agent primitive\u2019s animation clips.</p><div class=\"usage\"> <code>void setagentcliptimes(int geohandle, int prim, float cliptimes[])</code></div><div class=\"argument\"><code>geohandle</code></div><p>Handle to the geometry to write to. <code>geoself()</code> can be used to get a handle to the current geometry.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>cliptimes</code></div><p>A list of clip times (in seconds).</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">agentclipcatalog</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplength\">agentcliplength</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipnames\">agentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplelocal\">agentclipsamplelocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsampleworld\">agentclipsampleworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptimes\">agentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipweights\">agentclipweights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipnames\">setagentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipweights\">setagentclipweights</a></div></body>",
    "setagentclipweights": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipweights\">setagentclipweights</a></h1><p class=\"summary\">Sets the blend weights for an agent primitive\u2019s animation clips.</p><div class=\"usage\"> <code>void setagentclipweights(int geohandle, int prim, float clipweights[])</code></div><div class=\"argument\"><code>geohandle</code></div><p>Handle to the geometry to write to. <code>geoself()</code> can be used to get a handle to the current geometry.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>clipweights</code></div><p>A list of weights.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipcatalog\">agentclipcatalog</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliplength\">agentcliplength</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipnames\">agentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsamplelocal\">agentclipsamplelocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipsampleworld\">agentclipsampleworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcliptimes\">agentcliptimes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentclipweights\">agentclipweights</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentclipnames\">setagentclipnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcliptimes\">setagentcliptimes</a></div></body>",
    "setagentcollisionlayer": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcollisionlayer\">setagentcollisionlayer</a></h1><p class=\"summary\">Sets the collision layer of an agent primitive.</p><h2>Warning</h2><p>This function has been deprecated. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcollisionlayers\">setagentcollisionlayers</a> instead.</p><div class=\"usage\"> <code>void setagentcollisionlayer(int geohandle, int prim, string layername)</code></div><div class=\"argument\"><code>geohandle</code></div><p>Handle to the geometry to write to. <code>geoself()</code> can be used to get a handle to the current geometry.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>layername</code></div><p>The name of one of the agent\u2019s layers.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcollisionlayer\">agentcollisionlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcurrentlayer\">agentcurrentlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayerbindings\">agentlayerbindings</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayers\">agentlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayershapes\">agentlayershapes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcurrentlayer\">setagentcurrentlayer</a></div></body>",
    "setagentcollisionlayers": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcollisionlayers\">setagentcollisionlayers</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Sets the collision layers of an agent primitive.</p><div class=\"usage\"> <code>int setagentcollisionlayers(int geohandle, int prim, string layernames[])</code></div><div class=\"usage\"> <code>int setagentcollisionlayers(int geohandle, int prim, int layer_ids[])</code></div><div class=\"argument\"><code>geohandle</code></div><p>Handle to the geometry to write to. <code>geoself()</code> can be used to get a handle to the current geometry.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>layernames</code></div><p>A list of agent layer names.</p><div class=\"argument\"><code>layer_ids</code></div><p>A list of agent layer indices, as returned by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindlayer\">agentfindlayer</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcollisionlayers\">agentcollisionlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcurrentlayers\">agentcurrentlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayerbindings\">agentlayerbindings</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayers\">agentlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayershapes\">agentlayershapes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcurrentlayers\">setagentcurrentlayers</a></div></body>",
    "setagentcurrentlayer": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcurrentlayer\">setagentcurrentlayer</a></h1><p class=\"summary\">Sets the current layer of an agent primitive.</p><h2>Warning</h2><p>This function has been deprecated. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcurrentlayers\">setagentcurrentlayers</a> instead.</p><div class=\"usage\"> <code>void setagentcurrentlayer(int geohandle, int prim, string layername)</code></div><div class=\"argument\"><code>geohandle</code></div><p>Handle to the geometry to write to. <code>geoself()</code> can be used to get a handle to the current geometry.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>layername</code></div><p>The name of one of the agent\u2019s layers.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcollisionlayer\">agentcollisionlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcurrentlayer\">agentcurrentlayer</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayerbindings\">agentlayerbindings</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayers\">agentlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayershapes\">agentlayershapes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcollisionlayer\">setagentcollisionlayer</a></div></body>",
    "setagentcurrentlayers": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcurrentlayers\">setagentcurrentlayers</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Sets the current display layers of an agent primitive.</p><div class=\"usage\"> <code>int setagentcurrentlayers(int geohandle, int prim, string layernames[])</code></div><div class=\"usage\"> <code>int setagentcurrentlayers(int geohandle, int prim, int layer_ids[])</code></div><div class=\"argument\"><code>geohandle</code></div><p>Handle to the geometry to write to. <code>geoself()</code> can be used to get a handle to the current geometry.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>layernames</code></div><p>A list of agent layer names.</p><div class=\"argument\"><code>layer_ids</code></div><p>A list of agent layer indices, as returned by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentfindlayer\">agentfindlayer</a>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcollisionlayers\">agentcollisionlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentcurrentlayers\">agentcurrentlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayerbindings\">agentlayerbindings</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayers\">agentlayers</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlayershapes\">agentlayershapes</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentcollisionlayers\">setagentcollisionlayers</a></div></body>",
    "setagentlocaltransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransform\">setagentlocaltransform</a></h1><p class=\"summary\">Overrides the local space transform of an agent primitive\u2019s bone.</p><div class=\"usage\"> <code>int setagentlocaltransform(int geohandle, int prim, matrix transform, int index)</code></div><div class=\"argument\"><code>geohandle</code></div><p>Handle to the geometry to write to. <code>geoself()</code> can be used to get a handle to the current geometry.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>transform</code></div><p>The new transform (in local space) of the bone.</p><div class=\"argument\"><code>index</code></div><p>Index of a transform in the agent\u2019s rig.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransforms\">agentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtolocal\">agenttransformtolocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtoworld\">agenttransformtoworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransforms\">setagentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransform\">setagentworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransforms\">setagentworldtransforms</a></div></body>",
    "setagentlocaltransforms": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransforms\">setagentlocaltransforms</a></h1><p class=\"summary\">Overrides the local space transforms of an agent primitive.</p><div class=\"usage\"> <code>void setagentlocaltransforms(int geohandle, int prim, matrix transforms[])</code></div><p>When modifying a single transform, using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransform\">setagentlocaltransform</a> instead can be significantly faster.</p><div class=\"argument\"><code>geohandle</code></div><p>Handle to the geometry to write to. <code>geoself()</code> can be used to get a handle to the current geometry.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>transforms</code></div><p>The new transform (in local space) of each bone in the agent\u2019s rig.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransforms\">agentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtolocal\">agenttransformtolocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtoworld\">agenttransformtoworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransform\">setagentlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransform\">setagentworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransforms\">setagentworldtransforms</a></div></body>",
    "setagentworldtransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransform\">setagentworldtransform</a></h1><p class=\"summary\">Overrides the world space transform of an agent primitive\u2019s bone.</p><div class=\"usage\"> <code>int setagentworldtransform(int geohandle, int prim, matrix transform, int index)</code></div><div class=\"argument\"><code>geohandle</code></div><p>Handle to the geometry to write to. <code>geoself()</code> can be used to get a handle to the current geometry.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>transform</code></div><p>The new transform (in world space) of the bone.</p><div class=\"argument\"><code>index</code></div><p>Index of a transform in the agent\u2019s rig.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransforms\">agentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtolocal\">agenttransformtolocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtoworld\">agenttransformtoworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransform\">setagentlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransforms\">setagentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransforms\">setagentworldtransforms</a></div></body>",
    "setagentworldtransforms": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransforms\">setagentworldtransforms</a></h1><p class=\"summary\">Overrides the world space transforms of an agent primitive.</p><div class=\"usage\"> <code>void setagentworldtransforms(int geohandle, int prim, matrix transforms[])</code></div><p>When modifying a single transform, using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransform\">setagentworldtransform</a> instead can be significantly faster.</p><div class=\"argument\"><code>geohandle</code></div><p>Handle to the geometry to write to. <code>geoself()</code> can be used to get a handle to the current geometry.</p><div class=\"argument\"><code>prim</code></div><p>The primitive number.</p><div class=\"argument\"><code>transforms</code></div><p>The new transform (in world space) of each bone in the agent\u2019s rig.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentlocaltransforms\">agentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtolocal\">agenttransformtolocal</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agenttransformtoworld\">agenttransformtoworld</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransform\">setagentlocaltransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentlocaltransforms\">setagentlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransform\">setagentworldtransform</a></div></body>",
    "setattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setattrib\">setattrib</a></h1><p class=\"summary\">Writes an attribute value to geometry.</p><p>If you know the attribute class ahead of time, using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setdetailattrib\">setdetailattrib</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setprimattrib\">setprimattrib</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointattrib\">setpointattrib</a>, or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setvertexattrib\">setvertexattrib</a> may be faster.</p><div class=\"usage\"> <code>int setattrib(int geohandle; string attribclass; string attribute_name; int element_num, int vertex_num, &lt;type&gt; value, string mode=\"set\")</code></div><div class=\"usage\"> <code>int setattrib(int geohandle; string attribclass; string attribute_name; int element_num, int vertex_num, &lt;type&gt; value[], string mode=\"set\")</code></div><div class=\"argument\"><code>attribute_name</code></div><p>The name of the attribute to change.</p><div class=\"argument\"><code>element_num</code></div><p>The point or primitive number on which to change the attribute.</p><p>For detail attributes, set this to <code>0</code> (the argument is ignored for detail attributes).</p><p>For vertex attributes, set this to the primitive number of the primitive containing the vertex.</p><div class=\"argument\"><code>vertex_num</code></div><p>For vertex attributes, this is the number of the vertex on the primitive specified in <code>element_num</code>.</p><p>To use a linear vertex index, set <code>element_num</code> to <code>-1</code> and use the linear vertex index here.</p><p>For other detail, primitive, or point attributes, set this to <code>0</code> (the argument is ignored in these cases).</p><div class=\"argument\"><code>value</code></div><p>The value to set. If the type of this argument is not compatible with the attribute type, the set will fail and the function will return <code>-1</code>.</p><p>Note that within a VEX program only one type may be written to a single attribute.  Ie, you cannot mix writes of float an integer.  This can be surprising as a literal like <code>1</code> will be an integer write so be ignored if floats were previously written.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setattrib\">setattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointattrib\">setpointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setvertexattrib\">setvertexattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setprimattrib\">setprimattrib</a></div></body>",
    "setattribtypeinfo": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setattribtypeinfo\">setattribtypeinfo</a></h1><p class=\"summary\">Sets the meaning of an attribute in geometry.</p><div class=\"usage\"> <code>int setattribtypeinfo(int geohandle, string attribclass, string name, string typeinfo)</code></div><div class=\"argument\"><code>name</code></div><p>The name of the attribute for which to change the transformation info.</p><div class=\"argument\"><code>typeinfo</code></div><p>The meaning of the attribute, which is used by transform nodes to determine how to modify the attribute. It is one of:</p></body>",
    "setcomp": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setcomp\">setcomp</a></h1><p class=\"summary\">Sets a single component of a vector or matrix type, or an item in an array.</p><div class=\"usage\"> <code>void|float setcomp(&lt;vector&gt; &amp;target, float value, int index)</code></div><p>Modifies the <code>target</code> vector in-place by changing the component at <code>index</code> to <code>value</code>.</p><p>Returns <code>value</code> if called with a <code>float</code> return type.</p><div class=\"usage\"> <code>void|float setcomp(&lt;matrix&gt; &amp;target, float value, int row, int column)</code></div><p>Modifies the <code>target</code> matrix in-place by changing the component specified by <code>row</code> and <code>column</code> to <code>value</code>.</p><p>Returns <code>value</code> if called with a <code>float</code> return type.</p><div class=\"usage\"> <code>&lt;type&gt; setcomp(&lt;type&gt; &amp;array[]; &lt;type&gt; value, int index)</code></div><p>Sets the item at <code>index</code> in <code>array</code> to <code>value</code>, and returns <code>value</code>.</p><p>This is the same as <code>array[index] = value</code>.</p><div class=\"usage\"> <code>float setcomp(&lt;vector&gt; &amp;array[]; float value, int i, int j)</code></div><p>Modifies the <code>array[i]</code> vector in-place by changing the component at <code>j</code> to <code>value</code>, and returns <code>value</code>.</p><p>This is the same as <code>setcomp(array[i], value, j)</code>.</p><div class=\"usage\"> <code>float setcomp(&lt;matrix&gt; &amp;array[]; float value, int i, int j, int k)</code></div><p>Modifies the <code>array[i]</code> matrix in-place by changing the component specified by <code>j</code> and <code>k</code> to <code>value</code>, and returns <code>value</code>.</p><p>This is the same as <code>setcomp(array[i], value, j, k)</code>.</p><div class=\"usage\"> <code>&lt;type&gt; setcomp(dict &amp;d; &lt;type&gt; value; string index)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] setcomp(dict &amp;d; &lt;type&gt; value[]; string index)</code></div><p>Sets the item at <code>index</code> in <code>d</code> to <code>value</code>, and returns <code>value</code>.</p><p>This is the same as <code>d[index] = value</code>.</p><p>Note that because the type to set isn\u2019t determined by the left\n    hand side, you may have to fully specify the type of value to\n    avoid ambiguity.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getcomp\">getcomp</a></div></body>",
    "setcurrentlight": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setcurrentlight\">setcurrentlight</a></h1><span class=\"padder\"><span class=\"pillow\">displace</span></span><span class=\"padder\"><span class=\"pillow\">fog</span></span><span class=\"padder\"><span class=\"pillow\">surface</span></span><p class=\"summary\">Sets the current light</p><div class=\"usage\"> <code>int setcurrentlight(int lightid)</code></div><p>Sets the current light, and returns true when the light exists and was successfully set. The lightid should be in the set of the values returned by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlights\">getlights</a>. The current light is used by the following shading functions:</p><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/renderstate\">renderstate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlightname\">getlightname</a></div></body>",
    "setdetailattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setdetailattrib\">setdetailattrib</a></h1><p class=\"summary\">Sets a detail attribute in a geometry.</p><p>If you don\u2019t know the attribute class ahead of time, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setattrib\">setattrib</a>.</p><div class=\"usage\"> <code>int setdetailattrib(int geohandle, string name, &lt;type&gt; value, string mode=\"set\")</code></div><div class=\"usage\"> <code>int setdetailattrib(int geohandle, string name, &lt;type&gt; value[], string mode=\"set\")</code></div><div class=\"argument\"><code>name</code></div><p>The attribute to set on the detail.</p><div class=\"argument\"><code>value</code></div><p>The value to set the attribute to.</p><p>Note that within a VEX program only one type may be written to a single attribute.  Ie, you cannot mix writes of float an integer.  This can be surprising as a literal like <code>1</code> will be an integer write so be ignored if floats were previously written.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setattrib\">setattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setdetailintrinsic\">setdetailintrinsic</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointattrib\">setpointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setvertexattrib\">setvertexattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setprimattrib\">setprimattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/detail\">detail</a></div></body>",
    "setdetailintrinsic": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setdetailintrinsic\">setdetailintrinsic</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Sets the value of a writeable detail intrinsic attribute.</p><div class=\"usage\"> <code>int setdetailintrinsic(int geohandle, string name, &lt;type&gt; value, string mode=\"set\")</code></div><div class=\"usage\"> <code>int setdetailintrinsic(int geohandle, string name, &lt;type&gt; value[], string mode=\"set\")</code></div><p>Despite the name, some intrinsic attributes on details are writeable.</p><div class=\"argument\"><code>name</code></div><p>The name of the intrinsic to set.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setattrib\">setattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setdetailattrib\">setdetailattrib</a></div></body>",
    "setedgegroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setedgegroup\">setedgegroup</a></h1><p class=\"summary\">Sets edge group membership in a geometry.</p><div class=\"usage\"> <code>int setedgegroup(int geohandle, string name, int pt0, int pt1, int value)</code></div><p>Changes an edge group membership on the given geometry. If the group does not exist, it will be created.</p><p><code>geohandle</code> is a handle to the geometry to write to.  <code>geoself()</code> can be used to get a handle to the current geometry.</p><p><code>name</code> is the name of the group to modify.</p><p><code>pt0</code>, <code>pt1</code> are the point pair the edge to change group membership for.</p><p>If the <code>value</code> is anything other than 0, the point will be in the group.</p><p>Note that only valid edges can be created this way, if a pair of points\nthat do not specify an edge are given, no edge will be added to the\ngroup.</p></body>",
    "setpackedtransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpackedtransform\">setpackedtransform</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Sets the transform of a packed primitive.</p><div class=\"usage\"> <code>void setpackedtransform(int input, int primnum, matrix transform)</code></div><p>Sets the transform of a packed primitive. This modifies the <code>P</code> attribute of\nthe primitive\u2019s point as well as its intrinsic <code>transform</code>.</p><h2>Warning</h2><p>This function replaces <em>only</em> the <code>P</code> (position) attribute and the <code>transform</code> intrinsic attribute. It ignores various details that the <code>packedfulltransform</code> intrinsic attribute includes:</p><div class=\"related\">The packed primitive\u2019s <code>pivot</code> intrinsic attribute.</div><div class=\"related\">Instancing attributes such as <code>orient</code> (when the <code>pointinstancetransform</code> intrinsic attribute is on, as with crowd agents).</div><div class=\"related\">The <code>packedlocaltransform</code> intrinsic attribute (Alembic primitives).</div><p>So this function will not apply the expected transform in several different cases.</p><p>The <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getpackedtransform\">getpackedtransform</a> function has the same issues since it returns a transform <em>only</em> based on <code>P</code> and <code>transform</code>.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// matrix to transform by</code><code class=\"codeline\">matrix tf = ident();</code><code class=\"codeline\">rotate(tf, radians(45), {0,1,0});</code><code class=\"codeline\">translate(tf, {0,1,0});</code><code class=\"codeline\"></code><code class=\"codeline\">matrix transform = getpackedtransform(0, @primnum);</code><code class=\"codeline\">setpackedtransform(0, @primnum, transform * tf);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getpackedtransform\">getpackedtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/packedtransform\">packedtransform</a></div></body>",
    "setpointattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointattrib\">setpointattrib</a></h1><p class=\"summary\">Sets a point attribute in a geometry.</p><p>If you don\u2019t know the attribute class ahead of time, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setattrib\">setattrib</a>.</p><div class=\"usage\"> <code>int setpointattrib(int geohandle, string name, int point_num, &lt;type&gt; value, string mode=\"set\")</code></div><div class=\"usage\"> <code>int setpointattrib(int geohandle, string name, int point_num, &lt;type&gt; value[], string mode=\"set\")</code></div><div class=\"argument\"><code>name</code></div><p>The attribute to set on the given point.</p><div class=\"argument\"><code>point_num</code></div><p>The number of the point to set the attribute on.</p><div class=\"argument\"><code>value</code></div><p>The value to set the attribute to.</p><p>Note that within a VEX program only one type may be written to a single attribute.  Ie, you cannot mix writes of float an integer.  This can be surprising as a literal like <code>1</code> will be an integer write so be ignored if floats were previously written.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setattrib\">setattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setvertexattrib\">setvertexattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setprimattrib\">setprimattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setdetailattrib\">setdetailattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/point\">point</a></div></body>",
    "setpointgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointgroup\">setpointgroup</a></h1><p class=\"summary\">Adds or removes a point to/from a group in a geometry.</p><div class=\"usage\"> <code>int setpointgroup(int geohandle, string name, int point_num, int value, string mode=\"set\")</code></div><div class=\"argument\"><code>name</code></div><p>The name of the group to modify.</p><div class=\"argument\"><code>point_num</code></div><p>The point number to add or remove from the group.</p><div class=\"argument\"><code>value</code></div><p><code>1</code> to put the point in the group, <code>0</code> to remove the point from the group.\n    This is ignored if <code>mode</code> is <code>\"toggle\"</code>.</p><div class=\"argument\"><code>mode</code></div><p>Use <code>\"set\"</code> to set the point\u2019s membership according to the <code>value</code>.\n    Use <code>\"toggle\"</code> to toggle the point\u2019s membership, regardless of the <code>value</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/groups\">/vex/groups</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setprimgroup\">setprimgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setvertexgroup\">setvertexgroup</a></div></body>",
    "setpointlocaltransforms": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointlocaltransforms\">setpointlocaltransforms</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Sets an array of point local transforms at the given point indices.</p><div class=\"usage\"> <code>int setpointlocaltransforms(int geohandle, int pnts[], matrix transforms[])</code></div><p>Sets an array of local transforms associated with the point indices. This function set the <code>4@localtransform</code> attribute.</p><div class=\"argument\"><code>pnts</code></div><p>The array of point indices to set.</p><div class=\"argument\"><code>transforms</code></div><p>The array of transforms to set.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransforms\">pointtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointlocaltransforms\">pointlocaltransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointtransforms\">setpointtransforms</a></div></body>",
    "setpointtransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointtransform\">setpointtransform</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Sets the world space transform of a given point</p><div class=\"usage\"> <code>int setpointtransform(int geohandle, int pt, matrix transform)</code></div><div class=\"usage\"> <code>int setpointtransform(int geohandle, int pt, matrix transform, int constrain)</code></div><p>Sets the <code>v@P</code> and the <code>3@transform</code> attributes on the given point from the given 4\u00d74 matrix.</p><div class=\"argument\"><code>pt</code></div><p>The point index to modify.</p><div class=\"argument\"><code>transform</code></div><p>The 4\u00d74 transform.</p><div class=\"argument\"><code>constrain</code></div><p>When True, update the children point transforms when modifying a point world \n    transform. When False, the children points stay in place like when using \n    Child Compensation on a transform handle. Defaults to True;</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransforms\">pointtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointlocaltransforms\">pointlocaltransforms</a></div></body>",
    "setpointtransforms": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointtransforms\">setpointtransforms</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Sets an array of point transforms at the given point indices.</p><div class=\"usage\"> <code>int setpointtransforms(int geohandle, int pnts[], matrix transforms[])</code></div><div class=\"usage\"> <code>int setpointtransforms(int geohandle, int pnts[], matrix transforms[], int constrain)</code></div><p>Sets an array of transforms associated with the point indices. This function set the <code>v@P</code> and the <code>3@transform</code> attributes.</p><div class=\"argument\"><code>pnts</code></div><p>The array of point indices to set.</p><div class=\"argument\"><code>transforms</code></div><p>The array of transforms to set.</p><div class=\"argument\"><code>constrain</code></div><p>When True, update the children point transforms when modifying a point world \n    transform. When False, the children points stay in place like when using \n    Child Compensation on a transform handle. Defaults to True;</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointtransforms\">pointtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointlocaltransforms\">pointlocaltransforms</a></div></body>",
    "setprimattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setprimattrib\">setprimattrib</a></h1><p class=\"summary\">Sets a primitive attribute in a geometry.</p><p>If you don\u2019t know the attribute class ahead of time, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setattrib\">setattrib</a>.</p><div class=\"usage\"> <code>int setprimattrib(int geohandle, string name, int prim_num, &lt;type&gt; value, string mode=\"set\")</code></div><div class=\"usage\"> <code>int setprimattrib(int geohandle, string name, int prim_num, &lt;type&gt; value[], string mode=\"set\")</code></div><div class=\"argument\"><code>name</code></div><p>The attribute to set on the given primitive.</p><div class=\"argument\"><code>prim_num</code></div><p>The number of the primitive to set the attribute on.</p><div class=\"argument\"><code>value</code></div><p>The value to set the attribute to.</p><p>Note that within a VEX program only one type may be written to a single attribute.  Ie, you cannot mix writes of float an integer.  This can be surprising as a literal like <code>1</code> will be an integer write so be ignored if floats were previously written.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setattrib\">setattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointattrib\">setpointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setvertexattrib\">setvertexattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setdetailattrib\">setdetailattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prim\">prim</a></div></body>",
    "setprimgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setprimgroup\">setprimgroup</a></h1><p class=\"summary\">Adds or removes a primitive to/from a group in a geometry.</p><div class=\"usage\"> <code>int setprimgroup(int geohandle, string name, int prim_num, int value, string mode=\"set\")</code></div><div class=\"argument\"><code>name</code></div><p>The name of the group to modify.</p><div class=\"argument\"><code>prim_num</code></div><p>The primitive number to add or remove from the group.</p><div class=\"argument\"><code>value</code></div><p><code>1</code> to put the primitive in the group, <code>0</code> to remove the primitive from the group.\n    This is ignored if <code>mode</code> is <code>\"toggle\"</code>.</p><div class=\"argument\"><code>mode</code></div><p>Use <code>\"set\"</code> to set the primitive\u2019s membership according to the <code>value</code>.\n    Use <code>\"toggle\"</code> to toggle the primitive\u2019s membership, regardless of the <code>value</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/groups\">/vex/groups</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointgroup\">setpointgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setvertexgroup\">setvertexgroup</a></div></body>",
    "setprimintrinsic": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setprimintrinsic\">setprimintrinsic</a></h1><p class=\"summary\">Sets the value of a writeable primitive intrinsic attribute.</p><div class=\"usage\"> <code>int setprimintrinsic(int geohandle, string name, int prim_num, &lt;type&gt; value, string mode=\"set\")</code></div><div class=\"usage\"> <code>int setprimintrinsic(int geohandle, string name, int prim_num, &lt;type&gt; value[], string mode=\"set\")</code></div><p>Despite the name, some intrinsic attributes on primitives are writeable.</p><div class=\"argument\"><code>name</code></div><p>The name of the intrinsic to set.</p><div class=\"argument\"><code>prim_num</code></div><p>The number of the primitive to change the value on.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setattrib\">setattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setprimattrib\">setprimattrib</a></div></body>",
    "setprimvertex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setprimvertex\">setprimvertex</a></h1><p class=\"summary\">Rewires a vertex in the geometry to a different point.</p><div class=\"usage\"> <code>int setprimvertex(int geohandle, int prim, int vtxofprim, int pt)</code></div><p>Rewires a specified vertex to a point number.</p><p>If the point number is -1, no rewiring is done.</p><p>If prim is -1, <code>vtxofprim</code> is treated as a linear index, and vice versa.  Otherwise, the pair (<code>prim</code>, <code>vtxofprim</code>) is used to identify a vertex in a primitive\u2019s vertex list.</p><p>Since this sets a vertex\u2019s point, not a primitive\u2019s vertex, it\u2019s recommended to use the equivalent function <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setvertexpoint\">setvertexpoint</a> for clarity, instead.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setvertexpoint\">setvertexpoint</a></div></body>",
    "setsamplestore": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setsamplestore\">setsamplestore</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Stores sample data in a channel, referenced by a point.</p><div class=\"usage\"> <code>int setsamplestore(string channel, vector P, int value)</code></div><div class=\"usage\"> <code>int setsamplestore(string channel, vector P, float value)</code></div><div class=\"usage\"> <code>int setsamplestore(string channel, vector P, vector value)</code></div><div class=\"usage\"> <code>int setsamplestore(string channel, vector P, vector4 value)</code></div><p>Stores a value in a named channel at a specified point.\nReturns a non-zero value on success, or returns 0 if the data could not be set.</p><p>The sample store can be thought of as an in-memory point cloud, storing\nshading data at points. This allows data to be accessed across shader\nboundaries, unlike the internal export/import system. For example,\na lens shader could store data to be passed to the surface shader,\nan operation that is not supported using export variables due to the\nlayout of the shading pipeline.</p><p>Please note that the stored samples can only be accessed within the same render\ntile.</p><h2>Example</h2><div class=\"codeblock\"><code class=\"codeline\">cvex displacedlens(</code><code class=\"codeline\">    // Inputs</code><code class=\"codeline\">    float x = 0;</code><code class=\"codeline\">    float y = 0;</code><code class=\"codeline\">    float Time = 0;</code><code class=\"codeline\">    float dofx = 0;</code><code class=\"codeline\">    float dofy = 0;</code><code class=\"codeline\">    float aspect = 1;</code><code class=\"codeline\"></code><code class=\"codeline\">    float displaceScale = 1.0;</code><code class=\"codeline\">    float displaceGain = 0.1;</code><code class=\"codeline\"></code><code class=\"codeline\">    // Outputs</code><code class=\"codeline\">    export vector P = 0;</code><code class=\"codeline\">    export vector I = 0;</code><code class=\"codeline\">)</code><code class=\"codeline\">{</code><code class=\"codeline\">    P = {x, y, 0};</code><code class=\"codeline\">    I = {1, 0, 0};</code><code class=\"codeline\"></code><code class=\"codeline\">    vector displace = noise(P * displaceScale) * displaceGain;</code><code class=\"codeline\">    I += displace;</code><code class=\"codeline\"></code><code class=\"codeline\">    // Store the displacement at the eye point, 'P'</code><code class=\"codeline\">    int status = setsamplestore(\"displacedlens_d\", P, displace);</code><code class=\"codeline\">}</code><code class=\"codeline\"></code><code class=\"codeline\">surface mysurface()</code><code class=\"codeline\">{</code><code class=\"codeline\">    // Get the displacement at the eye point, 'Eye'</code><code class=\"codeline\">    vector displace = 0;</code><code class=\"codeline\">    int status = getsamplestore(\"displacedlens_d\", Eye, displace);</code><code class=\"codeline\"></code><code class=\"codeline\">    //...</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getsamplestore\">getsamplestore</a></div></body>",
    "setvertexattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setvertexattrib\">setvertexattrib</a></h1><p class=\"summary\">Sets a vertex attribute in a geometry.</p><div class=\"usage\"> <code>int setvertexattrib(int geohandle, string name, int prim_num, int vertex_num, &lt;type&gt; value, string mode=\"set\")</code></div><div class=\"usage\"> <code>int setvertexattrib(int geohandle, string name, int prim_num, int vertex_num, &lt;type&gt; value[], string mode=\"set\")</code></div><p><strong>To use a linear vertex index</strong>, set the <code>prim_num</code> to the <strong>linear vertex number</strong> and set <code>vertex_num</code> to <code>-1</code>. Note that <strong>this is different</strong> from how most other vertex functions work.</p><div class=\"argument\"><code>name</code></div><p>The name of the group to modify.</p><div class=\"argument\"><code>prim_num</code></div><p>The number of the primitive containing the vertex you want to add/remove.</p><div class=\"argument\"><code>vertex_num</code></div><p>The vertex offset on the primitive of the vertex you want to add/remove.</p><div class=\"argument\"><code>value</code></div><p>The value to set the attribute to.</p><p>Note that within a VEX program only one type may be written to a single attribute.  Ie, you cannot mix writes of float an integer.  This can be surprising as a literal like <code>1</code> will be an integer write so be ignored if floats were previously written.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setattrib\">setattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointattrib\">setpointattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setprimattrib\">setprimattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setdetailattrib\">setdetailattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertex\">vertex</a></div></body>",
    "setvertexgroup": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setvertexgroup\">setvertexgroup</a></h1><p class=\"summary\">Adds or removes a vertex to/from a group in a geometry.</p><div class=\"usage\"> <code>int setvertexgroup(int geohandle, string name, int prim_num, int vertex_num, int value, string mode=\"set\")</code></div><p><strong>To use a linear vertex index</strong>, set the <code>prim_num</code> to the <strong>linear vertex number</strong> and set <code>vertex_num</code> to <code>-1</code>. Note that <strong>this is different</strong> from how most other vertex functions work.</p><div class=\"argument\"><code>name</code></div><p>The name of the group to modify.</p><div class=\"argument\"><code>prim_num</code></div><p>The number of the primitive containing the vertex you want to add/remove.</p><div class=\"argument\"><code>vertex_num</code></div><p>The vertex offset on the primitive of the vertex you want to add/remove.</p><div class=\"argument\"><code>value</code></div><p><code>1</code> to put the vertex in the group, <code>0</code> to remove the vertex from the group.\n    This is ignored if <code>mode</code> is <code>\"toggle\"</code>.</p><div class=\"argument\"><code>mode</code></div><p>Use <code>\"set\"</code> to set the vertex\u2019s membership according to the <code>value</code>.\n    Use <code>\"toggle\"</code> to toggle the vertex\u2019s membership, regardless of the <code>value</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/groups\">/vex/groups</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setprimgroup\">setprimgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setpointgroup\">setpointgroup</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexindex\">vertexindex</a></div></body>",
    "setvertexpoint": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setvertexpoint\">setvertexpoint</a></h1><p class=\"summary\">Rewires a vertex in the geometry to a different point.</p><div class=\"usage\"> <code>int setvertexpoint(int geohandle, int prim, int vtxofprim, int pt)</code></div><p>Rewires a specified vertex to a point number.</p><p>If the point number is -1, no rewiring is done.</p><p>If prim is -1, <code>vtxofprim</code> is treated as a linear index, and vice versa.  Otherwise, the pair (<code>prim</code>, <code>vtxofprim</code>) is used to identify a vertex in a primitive\u2019s vertex list.</p><p>This function is a new name for the equivalent function <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setprimvertex\">setprimvertex</a>, added for clarity.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexpoint\">vertexpoint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexprim\">vertexprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexprimindex\">vertexprimindex</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexindex\">vertexindex</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexnext\">vertexnext</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexprev\">vertexprev</a></div></body>",
    "shadow": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/shadow\">shadow</a></h1><span class=\"padder\"><span class=\"pillow\">displace</span></span><span class=\"padder\"><span class=\"pillow\">fog</span></span><span class=\"padder\"><span class=\"pillow\">surface</span></span><p class=\"summary\">Calls shadow shaders for the current light source.</p><p>This function can only be called from within an <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a> statement.</p><div class=\"usage\"> <code>void shadow(vector &amp;Cl)</code></div><div class=\"usage\"> <code>vector shadow(vector Cl)</code></div><p>Uses the <code>P</code> and <code>L</code> global variables.</p><div class=\"usage\"> <code>void shadow(vector &amp;Cl, vector P, vector L)</code></div><div class=\"usage\"> <code>vector shadow(vector Cl, vector P, vector L)</code></div></body>",
    "shadowmap": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/shadowmap\">shadowmap</a></h1><p class=\"summary\">The shadowmap function will treat the shadow map as if the image were\nrendered from a light source.</p><div class=\"usage\"> <code>float|vector shadowmap(string filename, vector Pndc, float spread, float bias, float quality, ...)</code></div><div class=\"usage\"> <code>float|vector shadowmap(string filename, vector Pndc, float spread, float bias, float quality, ...)</code></div><div class=\"usage\"> <code>vector shadowmap(string filename, vector Pndc1, vector Pndc2, vector Pndc3, vector Pndc4, float spread, float bias, float quality, ...)</code></div><p>Allows you to specify your own sampling rectangle. If you don\u2019t want any filtering of the shadow map or you are unable to compute your own derivatives, you can just pass in the same vector repeated 4 times to perform no filtering.</p><p>The <code>shadowmap</code> function will treat the shadow map as if the image were\nrendered from a light source. You use this to access both depth maps and\ndeep shadow maps. In both cases it returns a vector where each color\ncomponent has the visibility of the light source to the point for that\ncolor.</p><div class=\"argument\"><code>filename</code></div><p>A path to the shadow or depth map.</p><div class=\"argument\"><code>Pndc</code></div><p>The position of the point being shaded in the NDC space of the light\u2019s projection.</p><div class=\"argument\"><code>spread</code></div><p>A softness control on the shadow.</p><div class=\"argument\"><code>bias</code></div><p>Controls how accurate the depth samples need to be.</p><div class=\"argument\"><code>quality</code></div><p>A general control to increase/decrease sampling, where <code>1</code> is default quality.</p><h2>Returns</h2><p>The fractional amount of illumination which\n    reaches the sample point. For example, if the point is fully in\n    shadow, the return value will be 0, if it is fully illuminated, the\n    return value will be 1.</p><p>The shadowmap() VEX function takes the same variadic arguments as texture(). For additional information, see <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texture\">texture</a>.</p><h2>Deep camera map channels</h2><p>If the shadow map is a <a href=\"https://www.sidefx.com/docs/houdini/render/dcm\">Deep camera map</a>,\n<code>shadowmap</code> takes an optional extra argument <code>\"channel\"</code>, followed by the\nstring name of the channel in the map evaluate.</p><div class=\"codeblock\"><code class=\"codeline\">shadowmap(mapname, pz, spread, bias, quality, \"channel\", channel);</code></div><p>This uses the same opacity semantics, so the function will return the\ncomplement of the actual color.  So, to get accurate results, you will\nusually want to evaluate:</p><div class=\"codeblock\"><code class=\"codeline\">{1,1,1} - shadowmap(...);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/depthmap\">depthmap</a></div></body>",
    "shadow_light": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/shadow_light\">shadow_light</a></h1><span class=\"padder\"><span class=\"pillow\">displace</span></span><span class=\"padder\"><span class=\"pillow\">fog</span></span><span class=\"padder\"><span class=\"pillow\">surface</span></span><p class=\"summary\">Executes the shadow shader for a given light and returns the amount of shadowing as a multiplier of the shaded color.</p><div class=\"usage\"> <code>vector shadow_light(int lightid, vector pos, vector dir, float time, ...)</code></div><p>This operation is similar to the shadow() function but it allows execution\nof the shadow shader outside an illuminance loop.  The position and\ndirection toward the light source are provided directly, and the shadow\nshader is executed - returning the shadow multiplier.  To produce the final\nshadowed color, multiply the shaded color by the value returned by\nshadow_light.</p><p>Keyword variadic arguments can be passed to the shadow shader, for import\nin the shadow shader with with simport().</p><div class=\"argument\"><code>lightid</code></div><p>A light identifier, as returned by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getlights\">getlights</a>.</p><div class=\"argument\"><code>pos</code></div><p>The origin of the ray (such as the global variable <code>P</code>).</p><div class=\"argument\"><code>dir</code></div><p>Direction vector from the origin. The length of this vector should be\n    the distance from <em>pos</em> to the light source.</p><div class=\"argument\"><code>time</code></div><p>Time to send the ray at.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/shadow\">shadow</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_light\">sample_light</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/intersect_lights\">intersect_lights</a></div></body>",
    "shimport": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/shimport\">shimport</a></h1><span class=\"padder\"><span class=\"pillow\">fog</span></span><span class=\"padder\"><span class=\"pillow\">surface</span></span><p class=\"summary\">Imports a variable from the shadow shader for the surface.</p><p>This function is only valid inside an <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a> loop.</p><div class=\"usage\"> <code>int shimport(string variable_name, &lt;type&gt; &amp;value)</code></div><div class=\"argument\"><code>variable_name</code></div><p>The variable to import from the shadow shader.</p><div class=\"argument\"><code>value</code></div><p>If the variable is successfully read, the value is copied into this variable.</p><h2>Returns</h2><p><code>1</code> if the variable is defined and exported, <code>0</code> otherwise.</p></body>",
    "shl": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/shl\">shl</a></h1><p class=\"summary\">Bit-shifts an integer left.</p><div class=\"usage\"> <code>int shl(int a, int bits)</code></div><p>Bit-shifts <code>a</code> to the left by <code>bits</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/shr\">shr</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/shrz\">shrz</a></div></body>",
    "shr": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/shr\">shr</a></h1><p class=\"summary\">Bit-shifts an integer right.</p><div class=\"usage\"> <code>int shr(int a, int bits)</code></div><p>Bit-shifts <code>a</code> to the right by <code>bits</code>.</p><p>This is an arithmetic shift, the sign is shifted with it.  Thus, <code>shr(-1, 2)</code>\nwill give -1, not zero.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/shl\">shl</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/shrz\">shrz</a></div></body>",
    "shrz": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/shrz\">shrz</a></h1><p class=\"summary\">Bit-shifts an integer right.</p><div class=\"usage\"> <code>int shrz(int a, int bits)</code></div><p>Bit-shifts <code>a</code> to the right by <code>bits</code>.  This is a zero-extend shift, so\nnew bits are always zero.  Thus, <code>shrz(-1, 2)</code> is zero, not -1.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/shl\">shl</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/shr\">shr</a></div></body>",
    "sign": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sign\">sign</a></h1><p class=\"summary\">Returns -1, 0, or 1 depending on the sign of the argument.</p><div class=\"usage\"> <code>int sign(int n)</code></div><div class=\"usage\"> <code>float sign(float n)</code></div><p>For a scalar value, returns <code>-1</code> for a negative number, <code>0</code> for the number zero,\n    and <code>+1</code> for a positive number.</p><div class=\"usage\"> <code>vector2 sign(vector2 v)</code></div><div class=\"usage\"> <code>vector sign(vector v)</code></div><div class=\"usage\"> <code>vector4 sign(vector4 v)</code></div><p>For vector values the sign of the individual components is returned as a vector.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/abs\">abs</a></div></body>",
    "simport": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/simport\">simport</a></h1><span class=\"padder\"><span class=\"pillow\">fog</span></span><span class=\"padder\"><span class=\"pillow\">light</span></span><span class=\"padder\"><span class=\"pillow\">shadow</span></span><p class=\"summary\">Imports a variable sent by a surface shader in an illuminance loop.</p><div class=\"usage\"> <code>int simport(string name, &lt;type&gt; &amp;value)</code></div><p>Imports a variable from the surface shader.</p><p>Mantra runs the shaders for a surface in a fixed order:</p><p>Once the displacement shader has run, you can use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/dimport\">dimport</a>\nto retrieve exported variables from it. Once the surface shader\nhas run, you can use <code>simport</code> to retrieve exported variables\nfrom it.</p><p>If the shader variable named by the first argument is defined and\nexported, the function returns 1 and puts the value in the second\nargument. Otherwise, it returns 0.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/dimport\">dimport</a></div></body>",
    "sin": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sin\">sin</a></h1><p class=\"summary\">Returns the sine of the argument.</p><div class=\"usage\"> <code>float sin(float n)</code></div><p>Returns the sine of <code>n</code>, where <code>n</code> is in radians.</p><div class=\"usage\"> <code>&lt;vector&gt; sin(&lt;vector&gt; n)</code></div><p>Returns a new vector with <code>sin()</code> applied to each component.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sinh\">sinh</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cos\">cos</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tan\">tan</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/asin\">asin</a></div></body>",
    "sinh": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sinh\">sinh</a></h1><p class=\"summary\">Returns the hyperbolic sine of the argument.</p><div class=\"usage\"> <code>float sinh(float n)</code></div><p>Returns the hyperbolic sine of <code>n</code>.</p><div class=\"usage\"> <code>vector2 sinh(vector2 v)</code></div><div class=\"usage\"> <code>vector sinh(vector v)</code></div><div class=\"usage\"> <code>vector4 sinh(vector4 v)</code></div><p>Returns a new vector with <code>sinh()</code> applied to each component.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sin\">sin</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cosh\">cosh</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tanh\">tanh</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cos\">cos</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tan\">tan</a></div></body>",
    "sleep": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sleep\">sleep</a></h1><p class=\"summary\">Yields processing for a certain number of milliseconds.</p><div class=\"usage\"> <code>void sleep(int milliseconds)</code></div><p>Yields processing for a certain number of milliseconds.</p></body>",
    "slerp": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/slerp\">slerp</a></h1><p class=\"summary\">Quaternion blend between q1 and q2 based on the bias.</p><div class=\"usage\"> <code>vector4 slerp(vector4 q1, vector4 q2, float bias)</code></div><p>Blends between quaternions <code class=\"var\">q1</code> and <code class=\"var\">q2</code> based on the <code class=\"var\">bias</code>.</p><div class=\"usage\"> <code>vector4 slerp(vector4 qs[], float weights[])</code></div><p>Blends between any number of quaternions with the specified corresponding weights.\n    The weights are <strong>not</strong> normalized before blending.\n    <code>slerp(q1,q2,bias)</code> should be approximately equivalent to <code>slerp(array(q1,q2), array(1.0-bias,bias))</code>.</p><div class=\"usage\"> <code>matrix3 slerp(matrix3 m1, matrix3 m2, float bias)</code></div><div class=\"usage\"> <code>matrix slerp(matrix m1, matrix m2, float bias)</code></div><p>Blends between matrix <code class=\"var\">m1</code> and <code class=\"var\">m2</code> based on the <code class=\"var\">bias</code>.</p><div class=\"usage\"> <code>matrix3 slerp(matrix3 ms[], float weights[])</code></div><div class=\"usage\"> <code>matrix slerp(matrix ms[], float weights[])</code></div><p>Blends between any number of matrices with the specified corresponding weights via blending of their components via polar decomposition.\n    The weights are normalized before blending.</p></body>",
    "slice": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/slice\">slice</a></h1><p class=\"summary\">Slices a sub-string or sub-array of a string or array.</p><div class=\"usage\"> <code>string slice(string s; int start; int end)</code></div><div class=\"usage\"> <code>string slice(string s; int start; int end; int step)</code></div><p>Extracts a string from a larger string.</p><div class=\"usage\"> <code>&lt;type&gt;[] slice(&lt;type&gt; s[]; int start; int end)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] slice(&lt;type&gt; s[]; int start; int end; int step)</code></div><p>Extracts a sub-array from a larger array.</p><div class=\"usage\"> <code>string slice(string s; int hasstart; int start; int hasend; int end; int hasstep; int step)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] slice(&lt;type&gt; array[]; int hasstart; int start; int hasend; int end; int hasstep; int step)</code></div><p>A general-purpose signature to support the slicing syntax. If <code>hasstart</code> is <code>0</code>, it ignores <code>start</code> and uses <code>0</code>. If <code>hasend</code> is <code>0</code> it ignores <code>end</code> and uses the length of the array. If <code>hasstep</code> is <code>0</code> it ignores <code>step</code> and uses <code>1</code>.</p><div class=\"related\">This is the function equivalent of using <code>value[start:end:step]</code> slicing syntax.</div><div class=\"related\">If <code>start</code> or <code>end</code> are negative, they count from the end of the string/array.</div><div class=\"related\">The computed range is clamped to the bounds of the original string/array.</div><div class=\"related\">If step is zero, the function returns an empty string/array.</div><div class=\"related\">If step is negative, the items are returned in reverse, and <code>end</code> should be less than <code>start</code>.</div><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int[] nums = {10, 20, 30, 40, 50, 60};</code><code class=\"codeline\">slice(nums, 1, 3) == {20, 30};  // nums[1:3]</code><code class=\"codeline\">slice(nums, 1, -1) == {20, 30, 30, 40, 50};  // nums[1:-1]</code><code class=\"codeline\">slice(nums, 0, len(nums), 2) == {20, 40, 60};  // nums[0:len(nums):2]</code><code class=\"codeline\">slice(nums, 0, 0, 0, 0, 1, 2) == {20, 40, 60};  // nums[::2]</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/len\">len</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/push\">push</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/append\">append</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/resize\">resize</a></div></body>",
    "slideframe": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/slideframe\">slideframe</a></h1><p class=\"summary\">Finds the normal component of frame slid along a curve. </p><div class=\"usage\"> <code>vector slideframe(const vector t0, const vector t1, const vector v0)</code></div><div class=\"usage\"> <code>vector slideframe(const vector x0, const vector t0, const vector v0, const vector x1, const vector t1)</code></div><p>Given an arbitrary vector, <code>v0</code>, and two normalized vectors, <code>t0</code> and <code>t1</code>, this function applies to <code>v0</code> the minimal rotation that would take <code>t0</code> to <code>t1</code>, and returns the result.  This is equivalent to <code>v0*dihedral(t0,t1)</code>, but should be slightly faster.</p><p>The second function signature requires that <code>x1-x0</code> is in the same direction as the average of <code>t0</code> and <code>t1</code>, and is provided for compatibility, though should produce approximately the same results.</p><p>You can use this function to extend a curve normal at the starting point of a curve to the entire curve in a rotation minimizing fashion.</p></body>",
    "smooth": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/smooth\">smooth</a></h1><p class=\"summary\">Computes ease in/out interpolation between values.</p><div class=\"usage\"> <code>float smooth(float value1, float value2, float amount)</code></div><div class=\"usage\"> <code>float smooth(float value1, float value2, float amount, float rolloff)</code></div><p>Computes a number between zero and one. Returns 0 if the amount passed\nin is less than or equal to value1, 1 if the amount is greater than or\nequal to value2.</p><p>If the amount is between value1 and value2, a smooth (easin/easeout)\ninterpolation is computed. If a rolloff is specified, the inflection\npoint of the blend will be shifted.</p><p>If the rolloff is greater than 1, the shift will be to the right, if the\nrolloff is less than 1 (and greater than 0), the shift will be to the\nleft.</p></body>",
    "smoothrotation": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/smoothrotation\">smoothrotation</a></h1><p class=\"summary\">Returns the closest equivalent Euler rotations to a reference rotation.</p><div class=\"usage\"> <code>vector smoothrotation(int order, vector r, vector r_reference)</code></div><p>Returns the Euler rotations that have the closest values to <code class=\"var\">r_reference</code> while still describing the same orientation as <code class=\"var\">r</code>.\nTypically, <code class=\"var\">r_reference</code> will be the rotations from the previous sample or frame.</p><p>The angles are in radians.  Use the <code>radians()</code> function to convert degrees into radians.</p><p>The rotation order is specified by the <code class=\"var\">order</code> parameter. Use the constants defined in <code>$HH/vex/include/math.h</code> (for example, <code>XFORM_XYZ</code>).</p></body>",
    "snoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/snoise\">snoise</a></h1><p class=\"summary\">These functions are similar to wnoise.</p><div class=\"usage\"> <code>float snoise(vector pos)</code></div><div class=\"usage\"> <code>vector snoise(vector pos)</code></div><div class=\"usage\"> <code>float snoise(vector pos, int turbulence, float rough, float atten)</code></div><div class=\"usage\"> <code>vector snoise(vector pos, int turbulence, float rough, float atten)</code></div><div class=\"usage\"> <code>float snoise(vector pos, int periodX, int periodY, int periodZ)</code></div><div class=\"usage\"> <code>vector snoise(vector pos, int periodX, int periodY, int periodZ)</code></div><div class=\"usage\"> <code>float snoise(vector pos, int periodX, int periodY, int periodZ, int turbulence, float rough, float atten)</code></div><div class=\"usage\"> <code>vector snoise(vector pos, int periodX, int periodY, int periodZ, int turbulence, float rough, float atten)</code></div><p>These functions are similar to <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wnoise\">wnoise</a>. The noise returned\nis based on the weights of all of the closest points, with each point\u2019s\ncontribution based on a meta-ball like rolloff curve. That is, if the\nsample point is close to the sphere, its contribution will be greater.</p><p>The bounds on the noise are roughly (-1.7, 1.7). Only 3D noise is\nsupported. However, this noise has the ability to compute turbulence\nwith roughness and attenuation on the noise.</p><h2>Related</h2></body>",
    "solid_angle": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solid_angle\">solid_angle</a></h1><p class=\"summary\">Computes the solid angle (in steradians) a BSDF function subtends.</p><div class=\"usage\"> <code>float solid_angle(bsdf b, int mask)</code></div><div class=\"argument\"><code>b</code></div><p>BSDF to sample.</p><div class=\"argument\"><code>mask</code></div><p>A bitmask indicating which types of bounces to evaluate.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Split BSDF into component lobes</code><code class=\"codeline\">bsdf lobes[] = split_bsdf(hitF);</code><code class=\"codeline\"></code><code class=\"codeline\">// Get solid angle of lobes</code><code class=\"codeline\">float angles[];</code><code class=\"codeline\">resize(angles, len(lobes));</code><code class=\"codeline\">for (int i = 0; i &lt; len(lobes); i++)</code><code class=\"codeline\">{</code><code class=\"codeline\">    angles[i] = solid_angle(lobes[i], PBR_ALL_MASK);</code><code class=\"codeline\">}</code><code class=\"codeline\"></code><code class=\"codeline\">// Compute PDF from angles</code><code class=\"codeline\">float pdf[] = compute_pdf(angles);</code><code class=\"codeline\"></code><code class=\"codeline\">// Compute CDF from PDF</code><code class=\"codeline\">float cdf[] = compute_cdf(pdf);</code><code class=\"codeline\"></code><code class=\"codeline\">// Randomly select a BSDF based on albedo distribution</code><code class=\"codeline\">int id = sample_cdf(cdf, sx);</code><code class=\"codeline\"></code><code class=\"codeline\">// Do something with the selected BSDF</code><code class=\"codeline\">// lobes[id] ...</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/split_bsdf\">split_bsdf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_bsdf\">sample_bsdf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/eval_bsdf\">eval_bsdf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/albedo\">albedo</a></div></body>",
    "solveconstraint": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solveconstraint\">solveconstraint</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Applies an inverse kinematics algorithm to a skeleton.</p><div class=\"usage\"> <code>vector[] solveconstraint(float lengths[], vector targetpos, float tolerance, matrix relmat, vector constraints[])</code></div><p>Returns a array of local bone rotations in degrees.</p><div class=\"argument\"><code>lengths</code></div><p>The lengths of all the bones to solve.</p><div class=\"argument\"><code>targetpos</code></div><p>A target position in worldspace.</p><div class=\"argument\"><code>tolerance</code></div><p>Tolerance.</p><div class=\"argument\"><code>relmat</code></div><p>A relative matrix used to transform the target and twist positions relative to the origin.\n    This is normally the invert matrix of the root of the chain.</p><div class=\"argument\"><code>constraints</code></div><p>This is a vector array used to define the per bone restangles, dampening, minangles, maxangles, min damp, max damp, and rolloff.\n    If the array is empty, same default values present in the bone objects are used.\n    If the array size is equal to the number of input bones, the rest angles are defined.\n    If the array size is equal to 2 times the number of input bones, the rest angles and the dampening are defined.\n    If the array size is equal to 3 times the number of input bones, the rest angles, the dampening, the min/max angles are defined. Min/Max angles share the same values.\n    If the array size is equal to 4 times the number of input bones, the rest angles, the dampening, the min/max angles are defined. Min/Max angles have different values.\n    If the array size is equal to 5 times the number of input bones, the rest angles, the dampening, the min/max angles and damp angles are defined.\n    If the array size is equal to 6 times the number of input bones, the rest angles, the dampening, the min/max angles, min/max damp angles are defined.\n    If the array size is equal to 7 times the number of input bones, the rest angles, the dampening, the min/max angles, min/max damp angles, and rolloff are defined.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solveconstraint\">solveconstraint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvecurve\">solvecurve</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvefbik\">solvefbik</a></div></body>",
    "solvecubic": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvecubic\">solvecubic</a></h1><p class=\"summary\">Solves a cubic function returning the number of real roots.</p><div class=\"usage\"> <code>int solvecubic(float a, float b, float c, float d, float &amp;t1, float &amp;t2, float &amp;t3)</code></div><div class=\"usage\"> <code>int solvecubic(float a, float b, float c, float d, vector2 &amp;t1, vector2 &amp;t2, vector2 &amp;t3)</code></div><p>Solves the given cubic function where <code class=\"var\">a</code> , <code class=\"var\">b</code>, <code class=\"var\">c</code>, and <code class=\"var\">d</code> are the coefficients as so: <code>ax^3 + bx^2 + cx + d = 0</code></p><p>Returns the number of real roots.</p><p>In the real case the returned roots will be in ascending order. In case of only one root that root is filled into <code class=\"var\">t1</code>, <code class=\"var\">t2</code>, and <code class=\"var\">t3</code>.</p><p>In the complex case <code class=\"var\">t1</code>, <code class=\"var\">t2</code>, and <code class=\"var\">t3</code> are the complex roots.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvequadratic\">solvequadratic</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvepoly\">solvepoly</a></div></body>",
    "solvecurve": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvecurve\">solvecurve</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Applies a curve inverse kinematics algorithm to a skeleton.</p><div class=\"usage\"> <code>vector[] solvecurve(float lengths[], int closed, int orienttonormal, vector tangent, vector points[], vector normals[])</code></div><div class=\"usage\"> <code>matrix3[] solvecurve(float lengths[], int closed, int orienttonormal, vector tangent, vector points[], vector normals[])</code></div><div class=\"usage\"> <code>vector[] solvecurve(float &amp;outlength, vector &amp;outpos, float lengths[], int closed, int orienttonormal, int normalmode, vector tangent, vector points[], vector normals[])</code></div><div class=\"usage\"> <code>matrix3[] solvecurve(float &amp;outlength, vector &amp;outpos, float lengths[], int closed, int orienttonormal, int normalmode, vector tangent, vector points[], vector normals[])</code></div><div class=\"usage\"> <code>vector[] solvecurve(float &amp;outlength, vector &amp;outpos, float lengths[], int closed, int orienttonormal, int normalmode, vector tangent, vector points[], vector normals[], float twists[], float initialtwists[], int fmt, int order, float lod)</code></div><div class=\"usage\"> <code>matrix3[] solvecurve(float &amp;outlength, vector &amp;outpos, float lengths[], int closed, int orienttonormal, int normalmode, vector tangent, vector points[], vector normals[], float twists[], float initialtwists[], int fmt, int order, float lod)</code></div><div class=\"usage\"> <code>vector[] solvecurve(string op, float lengths[], int closed, int orienttonormal, vector tangent, int normalcalcmethod, matrix relmat)</code></div><div class=\"usage\"> <code>matrix3[] solvecurve(string op, float lengths[], int closed, int orienttonormal, vector tangent, int normalcalcmethod, matrix relmat)</code></div><div class=\"usage\"> <code>vector[] solvecurve(string op, float lengths[], int closed, int orienttonormal, vector tangent, int normalcalcmethod, matrix relmat, int primnum, float lod)</code></div><div class=\"usage\"> <code>matrix3[] solvecurve(string op, float lengths[], int closed, int orienttonormal, vector tangent, int normalcalcmethod, matrix relmat, int primnum, float lod)</code></div><p>Returns a array of vectors or matrix3 representing local bone rotations. Angles are in degrees.</p><div class=\"argument\"><code>op</code></div><p>The SOP path to a curve to evaluate.</p><div class=\"argument\"><code>outlength</code></div><p>Return the length of the curve where the solution ends. This is different than the sum of all lengths array.</p><div class=\"argument\"><code>outpos</code></div><p>Return the computed position of the last joint.</p><div class=\"argument\"><code>lengths</code></div><p>The lengths of all the bones to solve.</p><div class=\"argument\"><code>closed</code></div><p>Close the curve.</p><div class=\"argument\"><code>orienttonormal</code></div><p>Use the normals from the curve to orient the bones.</p><div class=\"argument\"><code>normalmode</code></div><p>Define how the normals/twists are computed from the control points.</p><p>Use the constants defined in <code>$HH/vex/include/math.h</code>.</p><p>SOLVECURVE_NORMALMODE_DEFAULT, default.\n        SOLVECURVE_NORMALMODE_NONE, no normals are computed&gt;\n        SOLVECURVE_NORMALMODE_QUAT, interpolating with quaternions.\n        SOLVECURVE_NORMALMODE_TWIST_SHORT, interpolating with twist angles in 0..180 range.\n        SOLVECURVE_NORMALMODE_TWIST_FULL, interpolating with twist angles in any range.</p><div class=\"argument\"><code>tangent</code></div><p>A tangent vector to orient the end tip of the curve.</p><div class=\"argument\"><code>points</code></div><p>An array of vectors to use as points to define the curve.</p><div class=\"argument\"><code>normals</code></div><p>An array of vectors to use as normals to define the curve.</p><div class=\"argument\"><code>twists</code></div><p>An optional array of floats to use as twist angles in degree to define the curve.</p><div class=\"argument\"><code>initialtwists</code></div><p>An optional array of floats to use as initial twist angles in degree define the curve.</p><div class=\"argument\"><code>normalcalcmethod</code></div><p>A normal calculation method when evaluating using a SOP. (0 default, 1 none, 2 interpolate with quaternions, 3 interpolate with twist angles in 0,180 range, 4 interpolate with twist angles in any range.)</p><div class=\"argument\"><code>relmat</code></div><p>A relative matrix used to transform the points, normals and tangent relative to the origin.\n    This is normally the invert matrix of the root of the chain.</p><div class=\"argument\"><code>fmt</code></div><p>The curve type to create. \n    Use constants defined in <code>$HH/vex/include/math.h</code>, or 0 to create a polygon curve, 1 to create a bezier curve or 2 to create a NURBS curve.</p><div class=\"argument\"><code>order</code></div><p>The curve order for NURBS or Bezier curves. This is ignored for polygon curves.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvefbik\">solvefbik</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solveconstraint\">solveconstraint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solveik\">solveik</a></div></body>",
    "solvefbik": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvefbik\">solvefbik</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Applies a full-body inverse kinematics algorithm to a skeleton.</p><div class=\"usage\"> <code>matrix[] solvefbik(matrix xforms[], int parents[], dict jointoptions[], matrix targetxforms[], int targets[], dict targetoptions[], int iters, float tolerance, int pinroot)</code></div><div class=\"usage\"> <code>matrix[] solvefbik(matrix xforms[], int parents[], int targets[], matrix targetxforms[], int iters)</code></div><div class=\"usage\"> <code>matrix[] solvefbik(matrix xforms[], int parents[], int targets[], matrix targetxforms[], int iters, float tolerance, int pinroot)</code></div><div class=\"usage\"> <code>matrix[] solvefbik(matrix xforms[], int parents[], int targets[], matrix targetxforms[], int iters, float tolerance, int pinroot, float targetweights[], int targetpriorities[], int targetdepths[])</code></div><div class=\"usage\"> <code>matrix[] solvefbik(matrix xforms[], int parents[], int targets[], matrix targetxforms[], int iters, float tolerance, int pinroot, float targetweights[], int targetpriorities[], int targetdepths[], int targettypes[], matrix targetoffsets[])</code></div><div class=\"usage\"> <code>matrix[] solvefbik(matrix xforms[], int parents[], int targets[], matrix targetxforms[], int iters, float tolerance, int pinroot, float targetweights[], int targetpriorities[], int targetdepths[], matrix goalxforms[], vector4 constrainedxforms[], vector jointlimits[])</code></div><div class=\"usage\"> <code>matrix[] solvefbik(matrix xforms[], int parents[], int targets[], matrix targetxforms[], int iters, float tolerance, int pinroot, float targetweights[], int targetpriorities[], int targetdepths[], int targettypes[], matrix targetoffsets[], matrix goalxforms[], vector4 constrainedxforms[], vector jointlimits[])</code></div><p>Returns an empty array if:</p><div class=\"related\"><code>xforms</code> is not the same size as <code>parents</code></div><div class=\"related\"><code>targets</code> is not the same size as <code>targetxforms</code></div><div class=\"related\">The <code>goalxforms</code>, <code>constrainedxforms</code>, and <code>jointlimits</code> arrays aren\u2019t empty, but are not the same size as <code>xforms</code></div><p>The <code>goalxforms</code>, <code>constrainedxforms</code>, and <code>jointlimits</code> parameters should be in the form produced by the <a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/agentconfigurejoints\">Agent Configure Joints SOP</a>.</p><div class=\"argument\"><code>xforms</code></div><p>The world transforms of all the transforms in the rig being solved.</p><div class=\"argument\"><code>parents</code></div><p>The parent transform index for each transform.  A value of -1 indicates a root.</p><div class=\"argument\"><code>jointoptions</code></div><p>Specifies optional parameters for the joints. The valid keys are:</p><div class=\"argument\"><code><code>limit_goalxform</code></code></div><p>A <code>matrix</code> specifying the position and orientation of the cone in the space of the parent transform.\n        This can be set from the attributes produced by <a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/agentconfigurejoints\">Agent Configure Joints</a>.</p><div class=\"argument\"><code><code>limit_constrainedxform</code></code></div><p>A <code>vector4</code> (quaternion) specifying the orientation of the twist axis, up axis, and out axis in the space of the child transform.\n        This can be set from the attributes produced by <a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/agentconfigurejoints\">Agent Configure Joints</a>.</p><div class=\"argument\"><code><code>limit_angles</code></code></div><p>A <code>vector</code> specifying the maximum rotation around each axis, in degrees.\n        This can be set from the attributes produced by <a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/agentconfigurejoints\">Agent Configure Joints</a>.</p><div class=\"argument\"><code>targets</code></div><p>A list of the transform indices of the end effectors in the skeleton.</p><div class=\"argument\"><code>targetoptions</code></div><p>Specifies optional parameters for the targets. The valid keys are:</p><div class=\"argument\"><code><code>weight</code></code></div><p>A <code>float</code> specifying the importance of the target.\n        When multiple targets have the same priority level, targets with a higher relative weight are more likely to be reached.\n        The default value is <code>1.0</code>.</p><div class=\"argument\"><code><code>priority</code></code></div><p>An <code>int</code> specifying the target\u2019s priority level.\n        Targets from a lower priority level cannot interfere with targets from a higher priority level.\n        For example, priority levels can be used to ensure that the feet remain planted when manipulating the upper body of a skeleton.\n        The default value is <code>0</code>.</p><div class=\"argument\"><code><code>depth</code></code></div><p>An <code>int</code> specifying the number of parent joints that can be adjusted to achieve the goal transform.\n        A negative depth indicates that the entire chain can be affected.\n        The default value is <code>-1</code>.</p><div class=\"argument\"><code><code>target_type</code></code></div><p>An <code>int</code> specifying how the end effector matches the position or orientation of its target transform.\n        A value of <code>0</code> (default) indicates a position-only target, <code>1</code> indicates an orientation-only target, and <code>2</code> matches both position and orientation.\n        A value of <code>3</code> indicates a target that controls the center of mass of the skeleton (the transform index from <code>targets</code> is not used).\n        Only one center of mass target can be provided.</p><div class=\"argument\"><code><code>joint_offset</code></code></div><p>A <code>matrix</code> specifying a local space transform that is combined with the joint transform to produce the transform that the solver attempts to align with the goal transform.\n        This can be used to place the target at an offset from the joint (for example, at the end of a bone).</p><div class=\"argument\"><code>goalxforms</code></div><p>Part of the joint constraints as produced by <a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/agentconfigurejoints\">Agent Configure Joints</a>.\n    An empty array indicates no joint constraints.</p><div class=\"argument\"><code>constrainedxforms</code></div><p>Part of the joint constraints as produced by <a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/agentconfigurejoints\">Agent Configure Joints</a>.\n    An empty array indicates no joint constraints.</p><div class=\"argument\"><code>jointlimits</code></div><p>Part of the joint constraints as produced by <a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/agentconfigurejoints\">Agent Configure Joints</a>.\n    An empty array indicates no joint constraints.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentsolvefbik\">agentsolvefbik</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransform\">agentworldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentworldtransforms\">agentworldtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/setagentworldtransforms\">setagentworldtransforms</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigfind\">agentrigfind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentrigparent\">agentrigparent</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvephysfbik\">solvephysfbik</a></div></body>",
    "solveik": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solveik\">solveik</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Applies an inverse kinematics algorithm to a skeleton.</p><div class=\"usage\"> <code>vector[] solveik(float lengths[], vector targetpos, vector twistpos, float twist, int twistflag, float dampen, int resiststraight, float trackingthres, matrix relmat, vector constraints[])</code></div><div class=\"usage\"> <code>matrix3[] solveik(float lengths[], vector targetpos, vector twistpos, float twist, int twistflag, float dampen, int resiststraight, float trackingthres, matrix relmat, vector constraints[])</code></div><p>Returns a array of local bone rotations in degrees.</p><div class=\"argument\"><code>lengths</code></div><p>The lengths of all the bones to solve.</p><div class=\"argument\"><code>targetpos</code></div><p>A target position in worldspace.</p><div class=\"argument\"><code>twistpos</code></div><p>A twist affect position in worldspace.</p><div class=\"argument\"><code>twist</code></div><p>A twist angle in degrees.</p><div class=\"argument\"><code>twistflag</code></div><p>Apply twist using the twist affector or not.</p><div class=\"argument\"><code>dampen</code></div><p>Dampening factor for the whole chain.</p><div class=\"argument\"><code>resiststraight</code></div><p>Resist straightening.</p><div class=\"argument\"><code>trackingthres</code></div><p>Tracking threshold.</p><div class=\"argument\"><code>relmat</code></div><p>A relative matrix used to transform the target and twist positions relative to the origin.\n    This is normally the invert matrix of the root of the chain.</p><div class=\"argument\"><code>constraints</code></div><p>This is a vector array used to define the per bone restangles, dampening, minangles, maxangles, min damp, max damp, and rolloff.\n    If the array is empty, same default values present in the bone objects are used.\n    If the array size is equal to the number of input bones, the rest angles are defined.\n    If the array size is equal to 2 times the number of input bones, the rest angles and the dampening are defined.\n    If the array size is equal to 3 times the number of input bones, the rest angles, the dampening, the min/max angles are defined. Min/Max angles share the same values.\n    If the array size is equal to 4 times the number of input bones, the rest angles, the dampening, the min/max angles are defined. Min/Max angles have different values.\n    If the array size is equal to 5 times the number of input bones, the rest angles, the dampening, the min/max angles and damp angles are defined.\n    If the array size is equal to 6 times the number of input bones, the rest angles, the dampening, the min/max angles, min/max damp angles are defined.\n    If the array size is equal to 7 times the number of input bones, the rest angles, the dampening, the min/max angles, min/max damp angles, and rolloff are defined.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solveconstraint\">solveconstraint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvecurve\">solvecurve</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvefbik\">solvefbik</a></div></body>",
    "solvephysfbik": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvephysfbik\">solvephysfbik</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Applies a full-body inverse kinematics algorithm to a skeleton, with optional control over the center of mass.</p><div class=\"usage\"> <code>matrix[] solvephysfbik(matrix xforms[], int parents[], dict jointoptions[], matrix targetxforms[], int targets[], dict targetoptions[], int iters, float damping, float tolerance)</code></div><p>This solver uses a different algorithm than <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvefbik\">solvefbik</a> - it typically performs somewhat slower, but provides more control over the skeleton\u2019s behavior and can produce higher-quality results.\nThe solver can also use the optional per-joint masses and center of mass positions to achieve a target position for the skeleton\u2019s center of mass, allowing for physics-based behavior such as maintaining balance.</p><p>Compared to <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvefbik\">solvefbik</a>, this solver has more stable behavior when joint limits are enabled, and produces more accurate results when there are targets at different priority levels.\nThis solver also tends to distribute joint angle changes more evenly along the chain (particularly when orientation targets are being used), rather than producing large joint angle changes for one or two joints.</p><p>The rotation and translation weight parameters provide control over how each joint axis behaves during the solve. This can be used to ensure that certain joints rotate more than others, to lock a specific joint axis, or to enable translating (stretchy) joints.</p><p>Returns an empty array if:</p><div class=\"related\"><code>xforms</code> or <code>jointoptions</code> are not the same size as <code>parents</code>.</div><div class=\"related\"><code>targetxforms</code> or <code>targetoptions</code> are not the same size as <code>targets</code>.</div><div class=\"argument\"><code>jointoptions</code></div><p>Specifies optional parameters for the joints. The valid keys are:</p><div class=\"argument\"><code><code>rotation_weights</code></code></div><p>A <code>vector</code> specifying weights for the joint\u2019s rotation axes.\n        Given a larger relative weight, the solution will tend to be achieved by rotating around that axis.\n        A weight of zero will disable the rotation axis.\n        The default value is <code>{1,1,1}</code>.</p><div class=\"argument\"><code><code>translation_weights</code></code></div><p>A <code>vector</code> specifying weights for the joint\u2019s translation axes.\n        Given a larger relative weight, the solution will tend to be achieved by translating along that axis.\n        A weight of zero will disable the translation axis.\n        To achieve an unpinned root joint, the root\u2019s translation weight should be non-zero (e.g. <code>{1,1,1}</code>).\n        The default value is <code>{0,0,0}</code>.</p><div class=\"argument\"><code><code>rotation_order</code></code></div><p>An <code>int</code> specifying the joint\u2019s rotation order.\n        The valid values can be found in <code>$HFS/houdini/vex/include/math.h</code>, and the default is <code>XFORM_XYZ</code>.</p><div class=\"argument\"><code><code>rotation_lower_limits</code></code></div><p>A <code>vector</code> specifying the lower rotation limits (in radians) for the joint\u2019s rotation axes.\n        The rotation limits are applied relative to the joint\u2019s local rest transform, if specified.</p><h2>Note</h2><p>To prevent a particular axis from rotating, it is much more efficient to set its weight to zero instead of setting its rotation limits to zero.</p><div class=\"argument\"><code><code>rotation_upper_limits</code></code></div><p>A <code>vector</code> specifying the upper rotation limits (in radians) for the joint\u2019s rotation axes.</p><div class=\"argument\"><code><code>translation_lower_limits</code></code></div><p>A <code>vector</code> specifying the lower translation limits for the joint\u2019s translation axes.</p><div class=\"argument\"><code><code>translation_upper_limits</code></code></div><p>A <code>vector</code> specifying the upper translation limits for the joint\u2019s translation axes.</p><div class=\"argument\"><code><code>rest_xform</code></code></div><p>A local space <code>matrix</code> specifying the joint\u2019s rest pose.\n        The default value is the identity matrix.</p><div class=\"argument\"><code><code>rest_rotation_weights</code></code></div><p>A <code>vector</code> specifying how strongly the solver attempts to match the rest transform for the rotation axes.\n        This has a priority lower than any of the end effector targets.\n        A value of <code>0.1</code> is typically a suitable value when enabling the rest transform constraint, and a value of 0 will disable it.\n        The default value is <code>{0,0,0}</code>.</p><div class=\"argument\"><code><code>rest_translation_weights</code></code></div><p>A <code>vector</code> specifying how strongly the solver attempts to match the rest transform for the translation axes.\n        This has a priority lower than any of the end effector targets.\n        A value of <code>0.1</code> is typically a suitable value when enabling the rest transform constraint, and a value of 0 will disable it.\n        The default value is <code>{0,0,0}</code>.</p><div class=\"argument\"><code><code>mass</code></code></div><p>A <code>float</code> specifying the mass of the body associated with the joint.\n        This parameter is only used when a center of mass target is provided.\n        The default value is <code>1.0</code>.</p><div class=\"argument\"><code><code>local_com</code></code></div><p>A <code>vector</code> specifying the position of the joint\u2019s center of mass, in local space.\n        An value of <code>{0,0,0}</code> (default) will position the center of mass at the joint\u2019s position.</p><div class=\"argument\"><code>damping</code></div><p>Damping factor for the solver.\n    Larger values will produce more stable results when, for example, a target is unreachable.\n    A value that is too large, however, will require more iterations to converge.\n    Around 0.5 is typically a suitable initial value.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/agentsolvefbik\">agentsolvefbik</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvefbik\">solvefbik</a></div></body>",
    "solvepoly": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvepoly\">solvepoly</a></h1><p class=\"summary\">Finds the real roots of a polynomial.</p><div class=\"usage\"> <code>int solvepoly(float coef[], float &amp;roots[], int maxiter=0)</code></div><div class=\"argument\"><code>coef</code></div><p>An array of coefficients of the polynomial.</p><p>You must order the coefficients such that <code>coef[i]</code> should be <code>x^i</code>.\n    <strong>This is reverse of the order you would write the polynomial out normally</strong>.</p><div class=\"argument\"><code>&amp;roots</code></div><p>The function overwrites this array with the real roots of the polynomial,\n    in ascending order.</p><h2>Returns</h2><p>The number of real roots.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvequadratic\">solvequadratic</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvecubic\">solvecubic</a></div></body>",
    "solvequadratic": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvequadratic\">solvequadratic</a></h1><p class=\"summary\">Solves a quadratic function returning the number of real roots.</p><div class=\"usage\"> <code>int solvequadratic(float a, float b, float c, float &amp;t1, float &amp;t2)</code></div><div class=\"usage\"> <code>int solvequadratic(float a, float b, float c, vector2 &amp;t1, vector2 &amp;t2)</code></div><p>Solves the given quadratic function where <code class=\"var\">a</code> , <code class=\"var\">b</code>, and <code class=\"var\">c</code> are the coefficients as so: <code>ax^2 + bx + c = 0</code>.</p><p>Returns the number of real roots.</p><p>In the real case <code class=\"var\">t1</code> and <code class=\"var\">t2</code> are filled such that <code class=\"var\">t1</code>  \u2264 <code class=\"var\">t2</code>. If there is only one root then <code class=\"var\">t1</code> = <code class=\"var\">t2</code>. If there are no roots then <code class=\"var\">t1</code> = <code class=\"var\">t2</code> and is the projection of the vertex of the quadratic function onto the x-axis.</p><p>In the complex case <code class=\"var\">t1</code> and <code class=\"var\">t2</code> are the complex roots.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvecubic\">solvecubic</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvepoly\">solvepoly</a></div></body>",
    "solvetriangleSSS": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/solvetriangleSSS\">solvetriangleSSS</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Finds the angles of a triangle from its sides.</p><div class=\"usage\"> <code>vector solvetriangleSSS(vector sides)</code></div><div class=\"usage\"> <code>vector solvetriangleSSS(float a, float b, float c)</code></div><h2>Returns</h2><p>The 3 angles of a triangle in radians given the value of its 3 sides using the Law of Cosines.</p></body>",
    "sort": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sort\">sort</a></h1><p class=\"summary\">Returns the array sorted in increasing order.</p><div class=\"usage\"> <code>int[] sort(int values[])</code></div><div class=\"usage\"> <code>float[] sort(float values[])</code></div><div class=\"usage\"> <code>string[] sort(string values[])</code></div><p>Returns a version of the given array sorted in increasing order.</p><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/argsort\">argsort</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sort\">sort</a> use a stable sort.</div><div class=\"related\">Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/reverse\">reverse</a> to reverse the order of the sort.</div><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int numbers[] = {5, 2, 90, 3, 1};</code><code class=\"codeline\">    int descending_nums[] = reverse(sort(numbers));  // {90, 5, 3, 2, 1}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/arrays\">/vex/arrays</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/argsort\">argsort</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/reorder\">reorder</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/reverse\">reverse</a></div></body>",
    "specular": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/specular\">specular</a></h1><p class=\"summary\">Returns a specular BSDF or computes specular shading.</p><p><a href=\"https://www.sidefx.com/docs/houdini/images/rendering/specular.png\">/images/rendering/specular.png</a></p><div class=\"usage\"> <code>bsdf specular(vector dir, ...)</code></div><p>Returns a specular BSDF where <code class=\"var\">dir</code> is the direction of specularity.\n    See <a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">writing a PBR shader</a> for information on BSDFs.</p><div class=\"usage\"> <code>vector specular(vector nml, vector V, float roughness, ...)</code></div><p>Computes specular shading.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/matchvex_specular\">matchvex_specular</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phong\">phong</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "specularBRDF": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/specularBRDF\">specularBRDF</a></h1><p class=\"summary\">Returns the computed BRDFs for the different lighting models used in VEX shading.</p><div class=\"usage\"> <code>float specularBRDF(vector L, vector N, vector V, float rough)</code></div><p><code>specularBRDF</code>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phongBRDF\">phongBRDF</a>, <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/blinnBRDF\">blinnBRDF</a>,\nand <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/diffuseBRDF\">diffuseBRDF</a> return the computed BRDF for the\ndifferent lighting models used in VEX shading. You can use them in\ncustom <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a> loops to replicate the lighting models of the\ncorresponding VEX lighting functions.</p><div class=\"codeblock\"><code class=\"codeline\">vector nn = normalize(frontface(N, I));</code><code class=\"codeline\">vector ii = normalize(-I);</code><code class=\"codeline\">Cf = 0;</code><code class=\"codeline\">illuminance(P, nn)</code><code class=\"codeline\">{</code><code class=\"codeline\">    vector ll = normalize(L);</code><code class=\"codeline\">    Cf += Cl * (specularBRDF(ll, nn, ii, rough) + diffuseBRDF(ll, nn));</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/phongBRDF\">phongBRDF</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/blinnBRDF\">blinnBRDF</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/diffuseBRDF\">diffuseBRDF</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/illuminance\">illuminance</a></div></body>",
    "spline": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/spline\">spline</a></h1><p class=\"summary\">Samples a value along a polyline or spline curve.</p><div class=\"usage\"> <code>float spline(string basis; float sample_pos; float value1, ...)</code></div><div class=\"usage\"> <code>vector spline(string basis; float sample_pos; vector value1, ...)</code></div><div class=\"usage\"> <code>vector4 spline(string basis; float sample_pos; vector4 value1, ...)</code></div><p>This version takes a single basis to use for all keys, and takes the (linearly spaced) key values as variadic arguments.</p><div class=\"usage\"> <code>float spline(string basis, float sample_pos, float values[], ...)</code></div><div class=\"usage\"> <code>vector spline(string basis; float sample_pos; vector values[], ...)</code></div><div class=\"usage\"> <code>vector4 spline(string basis; float sample_pos; vector4 values[], ...)</code></div><p>This version takes a single basis to use for all keys, and takes the (linearly spaced) key values as an array.</p><div class=\"usage\"> <code>float spline(string bases[], float sample_pos, float values[], ...)</code></div><div class=\"usage\"> <code>vector spline(string bases[]; float sample_pos; vector values[], ...)</code></div><div class=\"usage\"> <code>vector4 spline(string bases[]; float sample_pos; vector4 values[], ...)</code></div><p>This version takes an array specifying the bases to use between each pair of keys, and the (linearly spaced) key values as an array.</p><div class=\"usage\"> <code>float spline(string bases[], float sample_pos, float values[], float positions[], ...)</code></div><div class=\"usage\"> <code>vector spline(string bases[]; float sample_pos; vector values[], float positions[], ...)</code></div><div class=\"usage\"> <code>vector4 spline(string bases[]; float sample_pos; vector4 values[], float positions[], ...)</code></div><p>This version takes an array specifying the bases to use between each pair of keys, an array of key values, and an array of key positions.</p><p>These forms take an array of strings specifying the interpolation\n    bases between the keys, an array of key values, and an array of key positions.\n    They ensure that the interpolation curve is smooth (tangent-continuous) across\n    the control points (keys) if the adjoining segments have the same basis, even if\n    the key positions are not evenly spaced (i.e., are non-uniform and the distances\n    between them are not equal).</p><div class=\"argument\"><code><code>basis</code>, <code>bases</code></code></div><p>These are the same interpolations supported by ramp parameters.</p><div class=\"argument\"><code><code>\"constant\"</code></code></div><p>Maintains each key value until the next key, creating a stair step curve.</p><div class=\"argument\"><code><code>\"linear\"</code></code></div><p>Connects the key points with a polyline.</p><p>For example, if you specified four values:</p><div class=\"codeblock\"><code class=\"codeline\">spline(\"linear\", t, v0, v1, v2, v3)</code></div><p><a href=\"https://www.sidefx.com/docs/houdini/images/vex/spline_linear.svg\">/images/vex/spline_linear.svg</a></p><p>\u2026the function returns the height of the orange dot at position <code class=\"var\">sample_pos</code>.</p><div class=\"argument\"><code><code>\"cubic\"</code> (or <code>\"catmullrom\"</code>, <code>\"cspline\"</code>)</code></div><p>Connect the point values with a Catmull-Rom spline.</p><p>Note that the first and last values are outside the sample area to\n        provide the slope of the curve at the second point (at the start of the\n        sample range) and the second-to-last point (at the end of the sample\n        range).</p><p>For example, if you specified six values:</p><div class=\"codeblock\"><code class=\"codeline\">spline(\"catrom\", t, v0, v1, v2, v3, v4, v5)</code></div><p><a href=\"https://www.sidefx.com/docs/houdini/images/vex/spline_catrom.svg\">/images/vex/spline_catrom.svg</a></p><p>\u2026the function returns the height of the orange dot at position <code class=\"var\">t</code>.</p><p>(This image is for illustration only, it does not show the correct\n        curve for the shown points.)</p><div class=\"argument\"><code><code>\"linearsolve\"</code> (or <code>\"solvelinear\"</code>)</code></div><p>Maps between a set of non-uniform positions and a set of values.\n        The <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/kspline\">kspline</a> function does this mapping implicitly.</p><div class=\"codeblock\"><code class=\"codeline\">tk = spline(\"linearsolve\", t, k0, k1, k2, k3, ...);</code><code class=\"codeline\">        v = spline(basis, tk, v1, v2, v3, ...);</code></div><p>(Technically, <code>linearsolve</code> interprets the values as key values, solves the\n        intersection of the spline, and returns the intercept point.)</p><p><code>\"monotonecubic\"</code></p><p>A cubic spline with no overshoot of the control values.</p><p>bezier</p><p>A bezier spline.</p><p>bspline</p><p>A b-spline basis.</p><p>hermite</p><p>A hermite spline.</p><div class=\"argument\"><code>sample_pos</code></div><p>The position along the curve at which to sample the value.</p><h2>Returns</h2><p>The value at <code class=\"var\">sample_pos</code> along a polyline or cubic spline.</p><h2>Note</h2><p>For b-spline basis, this function implicitly assumes the multiplicity of 3\n    for b-spline curve end point, even though the given control points and\n    knots are not explicitly repeated. This ensures the curve passes through the\n    end control points, making it easier to create continuous ramp curves with\n    mixed interpolation bases (e.g., b-spline basis segments surrounded by\n    linear interpolation segments).</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cspline\">cspline</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/kspline\">kspline</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ckspline\">ckspline</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lspline\">lspline</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lkspline\">lkspline</a></div></body>",
    "spline_cdf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/spline_cdf\">spline_cdf</a></h1><span class=\"padder\"><span class=\"pillow\">18.5</span></span><p class=\"summary\">Generate a cumulative distribution function (CDF) by sampling a spline curve.</p><h2>Overview</h2><p>Whereas the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/create_cdf\">create_cdf</a> function creates a CDF from sample values, this functions creates a CDF by randomly sampling a curve defined by a list of <code>values</code> and corresponding <code>positions</code> (similar to a Ramp parameter).</p><p>See the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/create_cdf\">create_cdf</a> function docs for example code using a CDF.</p><h2>Usage</h2><div class=\"usage\"> <code>float[] spline_cdf(string bases[], float values[], float positions[], ...)</code></div><p>Takes an array of bases, an array of key values, a corresponding array of key\n    positions, and an optionally an int, res (resolution), corresponding to the number of samples\n    to build the CDF with. Function samples the spline according to the resolution,\n    then creates and returns a CDF from said samples. Note that there is only support\n    for single dimension splines.</p><div class=\"argument\"><code><code>bases</code></code></div><p>An array of strings describing how to interpret the corresponding <code>values</code>: each string can be <code>\"constant\"</code>, <code>\"linear\"</code>, <code>\"cubic\"</code> (or <code>\"catmullrom\"</code>, <code>\"cspline\"</code>), <code>\"linearsolve\"</code> (or <code>\"solvelinear\"</code>), or <code>\"monotonecubic\"</code>. See the <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/spline\">spline</a> function docs for information on how these options control the interpretation of the values.</p><div class=\"argument\"><code>res</code></div><span class=\"padder\"><span class=\"pillow\">128</span></span><p>When building a CDF, some splines may require more samples to accurately represent the spline. The <code>res</code> (resolution) controls how many samples the function takes when constructing the CDF (and consequently the size of the CDF). The default is 128.</p><h2>Returns</h2><p>A float array representing a CDF (like the array returned by <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/create_cdf\">create_cdf</a>).</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/spline\">spline</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/create_cdf\">create_cdf</a></div></body>",
    "split": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/split\">split</a></h1><p class=\"summary\">Splits a string into tokens.</p><div class=\"usage\"> <code>string[] split(string s)</code></div><div class=\"usage\"> <code>string[] split(string s, string separators)</code></div><div class=\"usage\"> <code>string[] split(string s, string separators; int maxsplits)</code></div><p>Splits a string into tokens by removing separator characters from the string\nand creating an array entry for each substring bounded by separators. When no\nseparator string is provided, the string is split on whitespace (spaces, tab,\nand return).</p><p>The <code>maxsplits</code> option limits the number of times the string is split,\nthis is useful to peel off one token at a time from a larger string.</p><h2>Note</h2><p>This differs from Python\u2019s split() in that it takes a list of separators, not a single string to use as a separator.</p><h2>Note</h2><p>This operates more as a tokenize method than as a split method.\n    In particular, if you have repeated separators they will be merged\n    and only a single split performed.</p></body>",
    "splitpath": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/splitpath\">splitpath</a></h1><p class=\"summary\">Splits a file path into the directory and name parts.</p><div class=\"usage\"> <code>void splitpath(string fullpath, string &amp;dir, string &amp;name)</code></div><p>Splits a string representing a path into the <code>directory</code> and <code>name</code> components.</p></body>",
    "split_bsdf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/split_bsdf\">split_bsdf</a></h1><p class=\"summary\">Splits a bsdf into its component lobes.</p><div class=\"usage\"> <code>void split_bsdf(bsdf &amp;lobes[], bsdf source, float &amp;weights[])</code></div><div class=\"usage\"> <code>void split_bsdf(bsdf &amp;lobes[]; bsdf source; float &amp;weights[]; int mask)</code></div><div class=\"usage\"> <code>void split_bsdf(bsdf &amp;lobes[], bsdf source, float &amp;weights[], int mask, int type)</code></div><div class=\"usage\"> <code>void split_bsdf(bsdf &amp;lobes[], bsdf source, float &amp;weights[], int mask, int type, float u)</code></div><div class=\"usage\"> <code>void split_bsdf(bsdf &amp;lobes[], bsdf source, float &amp;weights[], int mask, int type, float u, float cdf[])</code></div><div class=\"argument\"><code>&amp;lobes</code></div><p>The function overwrites this array with the BSDFs for the component lobes.</p><div class=\"argument\"><code>source</code></div><p>The BSDF to split.</p><div class=\"argument\"><code>weights</code></div><p>The function fills this array with the weights for the split lobes (same length as the returned <code>bsdf</code> array). When you sample Illumination using the returned lobes you must scale it by these weights.</p><div class=\"argument\"><code>mask</code></div><p>A bitmask indicating which types of bounces to evaluate.</p><div class=\"argument\"><code>type</code></div><p>How to split the lobes. You can <code>#import \"pbr.h\"</code> to get constant values representing the different split types:</p><div class=\"related\"><code>PBR_SPLIT_FULL = 0</code></div><div class=\"related\"><code>PBR_SPLIT_RANDOM = 1</code></div><div class=\"related\"><code>PBR_SPLIT_ALBEDO = 2</code></div><div class=\"related\"><code>PBR_SPLIT_COMPONENT = 3</code></div><div class=\"related\"><code>PBR_SPLIT_DEFAULT = PBR_SPLIT_ALBEDO</code></div><div class=\"argument\"><code>u</code></div><p>Random value to sample the CDF at.</p><div class=\"argument\"><code>cdf</code></div><p>CDF used to control sampling among components of the BSDF.</p><h2>Returns</h2><p>An array of <code>bsdf</code> objects representing the lobes.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Split BSDF into component lobes</code><code class=\"codeline\">float weights[];</code><code class=\"codeline\">bsdf lobes[];</code><code class=\"codeline\">split_bsdf(lobes, hitF, weights);</code><code class=\"codeline\"></code><code class=\"codeline\">// Get albedos of lobes</code><code class=\"codeline\">float albedos[];</code><code class=\"codeline\">resize(albedos, len(lobes));</code><code class=\"codeline\">for (int i = 0; i &lt; len(lobes); i++)</code><code class=\"codeline\">{</code><code class=\"codeline\">    albedos[i] = luminance(albedo(lobes[i], -hitnI)) * weights[i];</code><code class=\"codeline\">}</code><code class=\"codeline\"></code><code class=\"codeline\">// Compute CDF</code><code class=\"codeline\">float cdf[] = compute_cdf(albedos);</code><code class=\"codeline\"></code><code class=\"codeline\">// Randomly select a BSDF based on albedo distribution</code><code class=\"codeline\">int index = 0;</code><code class=\"codeline\">sample_cdf(cdf, s.x, index);</code><code class=\"codeline\"></code><code class=\"codeline\">// Do something with the selected BSDF</code><code class=\"codeline\">// lobes[index] ...</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_bsdf\">sample_bsdf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/eval_bsdf\">eval_bsdf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/albedo\">albedo</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/create_cdf\">create_cdf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sample_cdf\">sample_cdf</a></div></body>",
    "sprintf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sprintf\">sprintf</a></h1><p class=\"summary\">Formats a string like printf but returns the result as a string\ninstead of printing it.</p><div class=\"usage\"> <code>string sprintf(string format, ...)</code></div><p>Formats a string like <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/printf\">printf</a> but returns the result as a\n    string instead of printing it.</p><h2>Tip</h2><p>You can use this function pad a number (such as the frame number in a filename) with zeros (similarly to the <a href=\"https://www.sidefx.com/docs/houdini/expressions/padzero\">padzero</a> expression function) using a format such as <code>sprintf(\"texture%04d.exr\", @Frame)</code>.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/printf\">printf</a></div></body>",
    "sqrt": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sqrt\">sqrt</a></h1><p class=\"summary\">Returns the square root of the argument.</p><div class=\"usage\"> <code>float sqrt(float value)</code></div><div class=\"usage\"> <code>&lt;vector&gt; sqrt(&lt;vector&gt; value)</code></div><p>Returns the square root of <code>value</code>. For vectors, this is done per-component.</p><h2>Note</h2><p>The square root of a negative number is defined to be zero.</p><p>To quote Edgar Rice Burroughs, Pirates of Venus:\n    <em>I saw that argument was useless and said no more: there is no use arguing with a man who can multiply anything by the square root of minus one</em></p></body>",
    "sssapprox": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sssapprox\">sssapprox</a></h1><p class=\"summary\">Creates an approximate SSS BSDF.</p><div class=\"usage\"> <code>bsdf sssapprox(vector albedo, float meanFreePath, float roughness, float scale, ...)</code></div><div class=\"argument\"><code>albedo</code></div><p>Average surface reflectance.</p><div class=\"argument\"><code>meanFreePath</code></div><p>Average distance between scattering events.</p><div class=\"argument\"><code>roughness</code></div><p>A value from '0.0' to '1.0' blending to an ideal diffuse transmission reflectance profile.</p><div class=\"argument\"><code>scale</code></div><p>Physical scale of the material. Smaller scale values will make the material more transmissive.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">writing a PBR shader</a> for information on BSDFs.</p><p>Models SSS illumination based on an approximate reflectance profile.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/diffuse\">diffuse</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/translucent\">translucent</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "startswith": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/startswith\">startswith</a></h1><p class=\"summary\">Returns 1 if the string starts with the specified string.</p><div class=\"usage\"> <code>int startswith(const string str, const string startswith)</code></div><p>Returns 1 if the string starts with the given string. 0 otherwise.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/endswith\">endswith</a></div></body>",
    "storelightexport": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/storelightexport\">storelightexport</a></h1><span class=\"padder\"><span class=\"pillow\">displace</span></span><span class=\"padder\"><span class=\"pillow\">fog</span></span><span class=\"padder\"><span class=\"pillow\">surface</span></span><p class=\"summary\">Stores exported data for a light.</p><div class=\"usage\"> <code>void storelightexport(string lightname, string exportname, &lt;type&gt; value)</code></div><div class=\"usage\"> <code>void storelightexport(string lightname, string exportname, &lt;type&gt; value[])</code></div><p>Stores a per-light export to a shader export variable.  This method should\nnormally be called for each light to ensure that all light exports for the\ngiven variable are created, for example by placing the call in an\nilluminance() loop or a loop over the light array.</p><p>This method replaced the <code>storelightexports()</code> method used in Houdini 12.5 and earlier.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">surface test(export vector perlight = {0,0,0})</code><code class=\"codeline\">{</code><code class=\"codeline\">    int             lights[] = getlights();</code><code class=\"codeline\">    for (int i = 0; i &lt; len(lights); i++)</code><code class=\"codeline\">    {</code><code class=\"codeline\">        vector val = set(lights[i], 0, 0);</code><code class=\"codeline\">        storelightexport(getlightname(lights[i]), \"perlight\", val);</code><code class=\"codeline\">    }</code><code class=\"codeline\">}</code></div></body>",
    "strip": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/strip\">strip</a></h1><p class=\"summary\">Strips leading and trailing whitespace from a string.</p><div class=\"usage\"> <code>string strip(string value)</code></div><div class=\"usage\"> <code>string strip(string value, string whitespace)</code></div><p>Returns a string with the leading and trailing whitespace removed.  If\nwhitespace is provided, it is a string of characters that will be stripped.</p><p>This is also equivalent of doing both <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rstrip\">rstrip</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lstrip\">lstrip</a> on a string.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rstrip\">rstrip</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/lstrip\">lstrip</a></div></body>",
    "strlen": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/strlen\">strlen</a></h1><p class=\"summary\">Returns the length of the string.</p><div class=\"usage\"> <code>int strlen(string string)</code></div><p>Returns the length of the string in bytes.</p></body>",
    "sum": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sum\">sum</a></h1><p class=\"summary\">Returns the sum of a list of numbers.</p><div class=\"usage\"> <code>float sum(float n)</code></div><div class=\"usage\"> <code>int sum(int n)</code></div><p>Returns the argument.</p><div class=\"usage\"> <code>float sum(&lt;vector&gt; v)</code></div><p>Returns the sum of the vector\u2019s components.</p><div class=\"usage\"> <code>int sum(int nums[])</code></div><div class=\"usage\"> <code>float sum(float nums[])</code></div><p>Returns the sum of the items of the array.</p><div class=\"usage\"> <code>&lt;vector&gt; sum(&lt;vector&gt; arr[])</code></div><p>Returns a vector where the components are the sums of the corresponding components in the vectors in the array.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/product\">product</a></div></body>",
    "surfacedist": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/surfacedist\">surfacedist</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Finds the distance of a point to a group of points along the surface of a geometry.</p><div class=\"usage\"> <code>float surfacedist(&lt;geometry&gt;; string ptgroup; string P_attribute; int search_pt; int &amp;closest_pt; string distance_metric)</code></div><div class=\"usage\"> <code>float surfacedist(&lt;geometry&gt;; string ptgroup; string P_attribute; int search_pt; float max_radius; int &amp;closest_pt; string distance_metric)</code></div><p>Returns the distance from the search point to the closest point in the point\ngroup.</p><div class=\"argument\"><code>ptgroup</code></div><p>The name of a point group or a pattern to generate a point\n    group.  Uses the same semantics as a SOP group, so empty strings\n    will match all points.  Attribute groups like <code>@Cd.x&gt;0</code> can\n    also be used, but note that the <code>@</code> may need to be escaped with\n    a backslash in a <a href=\"https://www.sidefx.com/docs/houdini/nodes/vop/snippet\">Snippet VOP</a>.</p><div class=\"argument\"><code>P_attribrute</code></div><p>The name of the vector attribute to use to measure distance between\n    connected points. Using P will give the world distance along the surface,\n    but a custom attribute can be used to measure along a different metric.</p><div class=\"argument\"><code>search_pt</code></div><p>The point to measure the distance for.</p><div class=\"argument\"><code>max_radius</code></div><p>The maximum distance to measure the surface distance.  This can speed things\n    up by allowing the search to quit early if the point is not within the\n    radius. Points outside the radius will return a value of <code>-1</code> for both the\n    distance and the lead point.</p><div class=\"argument\"><code>&amp;closest_pt</code></div><p>Index of the closest point in the source group.</p><p><code>-1</code> if no closest point was found.</p><div class=\"argument\"><code>distance_metric</code></div><p>The method to use to measure distance. Accepted values are <code>edge</code> and\n    <code>surface</code>. Edge distance is measured along the edges of the model, while\n    surface distance is measured along edges and across single polygons. Surface\n    distance is a better approximation of the true geodesic distance, but is\n    also more expensive to compute.</p><h2>Returns</h2><p>The distance from the search point to the closest point in the point group.</p><p>Returns <code>-1</code> if no closest point was found.</p></body>",
    "svddecomp": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/svddecomp\">svddecomp</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Computes the singular value decomposition of a 3\u00d73 matrix.</p><div class=\"usage\"> <code>void svddecomp(matrix3 input_M, matrix3 &amp;output_U, vector &amp;output_S, matrix3 &amp;output_V)</code></div><div class=\"usage\"> <code>vector svddecomp(matrix3 input_M)</code></div><p>Computes the <a href=\"https://en.wikipedia.org/wiki/Singular_value_decomposition\">singular value decomposition</a> of a\n3\u00d73 matrix. More precisely, computes <code>U</code>, <code>S</code>, <code>V</code> such that\n<code>M = U*T*transpose(V)</code>, where <code>T</code> is the diagonal matrix constructed from <code>S</code>,\nthe vector of singular values.</p><p>The second form of this function simply returns the vector of singular values.</p></body>",
    "switch": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/switch\">switch</a></h1><p class=\"summary\">Use a different bsdf for direct or indirect lighting.</p><div class=\"usage\"> <code>bsdf switch(bsdf direct, bsdf indirect)</code></div><p>This makes it possible to use a different bsdf for direct and indirect lighting.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/nodes/vop/switchlightingbsdf.txt\">vop/switchlightingbsdf.txt</a></div></body>",
    "swizzle": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/swizzle\">swizzle</a></h1><p class=\"summary\">Rearranges the components of a vector.</p><div class=\"usage\"> <code>vector2 swizzle(vector2 v; int i0, int i1)</code></div><div class=\"usage\"> <code>vector swizzle(vector v; int i0, int i1, int i2)</code></div><div class=\"usage\"> <code>vector4 swizzle(vector4 v; int i0, int i1, int i2, int i3)</code></div><p>The integer arguments specify which component of the original vector to put in each place in the returned vector. So, for example, if <code>i0</code> is <code>3</code>, the third component of the original vector is copied to the zeroth component of the returned vector.</p><p>Integer arguments less than <code>0</code> or greater than the number of components are clamped.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">swizzle({10, 20, 30, 40}, 3, 2, 1, 0) == {40, 30, 20, 10}</code><code class=\"codeline\">swizzle({10, 20, 30, 40}, 0, 0, 0, 0) == {10, 10, 10, 10}</code></div></body>",
    "tan": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tan\">tan</a></h1><p class=\"summary\">Returns the trigonometric tangent of the argument</p><div class=\"usage\"> <code>float tan(float n)</code></div><p>Returns the trigonometric tangent of <code>n</code>, where <code>n</code> is in radians.</p><div class=\"usage\"> <code>vector2 tan(vector2 v)</code></div><div class=\"usage\"> <code>vector tan(vector v)</code></div><div class=\"usage\"> <code>vector4 tan(vector4 v)</code></div><p>Returns a new vector with <code>tan()</code> applied to each component.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/atan\">atan</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tanh\">tanh</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sin\">sin</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cos\">cos</a></div></body>",
    "tanh": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tanh\">tanh</a></h1><p class=\"summary\">Returns the hyperbolic tangent of the argument</p><div class=\"usage\"> <code>float tanh(float n)</code></div><p>Returns the hyperbolic tangent of <code>n</code>.</p><div class=\"usage\"> <code>vector2 tanh(vector2 n)</code></div><div class=\"usage\"> <code>vector tanh(vector n)</code></div><div class=\"usage\"> <code>vector4 tanh(vector4 n)</code></div><p>Returns a new vector with <code>tanh()</code> applied to each component.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tan\">tan</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sinh\">sinh</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cosh\">cosh</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sin\">sin</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/cos\">cos</a></div></body>",
    "tet_adjacent": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tet_adjacent\">tet_adjacent</a></h1><p class=\"summary\">Returns primitive number of an adjacent tetrahedron.</p><div class=\"usage\"> <code>int tet_adjacent(&lt;geometry&gt;, int primindex, int faceno)</code></div><div class=\"argument\"><code>primindex</code></div><p>The primitive number.</p><div class=\"argument\"><code>faceno</code></div><p>The face on the tetrahedron.  Face 0 is the triangle that doesn\u2019t\n    have vertex 0.</p><h2>Returns</h2><p>The primitive number of the tetrahedron opposite the given vertex.\n    Returns <code>-1</code> f the primitive is not a tet or doesn\u2019t have an adjacent tetrahedron.</p><p>Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tet_faceindex\">tet_faceindex</a> to get the vertex indices of each face of a tetrahedron.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tet_faceindex\">tet_faceindex</a></div></body>",
    "tet_faceindex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tet_faceindex\">tet_faceindex</a></h1><p class=\"summary\">Returns vertex indices of each face of a tetrahedron.</p><div class=\"usage\"> <code>int tet_faceindex(int faceno, int vtxno)</code></div><p>Returns <code>-1</code> if an invalid number is specified.</p><p>Returns <code>0</code> to <code>3</code> to refer to the four vertices of a generic tetrahedron.</p><div class=\"argument\"><code>faceno</code></div><p>The face on the tetrahedron.  Face 0 is the triangle that doesn\u2019t\n    have vertex 0.</p><div class=\"argument\"><code>vtxno</code></div><p>Which vertex on the triangle to return, <code>0</code> to <code>2</code>.  Starts with\n    the lowest number and follows Houdini\u2019s winding convention, ie,\n    face 0 is vertices 1, 2, and 3.</p></body>",
    "teximport": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/teximport\">teximport</a></h1><p class=\"summary\">Imports attributes from texture files.</p><div class=\"usage\"> <code>int teximport(string map, string attribute; &lt;type&gt; &amp;value)</code></div><p>Reads a single value. Returns <code>1</code> on success or <code>0</code> on failure.</p><div class=\"usage\"> <code>int teximport(string map, string token; int|string &amp;values[])</code></div><p>Returns the number of strings in the array.</p><p>Note that if the values cannot be imported, <code>values</code> will not be written to and may remain uninitialized.</p><p>This function queries metadata stored in an image file, and works with most texture formats.</p><p>You can choose what properties are stored using the <code>vm_saveoptions</code>\nHoudini property on a camera or light\n(<code>image:saveoptions</code> in <a href=\"https://www.sidefx.com/docs/houdini/render/ifd\">IFD</a>).\nHowever, the defaults probably contain all the information you'd want.\nSee <a href=\"https://www.sidefx.com/docs/houdini/props/\">rendering properties</a>.</p><h2>Queryable attributes</h2><p>There are several generic attributes you can always query:</p><div class=\"argument\"><code>int texture:xres</code></div><p>X resolution of the texture map.</p><div class=\"argument\"><code>int texture:yres</code></div><p>Y resolution of the texture map.</p><div class=\"argument\"><code>int texture:channels</code></div><p>Number of channels in the texture map.</p><div class=\"argument\"><code>vector texture:resolution</code></div><p>Resolution of the texture as the vector <code>(xres, yres, channels)</code>.</p><div class=\"argument\"><code>matrix texture:worldtoview</code></div><p>The transform matrix that will take world space points into the camera\n    space used to generate the image.</p><div class=\"argument\"><code>matrix texture:projection</code></div><p>The transform matrix representing the projection matrix of the camera\n    used to generate the image.</p><div class=\"argument\"><code>matrix texture:worldtondc</code></div><p>The transform matrix that will transform world spaced points into the NDC\n    space of the camera used to make the image. The points are generated in\n    homogeneous coordinates.  That is, to get the values in the range 0 to 1:</p><div class=\"codeblock\"><code class=\"codeline\">matrix ndc;</code><code class=\"codeline\">    if (teximport(map, \"texture:worldtoNDC\", ndc))</code><code class=\"codeline\">    {</code><code class=\"codeline\">        vector P_ndc = pos * ndc;</code><code class=\"codeline\">        // If the camera is a perspective camera,</code><code class=\"codeline\">        // dehomogenize the point</code><code class=\"codeline\">        if (getcomp(ndc, 2, 3) != 0)</code><code class=\"codeline\">        {</code><code class=\"codeline\">            P_ndc.x = P_ndc.x / P_ndc.z;</code><code class=\"codeline\">            P_ndc.y = P_ndc.y / P_ndc.z;</code><code class=\"codeline\">        }</code><code class=\"codeline\">        // Finally, scale and offset XY</code><code class=\"codeline\">        // from [-1,1] to [0,1]</code><code class=\"codeline\">        P_ndc *= {.5, .5, 1};</code><code class=\"codeline\">        P_ndc += {.5, .5, 0};</code><code class=\"codeline\">    }</code></div><div class=\"argument\"><code>string texture:tokens</code></div><p>A space separated list of all attribute names you can query.</p><div class=\"argument\"><code>The <code>string &amp;values[]</code> version can query the following</code></div><div class=\"argument\"><code><code>texture:channelnames</code></code></div><p>List of all the raster plane channel names.</p><div class=\"argument\"><code><code>texture:channelsize</code></code></div><p>This returns an array of the number of floats in each image channel.</p><div class=\"argument\"><code><code>texture:channelstorage</code></code></div><p>This returns an array with a string for the underlying storage type for\n        each channel (i.e.  uint8 or real16).</p><div class=\"argument\"><code><code>texture:tokens</code></code></div><p>List of all the built-in tokens understood by <code>teximport()</code>.</p><div class=\"argument\"><code>string texture:device</code></div><p>The device that\u2019s used to evaluate the texture.  Possible values are:</p><div class=\"related\"><code>native</code> - Evaluated using the built-in Houdini texture engine</div><div class=\"related\"><code>oiio</code> - Evaluated using OpenImageIO</div><div class=\"related\"><code>ptex</code> - Evaluated using Ptex</div><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">cvex</code><code class=\"codeline\"> test(string map=\"Mandril.rat\")</code><code class=\"codeline\">{</code><code class=\"codeline\">    for (string token : {</code><code class=\"codeline\">                    \"texture:xres\",</code><code class=\"codeline\">                    \"texture:yres\",</code><code class=\"codeline\">                    \"texture:channels\",</code><code class=\"codeline\">                    \"texture:resolution\",</code><code class=\"codeline\">                    \"texture:tokens\",</code><code class=\"codeline\">                    \"image:pixelaspect\",</code><code class=\"codeline\">                    \"space:world\"</code><code class=\"codeline\">                })</code><code class=\"codeline\">    {</code><code class=\"codeline\">        float fval;</code><code class=\"codeline\">        vector vval;</code><code class=\"codeline\">        matrix mval;</code><code class=\"codeline\"></code><code class=\"codeline\">        printf(\"----------------- %s ---------------------\\n\", token);</code><code class=\"codeline\">        if (teximport(map, token, fval))</code><code class=\"codeline\">            printf(\"'%s' = %g\\n\", token, fval);</code><code class=\"codeline\">        else if (teximport(map, token, vval))</code><code class=\"codeline\">            printf(\"'%s' = %g\\n\", token, vval);</code><code class=\"codeline\">        else if (teximport(map, token, mval))</code><code class=\"codeline\">            printf(\"'%s' = %g\\n\", token, mval);</code><code class=\"codeline\">    }</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/dsmpixel\">dsmpixel</a></div></body>",
    "texprintf": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texprintf\">texprintf</a></h1><p class=\"summary\">Similar to sprintf, but does expansion of UDIM or UVTILE texture filename expansion.</p><div class=\"usage\"> <code>string texprintf(float u, float v; string format; ...)</code></div><p>Formats a string like <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sprintf\">sprintf</a>, but scans for special conversion\ncharacters to perform either UDIM or UVTILE style filename expansion.</p><p>This can be significantly more efficient than calling sprintf() directly.</p><p>The special conversion sequences are:</p><div class=\"argument\"><code><code>%(UDIM)d</code></code></div><p>The UDIM coordinate, as computed by <code>1000 + int(u)+1 + int(v)*10</code></p><div class=\"argument\"><code><code>%(U)d</code></code></div><p>The UVTILE style u-coordinate (<code>int(u)+1</code>)</p><div class=\"argument\"><code><code>%(V)d</code></code></div><p>The UVTILE style v-coordinate (<code>int(v)+1</code>)</p><div class=\"argument\"><code><code>%(UVTILE)d</code></code></div><p>Expands to both u and v coordinates in the form <code>u%d_v%d</code>.</p><p>The <code>d</code> conversion specifier for texture identification can be modified with\nfield modifiers.  For example <code>%(U)02d</code> or <code>%(V)04d</code>.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">!vex</code><code class=\"codeline\">// Returns \"map_1044.rat</code><code class=\"codeline\">texprintf(3.1, 4.15, \"map_%(UDIM)d.rat\");</code><code class=\"codeline\"></code><code class=\"codeline\">// Returns \"map_04_05.rat\"</code><code class=\"codeline\">texprintf(3.1, 4.15, \"map_%(U)02d_%(V)02d.rat\");</code><code class=\"codeline\"></code><code class=\"codeline\">// Returns \"map_u4_v12.rat\"</code><code class=\"codeline\">texprintf(3.14, 11.5, \"map_u%(U)d_v%(V)d.rat\");</code><code class=\"codeline\"></code><code class=\"codeline\">// Returns \"/path/basename_04_05.rat\"</code><code class=\"codeline\">texprintf(3.1, 4.1, \"%s/%s_%(U)02d_%(V)02d.rat\", \"/path\", \"basename\");</code><code class=\"codeline\"></code><code class=\"codeline\">// Returns \"/path/basename_u04_v05.rat\"</code><code class=\"codeline\">texprintf(3.1, 4.1, \"%s/%s_%(UVTILE)02d.rat\", \"/path\", \"basename\")</code></div><div class=\"codeblock\"><code class=\"codeline\">string map = texprintf(u, v, \"%s/%s_%(UDIM)d.rat\", texture_path, texture_base);</code><code class=\"codeline\">Cf = texture(map, u, v);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/sprintf\">sprintf</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/expand_udim\">expand_udim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texture\">texture</a></div></body>",
    "texture": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texture\">texture</a></h1><p class=\"summary\">Computes a filtered sample of the texture map specified.</p><div class=\"usage\"> <code>vector|vector4 texture(string map, ...)</code></div><p>Samples the texture at the global S and T coordinates from the shading context. These signatures are only available in <a href=\"https://www.sidefx.com/docs/houdini/vex/contexts/shading_contexts\">shading contexts</a>.</p><div class=\"usage\"> <code>vector|vector4 texture(string map, float ss, float tt, ...)</code></div><p>Samples the texture at the given S and T coordinates, using a filter width based on the derivatives of S and T at that point. If you use this function outside a <a href=\"https://www.sidefx.com/docs/houdini/vex/contexts/shading_contexts\">shading context</a>, the filter width will be 0.</p><div class=\"usage\"> <code>vector|vector4 texture(string map, float s0, float t0, float s1, float t1, float s2, float t2, float s3, float t3, ...)</code></div><p>Takes an explicit sampling quadrilateral with corners (s0, t0), (s1, t1), (s2, t2), and (s3, t3).</p><h2>Returns</h2><p>A sampled color value from the texture.</p><p>If you call the function with a <code>vector4</code> return type, the function includes the texture alpha in the fourth component.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/colormap\">colormap</a></div></body>",
    "texture3d": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texture3d\">texture3d</a></h1><p class=\"summary\">Returns the value of the 3d image at the position specified by P.</p><div class=\"usage\"> <code>&lt;type&gt; texture3d(string filename, string channel, vector P, ...)</code></div><p>Returns the value of the 3d image at the position specified by P. If P\nis outside of the bounding box of the image, the value returned will be\n0. If the channel specified contains more values than the return type\n(i.e. a vector channel when a float return type is desired), the first\ncomponent of the vector will be returned. If the channel specified\ncontains fewer values than the return type, the missing components will\nbe filled with the last valid channel.</p><p>Texture files will be searched for in the path specified by the\n<code>HOUDINI_TEXTURE_PATH</code> environment variable.</p><p>You can pass additional arguments to control the evaluation (see\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/colormap\">colormap</a>):</p><span><code>\"filter\"</code> </span><p>Specifies the filter for evaluation.</p><span><code>\"width\"</code> </span><p>Specifies the filter width for evaluation.</p></body>",
    "texture3dBox": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/texture3dBox\">texture3dBox</a></h1><p class=\"summary\">This function queries the 3D texture map specified and returns the\nbounding box information of the file.</p><div class=\"usage\"> <code>void texture3dBox(string filename, string channel; vector &amp;min, vector &amp;max, ...)</code></div><p>Writes the minimum and maximum coordinates of the 3D texture into the vector variables <code>min</code> and <code>max</code>.</p></body>",
    "titlecase": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/titlecase\">titlecase</a></h1><p class=\"summary\">Returns a string that is the titlecase version of the input string.</p><div class=\"usage\"> <code>string titlecase(const string str)</code></div><p>Converts a normal sentence into titlecase. The rules in use are as follows:</p><div class=\"related\">First and last world are always capitalized</div><div class=\"related\">Subtitles are capitalized</div><div class=\"related\">Capitalize all words other than: articles, prepositions, and conjunctions.</div><div class=\"related\">Hyphenated words that are capitalized should have their second part capitalized as well</div><div class=\"related\">Words that already contain capital letters are not modified</div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tolower\">tolower</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/toupper\">toupper</a></div></body>",
    "tolower": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tolower\">tolower</a></h1><p class=\"summary\">Converts all characters in string to lower case</p><div class=\"usage\"> <code>string tolower(const string str)</code></div><p>Returns the string with A-Z replaced with a-z.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/toupper\">toupper</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/titlecase\">titlecase</a></div></body>",
    "toNDC": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/toNDC\">toNDC</a></h1><p class=\"summary\">Transforms a position into normal device coordinates.</p><div class=\"usage\"> <code>vector toNDC(vector point)</code></div><div class=\"usage\"> <code>vector toNDC(string camera_name, vector point)</code></div><p>Transforms a position to the normal device coordinates for a camera.\nThe point should be in the local space of the object (i.e. not in the space of the camera).</p><p>toNDC() will return values above and below the 0-1 range outside the view of the camera or light. To the right of the camera are values of 1+ and to the left are values of 0-. The same goes for the range above and below the camera or light.</p><p>Transforms a position into normal device coordinates. This space is only\nwell-defined for the <a href=\"https://www.sidefx.com/docs/houdini/vex/contexts/shading_contexts\">shading contexts</a>.</p></body>",
    "toupper": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/toupper\">toupper</a></h1><p class=\"summary\">Converts all characters in string to upper case</p><div class=\"usage\"> <code>string toupper(const string str)</code></div><p>Returns the string with a-z replaced with A-Z.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tolower\">tolower</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/titlecase\">titlecase</a></div></body>",
    "trace": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/trace\">trace</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Sends a ray from P along the normalized vector D.</p><div class=\"usage\"> <code>void trace(vector &amp;cv, vector &amp;of, float &amp;af, vector P, vector D, float shadow_bias, float max_contrib, ...)</code></div><p>Sends a ray from <code class=\"var\">P</code> along the normalized vector <code class=\"var\">D</code>. The resulting\n    color, opacity and alpha will be put in the export variables.</p><p><code class=\"var\">shadow_bias</code> is typically a small number which is used to prevent\n    self-shading.</p><p><code class=\"var\">max_contrib</code> controls how much the result of the trace() call will\n    contribute to the resulting pixel color. <code class=\"var\">max_contrib</code> has no effect\n    on the results of the trace() call.</p><div class=\"usage\"> <code>int trace(vector pos, vector dir, float time, ...)</code></div><p>Sends a single ray into the scene at <code>time</code> and retrieves information from the hit surface. A return value of 1 means the ray hit a surface.</p><p>Only the second signature accepts any of the following variadic arguments. The first trace signature is more specific, and is legacy from older versions of mantra.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rayhittest\">rayhittest</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/nodes/vop/raytrace\">vop/raytrace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/reflectlight\">reflectlight</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gather\">gather</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/trace\">trace</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/irradiance\">irradiance</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pathtrace\">pathtrace</a></div></body>",
    "translate": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/translate\">translate</a></h1><p class=\"summary\">Translates a matrix by a vector.</p><div class=\"usage\"> <code>void translate(matrix &amp;m, vector amount)</code></div><div class=\"usage\"> <code>void translate(matrix &amp;m, vector4 amount)</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pretranslate\">pretranslate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prerotate\">prerotate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prescale\">prescale</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rotate\">rotate</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/scale\">scale</a></div></body>",
    "translucent": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/translucent\">translucent</a></h1><p class=\"summary\">Returns a Lambertian translucence BSDF.</p><div class=\"usage\"> <code>bsdf translucent(vector nml, vector ng, ...)</code></div><p>Returns a diffuse BSDF for the transmission direction. This can\n    be used as a cheap alternative to subsurface scattering for thin surfaces,\n    to allow illumination to pass from one side of the object to the other\n    while also broadly diffusing the illumination like diffuse.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/diffuse\">diffuse</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "transpose": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/transpose\">transpose</a></h1><p class=\"summary\">Transposes the given matrix.</p><div class=\"usage\"> <code>void transpose(&lt;matrix&gt; &amp;m)</code></div><div class=\"usage\"> <code>&lt;matrix&gt; transpose(&lt;matrix&gt; m)</code></div><p><a href=\"https://en.wikipedia.org/wiki/Transpose\">Transposes</a> the given matrix.</p></body>",
    "trunc": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/trunc\">trunc</a></h1><p class=\"summary\">Removes the fractional part of a floating point number.</p><div class=\"usage\"> <code>float trunc(float x)</code></div><p>If the argument is negative, this returns <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ceil\">ceil(x)</a>, otherwise it returns\n    <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/floor\">floor(x)</a>.</p><div class=\"usage\"> <code>vector2 trunc(vector2 x)</code></div><div class=\"usage\"> <code>vector trunc(vector x)</code></div><div class=\"usage\"> <code>vector4 trunc(vector4 x)</code></div><p>Returns a new vector with the <code>trunc()</code> of each component.</p></body>",
    "tw_nspace": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tw_nspace\">tw_nspace</a></h1><p class=\"summary\">Transforms a normal vector from Texture to World space.</p><div class=\"usage\"> <code>vector tw_nspace(vector v)</code></div><p>Transforms a normal vector from <em>Texture</em> to <em>World</em> space.</p></body>",
    "tw_space": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tw_space\">tw_space</a></h1><p class=\"summary\">Transforms a position value from Texture to World space.</p><div class=\"usage\"> <code>matrix tw_space()</code></div><div class=\"usage\"> <code>vector tw_space(vector v)</code></div><div class=\"usage\"> <code>vector4 tw_space(vector4 v)</code></div><p>Transforms a position value from <em>Texture</em> to <em>World</em> space.</p></body>",
    "tw_vspace": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/tw_vspace\">tw_vspace</a></h1><p class=\"summary\">Transforms a direction vector from Texture to World space.</p><div class=\"usage\"> <code>vector tw_vspace(vector v)</code></div><p>Transforms a direction vector from <em>Texture</em> to <em>World</em> space.</p></body>",
    "uniqueval": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uniqueval\">uniqueval</a></h1><p class=\"summary\">Returns one of the set of unique values across all values for an int or string attribute.</p><div class=\"usage\"> <code>int|string uniqueval( &lt;geometry&gt;, string attribclass, string attribute_name, int which)</code></div><p>If any points/primitives/vertices in the geometry have the same value for the given attribute, the set of <em>unique</em> values will be smaller than the total number of points/primitives/vertices. This function lets you iterate through the set of unique values.</p><p>This function only works with string and integer attributes.</p><div class=\"argument\"><code>which</code></div><p>Which one of the unique values to return.\n    Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nuniqueval\">nuniqueval</a> to get how many unique values the attribute has.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int count = nuniqueval(0, \"point\", \"foo\");</code><code class=\"codeline\">    for (int i = 0; i &lt; count; i++) {</code><code class=\"codeline\">        string val = uniqueval(0, \"point\", \"foo\", i);</code><code class=\"codeline\">        // ...do something with the value...</code><code class=\"codeline\">    }</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uniquevals\">uniquevals</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nuniqueval\">nuniqueval</a></div></body>",
    "uniquevals": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uniquevals\">uniquevals</a></h1><span class=\"padder\"><span class=\"pillow\">17.0</span></span><p class=\"summary\">Returns the set of unique values across all values for an int or string attribute.</p><div class=\"usage\"> <code>int[] uniquevals( &lt;geometry&gt;, string attribclass, string attribute_name)</code></div><div class=\"usage\"> <code>string[] uniquevals( &lt;geometry&gt;, string attribclass, string attribute_name)</code></div><p>If any points/primitives/vertices in the geometry have the same value for the given attribute, the set of <em>unique</em> values will be smaller than the total number of points/primitives/vertices. This function lets you acquire the set of unique values.</p><p>This function only works with string and integer attributes.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uniqueval\">uniqueval</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/nuniqueval\">nuniqueval</a></div></body>",
    "unpack_intfromsafefloat": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/unpack_intfromsafefloat\">unpack_intfromsafefloat</a></h1><p class=\"summary\">Reverses the packing of pack_inttosafefloat to get back the original integer.</p><div class=\"usage\"> <code>int unpack_intfromsafefloat(float f)</code></div><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pack_inttosafefloat\">pack_inttosafefloat</a></p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pack_inttosafefloat\">pack_inttosafefloat</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xyzdist\">xyzdist</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/intersect\">intersect</a></div></body>",
    "unserialize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/unserialize\">unserialize</a></h1><p class=\"summary\">Turns a flat array of floats into an array of vectors or matrices.</p><div class=\"usage\"> <code>&lt;vector&gt;[]  unserialize(float values[])</code></div><div class=\"usage\"> <code>&lt;matrix&gt;[] unserialize(float values[])</code></div><p>The inverse operation to <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/serialize\">serialize</a>. This operation takes an array of float values\n    and creates a new array of vectors or floats by taking each float and assigning it to the\n    next component of the vector or matrix in the output array. For example:</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">vector v[]</code><code class=\"codeline\">float  f[] = { 1, 2, 3,  7, 8, 9 };</code><code class=\"codeline\"></code><code class=\"codeline\">v = vector(unserialize(f));</code><code class=\"codeline\">// Now v has a length of 2 and contains { {1,2,3}, {7,8,9} }</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/serialize\">serialize</a></div></body>",
    "upush": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/upush\">upush</a></h1><p class=\"summary\">Adds a uniform item to an array.</p><div class=\"usage\"> <code>void upush(&lt;type&gt; &amp;array[]; &lt;type&gt; value)</code></div><p>Pushes a uniform value onto an array for all SIMD processors (regardless of the processor enabled state).</p><p>This is a very specialized function, primarily used to manage light exports in PBR lighting.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/push\">push</a></div></body>",
    "usd_addattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addattrib\">usd_addattrib</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Creates an attribute of a given type on a primitive.</p><div class=\"usage\"> <code>int usd_addattrib(int stagehandle, string primpath, string name, string typename)</code></div><p>This function adds an attribute of a given type to the primitive, if such attribute is not part of a schema. It is useful for controlling the exact type of a custom attribute. For attributes defined by primitive\u2019s schema, this call has no effect, because the schema already determines their type.</p><div class=\"argument\"><code>name</code></div><p>Attribute name.</p><div class=\"argument\"><code>typename</code></div><p>The name or an alias of the type.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success, or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Adds a half-precision float attribute and sets its falue.</code><code class=\"codeline\">usd_addattrib(0, \"/geo/sphere\", \"half_attrib\", \"half3\");</code><code class=\"codeline\">usd_setattrib(0, \"/geo/sphere\", \"half_attrib\", {1.25, 1.50, 1.75});</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setattrib\">usd_setattrib</a></div></body>",
    "usd_addcollectionexclude": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addcollectionexclude\">usd_addcollectionexclude</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Excludes an object from the collection</p><div class=\"usage\"> <code>int usd_addcollectionexclude(int stagehandle, string collectionpath, string path)</code></div><p>This function excludes the object from the collection. This is usually achieved by adding an explicit path to the collection\u2019s exclude list, but it may just remove a path from the collection\u2019s include list, if it\u2019s sufficient.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Exclude sphere3 from cube's collection.</code><code class=\"codeline\">string collection_path = usd_makecollectionpath(0, \"/geo/cube\", \"some_collection\");</code><code class=\"codeline\">usd_addcollectionexclude(0, collection_path, \"/geo/sphere3\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iscollection\">usd_iscollection</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addcollectioninclude\">usd_addcollectioninclude</a></div></body>",
    "usd_addcollectioninclude": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addcollectioninclude\">usd_addcollectioninclude</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Includes an object in the collection</p><div class=\"usage\"> <code>int usd_addcollectioninclude(int stagehandle, string collectionpath, string path)</code></div><p>This function includes the object in the collection. This is usually achieved by adding an explicit path to the collection\u2019s include list, but it may just remove a path from the collection\u2019s exclude list, if it\u2019s sufficient.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Include sphere4 in cube's collection.</code><code class=\"codeline\">string collection_path = usd_makecollectionpath(0, \"/geo/cube\", \"some_collection\");</code><code class=\"codeline\">usd_addcollectioninclude(0, collection_path, \"/geo/sphere4\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iscollection\">usd_iscollection</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addcollectionexclude\">usd_addcollectionexclude</a></div></body>",
    "usd_addinversetotransformorder": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addinversetotransformorder\">usd_addinversetotransformorder</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Appends an inversed transform operation to the primitive\u2019s transform order</p><div class=\"usage\"> <code>int usd_addinversetotransformorder(int stagehandle, string primpath, string name)</code></div><p>This function appends an inversed transformation to the primitive\u2019s transform order.  Transform order is a sequence of transform operations, whose full names are stored in <code>xformOpOrder</code> attribute as a string array.  Thus, this function appends a new operation name to that attribute.</p><p>Inverse transforms are used primary for rotating (or scaling) around a pivot that does not coincide with the origin. The usual practice is to apply a translation to the pivot point, then perform rotation, and finally apply an inverse of the original translation. This function is used for applying the inverse of the original translation.</p><p>NOTE: unlike most VEX functions that deal with primitive transforms and take an operation suffix as a parameter, this function takes the full operation name.  Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformname\">usd_transformname</a> to obtain the full name if you know the suffix.</p><div class=\"argument\"><code>name</code></div><p>The full name of the transform operation. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformname\">usd_transformname</a> to obtain the full name from the operation suffix.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Note, the USD_XFORM_TRANSLATE and USD_AXIS_Z constants used below </code><code class=\"codeline\">// are defined in \"usd.h\" VEX header, so include it.</code><code class=\"codeline\">#include &lt;usd.h&gt;</code><code class=\"codeline\"></code><code class=\"codeline\">// Construct the pivot translation operation suffix and name. </code><code class=\"codeline\">string pivot_xform_suffix = \"some_pivot\";</code><code class=\"codeline\">string pivot_xform_name   = usd_transformname(USD_XFORM_TRANSLATE, pivot_xform_suffix);</code><code class=\"codeline\"></code><code class=\"codeline\">// Rotate about z-axis that goes thru pivot (1,0,0).</code><code class=\"codeline\">usd_addtranslate(0, \"/geo/cone\", pivot_xform_suffix, {1, 0, 0});</code><code class=\"codeline\">usd_addrotate(0, \"/geo/cone\", \"some_rotation\", USD_AXIS_Z, -90);</code><code class=\"codeline\">usd_addinversetotransformorder(0, \"/geo/cone\", pivot_xform_name);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformorder\">usd_transformorder</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addtotransformorder\">usd_addtotransformorder</a></div></body>",
    "usd_addorient": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addorient\">usd_addorient</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Applies a quaternion orientation to the primitive</p><div class=\"usage\"> <code>int usd_addorient(int stagehandle; string primpath; string suffix; vector4 orient)</code></div><p>This function applies a quaternion orientation to the primitive. It creates and sets a value of a transform operation attribute that defines the orientation, and appends it to the primitive\u2019s transform order.</p><div class=\"argument\"><code>orient</code></div><p>The quaternion (in a vector4 format) representing the orientation.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Orient the cube</code><code class=\"codeline\">vector4 quat = eulertoquaternion(radians({30,0,0}), XFORM_XYZ);</code><code class=\"codeline\">usd_addorient(0, \"/dst/cone\", \"my_orientation\", quat);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformorder\">usd_transformorder</a></div></body>",
    "usd_addprim": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addprim\">usd_addprim</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Creates a primitive of a given type.</p><div class=\"usage\"> <code>int usd_addprim(int stagehandle, string primpath, string typename)</code></div><p>This function creates a new primitive of a given type and at a given path, if it one does not exist yet.</p><div class=\"argument\"><code>typename</code></div><p>The name or an alias of the type.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success, or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Adds a sphere primitive.</code><code class=\"codeline\">usd_addprim(0, \"/geo/sphere\", \"Sphere\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div></body>",
    "usd_addprimvar": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addprimvar\">usd_addprimvar</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Creates a primvar of a given type on a primitive.</p><div class=\"usage\"> <code>int usd_addprimvar(int stagehandle, string primpath, string name, string typename)</code></div><div class=\"usage\"> <code>int usd_addprimvar(int stagehandle, string primpath, string name, string typename, string interpolation)</code></div><p>This function adds a primvar of a given type to the primitive, if such primvar is not part of a schema. It is useful for controlling the exact type of a custom primvar. For primvars defined by primitive\u2019s schema, this call has no effect, because the schema already determines their type.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><div class=\"argument\"><code>typename</code></div><p>The name or an alias of the type.</p><div class=\"argument\"><code>interpolation</code></div><p>The name of the interpolation to be used for this primvar (e.g., constant, vertex, faceVarying, etc).</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success, or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Adds a half-precision float primvar and sets its falue.</code><code class=\"codeline\">usd_addprimvar(0, \"/geo/sphere\", \"half_primvar\", \"half3\");</code><code class=\"codeline\">usd_setprimvar(0, \"/geo/sphere\", \"half_primvar\", {1.25, 1.50, 1.75});</code><code class=\"codeline\"></code><code class=\"codeline\">// Adds a color primitive with 'vertex' interpolation.</code><code class=\"codeline\">usd_addprimvar(0, pp, \"color_primvar\", \"color3d[]\", \"vertex\");</code><code class=\"codeline\">usd_setprimvar(0, pp, \"color_primvar\",  vector[](array({1,0,0}, {0,1,0}, {0,0,1})));</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setprimvar\">usd_setprimvar</a></div></body>",
    "usd_addrelationshiptarget": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addrelationshiptarget\">usd_addrelationshiptarget</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Adds a target to the primitive\u2019s relationship</p><div class=\"usage\"> <code>int usd_addrelationshiptarget(int stagehandle; string primpath; string name; string target)</code></div><p>This function adds a target to the primitive\u2019s relationship.</p><div class=\"argument\"><code>name</code></div><p>The relationship name.</p><div class=\"argument\"><code>target</code></div><p>The the target path to add.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Add the sphere to cube's relationship.</code><code class=\"codeline\">usd_addrelationshiptarget(0, \"/geo/cube\", \"relationship_name\", \"/geo/sphere\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isrelationship\">usd_isrelationship</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_removerelationshiptarget\">usd_removerelationshiptarget</a></div></body>",
    "usd_addrotate": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addrotate\">usd_addrotate</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Applies a rotation to the primitive</p><div class=\"usage\"> <code>int usd_addrotate(int stagehandle; string primpath; string suffix; int axis; float angle)</code></div><div class=\"usage\"> <code>int usd_addrotate(int stagehandle; string primpath; string suffix; int xyz; vector angles)</code></div><p>This function applies a rotation to the primitive. It creates and sets a value of a transform operation attribute that defines the rotation, and appends it to the primitive\u2019s transform order.</p><div class=\"argument\"><code>axis</code></div><p>The numeric code for the rotation axis. See the usd.h VEX header for definitions of the axis.</p><div class=\"argument\"><code>angle</code></div><p>Angle of rotation in degrees, when rotating around a single principle axis.</p><div class=\"argument\"><code>axis</code></div><p>The numeric code for the axis rotation order. See the usd.h VEX header for definitions of the order.</p><div class=\"argument\"><code>angles</code></div><p>Three angles of rotation in degrees, when rotating sequentially around each of the principle axes.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Include \"usd.h\" that defines axis and order constants.</code><code class=\"codeline\">#include &lt;usd.h&gt;</code><code class=\"codeline\"></code><code class=\"codeline\">// Rotate the cube 30 degrees around the z-axis.</code><code class=\"codeline\">usd_addrotate(0, \"/geo/cube\", \"\", USD_AXIS_Z, 30);</code><code class=\"codeline\"></code><code class=\"codeline\">// Rotate the mesh 45 degrees counter-clock wise around the y-axis.</code><code class=\"codeline\">usd_addrotate(0, \"/geo/mesh\", \"geo_rotation\", USD_AXIS_Y, -45);</code><code class=\"codeline\"></code><code class=\"codeline\">// Rotate the cone about Euler angles.</code><code class=\"codeline\">usd_addrotate(0, \"/geo/cone\", \"cone_rotation\", USD_ROTATE_XYZ, {0, 30, 45});</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformorder\">usd_transformorder</a></div></body>",
    "usd_addscale": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addscale\">usd_addscale</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Applies a scale to the primitive</p><div class=\"usage\"> <code>int usd_addscale(int stagehandle; string primpath; string suffix; vector scale)</code></div><p>This function applies a scale to the primitive. It creates and sets a value of a transform operation attribute that defines the scale, and appends it to the primitive\u2019s transform order.</p><div class=\"argument\"><code>scale</code></div><p>The the scale factors along each of the principle axes.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Scale the cube</code><code class=\"codeline\">usd_addscale(0, \"/geo/cube\", \"my_scale\", {0.25, 0.5, 2});</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformorder\">usd_transformorder</a></div></body>",
    "usd_addtotransformorder": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addtotransformorder\">usd_addtotransformorder</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Appends a transform operation to the primitive\u2019s transform order</p><div class=\"usage\"> <code>int usd_addtotransformorder(int stagehandle, string primpath, string name)</code></div><p>This function appends a transformation to the primitive\u2019s transform order.  Transform order is a sequence of transform operations, whose full names are stored in <code>xformOpOrder</code> attribute as a string array.  Thus, this function appends a new operation name to that attribute.</p><p>NOTE: unlike most VEX functions that deal with primitive transforms and take an operation suffix as a parameter, this function takes the full operation name.  Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformname\">usd_transformname</a> to obtain the full name if you know the suffix.</p><div class=\"argument\"><code>name</code></div><p>The full name of the transform operation. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformname\">usd_transformname</a> to obtain the full name from the operation suffix.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Note, the USD_XFORM_TRANSLATE and USD_AXIS_Z constants used below </code><code class=\"codeline\">// are defined in \"usd.h\" VEX header, so include it.</code><code class=\"codeline\">#include &lt;usd.h&gt;</code><code class=\"codeline\"></code><code class=\"codeline\">// Make the first step (i.e., translate)</code><code class=\"codeline\">string step_suffix = \"step\";</code><code class=\"codeline\">usd_addtranslate(0, \"/geo/cone\", step_suffix, {1, 0, 0});</code><code class=\"codeline\"></code><code class=\"codeline\">// Now repeat the same step translation by adding it to the transform order</code><code class=\"codeline\">string step_name   = usd_transformname(USD_XFORM_TRANSLATE, step_suffix);</code><code class=\"codeline\">usd_addrotate(0, \"/geo/cone\", \"first_rotation\", USD_AXIS_Z, -30);</code><code class=\"codeline\">usd_addtotransformorder(0, \"/geo/cone\", step_name);</code><code class=\"codeline\">usd_addrotate(0, \"/geo/cone\", \"second_rotation\", USD_AXIS_Z, 45);</code><code class=\"codeline\">usd_addtotransformorder(0, \"/geo/cone\", step_name);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformorder\">usd_transformorder</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addinversetotransformorder\">usd_addinversetotransformorder</a></div></body>",
    "usd_addtransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addtransform\">usd_addtransform</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Applies a transformation to the primitive</p><div class=\"usage\"> <code>int usd_addtransform(int stagehandle; string primpath; string suffix; matrix xform)</code></div><p>This function applies a transformation to the primitive. It creates and sets a value of a transform operation attribute that defines the transformation, and appends it to the primitive\u2019s transform order.</p><div class=\"argument\"><code>xform</code></div><p>The the matrix that encodes the space transformation.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Transform the cube.</code><code class=\"codeline\">#include &lt;math.h&gt;</code><code class=\"codeline\">matrix xform = maketransform(XFORM_SRT, XFORM_XYZ, {1,2,3}, {3,45,60}, {0.5,0.25,2});</code><code class=\"codeline\">usd_addtransform(0, \"/geo/cube\", \"my_xform\", xform);</code></div><div class=\"codeblock\"><code class=\"codeline\">// Get the cube's world transform.</code><code class=\"codeline\">matrix xform = usd_worldtransform(0, \"/src/cube\");</code><code class=\"codeline\"></code><code class=\"codeline\">// Match the cone's spacial location to the cube.</code><code class=\"codeline\">// First need to clear current transforms on the cube,</code><code class=\"codeline\">// and also need to block the transform inheritance from the parent.</code><code class=\"codeline\">usd_cleartransformorder(0, \"/dst/cone\");</code><code class=\"codeline\">usd_settransformreset(0, \"/dst/cone\", 1);</code><code class=\"codeline\">usd_addtransform(0, \"/dst/cone\", \"\", xform);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformorder\">usd_transformorder</a></div></body>",
    "usd_addtranslate": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addtranslate\">usd_addtranslate</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Applies a translation to the primitive</p><div class=\"usage\"> <code>int usd_addtranslate(int stagehandle; string primpath; string suffix; vector amount)</code></div><p>This function applies a translation to the primitive. It creates and sets a value of a transform operation attribute that defines the translation, and appends it to the primitive\u2019s transform order.</p><div class=\"argument\"><code>amount</code></div><p>The the distance to move along each of the principle axes.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Translate the cube</code><code class=\"codeline\">usd_addtranslate(0, \"/geo/cube\", \"my_translation\", {10, 0, -2.5});</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformorder\">usd_transformorder</a></div></body>",
    "usd_attrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attrib\">usd_attrib</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Reads the value of an attribute from the USD primitive.</p><div class=\"usage\"> <code>&lt;type&gt; usd_attrib(&lt;stage&gt;; string primpath; string name)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] usd_attrib(&lt;stage&gt;; string primpath; string name)</code></div><div class=\"usage\"> <code>&lt;type&gt; usd_attrib(&lt;stage&gt;; string primpath; string name; float timecode)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] usd_attrib(&lt;stage&gt;; string primpath; string name; float timecode)</code></div><p>This function returns a value of a given attribute on a given primitive.</p><div class=\"argument\"><code>name</code></div><p>Attribute name.</p><h2>Returns</h2><p>The value of an existing attribute, or zero/empty value if the attribute does not exist. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a> if you want to check whether the attribute exists.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the value of some attributes on the cube primitive.</code><code class=\"codeline\">float a = usd_attrib(\"opinput:0\", \"/geo/cube\", \"attribute_name_a\");</code><code class=\"codeline\">vector b[] = usd_attrib(0, \"/geo/cube\", \"attribute_name_b\");</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the value of attribute \"bar\" at various time codes.</code><code class=\"codeline\">f[]@b_at_current_frame = usd_attrib(0, \"/geo/sphere\", \"bar\");</code><code class=\"codeline\">f[]@b_at_frame_7       = usd_attrib(0, \"/geo/sphere\", \"bar\", 7.0);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attribtypename\">usd_attribtypename</a></div></body>",
    "usd_attribelement": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attribelement\">usd_attribelement</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Reads the value of an element from an array attribute.</p><div class=\"usage\"> <code>&lt;type&gt; usd_attribelement(&lt;stage&gt;; string primpath; string name; int index)</code></div><div class=\"usage\"> <code>&lt;type&gt; usd_attribelement(&lt;stage&gt;; string primpath; string name; int index; float timecode)</code></div><p>This function returns a value of an element in given array attribute on a given primitive.</p><div class=\"argument\"><code>name</code></div><p>Attribute name.</p><div class=\"argument\"><code>index</code></div><p>The element index in the array attribute. </p><h2>Returns</h2><p>The value of an element in an existing attribute, or zero/empty value if the attribute does not exist. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a> if you want to check whether the attribute exists.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the value of an element at index 3 in the array attribute.</code><code class=\"codeline\">float a = usd_attribelement(\"opinput:0\", \"/geo/cube\", \"array_attrib_name\", 3);</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the value of an element at index 2 of the \"bar\" array attribute.</code><code class=\"codeline\">@b_element_2_at_current_frame = usd_attribelement(0, \"/geo/sphere\", \"bar\", 2);</code><code class=\"codeline\">@b_element_2_at_frame_11      = usd_attribelement(0, \"/geo/sphere\", \"bar\", 2, 11.0);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attrib\">usd_attrib</a></div></body>",
    "usd_attriblen": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attriblen\">usd_attriblen</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Returns the length of the array attribute.</p><div class=\"usage\"> <code>int usd_attriblen(&lt;stage&gt;; string primpath; string name)</code></div><div class=\"usage\"> <code>int usd_attriblen(&lt;stage&gt;; string primpath; string name; float timecode)</code></div><p>This function returns the length of a given attribute.</p><p>For array attributes it is the length of the array, and for non-array attributes the length is 1.</p><div class=\"argument\"><code>name</code></div><p>Attribute name.</p><h2>Returns</h2><p>The length of the array attribute, or 1 if the attribute is not an array. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isarray\">usd_isarray</a> if you want to check whether the attribute is an array.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the array length of an attribute on the cube primitive.</code><code class=\"codeline\">int length = usd_attriblen(0, \"/geo/cube\", \"attribute_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isarray\">usd_isarray</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attrib\">usd_attrib</a></div></body>",
    "usd_attribnames": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attribnames\">usd_attribnames</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Returns the names of the attributes available on the primitive.</p><div class=\"usage\"> <code>string[] usd_attribnames(&lt;stage&gt;, string primpath)</code></div><p>This function returns the attribute names that are available on the given primitive.</p><h2>Returns</h2><p>String array containing the names of the primitive\u2019s attributes.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the attribute names from the primitive.</code><code class=\"codeline\">string attrib_names[] = usd_attribnames(0, \"/geo/sphere\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div></body>",
    "usd_attribsize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attribsize\">usd_attribsize</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Returns the tuple size of the attribute.</p><div class=\"usage\"> <code>int usd_attribsize(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns the tuple size of a given attribute. If the attribute is an array, it returns the tuple size of the array element. E.g., for vector types,this is the number of components.</p><div class=\"argument\"><code>name</code></div><p>Attribute name.</p><h2>Returns</h2><p>The tuple size of the attribute. </p><div class=\"related\">For a vector type, this is the number of components.</div><div class=\"related\">For an integer, float, or string, this returns <code>1</code>.</div><div class=\"related\">For an array attribute, this returns the tuple size of the elements.</div><p>If the attribute does not exist, returns <code>0</code>.</p><p>Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attriblen\">usd_attriblen</a> if you want to obtain the array attribute length.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the tuple size of an attribute on the cube primitive.</code><code class=\"codeline\">int tuple_size = usd_attribsize(0, \"/geo/cube\", \"attribute_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attriblen\">usd_attriblen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attrib\">usd_attrib</a></div></body>",
    "usd_attribtimesamples": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attribtimesamples\">usd_attribtimesamples</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the time codes at which the attribute values are authored.</p><div class=\"usage\"> <code>float[] usd_attribtimesamples(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns an array of time codes at which the attribute values are\nauthored.</p><div class=\"argument\"><code>name</code></div><p>Attribute name.</p><h2>Returns</h2><p>The array of time codes at which the attribute values are authored, or an empty array if the attribute does not exist or has no time samples.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the time codes of a foo attribute.</code><code class=\"codeline\">float time_codes[] = usd_attribtimesamples(0, \"/geo/cube\", \"foo\");</code></div><div class=\"codeblock\"><code class=\"codeline\">// Get attribute values at authored time samples.</code><code class=\"codeline\">float[] usd_attribtimesamplevalues(const int input; const string primpath, attribname)</code><code class=\"codeline\">{</code><code class=\"codeline\">    float result[];</code><code class=\"codeline\"></code><code class=\"codeline\">    float time_samples[] = usd_attribtimesamples( input, primpath, attribname );</code><code class=\"codeline\">    foreach( float time_code ; time_samples ) </code><code class=\"codeline\">    {</code><code class=\"codeline\">        float value = usd_attrib( input, primpath, attribname, time_code );</code><code class=\"codeline\">        push( result, value );</code><code class=\"codeline\">    }</code><code class=\"codeline\"></code><code class=\"codeline\">    return result;</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attrib\">usd_attrib</a></div></body>",
    "usd_attribtypename": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attribtypename\">usd_attribtypename</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Returns the name of the attribute type.</p><div class=\"usage\"> <code>string usd_attribtypename(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns the attribute type name, as it is known to the USD value type registry. E.g., float, vector3d, double3<a href=\"https://www.sidefx.com/docs/houdini\"></a>, etc.</p><div class=\"argument\"><code>name</code></div><p>Attribute name.</p><h2>Returns</h2><p>The attribute type name used in the value type registry.  E.g., float, vector3d, double3<a href=\"https://www.sidefx.com/docs/houdini\"></a>, etc.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the type name of the attribute.</code><code class=\"codeline\">string type_name = usd_attribtypename(0, \"/geo/cube\", \"attribute_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attrib\">usd_attrib</a></div></body>",
    "usd_blockattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_blockattrib\">usd_blockattrib</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Blocks the attribute.</p><div class=\"usage\"> <code>int usd_blockattrib(int stagehandle, string primpath, string name)</code></div><p>This function blocks the attribute. I.e., removes all time samples and sets the <em>block</em> as default value.</p><div class=\"argument\"><code>name</code></div><p>Attribute name.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success, or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Block the attribute.</code><code class=\"codeline\">usd_blockattrib(0, \"/geo/sphere\", \"attribute_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setattrib\">usd_setattrib</a></div></body>",
    "usd_blockprimvar": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_blockprimvar\">usd_blockprimvar</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Blocks the primvar.</p><div class=\"usage\"> <code>int usd_blockprimvar(int stagehandle, string primpath, string name)</code></div><p>This function blocks the primvar. I.e., removes all time samples and sets the <em>block</em> as default value.</p><p>Note, if primvar is indexed, you may also want to block the indices with\n<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_blockprimvarindices\">usd_blockprimvarindices</a>.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success, or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Block the primvar.</code><code class=\"codeline\">usd_blockprimvar(0, \"/geo/sphere\", \"primvar_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_blockprimvarindices\">usd_blockprimvarindices</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setprimvar\">usd_setprimvar</a></div></body>",
    "usd_blockprimvarindices": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_blockprimvarindices\">usd_blockprimvarindices</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Blocks the primvar.</p><div class=\"usage\"> <code>int usd_blockprimvarindices(int stagehandle, string primpath, string name)</code></div><p>This function blocks the primvar indices. I.e., removes all time samples and sets the <em>block</em> as default value. It changes the indexed primvar into a non-indexed primvar.</p><p>Note, you may also want to block the primvar itself with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_blockprimvar\">usd_blockprimvar</a>.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success, or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Block the primvar indices.</code><code class=\"codeline\">usd_blockprimvarindices(0, \"/geo/sphere\", \"primvar_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_blockprimvar\">usd_blockprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setprimvarindices\">usd_setprimvarindices</a></div></body>",
    "usd_blockrelationship": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_blockrelationship\">usd_blockrelationship</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Blocks the primitive\u2019s relationship</p><div class=\"usage\"> <code>int usd_blockrelationship(int stagehandle; string primpath; string name)</code></div><p>This function blocks the primitive\u2019s relationship, i.e., clears the targets from the relationship.</p><div class=\"argument\"><code>name</code></div><p>The relationship name.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Clear the the cube's relationship.</code><code class=\"codeline\">usd_blockrelationship(0, \"/geo/cube\", \"relationship_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isrelationship\">usd_isrelationship</a></div></body>",
    "usd_boundmaterialpath": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_boundmaterialpath\">usd_boundmaterialpath</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the material path bound to a given primitive.</p><div class=\"usage\"> <code>string usd_boundmaterialpath(&lt;stage&gt;, string primpath)</code></div><p>This function returns the material path for the given primitive. May return an\nempty string if no material is bound.</p><h2>Returns</h2><p>The material bound to the given primitive.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the sphere primitive's material.</code><code class=\"codeline\">string matpath = usd_boundmaterialpath(0, \"/geo/sphere\");</code></div></body>",
    "usd_childnames": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_childnames\">usd_childnames</a></h1><span class=\"padder\"><span class=\"pillow\">19.5</span></span><p class=\"summary\">Returns the names of the primitive\u2019s children.</p><div class=\"usage\"> <code>string[] usd_childnames(&lt;stage&gt;, string primpath)</code></div><p>This function returns the names of the children authored directly in the namespace of the given parent primitive.</p><h2>Returns</h2><p>The names of the children of the given primitive.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the children of the \"mother\" primitive.</code><code class=\"codeline\">string children[] = usd_child(0, \"/geo/mother\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attributenames\">usd_attributenames</a></div></body>",
    "usd_clearmetadata": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_clearmetadata\">usd_clearmetadata</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Clears the value of the metadata.</p><div class=\"usage\"> <code>int usd_clearmetadata(int stagehandle, string path, string name)</code></div><p>This function clears the value of the given metadata.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success, or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Clear the metadata value.</code><code class=\"codeline\">usd_clearmetadata(0, \"/geo/sphere\", \"customData:some_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_ismetadata\">usd_ismetadata</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_metadata\">usd_metadata</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setmetadata\">usd_setmetadata</a></div></body>",
    "usd_cleartransformorder": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_cleartransformorder\">usd_cleartransformorder</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Clears the primitive\u2019s transform order</p><div class=\"usage\"> <code>int usd_cleartransformorder(int stagehandle, string primpath)</code></div><p>This function clears the primitive\u2019s transform order.  Transform order is a sequence of transform operations, whose full names are stored in <code>xformOpOrder</code> attribute as a string array.  Thus, this function clears that attribute.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">usd_cleartransformorder(0, \"/geo/cone\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformorder\">usd_transformorder</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addinversetotransformorder\">usd_addinversetotransformorder</a></div></body>",
    "usd_collectioncomputedpaths": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_collectioncomputedpaths\">usd_collectioncomputedpaths</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Obtains the list of all objects that belong to the collection</p><div class=\"usage\"> <code>string[] usd_collectioncomputedpaths(&lt;stage&gt;, string collectionpath)</code></div><p>This function returns the list of all objects that belong to the given collection.</p><h2>Returns</h2><p>The list of all objects that belong to the given collection.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get all objects in cube's collection.</code><code class=\"codeline\">string collection_path = usd_makecollectionpath(0, \"/geo/cube\", \"some_collection\");</code><code class=\"codeline\">string members[] = usd_collectioncomputedpaths(0, collection_path);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iscollection\">usd_iscollection</a></div></body>",
    "usd_collectioncontains": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_collectioncontains\">usd_collectioncontains</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Checks if an object path belongs to the collection</p><div class=\"usage\"> <code>int usd_collectioncontains(&lt;stage&gt;, string collectionpath, string path)</code></div><p>This function returns <code>1</code> if the given objects belongs to the collection, otherwise returns <code>0</code>.</p><h2>Returns</h2><p><code>1</code> if the given objects belongs to the collection, otherwise returns <code>0</code>.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if sphere3 is in cube's collection.</code><code class=\"codeline\">string collection_path = usd_makecollectionpath(0, \"/geo/cube\", \"some_collection\");</code><code class=\"codeline\">int contains_sphere3 = usd_collectioncontains(0, collection_path, \"/geo/sphere3\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iscollection\">usd_iscollection</a></div></body>",
    "usd_collectionexcludes": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_collectionexcludes\">usd_collectionexcludes</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Obtains the object paths that are in the collection\u2019s exclude list</p><div class=\"usage\"> <code>string[] usd_collectionexcludes(&lt;stage&gt;, string collectionpath)</code></div><p>This function returns the collection\u2019s exclude list. </p><h2>Returns</h2><p>The collection\u2019s exclude list. </p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get collection's exclude list.</code><code class=\"codeline\">string collection_path = usd_makecollectionpath(0, \"/geo/cube\", \"some_collection\");</code><code class=\"codeline\">string exclude_list[]  = usd_collectionexcludes(0, collection_path);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iscollection\">usd_iscollection</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_collectionincludes\">usd_collectionincludes</a></div></body>",
    "usd_collectionexpansionrule": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_collectionexpansionrule\">usd_collectionexpansionrule</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Obtains the collection\u2019s expansion rule</p><div class=\"usage\"> <code>string usd_collectionexpansionrule(&lt;stage&gt;, string collectionpath)</code></div><p>This function returns the collection\u2019s expansion rule. </p><div class=\"argument\"><code>USD supports a few standard expansion rules</code></div><div class=\"related\"><code>explicitOnly</code> - only paths in the include list and not in the exclude list belong to the collection</div><div class=\"related\"><code>expandPrims</code> - all the primitives at or below the includes (but not excludes) belong to the collection</div><div class=\"related\"><code>expanPrimsAndProperties</code> - like <code>expandPrims</code> but also includes properties of matched primitives</div><h2>Returns</h2><p>The collection\u2019s expansion rule.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get collection's expansion rule.</code><code class=\"codeline\">string collection_path = usd_makecollectionpath(0, \"/geo/cube\", \"some_collection\");</code><code class=\"codeline\">string expansion_rule  = usd_collectionexpansionrule(0, collection_path);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iscollection\">usd_iscollection</a></div></body>",
    "usd_collectionincludes": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_collectionincludes\">usd_collectionincludes</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Obtains the object paths that are in the collection\u2019s include list</p><div class=\"usage\"> <code>string[] usd_collectionincludes(&lt;stage&gt;, string collectionpath)</code></div><p>This function returns the collection\u2019s include list. </p><h2>Returns</h2><p>The collection\u2019s include list. </p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get collection's include list.</code><code class=\"codeline\">string collection_path = usd_makecollectionpath(0, \"/geo/cube\", \"some_collection\");</code><code class=\"codeline\">string include_list[]  = usd_collectionincludes(0, collection_path);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iscollection\">usd_iscollection</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_collectionexcludes\">usd_collectionexcludes</a></div></body>",
    "usd_drawmode": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_drawmode\">usd_drawmode</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Returns the primitive\u2019s draw mode.</p><div class=\"usage\"> <code>string usd_drawmode(&lt;stage&gt;, string primpath)</code></div><p>This function returns the given primitive\u2019s draw mode, eg, default, origin, bounds, etc.</p><h2>Returns</h2><p>The draw mode of the given primitive.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the cube's draw mode, eg, \"default\", \"bounds\", etc.</code><code class=\"codeline\">string draw_mode = usd_drawmode(0, \"/geo/cube\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setdrawmode\">usd_setdrawmode</a></div></body>",
    "usd_findtransformname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_findtransformname\">usd_findtransformname</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Retrurns primitive\u2019s transform operation full name for given the transform operation suffix</p><div class=\"usage\"> <code>string usd_findtransformname(&lt;stage&gt;, string primpath, string suffix)</code></div><p>This function returns the full name of a transform operation given the suffix, if such an operation attribute exists on the given primitive.</p><h2>Returns</h2><p>The full name of the primitive\u2019s transform operation that has the given suffix, or an empty string if no such operation is found.</p><p>There may be a few transform operations with the same suffix (eg, a translation an a rotation), so the first encountered one will be returned.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Find the transform operation name for the pivot translation, and add an iverse of it.</code><code class=\"codeline\">string xform_name = usd_findtransformname(0, \"/geo/cone\", \"cone_pivot\");</code><code class=\"codeline\">usd_addinversetotransformorder(0, \"/geo/cone\", xform_name);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformorder\">usd_transformorder</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addinversetotransformorder\">usd_addinversetotransformorder</a></div></body>",
    "usd_flattenediprimvar": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_flattenediprimvar\">usd_flattenediprimvar</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Reads the value of a flattened primvar directly from the USD primitive or from USD primitive\u2019s ancestor.</p><div class=\"usage\"> <code>&lt;type&gt;[] usd_flattenediprimvar(&lt;stage&gt;; string primpath; string name)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] usd_flattenediprimvar(&lt;stage&gt;; string primpath; string name; float timecode)</code></div><p>This function returns a value of a flattened primvar on a given primitive or inherited from primitive\u2019s ancestor.</p><p>Some primvars can be indexed, where the primvar is a compacted array of unique values, and there is an index array to map an entity to the value element. This function expands the compacted array by using the index array, and returns the expanded array of values.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The flattened value of an existing primvar, or zero/empty value if the primvar does not exist. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isiprimvar\">usd_isiprimvar</a> if you want to check whether the primvar exists.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the value of a flattened primvar on the cube primitive or cube's ancestor.</code><code class=\"codeline\">float flat_values[] = usd_flattenediprimvar(0, \"/geo/cube\", \"primvar_name\");</code><code class=\"codeline\"></code><code class=\"codeline\">f[]@flat_primvar_at_current_frame = usd_flattenediprimvar(0, \"/geo/sphere\", \"bar\");</code><code class=\"codeline\">f[]@flat_primvar_at_frame_7       = usd_flattenediprimvar(0, \"/geo/sphere\", \"bar\", 7.0);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_flattenedprimvar\">usd_flattenedprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isindexediprimvar\">usd_isindexediprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarindices\">usd_iprimvarindices</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvar\">usd_iprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvartypename\">usd_iprimvartypename</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_flattenediprimvarelement\">usd_flattenediprimvarelement</a></div></body>",
    "usd_flattenediprimvarelement": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_flattenediprimvarelement\">usd_flattenediprimvarelement</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Reads an element value of a flattened array primvar directly from the USD primitive or from its ancestor.</p><div class=\"usage\"> <code>&lt;type&gt; usd_flattenediprimvarelement(&lt;stage&gt;; string primpath; string name; int index)</code></div><div class=\"usage\"> <code>&lt;type&gt; usd_flattenediprimvarelement(&lt;stage&gt;; string primpath; string name; int index; float timecode)</code></div><p>This function returns a value of an element of a flattened array primvar on a given primitive or inherited from primitive\u2019s ancestor.</p><p>Some primvars can be indexed, where the primvar is a compacted array of unique values, and there is an index array to map an entity to the value element. This function expands the compacted array by using the index array, and returns element value from the expanded array at a given index.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><div class=\"argument\"><code>index</code></div><p>The index into the expanded array. </p><h2>Returns</h2><p>The element of a flattened value array of an existing primvar, or zero/empty value if the primvar does not exist. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isiprimvar\">usd_isiprimvar</a> if you want to check whether the primvar exists.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the value of a flattened primvar on the cube primitive or cube's ancestor.</code><code class=\"codeline\">float flat_value    = usd_flattenediprimvarelement(0, \"/geo/cube\", \"primvar_name\", 3);</code><code class=\"codeline\"></code><code class=\"codeline\">f@flat_primvar_element_10_at_current_frame = usd_flattenediprimvarelement(0, \"/geo/sphere\", \"bar\", 10);</code><code class=\"codeline\">f@flat_primvar_element_10_at_frame_7       = usd_flattenediprimvarelement(0, \"/geo/sphere\", \"bar\", 10, 7.0);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_flattenediprimvar\">usd_flattenediprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_flattenedprimvarelement\">usd_flattenedprimvarelement</a></div></body>",
    "usd_flattenedprimvar": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_flattenedprimvar\">usd_flattenedprimvar</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Reads the value of an flattened primvar directly from the USD primitive.</p><div class=\"usage\"> <code>&lt;type&gt;[] usd_flattenedprimvar(&lt;stage&gt;; string primpath; string name)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] usd_flattenedprimvar(&lt;stage&gt;; string primpath; string name; float timecode)</code></div><p>This function returns a value of a flattened primvar on a given primitive.</p><p>Some primvars can be indexed, where the primvar is a compacted array of unique values, and there is an index array to map an entity to the value element. This function expands the compacted array by using the index array, and returns the expanded array of values.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The flattened value of an existing primvar, or zero/empty value if the primvar does not exist. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a> if you want to check whether the primvar exists.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the value of a flattened primvar on the cube primitive.</code><code class=\"codeline\">float flat_values[] = usd_flattenedprimvar(0, \"/geo/cube\", \"primvar_name\");</code><code class=\"codeline\"></code><code class=\"codeline\">f[]@flat_primvar_at_current_frame = usd_flattenedprimvar(0, \"/geo/sphere\", \"bar\");</code><code class=\"codeline\">f[]@flat_primvar_at_frame_7       = usd_flattenedprimvar(0, \"/geo/sphere\", \"bar\", 7.0);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_flattenediprimvar\">usd_flattenediprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isindexedprimvar\">usd_isindexedprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarindices\">usd_primvarindices</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvar\">usd_primvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvartypename\">usd_primvartypename</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_flattenedprimvarelement\">usd_flattenedprimvarelement</a></div></body>",
    "usd_flattenedprimvarelement": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_flattenedprimvarelement\">usd_flattenedprimvarelement</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Reads an element value of a flattened array primvar directly from a USD primitive.</p><div class=\"usage\"> <code>&lt;type&gt; usd_flattenedprimvarelement(&lt;stage&gt;; string primpath; string name; int index)</code></div><div class=\"usage\"> <code>&lt;type&gt; usd_flattenedprimvarelement(&lt;stage&gt;; string primpath; string name; int index; float timecode)</code></div><p>This function returns a value of an element of a flattened array primvar on a given primitive.</p><p>Some primvars can be indexed, where the primvar is a compacted array of unique values, and there is an index array to map an entity to the value element. This function expands the compacted array by using the index array, and returns element value from the expanded array at a given index.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><div class=\"argument\"><code>index</code></div><p>The index into the expanded array. </p><h2>Returns</h2><p>The element of a flattened value array of an existing primvar, or zero/empty value if the primvar does not exist. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a> if you want to check whether the primvar exists.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the value of a flattened primvar on the cube primitive.</code><code class=\"codeline\">float flat_value    = usd_flattenedprimvarelement(0, \"/geo/cube\", \"primvar_name\", 3);</code><code class=\"codeline\"></code><code class=\"codeline\">f@flat_primvar_element_10_at_current_frame = usd_flattenedprimvarelement(0, \"/geo/sphere\", \"bar\", 10);</code><code class=\"codeline\">f@flat_primvar_element_10_at_frame_7       = usd_flattenedprimvarelement(0, \"/geo/sphere\", \"bar\", 10, 7.0);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_flattenediprimvarelement\">usd_flattenediprimvarelement</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_flattenedprimvar\">usd_flattenedprimvar</a></div></body>",
    "usd_getbbox": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox\">usd_getbbox</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Sets two vectors to the minimum and maximum corners of the bounding box for the primitive.</p><div class=\"usage\"> <code>int usd_getbbox(&lt;stage&gt;, string primpath, string purpose, vector &amp;min, vector &amp;max)</code></div><p>This function returns primitive\u2019s axis-aligned bounding box. The point corresponding to the minimum corner of the bounding box will be returned in min, while the maximum will be in max. Always returns 1. </p><div class=\"argument\"><code>purpose</code></div><p>The primitive\u2019s purpose for which to return the bounding box (e.g., render).</p><h2>Returns</h2><p>Always 1.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the sphere's bounding box.</code><code class=\"codeline\">vector min, max;</code><code class=\"codeline\">usd_getbbox(0, \"/src/sphere\", \"render\", min, max);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbounds\">usd_getbounds</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_center\">usd_getbbox_center</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_size\">usd_getbbox_size</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_min\">usd_getbbox_min</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_max\">usd_getbbox_max</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_relbox\">usd_relbox</a></div></body>",
    "usd_getbbox_center": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_center\">usd_getbbox_center</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the center of the bounding box for the primitive.</p><div class=\"usage\"> <code>vector usd_getbbox_center(&lt;stage&gt;, string primpath, string purpose)</code></div><p>Computes the center of the bounding box for the geometry.</p><div class=\"argument\"><code>purpose</code></div><p>The primitive\u2019s purpose for which to return the bounding box center (e.g., render).</p><h2>Returns</h2><p>The center of the primitive\u2019s bounding box.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the center of the sphere's bounding box.</code><code class=\"codeline\">vector center = usd_getbbox_center(0, \"/src/sphere\", \"render\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbounds\">usd_getbounds</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox\">usd_getbbox</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_size\">usd_getbbox_size</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_min\">usd_getbbox_min</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_max\">usd_getbbox_max</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_relbox\">usd_relbox</a></div></body>",
    "usd_getbbox_max": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_max\">usd_getbbox_max</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the maximum of the bounding box for the primitive.</p><div class=\"usage\"> <code>vector usd_getbbox_max(&lt;stage&gt;, string primpath, string purpose)</code></div><p>Computes the maximum of the bounding box for the geometry.</p><div class=\"argument\"><code>purpose</code></div><p>The primitive\u2019s purpose for which to return the bounding box (e.g., render).</p><h2>Returns</h2><p>The maximum point of the primitive\u2019s bounding box.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the sphere's bounding box.</code><code class=\"codeline\">vector max = usd_getbbox_max(0, \"/src/sphere\", \"render\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbounds\">usd_getbounds</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox\">usd_getbbox</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_center\">usd_getbbox_center</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_size\">usd_getbbox_size</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_min\">usd_getbbox_min</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_relbox\">usd_relbox</a></div></body>",
    "usd_getbbox_min": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_min\">usd_getbbox_min</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the minimum of the bounding box for the primitive.</p><div class=\"usage\"> <code>vector usd_getbbox_min(&lt;stage&gt;, string primpath, string purpose)</code></div><p>Computes the minimum of the bounding box for the geometry.</p><div class=\"argument\"><code>purpose</code></div><p>The primitive\u2019s purpose for which to return the bounding box (e.g., render).</p><h2>Returns</h2><p>The minimum point of the primitive\u2019s bounding box.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the sphere's bounding box.</code><code class=\"codeline\">vector min = usd_getbbox_min(0, \"/src/sphere\", \"render\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbounds\">usd_getbounds</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox\">usd_getbbox</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_center\">usd_getbbox_center</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_size\">usd_getbbox_size</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_max\">usd_getbbox_max</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_relbox\">usd_relbox</a></div></body>",
    "usd_getbbox_size": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_size\">usd_getbbox_size</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the size of the bounding box for the primitive.</p><div class=\"usage\"> <code>vector usd_getbbox_size(&lt;stage&gt;, string primpath, string purpose)</code></div><p>Computes the size of the bounding box for the geometry.</p><div class=\"argument\"><code>purpose</code></div><p>The primitive\u2019s purpose for which to return the bounding box size (e.g., render).</p><h2>Returns</h2><p>The size of the primitive\u2019s bounding box.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the sphere's bounding box.</code><code class=\"codeline\">vector size = usd_getbbox_size(0, \"/src/sphere\", \"render\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbounds\">usd_getbounds</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox\">usd_getbbox</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_center\">usd_getbbox_center</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_min\">usd_getbbox_min</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_max\">usd_getbbox_max</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_relbox\">usd_relbox</a></div></body>",
    "usd_getbounds": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbounds\">usd_getbounds</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Obtains the primitive\u2019s bounds</p><div class=\"usage\"> <code>int usd_getbounds(&lt;stage&gt;, string primpath, string purpose, vector &amp;min, vector &amp;max)</code></div><div class=\"usage\"> <code>int usd_getbounds(&lt;stage&gt;, string primpath, string purpose, float timecode, vector &amp;min, vector &amp;max)</code></div><div class=\"usage\"> <code>int usd_getbounds(&lt;stage&gt;, string primpath, string[] purpose, vector &amp;min, vector &amp;max)</code></div><div class=\"usage\"> <code>int usd_getbounds(&lt;stage&gt;, string primpath, string[] purpose, float timecode, vector &amp;min, vector &amp;max)</code></div><p>This function returns primitive\u2019s axis-aligned bounding box. The point corresponding to the minimum corner of the bounding box will be returned in min, while the maximum will be in max. Always returns 1. </p><div class=\"argument\"><code>purpose</code></div><p>The primitive\u2019s purpose for which to return the bounding box (e.g., render).</p><h2>Returns</h2><p>Always 1.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the sphere's bounding box.</code><code class=\"codeline\">vector min, max;</code><code class=\"codeline\">usd_getbounds(0, \"/src/sphere\", \"render\", min, max);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox\">usd_getbbox</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_worldtransform\">usd_worldtransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_localtransform\">usd_localtransform</a></div></body>",
    "usd_getpointinstancebounds": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getpointinstancebounds\">usd_getpointinstancebounds</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Obtains the primitive\u2019s bounds</p><div class=\"usage\"> <code>int usd_getpointinstancebounds( &lt;stage&gt;, string primpath, int instance_index, string purpose, vector &amp;min, vector &amp;max )</code></div><div class=\"usage\"> <code>int usd_getpointinstancebounds( &lt;stage&gt;, string primpath, int instance_index, string[] purpose, vector &amp;min, vector &amp;max )</code></div><div class=\"usage\"> <code>int usd_getpointinstancebounds( &lt;stage&gt;, string primpath, int instance_index, string purpose, float timecode, vector &amp;min, vector &amp;max )</code></div><div class=\"usage\"> <code>int usd_getpointinstancebounds( &lt;stage&gt;, string primpath, int instance_index, string[] purpose, float timecode, vector &amp;min, vector &amp;max )</code></div><p>This function returns primitive\u2019s axis-aligned bounding box of a particular instance in a point instancer primitive. The point corresponding to the minimum corner of the bounding box will be returned in min, while the maximum will be in max. Always returns 1. </p><div class=\"argument\"><code>instance_index</code></div><p>The index of the instance whose bounding box to return.</p><div class=\"argument\"><code>purpose</code></div><p>The primitive\u2019s purpose for which to return the bounding box (e.g., default, render).</p><h2>Returns</h2><p>Always 1.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the second sphere's bounding box.</code><code class=\"codeline\">vector min, max;</code><code class=\"codeline\">usd_getpointinstancebounds(0, \"/src/instanced_spheres\", 1, \"render\", min, max);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbounds\">usd_getbounds</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_pointinstancetransform\">usd_pointinstancetransform</a></div></body>",
    "usd_hasapi": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_hasapi\">usd_hasapi</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Checks if the primitive adheres to the given API.</p><div class=\"usage\"> <code>int usd_hasapi(&lt;stage&gt;, string primpath, string api)</code></div><p>This function checks whether the given primitive adheres to the given API. I.e., whether that API has been applied to this primitive.</p><div class=\"argument\"><code>api</code></div><p>The name or an alias of the API schema to check.</p><h2>Returns</h2><p>1 if the primitive has the given API, or 0 otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if the primitive has a USD Geometry Model API applied.</code><code class=\"codeline\">int has_geom_model_api_by_name  = usd_hasapi(0, \"/geo/sphere\", \"UsdGeomModelAPI\");</code><code class=\"codeline\">int has_geom_model_api_by_alias = usd_hasapi(0, \"/geo/sphere\", \"GeomModelAPI\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_typename\">usd_typename</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_name\">usd_name</a></div></body>",
    "usd_haspayload": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_haspayload\">usd_haspayload</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Checks if the primitive adheres to the given API.</p><div class=\"usage\"> <code>int usd_haspayload(&lt;stage&gt;, string primpath)</code></div><p>Returns true if the primitive has payload.</p><h2>Returns</h2><p>1 if the primitive has payload, or 0 otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int has_payload  = usd_haspayload(0, \"/geo/sphere\" );</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div></body>",
    "usd_iprimvar": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvar\">usd_iprimvar</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Reads the value of a primvar directly from the USD primitive or from USD primitive\u2019s ancestor.</p><div class=\"usage\"> <code>&lt;type&gt; usd_iprimvar(&lt;stage&gt;; string primpath; string name)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] usd_iprimvar(&lt;stage&gt;; string primpath; string name)</code></div><div class=\"usage\"> <code>&lt;type&gt; usd_iprimvar(&lt;stage&gt;; string primpath; string name; float timecode)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] usd_iprimvar(&lt;stage&gt;; string primpath; string name; float timecode)</code></div><p>This function returns a value of a primvar on a given primitive or inherited from primitive\u2019s ancestor.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The value of an existing primvar, or zero/empty value if the primvar does not exist. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isiprimvar\">usd_isiprimvar</a> if you want to check whether the primvar exists.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the value of some primvars on the cube primitive or cube's ancestor.</code><code class=\"codeline\">vector vec_value = usd_iprimvar(0, \"/geo/cube\", \"vec_primvar_name\"); </code><code class=\"codeline\">float values[] = usd_iprimvar(0, \"/geo/cube\", \"primvar_name\");</code><code class=\"codeline\">float value    = usd_iprimvar(0, \"/geo/cube\", \"primvar_name\", 3);</code><code class=\"codeline\"></code><code class=\"codeline\">v[]@foo_at_current_frame = usd_iprimvar(0, \"/geo/sphere\", \"foo\");</code><code class=\"codeline\">v[]@foo_at_frame_8       = usd_iprimvar(0, \"/geo/sphere\", \"foo\", 8.0);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvar\">usd_primvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isiprimvar\">usd_isiprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isindexediprimvar\">usd_isindexediprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvartypename\">usd_iprimvartypename</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarelement\">usd_iprimvarelement</a></div></body>",
    "usd_iprimvarelement": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarelement\">usd_iprimvarelement</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Reads the value of an element from the array primvar directly from the USD primitive or from USD primitive\u2019s ancestor.</p><div class=\"usage\"> <code>&lt;type&gt; usd_iprimvarelement(&lt;stage&gt;; string primpath; string name; int index)</code></div><div class=\"usage\"> <code>&lt;type&gt; usd_iprimvarelement(&lt;stage&gt;; string primpath; string name; int index; float timecode)</code></div><p>This function returns a value of an element in given array primvar on a given primitive or inherited from primitive\u2019s ancestor.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><div class=\"argument\"><code>index</code></div><p>The index into the array. </p><h2>Returns</h2><p>The value of an element in an existing array primvar, or zero/empty value if the primvar does not exist. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isiprimvar\">usd_isiprimvar</a> if you want to check whether the primvar exists.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the value of some primvars on the cube primitive or its ancestor.</code><code class=\"codeline\">float value    = usd_iprimvarelement(0, \"/geo/cube\", \"primvar_name\", 3);</code><code class=\"codeline\"></code><code class=\"codeline\">v@element_2_at_current_frame  = usd_iprimvarelement(0, \"/geo/sphere\", \"foo\", 2);</code><code class=\"codeline\">v@element_2_at_frame_8        = usd_iprimvarelement(0, \"/geo/sphere\", \"foo\", 2, 8.0);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarelement\">usd_primvarelement</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvar\">usd_iprimvar</a></div></body>",
    "usd_iprimvarelementsize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarelementsize\">usd_iprimvarelementsize</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Returns the element size of the primvar directly from the USD primitive or from USD primitive\u2019s ancestor.</p><div class=\"usage\"> <code>int usd_iprimvarelementsize(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns the element size of a primvar found directly on the given primitive or inherited from primitive\u2019s ancestor. </p><p>The primvar element size applies to array primvars, but it does not encode the length of the array. It specifies how many consecutive array elements should be taken as an atomic element to be interpolated over a gprim. So, on a mesh, array length relates to element size like this <code>array_length = element_size * face_count</code>.</p><p>In most cases, the element size is <code>1</code>.</p><p>Note, element size is a USD concept and differs from the VEX tuple size obtained with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarsize\">usd_iprimvarsize</a> or the VEX array length obtained with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarlen\">usd_iprimvarlen</a>.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The primvar\u2019s element size.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the element size of a primvar on the cube primitive or its ancestor.</code><code class=\"codeline\">int element_size = usd_iprimvarelementsize(0, \"/geo/cube\", \"primvar_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarelementsize\">usd_primvarelementsize</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isiprimvar\">usd_isiprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarlen\">usd_iprimvarlen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarsize\">usd_iprimvarsize</a></div></body>",
    "usd_iprimvarindices": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarindices\">usd_iprimvarindices</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Returns the index array of an indexed primvar directly on the USD primitive or on USD primitive\u2019s ancestor.</p><div class=\"usage\"> <code>int[] usd_iprimvarindices(&lt;stage&gt;; string primpath; string name)</code></div><div class=\"usage\"> <code>int[] usd_iprimvarindices(&lt;stage&gt;; string primpath; string name; float timecode)</code></div><p>This function returns the index array of an indexed primvar found directly on the given primitive or inherited from primitive\u2019s ancestor.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The index array of an indexed primvar, or zero/empty value if the primvar does not exist or is not indexed. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isiprimvar\">usd_isiprimvar</a> if you want to check whether the primvar exists and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isindexediprimvar\">usd_isindexediprimvar</a> to check whether it is indexed.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the index array of an indexed primvar.</code><code class=\"codeline\">int indices[] = usd_iprimvarindices(0, \"/geo/cube\", \"indexed_primvar_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarindices\">usd_primvarindices</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isiprimvar\">usd_isiprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isindexediprimvar\">usd_isindexediprimvar</a></div></body>",
    "usd_iprimvarinterpolation": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarinterpolation\">usd_iprimvarinterpolation</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Returns the element size of the primvar directly on the USD primitive or on USD primitive\u2019s ancestor.</p><div class=\"usage\"> <code>string usd_iprimvarinterpolation(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns the interpolation style of the primvar found directly on the given primitive or inherited from primitive\u2019s ancestor. E.g.  constant, varying, etc.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The primvar\u2019s interpolation. The standard interpolation styles are:</p><div class=\"related\">constant - same value over the entire surface (i.e., detail)</div><div class=\"related\">uniform - one value for each uv patch or a face (i.e., primitive)</div><div class=\"related\">vertex - values interpolated between each vertex using surface\u2019s basis function (i.e., point)</div><div class=\"related\">varying - four values interpolated over uv patch or a face (i.e., vertex)</div><div class=\"related\">faceVarying - for polygons and subdivision surfaces, four values are interpolated over each face of the mesh (i.e., vertext)</div><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the interpolation style of the primvar on the cube or its parent.</code><code class=\"codeline\">string interpolation = usd_iprimvarinterpolation(0, \"/geo/cube\", \"primvar_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarinterpolation\">usd_primvarinterpolation</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isiprimvar\">usd_isiprimvar</a></div></body>",
    "usd_iprimvarlen": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarlen\">usd_iprimvarlen</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Returns the length of the array primvar directly on the USD primitive or on USD primitive\u2019s ancestor.</p><div class=\"usage\"> <code>int usd_iprimvarlen(&lt;stage&gt;; string primpath; string name)</code></div><div class=\"usage\"> <code>int usd_iprimvarlen(&lt;stage&gt;; string primpath; string name; float timecode)</code></div><p>This function returns the length of a given primvar found directly on the given primitive or inherited from primitive\u2019s ancestor. </p><p>For array primvars it is the length of an array, and for non-array primvars the length is 1.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The length of the array primvar, or <code>1</code> if the primvar is not an array, or <code>0</code> if the primvar does not exist. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isarrayprimvar\">usd_isarrayprimvar</a> to check if the primvar is an array.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the array length of the primvar on cube or its ancestor.</code><code class=\"codeline\">int array_length = usd_iprimvarlen(0, \"/geo/cube\", \"array_primvar_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarlen\">usd_primvarlen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isiprimvar\">usd_isiprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarsize\">usd_iprimvarsize</a></div></body>",
    "usd_iprimvarnames": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarnames\">usd_iprimvarnames</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Returns the names of the primvars available directly on the given USD primitive or on USD primitive\u2019s ancestor.</p><div class=\"usage\"> <code>string[] usd_iprimvarnames(&lt;stage&gt;, string primpath)</code></div><p>This function returns the primvar names that are available directly on the given\nprimitive or are inherited from primitive\u2019s ancestors. </p><h2>Returns</h2><p>String array containing the names of the primvars of the primitive and its ancestors.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the primvar names from the primitive and its ancestors.</code><code class=\"codeline\">string primvar_names[] = usd_iprimvarnames(0, \"/geo/src_sphere\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarnames\">usd_primvarnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isiprimvar\">usd_isiprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div></body>",
    "usd_iprimvarsize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarsize\">usd_iprimvarsize</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Returns the tuple size of the primvar directly on the USD primitive or on USD primitive\u2019s ancestor.</p><div class=\"usage\"> <code>int usd_iprimvarsize(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns the tuple size of a primvar found directly on the given primitive or inherited from primitive\u2019s ancestor. If the primvar is an array, it returns the tuple size of the array element. E.g., for vector types, this is the number of components.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The tuple size of the primvar. </p><div class=\"related\">For a vector type, this is the number of components.</div><div class=\"related\">For an integer, float, or string, this returns <code>1</code>.</div><div class=\"related\">For an array primvar, this returns the tuple size of the elements.</div><p>If the primvar does not exist, returns <code>0</code>.</p><p>Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarlen\">usd_iprimvarlen</a> if you want to obtain the array primvar length.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the tuple size of a primvar on the cube primitive or its ancestor.</code><code class=\"codeline\">int tuple_size = usd_iprimvarsize(0, \"/geo/cube\", \"primvar_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarsize\">usd_primvarsize</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarlen\">usd_iprimvarlen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isiprimvar\">usd_isiprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvar\">usd_iprimvar</a></div></body>",
    "usd_iprimvartimesamples": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvartimesamples\">usd_iprimvartimesamples</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Returns the time codes at which the primvar values are authored directly on the given primitive or on its ancestor.</p><div class=\"usage\"> <code>float[] usd_iprimvartimesamples(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns an array of time codes at which the values are authored for a primvar found directly on the given primitive or inherited from primitive\u2019s ancestor. </p><div class=\"argument\"><code>name</code></div><p>Primvar name.</p><h2>Returns</h2><p>The array of time codes at which the primvar values are authored, or an empty array if the primvar does not exist or has no time samples.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the time codes of a foo primvar.</code><code class=\"codeline\">float time_codes[] = usd_primvartimesamples(0, \"/geo/cube\", \"foo\");</code></div><div class=\"codeblock\"><code class=\"codeline\">// Get primvar values at authored time samples on the given prim or its ancestor.</code><code class=\"codeline\">float[] usd_iprimvartimesamplevalues(const int input; const string primpath, primvarname)</code><code class=\"codeline\">{</code><code class=\"codeline\">    float result[];</code><code class=\"codeline\"></code><code class=\"codeline\">    float time_samples[] = usd_iprimvartimesamples( input, primpath, primvarname );</code><code class=\"codeline\">    foreach( float time_code ; time_samples ) </code><code class=\"codeline\">    {</code><code class=\"codeline\">        float value = usd_iprimvar( input, primpath, primvarname, time_code );</code><code class=\"codeline\">        push( result, value );</code><code class=\"codeline\">    }</code><code class=\"codeline\"></code><code class=\"codeline\">    return result;</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvartimesamples\">usd_primvartimesamples</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvar\">usd_iprimvar</a></div></body>",
    "usd_iprimvartypename": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvartypename\">usd_iprimvartypename</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Returns the name of the primvar type found on the given primitive or its ancestor.</p><div class=\"usage\"> <code>string usd_iprimvartypename(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns the type name of a primvar found directly on the given primitive or inherited from primitive\u2019s ancestor. The type name is taken from the USD value type registry, e.g., float, vector3d, double3<a href=\"https://www.sidefx.com/docs/houdini\"></a>, etc.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The primvar type name used in the value type registry.  E.g., float, vector3d, double3<a href=\"https://www.sidefx.com/docs/houdini\"></a>, etc.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the type name of the primvar on cube or its ancestor..</code><code class=\"codeline\">string type_name = usd_iprimvartypename(0, \"/geo/cube\", \"primvar_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvartypename\">usd_primvartypename</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isiprimvar\">usd_isiprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvar\">usd_iprimvar</a></div></body>",
    "usd_isabstract": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isabstract\">usd_isabstract</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Checks if the primitive is abstract.</p><div class=\"usage\"> <code>int usd_isabstract(&lt;stage&gt;, string primpath)</code></div><p>This function checks whether the given primitive is abstract or defined.</p><h2>Returns</h2><p>1 if the primitive is abstract, and 0 otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if the sphere primitive is abstract.</code><code class=\"codeline\">int is_abstract = usd_isabstract(0, \"/geometry/sphere\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_specifier\">usd_specifier</a></div></body>",
    "usd_isactive": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isactive\">usd_isactive</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Checks if the primitive is active.</p><div class=\"usage\"> <code>int usd_isactive(&lt;stage&gt;, string primpath)</code></div><p>This function checks whether the given primitive is active.</p><h2>Returns</h2><p>1 if the primitive is active, and 0 otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if the sphere primitive is active.</code><code class=\"codeline\">int is_active = usd_isactive(0, \"/geometry/sphere\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setactive\">usd_setactive</a></div></body>",
    "usd_isarray": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isarray\">usd_isarray</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Checks if the attribute is an array.</p><div class=\"usage\"> <code>int usd_isarray(&lt;stage&gt;; string primpath; string name)</code></div><p>This function checks whether the given attribute is an array.</p><div class=\"argument\"><code>name</code></div><p>Attribute name.</p><h2>Returns</h2><p><code>1</code> if the attribute exists and is an array, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if attribute \"some_attribute\" is an array.</code><code class=\"codeline\">int is_array = usd_isarray(0, \"/geometry/sphere\", \"some_attribute\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attriblen\">usd_attriblen</a></div></body>",
    "usd_isarrayiprimvar": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isarrayiprimvar\">usd_isarrayiprimvar</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Checks if there is an array primvar directly on the USD primitive or on USD primitive\u2019s ancestor.</p><div class=\"usage\"> <code>int usd_isarrayiprimvar(&lt;stage&gt;; string primpath; string name)</code></div><p>This function checks whether the primvar is an array, if it\u2019s found directly on the given primitive or is inherited from primitive\u2019s ancestor. </p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p><code>1</code> if the primvar exists and is an array, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if primvar \"some_primvar\" is an array.</code><code class=\"codeline\">int is_array = usd_isarrayiprimvar(0, \"/geometry/sphere\", \"some_primvar\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isarrayprimvar\">usd_isarrayprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isiprimvar\">usd_isiprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarlen\">usd_iprimvarlen</a></div></body>",
    "usd_isarraymetadata": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isarraymetadata\">usd_isarraymetadata</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Checks if the given metadata is an array.</p><div class=\"usage\"> <code>int usd_isarraymetadata(&lt;stage&gt;; string path; string name)</code></div><p>This function checks whether the given metadata is an array.</p><h2>Returns</h2><p><code>1</code> if the metadata exists and is an array, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if the metadata is an array.</code><code class=\"codeline\">int is_array = usd_isarraymetadata(0, \"/geo/sphere\", \"documentation\");</code><code class=\"codeline\">int is_array_too = usd_isarraymetadata(0, \"/geo/cube\", \"customData:foo:bar\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_ismetadata\">usd_ismetadata</a></div></body>",
    "usd_isarrayprimvar": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isarrayprimvar\">usd_isarrayprimvar</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Checks if there is an array primvar directly on the USD primitive.</p><div class=\"usage\"> <code>int usd_isarrayprimvar(&lt;stage&gt;; string primpath; string name)</code></div><p>This function checks whether the primvar is an array, if it\u2019s found directly on the given primitive.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p><code>1</code> if the primvar exists and is an array, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if primvar \"some_primvar\" is an array.</code><code class=\"codeline\">int is_array = usd_isarrayprimvar(0, \"/geometry/sphere\", \"some_primvar\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isarrayiprimvar\">usd_isarrayiprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarlen\">usd_primvarlen</a></div></body>",
    "usd_isattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Checks if the primitive has an attribute by the given name.</p><div class=\"usage\"> <code>int usd_isattrib(&lt;stage&gt;; string primpath; string name)</code></div><p>This function checks whether the given primitive has an attribute of a given name.</p><div class=\"argument\"><code>name</code></div><p>Attribute name.</p><h2>Returns</h2><p><code>1</code> if the primitive has the given attribute, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if the sphere has an attribute \"some_attribute\".</code><code class=\"codeline\">int is_valid_attrib = usd_isattrib(0, \"/geometry/sphere\", \"some_attribute\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isstage\">usd_isstage</a></div></body>",
    "usd_iscollection": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iscollection\">usd_iscollection</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Checks if the collection exists.</p><div class=\"usage\"> <code>int usd_iscollection(&lt;stage&gt;; string collectionpath)</code></div><p>This function checks whether the given path points to an existing collection.</p><h2>Returns</h2><p><code>1</code> if the path points to an existing collection, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if cube has a collection \"some_collection\".</code><code class=\"codeline\">string collection_path = usd_makecollectionpath(0, \"/geo/cube\", \"some_collection\");</code><code class=\"codeline\">int is_collection_existing = usd_iscollection(0, collection_path);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iscollectionpath\">usd_iscollectionpath</a></div></body>",
    "usd_iscollectionpath": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iscollectionpath\">usd_iscollectionpath</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Checks if the path is a valid collection path.</p><div class=\"usage\"> <code>int usd_iscollectionpath(&lt;stage&gt;; string collectionpath)</code></div><p>This function checks whether the given path is of a valid collection format.</p><h2>Returns</h2><p><code>1</code> if the path is of a valid collection path format, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if string is an acceptable collection path.</code><code class=\"codeline\">int is_valid_collection_path = usd_iscollectionpath(0, \"/geo/cube.collection:some_collection\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iscollection\">usd_iscollection</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_makecollectionpath\">usd_makecollectionpath</a></div></body>",
    "usd_isindexediprimvar": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isindexediprimvar\">usd_isindexediprimvar</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Checks if there is an indexed primvar directly on the USD primitive or on USD primitive\u2019s ancestor.</p><div class=\"usage\"> <code>int usd_isindexediprimvar(&lt;stage&gt;; string primpath; string name)</code></div><p>This function checks whether the given primvar is indexed, if it\u2019s found directly on the given primitive or is inherited from primitive\u2019s ancestor. </p><p>Some primvars may contain a compacted array of unique values, and an additional array of indices into the value array. They are called indexed primvars. The length of the value array depends on the number of unique elements, but the length of the index array corresponds to the number of entities the primvar applies to.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p><code>1</code> if the primvar exists and is indexed, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if primvar \"some_primvar\" is indexed on sphere or its ancestor.</code><code class=\"codeline\">int is_indexed = usd_isindexedprimvar(0, \"/geometry/sphere\", \"some_primvar\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isindexedprimvar\">usd_isindexedprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isiprimvar\">usd_isiprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarindices\">usd_iprimvarindices</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_flattenediprimvar\">usd_flattenediprimvar</a></div></body>",
    "usd_isindexedprimvar": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isindexedprimvar\">usd_isindexedprimvar</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Checks if there is an indexed primvar directly on the USD primitive.</p><div class=\"usage\"> <code>int usd_isindexedprimvar(&lt;stage&gt;; string primpath; string name)</code></div><p>This function checks whether the given primvar is indexed, if it\u2019s found directly on the given primitive.</p><p>Some primvars may contain a compacted array of unique values, and an additional array of indices into the value array. They are called indexed primvars. The length of the value array depends on the number of unique elements, but the length of the index array corresponds to the number of entities the primvar applies to.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p><code>1</code> if the primvar exists and is indexed, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if primvar \"some_primvar\" on sphere is indexed.</code><code class=\"codeline\">int is_indexed = usd_isindexedprimvar(0, \"/geometry/sphere\", \"some_primvar\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isindexediprimvar\">usd_isindexediprimvar</a> </div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarindices\">usd_primvarindices</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_flattenedprimvar\">usd_flattenedprimvar</a></div></body>",
    "usd_isinstance": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isinstance\">usd_isinstance</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Checks if the primitive is an instance.</p><div class=\"usage\"> <code>int usd_isinstance(&lt;stage&gt;, string primpath)</code></div><p>This function checks whether the given primitive is an instance.</p><h2>Returns</h2><p>1 if the primitive is an instance, and 0 otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if the sphere primitive is an instance.</code><code class=\"codeline\">int is_instance = usd_isinstance(0, \"/geometry/sphere\");</code></div></body>",
    "usd_isiprimvar": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isiprimvar\">usd_isiprimvar</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Checks if the primitive or its ancestor has a primvar of the given name.</p><div class=\"usage\"> <code>int usd_isiprimvar(&lt;stage&gt;; string primpath; string name)</code></div><p>This function checks whether the primitive or its ancestor has a primvar of the\ngiven name.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p><code>1</code> if the primvar exists directly on the given primitive or on its ancestor, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if the sphere primitive or its ancestor has a primvar \"some_primvar\".</code><code class=\"codeline\">int is_primvar = usd_isiprimvar(0, \"/geometry/sphere\", \"some_primvar\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isarrayiprimvar\">usd_isarrayiprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isindexediprimvar\">usd_isindexediprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvar\">usd_iprimvar</a></div></body>",
    "usd_iskind": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iskind\">usd_iskind</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Checks if the primitive is of a given kind.</p><div class=\"usage\"> <code>int usd_iskind(&lt;stage&gt;, string primpath, string kind)</code></div><p>This function checks whether the given primitive is of a given kind, e.g., an\nassembly, component, etc.</p><div class=\"argument\"><code>kind</code></div><p>The name of a kind to check.</p><h2>Returns</h2><p>1 if the primitive is of a given kind, and 0 otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if the sphere primitive is of an assembly kind.</code><code class=\"codeline\">int is_assembly = usd_iskind(0, \"/geometry/sphere\", \"assembly\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_kind\">usd_kind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setkind\">usd_setkind</a></div></body>",
    "usd_ismetadata": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_ismetadata\">usd_ismetadata</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Checks if the primitive has metadata by the given name.</p><div class=\"usage\"> <code>int usd_ismetadata(&lt;stage&gt;; string path; string name)</code></div><p>This function checks whether the given object has metadata of a given name.</p><h2>Returns</h2><p><code>1</code> if the primitive has the given metadata, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if the primitives have various metadata:</code><code class=\"codeline\">int has_doc = usd_ismetadata(0, \"/geo/sphere\", \"documentation\");</code><code class=\"codeline\">int has_custom_foo_bar = usd_ismetadata(0, \"/geo/cube\", \"customData:foo:bar\");</code><code class=\"codeline\"></code><code class=\"codeline\">// Check if the attribute has custom data set</code><code class=\"codeline\">string attrib_path = usd_makeattribpath(0, \"/geo/sphere\", \"attrib_name\");</code><code class=\"codeline\">int has_attrib_foo = usd_ismetadata(0, attrib_path, \"customData:foo\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_makeattribpath\">usd_makeattribpath</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isstage\">usd_isstage</a></div></body>",
    "usd_ismodel": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_ismodel\">usd_ismodel</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Checks if the primitive is a model.</p><div class=\"usage\"> <code>int usd_ismodel(&lt;stage&gt;, string primpath)</code></div><p>This function checks whether the given primitive is a model, based on its kind\nmetadata.</p><h2>Returns</h2><p>1 if the primitive is of a model kind, and 0 otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if the sphere primitive is a model.</code><code class=\"codeline\">int is_model = usd_ismodel(0, \"/geometry/sphere\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isabstract\">usd_isabstract</a></div></body>",
    "usd_isprim": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Checks if the path refers to a valid primitive.</p><div class=\"usage\"> <code>int usd_isprim(&lt;stage&gt;, string primpath)</code></div><p>This function checks whether the path points to a valid USD primitive.</p><h2>Returns</h2><p>1 if the primitive at the given path is valid, and 0 otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if the stage coming on the first input has a sphere primitive </code><code class=\"codeline\">// at scene graph location \"/geometry/sphere\".</code><code class=\"codeline\">int is_valid_primitive = usd_isprim(0, \"/geometry/sphere\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isstage\">usd_isstage</a></div></body>",
    "usd_isprimvar": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Checks if the primitive has a primvar of the given name.</p><div class=\"usage\"> <code>int usd_isprimvar(&lt;stage&gt;; string primpath; string name)</code></div><p>This function checks whether the primitive has a primvar of the given name.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p><code>1</code> if the primvar exists directly on the given primitive, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if the sphere primitive has a primvar \"some_primvar\".</code><code class=\"codeline\">int is_primvar = usd_isprimvar(0, \"/geometry/sphere\", \"some_primvar\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isiprimvar\">usd_isiprimvar</a> </div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isarrayprimvar\">usd_isarrayprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isindexedprimvar\">usd_isindexedprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvar\">usd_primvar</a></div></body>",
    "usd_isrelationship": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isrelationship\">usd_isrelationship</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Checks if the primitive has a relationship by the given name.</p><div class=\"usage\"> <code>int usd_isrelationship(&lt;stage&gt;; string primpath; string name)</code></div><p>This function checks whether the primitive has a relationship of a given name.</p><div class=\"argument\"><code>name</code></div><p>The relationship name.</p><h2>Returns</h2><p><code>1</code> if the primitive has such a relationship, or <code>0</code> otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if the cube has a relationship \"some_relationship\".</code><code class=\"codeline\">int is_valid_relationship = usd_isrelationship(0, \"/geo/cube\", \"some_relationship\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a></div></body>",
    "usd_isstage": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isstage\">usd_isstage</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Checks if the stage is valid.</p><div class=\"usage\"> <code>int usd_isstage(&lt;stage&gt;)</code></div><p>This function verifies whether a given input contains a valid USD stage. If so, all other USD functions will be able to access it to perform queries and actions. Otherwise, they will fail.</p><h2>Returns</h2><p>1 if the stage is valid, and 0 otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if the first input has a valid stage.</code><code class=\"codeline\">int is_valid_stage_on_first_input = usd_isstage(0);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div></body>",
    "usd_istransformreset": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_istransformreset\">usd_istransformreset</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Checks if the primitive transform is reset</p><div class=\"usage\"> <code>int usd_istransformreset(&lt;stage&gt;, string primpath)</code></div><p>This function checks if the primitive transform is reset, i.e., whether it uses the world co-ordinate system as the initial space, or whether it inherits the space transformation from the parent (default).</p><h2>Returns</h2><p><code>1</code> if the primitive transform is reset (i.e., the primitive uses the world space), or <code>0</code> if it inherits the space from the parent (the default behavior).</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if the cube's transform is reset.</code><code class=\"codeline\">int is_xform_reset = usd_istransformreset(1, \"/geo/cube\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformorder\">usd_transformorder</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_settransformreset\">usd_settransformreset</a></div></body>",
    "usd_istype": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_istype\">usd_istype</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Checks if the primitive is of a given type.</p><div class=\"usage\"> <code>int usd_istype(&lt;stage&gt;, string primpath, string type)</code></div><p>This function checks whether the given primitive is of a given type or derives\nfrom a given type, e.g., an Cube, UsdGeomBoundable, etc.</p><div class=\"argument\"><code>type</code></div><p>The name or an alias of a type to check.</p><h2>Returns</h2><p>1 if the primitive is of a given type, and 0 otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if the primitive is a Cube and is boundable</code><code class=\"codeline\">int is_cube_by_alias     = usd_istype(0, \"/geo/cube\", \"Cube\");</code><code class=\"codeline\">int is_cube_by_name      = usd_istype(0, \"/geo/cube\", \"UsdGeomCube\");</code><code class=\"codeline\">int is_boundable_by_name = usd_istype(0, \"/geo/cube\", \"UsdGeomBoundable\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_typename\">usd_typename</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_hasapi\">usd_hasapi</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_name\">usd_name</a></div></body>",
    "usd_isvisible": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isvisible\">usd_isvisible</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Checks if the primitive is visible.</p><div class=\"usage\"> <code>int usd_isvisible(&lt;stage&gt;, string primpath)</code></div><div class=\"usage\"> <code>int usd_isvisible(&lt;stage&gt;, string primpath, float timecode)</code></div><p>This function checks whether the given primitive is visible.</p><h2>Returns</h2><p>1 if the primitive is visible, and 0 otherwise.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Check if the sphere primitive is visible.</code><code class=\"codeline\">int is_visible = usd_isvisible(0, \"/geometry/sphere\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setvisible\">usd_setvisible</a></div></body>",
    "usd_kind": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_kind\">usd_kind</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Returns the primitive\u2019s kind.</p><div class=\"usage\"> <code>string usd_kind(&lt;stage&gt;, string primpath)</code></div><p>This function returns the given primitive\u2019s kind, e.g., an assembly, component, etc.</p><h2>Returns</h2><p>The kind of the given primitive.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the sphere primitive's kind.</code><code class=\"codeline\">string kind = usd_kind(0, \"/geo/sphere\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_kind\">usd_kind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setkind\">usd_setkind</a></div></body>",
    "usd_localtransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_localtransform\">usd_localtransform</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Obtains the primitive\u2019s local transform</p><div class=\"usage\"> <code>matrix usd_localtransform(&lt;stage&gt;, string primpath)</code></div><div class=\"usage\"> <code>matrix usd_localtransform(&lt;stage&gt;, string primpath, float timecode)</code></div><p>This function returns primitive\u2019s local transform.</p><h2>Returns</h2><p>The primitive\u2019s local transform.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the cube's local transform.</code><code class=\"codeline\">matrix cube_local_xform = usd_localtransform(0, \"/src/cube\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_worldtransform\">usd_worldtransform</a></div></body>",
    "usd_makeattribpath": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_makeattribpath\">usd_makeattribpath</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Constructs an attribute path from a primitive path and an attribute name.</p><div class=\"usage\"> <code>string usd_makeattribpath(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns the full path of a given attribute.</p><div class=\"argument\"><code>name</code></div><p>Attribute name.</p><h2>Returns</h2><p>The full path of a given attribute.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Obtain the full path to the attribute \"attrib_name\" on the cube primitive.</code><code class=\"codeline\">string attrib_path = usd_makeattribpath(0, \"/geo/cube\", \"attrib_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_makecollectionpath\">usd_makecollectionpath</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_makerelationshippath\">usd_makerelationshippath</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_makepropertypath\">usd_makepropertypath</a></div></body>",
    "usd_makecollectionpath": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_makecollectionpath\">usd_makecollectionpath</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Constructs a collection path from a primitive path and a collection name.</p><div class=\"usage\"> <code>string usd_makecollectionpath(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns the full path of a given collection.</p><div class=\"argument\"><code>name</code></div><p>Collection name.</p><h2>Returns</h2><p>The full path of a given collection.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Obtain the full path to the collection \"some_collection\" on the cube primitive.</code><code class=\"codeline\">string collection_path = usd_makecollectionpath(0, \"/geo/cube\", \"some_collection\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iscollection\">usd_iscollection</a></div></body>",
    "usd_makepropertypath": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_makepropertypath\">usd_makepropertypath</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Constructs an property path from a primitive path and an property name.</p><div class=\"usage\"> <code>string usd_makepropertypath(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns the full path of a given property.</p><div class=\"argument\"><code>name</code></div><p>Property name.</p><h2>Returns</h2><p>The full path of a given property.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Obtain the full path to the property \"prop_name\" on the cube primitive.</code><code class=\"codeline\">string prop_path = usd_makepropertypath(0, \"/geo/cube\", \"prop_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_makeattribpath\">usd_makeattribpath</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_makerelationshippath\">usd_makerelationshippath</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_makecollectionpath\">usd_makecollectionpath</a></div></body>",
    "usd_makerelationshippath": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_makerelationshippath\">usd_makerelationshippath</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Constructs an relationship path from a primitive path and a relationship name.</p><div class=\"usage\"> <code>string usd_makerelationshippath(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns the full path of a given relationship.</p><div class=\"argument\"><code>name</code></div><p>Relationship name.</p><h2>Returns</h2><p>The full path of a given relationship.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Obtain the full path to the relationship \"relationship_name\" on the cube primitive.</code><code class=\"codeline\">string relationship_path = usd_makerelationshippath(0, \"/geo/cube\", \"relationship_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isrelationship\">usd_isrelationship</a></div></body>",
    "usd_makevalidprimname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_makevalidprimname\">usd_makevalidprimname</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Forces a string to conform to the rules for naming USD primitives.</p><div class=\"usage\"> <code>string usd_makevalidprimname(string name)</code></div><p>This function ensures that a string meets the requirements of a legal USD\nprimitive name that can be used as part of a valid primitive path.</p><div class=\"argument\"><code>name</code></div><p>String that should be turned into a valid primitive name.</p><h2>Returns</h2><p>A possibly modified version of the original string which conforms to the\n    requirements for naming USD primitives. Invalid characters such as spaces\n    and most punctuation will be converted to underscores. Note that this means\n    the translation is not reversible. If the original string is already a\n    legal primitive name, the string is returned unchanged.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_makevalidprimpath\">usd_makevalidprimpath</a></div></body>",
    "usd_makevalidprimpath": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_makevalidprimpath\">usd_makevalidprimpath</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Forces a string to conform to the rules for paths to USD primitives.</p><div class=\"usage\"> <code>string usd_makevalidprimpath(string path, int allow_relative)</code></div><p>This function ensures that a string meets the requirements of a legal USD\nprimitive path that can be passed to other USD functions.</p><div class=\"argument\"><code>path</code></div><p>String that should be turned into a valid primitive path.</p><div class=\"argument\"><code>allow_relative</code></div><p>If this value is non-zero, the string is allowed to represent a relative\n    primitive path. A relative path is one that starts with <code>./</code> or <code>../</code>. If\n    this argument is zero, only absolute paths (which start with <code>/</code>) are\n    allowed. Relative prefixes are simply removed from the path and the\n    returned path will always start with a <code>/</code>.</p><h2>Returns</h2><p>A possibly modified version of the original string which conforms to the\n    requirements for USD primitive paths. Invalid characters such as spaces\n    and most punctuation will be converted to underscores. Note that this means\n    the translation is not reversible. If the original string is already a\n    legal primitive path, the string is returned unchanged.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_makevalidprimname\">usd_makevalidprimname</a></div></body>",
    "usd_metadata": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_metadata\">usd_metadata</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Reads the value of metadata from the USD object.</p><div class=\"usage\"> <code>&lt;type&gt; usd_metadata(&lt;stage&gt;; string path; string name)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] usd_metadata(&lt;stage&gt;; string path; string name)</code></div><p>This function returns a value of a given metadata from a given object.</p><h2>Returns</h2><p>The value of an existing metadata, or zero/empty value if the metadata does not exist. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_ismetadata\">usd_ismetadata</a> if you want to check whether the metadata exists.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the documentation string of the cube primitive.</code><code class=\"codeline\">string docs = usd_metadata(0, \"/geo/cube\", \"documentation\");</code><code class=\"codeline\"></code><code class=\"codeline\">// Get custom data from a parameter.</code><code class=\"codeline\">string attrib_path = usd_makeattribpath(0, \"/geo/cube\", \"some_attribute\");</code><code class=\"codeline\">float custom_val = usd_metadata(0, attrib_path, \"customData:foo:bar\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_ismetadata\">usd_ismetadata</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setmetadata\">usd_setmetadata</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_metadataelement\">usd_metadataelement</a></div></body>",
    "usd_metadataelement": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_metadataelement\">usd_metadataelement</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Reads the value of an element from the array metadata.</p><div class=\"usage\"> <code>&lt;type&gt; usd_metadataelement(&lt;stage&gt;; string path; string name; int index)</code></div><p>This function returns an element value of of a given array metadata at a given index.</p><div class=\"argument\"><code>index</code></div><p>The index into the array. </p><h2>Returns</h2><p>The value of an element in an existing array metadata, or zero/empty value if the metadata does not exist. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_ismetadata\">usd_ismetadata</a> if you want to check whether the metadata exists.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the value of an element at index 3 in the \"foo:bar\" array custom data.</code><code class=\"codeline\">string docs = usd_metadataelement(0, \"/geo/cube\", \"customData:foo:bar\", 3);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_metadata\">usd_metadata</a></div></body>",
    "usd_metadatalen": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_metadatalen\">usd_metadatalen</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the length of the array metadata.</p><div class=\"usage\"> <code>int usd_metadatalen(&lt;stage&gt;; string path; string name)</code></div><p>This function returns the length of a given metadata.</p><p>For array metadata it is the length of the array, and for non-array metadata the length is 1.</p><h2>Returns</h2><p>The length of the array metadata, or 1 if the metadata is not an array. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isarraymetadata\">usd_isarraymetadata</a> if you want to check whether the metadata is an array.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the array length of metadata on the cube primitive.</code><code class=\"codeline\">int length = usd_metadatalen(0, \"/geo/cube\", \"customData:name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_ismetadata\">usd_ismetadata</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_metadata\">usd_metadata</a></div></body>",
    "usd_metadatanames": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_metadatanames\">usd_metadatanames</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the names of the metadata available on the object.</p><div class=\"usage\"> <code>string[] usd_metadatanames(&lt;stage&gt;, string path)</code></div><p>This function returns the metadata names that are available on the given USD object.</p><h2>Returns</h2><p>String array containing the names of the object\u2019s metadata.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the metadata names from the primitive.</code><code class=\"codeline\">string prim_metadata_names[] = usd_metadatanames(0, \"/geo/sphere\");</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the metadata names from the attribute.</code><code class=\"codeline\">string attrib_path = usd_makeattribpath(0, \"/geo/sphere\", \"attrib_name\");</code><code class=\"codeline\">string attrib_metadata_names[] = usd_metadatanames(0, attrib_path);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_ismetadata\">usd_ismetadata</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div></body>",
    "usd_name": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_name\">usd_name</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Returns the name of the primitive.</p><div class=\"usage\"> <code>string usd_name(&lt;stage&gt;, string primpath)</code></div><p>This function returns the name of the given primitive. </p><p>Note, while this function takes the stage as an argument for consistency, it does not access the stage, but rather it extracts the name from the path.</p><h2>Returns</h2><p>The name of the primitive.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the primitive name, ie \"cube\".</code><code class=\"codeline\">string name = usd_name(0, \"/geo/cube\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_parentpath\">usd_parentpath</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_typename\">usd_typename</a></div></body>",
    "usd_parentpath": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_parentpath\">usd_parentpath</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Returns the path of the primitive\u2019s parent.</p><div class=\"usage\"> <code>string usd_parentpath(&lt;stage&gt;, string primpath)</code></div><p>This function returns the path of the given primitive\u2019s parent.</p><p>Note, while this function takes the stage as an argument for consistency, it does not access the stage, but rather it extracts the parent from the path.</p><h2>Returns</h2><p>The path of the primitive\u2019s parent.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the path of the primitive's parent, ie \"/geo\".</code><code class=\"codeline\">string path = usd_parentpath(0, \"/geo/cube\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_name\">usd_name</a></div></body>",
    "usd_pointinstancetransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_pointinstancetransform\">usd_pointinstancetransform</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Obtains the transform for the given point instance</p><div class=\"usage\"> <code>matrix usd_pointinstancetransform(&lt;stage&gt;, string primpath, int index)</code></div><div class=\"usage\"> <code>matrix usd_pointinstancetransform(&lt;stage&gt;, string primpath, int index, float timecode)</code></div><p>This function returns point instance transform.</p><div class=\"argument\"><code>index</code></div><p>The index of the instance within the point instancer.</p><h2>Returns</h2><p>The transform of the point instance.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the transform of the third instance.</code><code class=\"codeline\">matrix xform = usd_pointinstancetransform(0, \"/src/instanced_cubes\", 2);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_worldtransform\">usd_worldtransform</a></div></body>",
    "usd_pointinstance_getbbox": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_pointinstance_getbbox\">usd_pointinstance_getbbox</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Sets two vectors to the minimum and maximum corners of the bounding box for the given instance inside point instancer.</p><div class=\"usage\"> <code>int usd_pointinstance_getbbox( &lt;stage&gt;, string primpath, int instance_index, string purpose, vector &amp;min, vector &amp;max )</code></div><p>This function returns an axis-aligned bounding box for the given instance. The point corresponding to the minimum corner of the bounding box will be returned in min, while the maximum will be in max. Always returns 1. </p><div class=\"argument\"><code>instance_index</code></div><p>The index of the instance whose bounding box to return.</p><div class=\"argument\"><code>purpose</code></div><p>The primitive\u2019s purpose for which to return the bounding box (e.g., render).</p><h2>Returns</h2><p>Always 1.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the bounding box of the first instanced sphere.</code><code class=\"codeline\">vector min, max;</code><code class=\"codeline\">usd_pointinstance_getbbox(0, \"/src/instanced_spheres\", 0, \"render\", min, max);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getpointinstancebounds\">usd_getpointinstancebounds</a></div></body>",
    "usd_pointinstance_getbbox_center": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_pointinstance_getbbox_center\">usd_pointinstance_getbbox_center</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the center of the bounding box for the instance inside a point instancer primitive.</p><div class=\"usage\"> <code>vector usd_pointinstance_getbbox_center( &lt;stage&gt;, string primpath, int instance_index, string purpose )</code></div><p>Computes the center of the bounding box for the instance geometry.</p><div class=\"argument\"><code>instance_index</code></div><p>The index of the instance whose bounding box to return.</p><div class=\"argument\"><code>purpose</code></div><p>The primitive\u2019s purpose for which to return the bounding box center (e.g., render).</p><h2>Returns</h2><p>The center of the instance\u2019s bounding box.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the center of the first instance's boundsng box.</code><code class=\"codeline\">vector center = usd_pointinstance_getbbox_center(0, \"/src/instanced_spheres\", 0, \"render\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getpointinstancebounds\">usd_getpointinstancebounds</a></div></body>",
    "usd_pointinstance_getbbox_max": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_pointinstance_getbbox_max\">usd_pointinstance_getbbox_max</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the maximum position of the bounding box for the instance inside a point instancer primitive.</p><div class=\"usage\"> <code>vector usd_pointinstance_getbbox_max( &lt;stage&gt;, string primpath, int instance_index, string purpose )</code></div><p>Computes the largest position of the bounding box for the instance geometry.</p><div class=\"argument\"><code>instance_index</code></div><p>The index of the instance whose bounding box to return.</p><div class=\"argument\"><code>purpose</code></div><p>The primitive\u2019s purpose for which to return the bounding box maximum (e.g., render).</p><h2>Returns</h2><p>The maximum position of the instance\u2019s bounding box.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the max of the first instance's boundsng box.</code><code class=\"codeline\">vector max = usd_pointinstance_getbbox_max(0, \"/src/instanced_spheres\", 0, \"render\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getpointinstancebounds\">usd_getpointinstancebounds</a></div></body>",
    "usd_pointinstance_getbbox_min": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_pointinstance_getbbox_min\">usd_pointinstance_getbbox_min</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the minimum position of the bounding box for the instance inside a point instancer primitive.</p><div class=\"usage\"> <code>vector usd_pointinstance_getbbox_min( &lt;stage&gt;, string primpath, int instance_index, string purpose )</code></div><p>Computes the smallest position of the bounding box for the instance geometry.</p><div class=\"argument\"><code>instance_index</code></div><p>The index of the instance whose bounding box to return.</p><div class=\"argument\"><code>purpose</code></div><p>The primitive\u2019s purpose for which to return the bounding box minimum (e.g., render).</p><h2>Returns</h2><p>The minimum position of the instance\u2019s bounding box.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the min of the first instance's boundsng box.</code><code class=\"codeline\">vector min = usd_pointinstance_getbbox_min(0, \"/src/instanced_spheres\", 0, \"render\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getpointinstancebounds\">usd_getpointinstancebounds</a></div></body>",
    "usd_pointinstance_getbbox_size": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_pointinstance_getbbox_size\">usd_pointinstance_getbbox_size</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the size of the bounding box for the instance inside a point instancer primitive.</p><div class=\"usage\"> <code>vector usd_pointinstance_getbbox_size( &lt;stage&gt;, string primpath, int instance_index, string purpose )</code></div><p>Computes the largest position of the bounding box for the instance geometry.</p><div class=\"argument\"><code>instance_index</code></div><p>The index of the instance whose bounding box to return.</p><div class=\"argument\"><code>purpose</code></div><p>The primitive\u2019s purpose for which to return the bounding box size (e.g., render).</p><h2>Returns</h2><p>The size of the instance\u2019s bounding box.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the size of the first instance's boundsng box.</code><code class=\"codeline\">vector size = usd_pointinstance_getbbox_size(0, \"/src/instanced_spheres\", 0, \"render\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getpointinstancebounds\">usd_getpointinstancebounds</a></div></body>",
    "usd_pointinstance_relbbox": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_pointinstance_relbbox\">usd_pointinstance_relbbox</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the relative position of the point given with respect to the bounding box of the geometry.</p><div class=\"usage\"> <code>vector usd_pointinstance_relbbox(&lt;stage&gt;, string primpath, int instance_index, string purpose, vector position)</code></div><p>Returns the relative position of the given point with respect to the bounding box of the instance in a point instancer.</p><div class=\"argument\"><code>instance_index</code></div><p>The index of the instance whose bounding box to use.</p><div class=\"argument\"><code>purpose</code></div><p>The primitive\u2019s purpose for which to use the bounding box (e.g., render).</p><h2>Returns</h2><p>The relative position of the given point with respect to the bounding box of the primitive.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the point's position relative to the bounding box of the first instance.</code><code class=\"codeline\">vector pt = {1, 0, 0};</code><code class=\"codeline\">vector rel_pt = usd_pointinstance_relbbox(0, \"/src/instanced_spheres\", 0, \"render\", pt);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getpointinstancebounds\">usd_getpointinstancebounds</a></div></body>",
    "usd_primvar": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvar\">usd_primvar</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Reads the value of a primvar directly from the USD primitive.</p><div class=\"usage\"> <code>&lt;type&gt; usd_primvar(&lt;stage&gt;; string primpath; string name)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] usd_primvar(&lt;stage&gt;; string primpath; string name)</code></div><div class=\"usage\"> <code>&lt;type&gt; usd_primvar(&lt;stage&gt;; string primpath; string name; float timecode)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] usd_primvar(&lt;stage&gt;; string primpath; string name; float timecode)</code></div><p>This function returns a value of a primvar on a given primitive.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The value of an existing primvar, or zero/empty value if the primvar does not exist. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a> if you want to check whether the primvar exists.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the value of some primvars on the cube primitive.</code><code class=\"codeline\">vector vec_value = usd_primvar(0, \"/geo/cube\", \"vec_primvar_name\"); </code><code class=\"codeline\">float values[] = usd_primvar(0, \"/geo/cube\", \"primvar_name\");</code><code class=\"codeline\">float value    = usd_primvar(0, \"/geo/cube\", \"primvar_name\", 3);</code><code class=\"codeline\"></code><code class=\"codeline\">v[]@foo_at_current_frame = usd_primvar(0, \"/geo/sphere\", \"foo\");</code><code class=\"codeline\">v[]@foo_at_frame_8       = usd_primvar(0, \"/geo/sphere\", \"foo\", 8.0);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvar\">usd_iprimvar</a> </div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isindexedprimvar\">usd_isindexedprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvartypename\">usd_primvartypename</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarelement\">usd_primvarelement</a></div></body>",
    "usd_primvarattribname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarattribname\">usd_primvarattribname</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the namespaced attribute name for the given primvar.</p><div class=\"usage\"> <code>string usd_primvarattribname(&lt;stage&gt;; string name)</code></div><p>This function returns the namespaced attribute name corresponding to the given primvar name.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The namespaced name of an attribute corresponding to the given primvar name.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the attribute name for the given primvar.</code><code class=\"codeline\">string attrib_name  = usd_primvarattribname(0, \"some_primvar\");</code><code class=\"codeline\">int is_attrib = usd_isattrib(0, \"/geo/sphere\", attrib_name);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a></div></body>",
    "usd_primvarelement": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarelement\">usd_primvarelement</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Reads the value of an element from the array primvar directly from the USD primitive.</p><div class=\"usage\"> <code>&lt;type&gt; usd_primvarelement(&lt;stage&gt;; string primpath; string name; int index)</code></div><div class=\"usage\"> <code>&lt;type&gt; usd_primvarelement(&lt;stage&gt;; string primpath; string name; int index; float timecode)</code></div><p>This function returns a value of an element in given array primvar on a given primitive.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><div class=\"argument\"><code>index</code></div><p>The index into the array. </p><h2>Returns</h2><p>The value of an element in an existing array primvar, or zero/empty value if the primvar does not exist. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a> if you want to check whether the primvar exists.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the value of some primvars on the cube primitive.</code><code class=\"codeline\">float value    = usd_primvarelement(0, \"/geo/cube\", \"primvar_name\", 3);</code><code class=\"codeline\"></code><code class=\"codeline\">v@element_2_at_current_frame  = usd_primvarelement(0, \"/geo/sphere\", \"foo\", 2);</code><code class=\"codeline\">v@element_2_at_frame_8        = usd_primvarelement(0, \"/geo/sphere\", \"foo\", 2, 8.0);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarelement\">usd_iprimvarelement</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvar\">usd_primvar</a></div></body>",
    "usd_primvarelementsize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarelementsize\">usd_primvarelementsize</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the element size of the primvar directly from the USD primitive.</p><div class=\"usage\"> <code>int usd_primvarelementsize(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns the element size of a primvar found directly on the given primitive. </p><p>The primvar element size applies to array primvars, but it does not encode the length of the array. It specifies how many consecutive array elements should be taken as an atomic element to be interpolated over a gprim. So, on a mesh, array length relates to element size like this <code>array_length = element_size * face_count</code>.</p><p>In most cases, the element size is <code>1</code>.</p><p>Note, element size is a USD concept and differs from the VEX tuple size obtained with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarsize\">usd_primvarsize</a> or the VEX array length obtained with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarlen\">usd_primvarlen</a>.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The primvar\u2019s element size.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the element size of a primvar on the cube primitive.</code><code class=\"codeline\">int element_size = usd_primvarelementsize(0, \"/geo/cube\", \"primvar_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarelementsize\">usd_iprimvarelementsize</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarlen\">usd_primvarlen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarsize\">usd_primvarsize</a></div></body>",
    "usd_primvarindices": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarindices\">usd_primvarindices</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the index array of an indexed primvar directly on the USD primitive.</p><div class=\"usage\"> <code>int[] usd_primvarindices(&lt;stage&gt;; string primpath; string name)</code></div><div class=\"usage\"> <code>int[] usd_primvarindices(&lt;stage&gt;; string primpath; string name; float timecode)</code></div><p>This function returns the index array of an indexed primvar found directly on the given primitive.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The index array of an indexed primvar, or zero/empty value if the primvar does not exist or is not indexed. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a> if you want to check whether the primvar exists and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isindexedprimvar\">usd_isindexedprimvar</a> to check whether it is indexed.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the index array of an indexed primvar.</code><code class=\"codeline\">int indices[] = usd_primvarindices(0, \"/geo/cube\", \"indexed_primvar_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarindices\">usd_iprimvarindices</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isindexedprimvar\">usd_isindexedprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setprimvarindices\">usd_setprimvarindices</a></div></body>",
    "usd_primvarinterpolation": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarinterpolation\">usd_primvarinterpolation</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the element size of the primvar directly on the USD primitive.</p><div class=\"usage\"> <code>string usd_primvarinterpolation(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns the interpolation style of the primvar found directly on the given primitive. E.g.  constant, varying, etc.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The primvar\u2019s interpolation. The standard interpolation styles are:</p><div class=\"related\">constant - same value over the entire surface (i.e., detail)</div><div class=\"related\">uniform - one value for each uv patch or a face (i.e., primitive)</div><div class=\"related\">vertex - values interpolated between each vertex using surface\u2019s basis function (i.e., point)</div><div class=\"related\">varying - four values interpolated over uv patch or a face (i.e., vertex)</div><div class=\"related\">faceVarying - for polygons and subdivision surfaces, four values are interpolated over each face of the mesh (i.e., vertext)</div><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the interpolation style of the primvar on the cube.</code><code class=\"codeline\">string interpolation = usd_primvarinterpolation(0, \"/geo/cube\", \"primvar_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarinterpolation\">usd_iprimvarinterpolation</a> </div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setprimvarinterpolation\">usd_setprimvarinterpolation</a></div></body>",
    "usd_primvarlen": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarlen\">usd_primvarlen</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the length of the array primvar directly on the USD primitive.</p><div class=\"usage\"> <code>int usd_primvarlen(&lt;stage&gt;; string primpath; string name)</code></div><div class=\"usage\"> <code>int usd_primvarlen(&lt;stage&gt;; string primpath; string name; float timecode)</code></div><p>This function returns the length of a given primvar found directly on the given primitive. </p><p>For array primvars it is the length of an array, and for non-array primvars the length is 1.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The length of the array primvar, or <code>1</code> if the primvar is not an array, or <code>0</code> if the primvar does not exist. Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isarrayprimvar\">usd_isarrayprimvar</a> to check if the primvar is an array.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the array length of the primvar on cube.</code><code class=\"codeline\">int array_length = usd_primvarlen(0, \"/geo/cube\", \"array_primvar_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarlen\">usd_iprimvarlen</a> </div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarsize\">usd_primvarsize</a></div></body>",
    "usd_primvarnames": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarnames\">usd_primvarnames</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the names of the primvars available on the given USD primitive.</p><div class=\"usage\"> <code>string[] usd_primvarnames(&lt;stage&gt;, string primpath)</code></div><p>This function returns the primvar names that are available on the given primitive.</p><h2>Returns</h2><p>String array containing the names of the primitive\u2019s primvars.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the primvar names from the primitive.</code><code class=\"codeline\">string primvar_names[] = usd_primvarnames(0, \"/geo/src_sphere\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarnames\">usd_iprimvarnames</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div></body>",
    "usd_primvarsize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarsize\">usd_primvarsize</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the tuple size of the primvar directly on the USD primitive.</p><div class=\"usage\"> <code>int usd_primvarsize(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns the tuple size of a primvar found directly on the given primitive. If the primvar is an array, it returns the tuple size of the array element. E.g., for vector types, this is the number of components.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The tuple size of the primvar. </p><div class=\"related\">For a vector type, this is the number of components.</div><div class=\"related\">For an integer, float, or string, this returns <code>1</code>.</div><div class=\"related\">For an array primvar, this returns the tuple size of the elements.</div><p>If the primvar does not exist, returns <code>0</code>.</p><p>Use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarlen\">usd_primvarlen</a> if you want to obtain the array primvar length.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the tuple size of a primvar on the cube primitive.</code><code class=\"codeline\">int tuple_size = usd_primvarsize(0, \"/geo/cube\", \"primvar_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvarsize\">usd_iprimvarsize</a> </div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarlen\">usd_primvarlen</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvar\">usd_primvar</a></div></body>",
    "usd_primvartimesamples": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvartimesamples\">usd_primvartimesamples</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the time codes at which the primvar values are authored directly on\nthe given primitive.</p><div class=\"usage\"> <code>float[] usd_primvartimesamples(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns an array of time codes at which the values are authored for a primvar found directly on the given primitive.</p><div class=\"argument\"><code>name</code></div><p>Primvar name.</p><h2>Returns</h2><p>The array of time codes at which the primvar values are authored, or an empty array if the primvar does not exist or has no time samples.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the time codes of a foo primvar.</code><code class=\"codeline\">float time_codes[] = usd_primvartimesamples(0, \"/geo/cube\", \"foo\");</code></div><div class=\"codeblock\"><code class=\"codeline\">// Get primvar values at authored time samples on the given primitive.</code><code class=\"codeline\">float[] usd_primvartimesamplevalues(const int input; const string primpath, primvarname)</code><code class=\"codeline\">{</code><code class=\"codeline\">    float result[];</code><code class=\"codeline\"></code><code class=\"codeline\">    float time_samples[] = usd_primvartimesamples( input, primpath, primvarname );</code><code class=\"codeline\">    foreach( float time_code ; time_samples ) </code><code class=\"codeline\">    {</code><code class=\"codeline\">        float value = usd_primvar( input, primpath, primvarname, time_code );</code><code class=\"codeline\">        push( result, value );</code><code class=\"codeline\">    }</code><code class=\"codeline\"></code><code class=\"codeline\">    return result;</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvartimesamples\">usd_iprimvartimesamples</a> </div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvar\">usd_primvar</a></div></body>",
    "usd_primvartypename": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvartypename\">usd_primvartypename</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the name of the primvar type found on the given primitive.</p><div class=\"usage\"> <code>string usd_primvartypename(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns the type name of a primvar found directly on the given primitive. The type name is taken from the USD value type registry, e.g., float, vector3d, double3<a href=\"https://www.sidefx.com/docs/houdini\"></a>, etc.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The primvar type name used in the value type registry.  E.g., float, vector3d, double3<a href=\"https://www.sidefx.com/docs/houdini\"></a>, etc.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the type name of the primvar on cube.</code><code class=\"codeline\">string type_name = usd_primvartypename(0, \"/geo/cube\", \"primvar_name\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iprimvartypename\">usd_iprimvartypename</a> </div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprimvar\">usd_isprimvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvar\">usd_primvar</a></div></body>",
    "usd_purpose": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_purpose\">usd_purpose</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Returns the primitive\u2019s purpose.</p><div class=\"usage\"> <code>string usd_purpose(&lt;stage&gt;, string primpath)</code></div><p>This function returns the given primitive\u2019s purpose, e.g., default, render, proxy, guide, etc.</p><h2>Returns</h2><p>The purpose of the given primitive.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the sphere primitive's purpose.</code><code class=\"codeline\">string purpose = usd_purpose(0, \"/geo/sphere\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setpurpose\">usd_setpurpose</a></div></body>",
    "usd_relationshipforwardedtargets": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_relationshipforwardedtargets\">usd_relationshipforwardedtargets</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Obtains the relationship forwarded targets.</p><div class=\"usage\"> <code>string[] usd_relationshipforwardedtargets(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns the list of forwarded targets of a given relationship.  This is a convenience function to expand all the nested relationships, since a target in a relationship can be another relationship.</p><div class=\"argument\"><code>name</code></div><p>The relationship name.</p><h2>Returns</h2><p>List of forwarded targets in a relationship.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the list of forwarded targets in cube's \"some_relationship\" relationship.</code><code class=\"codeline\">string targets[] = usd_relationshipforwardedtargets(0, \"/geo/cube\", \"some_relationship\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isrelationship\">usd_isrelationship</a></div></body>",
    "usd_relationshipnames": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_relationshipnames\">usd_relationshipnames</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the names of the relationships available on the primitive.</p><div class=\"usage\"> <code>string[] usd_relationshipnames(&lt;stage&gt;, string primpath)</code></div><p>This function returns the relationship names that are available on the given primitive.</p><h2>Returns</h2><p>String array containing the names of the primitive\u2019s relationships.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the relationship names from the primitive.</code><code class=\"codeline\">string relationship_names[] = usd_relationshipnames(0, \"/geo/cube\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isrelationship\">usd_isrelationship</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div></body>",
    "usd_relationshiptargets": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_relationshiptargets\">usd_relationshiptargets</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Obtains the relationship targets.</p><div class=\"usage\"> <code>string[] usd_relationshiptargets(&lt;stage&gt;; string primpath; string name)</code></div><p>This function returns the list of targets of a given relationship.  </p><div class=\"argument\"><code>name</code></div><p>The relationship name.</p><h2>Returns</h2><p>List of targets in a relationship.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the list of targets in cube's \"some_relationship\" relationship.</code><code class=\"codeline\">string targets[] = usd_relationshiptargets(0, \"/geo/cube\", \"some_relationship\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isrelationship\">usd_isrelationship</a></div></body>",
    "usd_relbbox": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_relbbox\">usd_relbbox</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Returns the relative position of the point given with respect to the bounding box of the geometry.</p><div class=\"usage\"> <code>vector usd_relbbox(&lt;stage&gt;, string primpath, string purpose, vector position)</code></div><p>Returns the relative position of the given point with respect to the bounding box of the primitive.</p><div class=\"argument\"><code>purpose</code></div><p>The primitive\u2019s purpose for which to use the bounding box (e.g., render).</p><h2>Returns</h2><p>The relative position of the given point with respect to the bounding box of the primitive.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the points relative position.</code><code class=\"codeline\">vector pt = {1, 0, 0};</code><code class=\"codeline\">vector rel_pt = usd_relbbox(0, \"/src/sphere\", \"render\", pt);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbounds\">usd_getbounds</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox\">usd_getbbox</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_center\">usd_getbbox_center</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_size\">usd_getbbox_size</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_min\">usd_getbbox_min</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_getbbox_max\">usd_getbbox_max</a></div></body>",
    "usd_removerelationshiptarget": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_removerelationshiptarget\">usd_removerelationshiptarget</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Remove a target from the primitive\u2019s relationship</p><div class=\"usage\"> <code>int usd_removerelationshiptarget(int stagehandle; string primpath; string name; string target)</code></div><p>This function removes a target from the primitive\u2019s relationship.</p><div class=\"argument\"><code>name</code></div><p>The relationship name.</p><div class=\"argument\"><code>target</code></div><p>The the target path to remove.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Remove the sphere from cube's relationship.</code><code class=\"codeline\">usd_removerelationshiptarget(0, \"/geo/cube\", \"relationship_name\", \"/geo/sphere\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isrelationship\">usd_isrelationship</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addrelationshiptarget\">usd_addrelationshiptarget</a></div></body>",
    "usd_setactive": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setactive\">usd_setactive</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Sets the primitive active state.</p><div class=\"usage\"> <code>int usd_setactive(int stagehandle, string primpath, int flag)</code></div><p>This function sets the primitive\u2019s active state.</p><div class=\"argument\"><code>flag</code></div><p>Non-zero to make the primitive active or 0 to make it inactive.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the sphere primitive as active.</code><code class=\"codeline\">usd_setactive(0, \"/geo/sphere\", true);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isactive\">usd_isactive</a></div></body>",
    "usd_setattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setattrib\">usd_setattrib</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Sets the value of an attribute.</p><div class=\"usage\"> <code>int usd_setattrib(int stagehandle, string primpath, string name, &lt;type&gt; value)</code></div><div class=\"usage\"> <code>int usd_setattrib(int stagehandle, string primpath, string name, &lt;type&gt; value[])</code></div><p>This function sets the attribute value. </p><div class=\"argument\"><code>name</code></div><p>Attribute name.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success, or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the value of some attributes.</code><code class=\"codeline\">usd_setattrib(0, \"/geo/sphere\", \"float_attrib\", 0.25);</code><code class=\"codeline\">usd_setattrib(0, \"/geo/sphere\", \"string_attrib\", \"foo bar baz\");</code><code class=\"codeline\">usd_setattrib(0, \"/geo/sphere\", \"vector_attrib\", {1.25, 1.50, 1.75});</code><code class=\"codeline\"></code><code class=\"codeline\">float  f_arr[] = {0, 0.25, 0.5, 0.75, 1};</code><code class=\"codeline\">usd_setattrib(0, \"/geo/sphere\", \"float_array_attrib\", f_arr);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attrib\">usd_attrib</a></div></body>",
    "usd_setattribelement": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setattribelement\">usd_setattribelement</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Sets the value of an element in an array attribute.</p><div class=\"usage\"> <code>int usd_setattribelement(int stagehandle, string primpath, string name, int index, &lt;type&gt; value)</code></div><p>This function sets the element value in an array attribute. </p><div class=\"argument\"><code>name</code></div><p>Attribute name.</p><div class=\"argument\"><code>index</code></div><p>An index of an element in the array attribute.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success, or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the value of element at index 2 in the array attribute.</code><code class=\"codeline\">usd_setattribelement(0, \"/geo/sphere\", \"float_array_attrib\", 2, 0.25);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isattrib\">usd_isattrib</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_attribelement\">usd_attribelement</a></div></body>",
    "usd_setcollectionexcludes": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setcollectionexcludes\">usd_setcollectionexcludes</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Sets the excludes list on the collection</p><div class=\"usage\"> <code>int usd_setcollectionexcludes(int stagehandle, string collectionpath, string excludes[])</code></div><p>This function sets the excludes list on the collection.</p><div class=\"argument\"><code>excludes</code></div><p>A list of object paths to set as an exclude list on the collection.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the exludes list on the cube's collection.</code><code class=\"codeline\">string collection_path = usd_makecollectionpath(0, \"/geo/cube\", \"some_collection\");</code><code class=\"codeline\">usd_setcollectionexcludes(0, collection_path, array(\"/geo/sphere4\", \"/geo/sphere5\"));</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iscollection\">usd_iscollection</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setcollectionincludes\">usd_setcollectionincludes</a></div></body>",
    "usd_setcollectionexpansionrule": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setcollectionexpansionrule\">usd_setcollectionexpansionrule</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Sets the expansion rule on the collection</p><div class=\"usage\"> <code>int usd_setcollectionexpansionrule(int stagehandle, string collectionpath, string rule)</code></div><p>This function sets the expansion rule on the collection.</p><div class=\"argument\"><code>rule</code></div><p>The expansion rule to set on the collection.</p><div class=\"argument\"><code>USD supports a few standard expansion rules</code></div><div class=\"related\"><code>explicitOnly</code> - only paths in the include list and not in the exclude list belong to the collection</div><div class=\"related\"><code>expandPrims</code> - all the primitives at or below the includes (but not excludes) belong to the collection</div><div class=\"related\"><code>expanPrimsAndProperties</code> - like <code>expandPrims</code> but also includes properties of matched primitives</div><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the expansion rule on the cube's collection.</code><code class=\"codeline\">string collection_path = usd_makecollectionpath(0, \"/geo/cube\", \"some_collection\");</code><code class=\"codeline\">usd_setcollectionexpansionrule(0, collection_foo, \"explicitOnly\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iscollection\">usd_iscollection</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_collectionexpansionrule\">usd_collectionexpansionrule</a></div></body>",
    "usd_setcollectionincludes": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setcollectionincludes\">usd_setcollectionincludes</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Sets the includes list on the collection</p><div class=\"usage\"> <code>int usd_setcollectionincludes(int stagehandle, string collectionpath, string includes[])</code></div><p>This function sets the includes list on the collection.</p><div class=\"argument\"><code>includes</code></div><p>A list of object paths to set as an includes list on the collection.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the exludes list on the cube's collection.</code><code class=\"codeline\">string collection_path = usd_makecollectionpath(0, \"/geo/cube\", \"some_collection\");</code><code class=\"codeline\">usd_setcollectionincludes(0, collection_path, array(\"/geo/sphere1\", \"/geo/sphere2\"));</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iscollection\">usd_iscollection</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setcollectionexcludes\">usd_setcollectionexcludes</a></div></body>",
    "usd_setdrawmode": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setdrawmode\">usd_setdrawmode</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Sets the primitive\u2019s draw mode.</p><div class=\"usage\"> <code>int usd_setdrawmode(int stagehandle, string primpath, string mode)</code></div><p>This function sets the primitive\u2019s draw mode.</p><div class=\"argument\"><code>mode</code></div><p>The draw mode to set the primitive to.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the sphere to draw as bounds and the cube to draw as default.</code><code class=\"codeline\">usd_setdrawmode(0, \"/geo/sphere\", \"bounds\");</code><code class=\"codeline\">usd_setdrawmode(0, \"/geo/cube\", \"default\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_drawmode\">usd_drawmode</a></div></body>",
    "usd_setkind": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setkind\">usd_setkind</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Sets the primitive\u2019s kind.</p><div class=\"usage\"> <code>int usd_setkind(int stagehandle, string primpath, string kind)</code></div><p>This function sets the primitive\u2019s kind.</p><div class=\"argument\"><code>kind</code></div><p>The kind to set the primitive to.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the sphere primitive to be an assembly.</code><code class=\"codeline\">usd_setkind(0, \"/geo/sphere\", \"assembly\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_kind\">usd_kind</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_iskind\">usd_iskind</a></div></body>",
    "usd_setmetadata": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setmetadata\">usd_setmetadata</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Sets the value of an metadata.</p><div class=\"usage\"> <code>int usd_setmetadata(int stagehandle, string path, string name, &lt;type&gt; value)</code></div><div class=\"usage\"> <code>int usd_setmetadata(int stagehandle, string path, string name, &lt;type&gt; value[])</code></div><p>This function sets the metadata value. </p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success, or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set a documentation string on the sphere.</code><code class=\"codeline\">usd_setmetadata(0, \"/geo/sphere\", \"documentation\", \"This is new documentation.\");</code><code class=\"codeline\"></code><code class=\"codeline\">// Set the value of some custom data on the sphere.</code><code class=\"codeline\">usd_setmetadata(0, \"/geo/sphere\", \"customData:a_float\", 0.25);</code><code class=\"codeline\">usd_setmetadata(0, \"/geo/sphere\", \"customData:a_string\", \"foo bar baz\");</code><code class=\"codeline\">usd_setmetadata(0, \"/geo/sphere\", \"customData:a_vector\", {1.25, 1.50, 1.75});</code><code class=\"codeline\"></code><code class=\"codeline\">float  f_arr[] = {0, 0.25, 0.5, 0.75, 1};</code><code class=\"codeline\">usd_setmetadata(0, \"/geo/sphere\", \"customData:a_float_array\", f_arr);</code><code class=\"codeline\"></code><code class=\"codeline\">// Set the metadata value on an attribute.</code><code class=\"codeline\">string attrib_path = usd_makeattribpath(0, \"/geo/sphere\", \"attrib_name\");</code><code class=\"codeline\">sd_setmetadata(0, attrib_path, \"customData:foo\", 1.25);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_ismetadata\">usd_ismetadata</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_metadata\">usd_metadata</a></div></body>",
    "usd_setmetadataelement": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setmetadataelement\">usd_setmetadataelement</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Sets the value of an element in an array metadata.</p><div class=\"usage\"> <code>int usd_setmetadataelement(int stagehandle, string path, string name, int index, &lt;type&gt; value)</code></div><p>This function sets the element value in an array metadata. </p><div class=\"argument\"><code>index</code></div><p>An index of an element in the array metadata.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success, or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the value of element at index 2 in the array attribute.</code><code class=\"codeline\">usd_setmetadata(0, \"/geo/sphere\", \"customData:a_float_arr\", 2, 0.25);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_ismetadata\">usd_ismetadata</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_metadataelement\">usd_metadataelement</a></div></body>",
    "usd_setprimvar": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setprimvar\">usd_setprimvar</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Sets the value of a primvar.</p><div class=\"usage\"> <code>int usd_setprimvar(int stagehandle, string primpath, string name, &lt;type&gt; value)</code></div><div class=\"usage\"> <code>int usd_setprimvar(int stagehandle, string primpath, string name, &lt;type&gt; value[])</code></div><p>This function sets the primvar\u2019s value. </p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success, or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the value of some primvars.</code><code class=\"codeline\">usd_setprimvar(0, \"/geo/sphere\", \"float_primvar\", 0.25);</code><code class=\"codeline\">usd_setprimvar(0, \"/geo/sphere\", \"string_primvar\", \"foo bar baz\");</code><code class=\"codeline\">usd_setprimvar(0, \"/geo/sphere\", \"vector_primvar\", {1.25, 1.50, 1.75});</code><code class=\"codeline\"></code><code class=\"codeline\">float  f_arr[] = {0, 0.25, 0.5, 0.75, 1};</code><code class=\"codeline\">usd_setprimvar(0, \"/geo/sphere\", \"float_array_primvar\", f_arr);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvar\">usd_primvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setprimvarindices\">usd_setprimvarindices</a></div></body>",
    "usd_setprimvarelement": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setprimvarelement\">usd_setprimvarelement</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Sets the value of an element in an array primvar.</p><div class=\"usage\"> <code>int usd_setprimvarelement(int stagehandle, string primpath, string name, int index, &lt;type&gt; value)</code></div><p>This function sets the element value in a array primvar.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><div class=\"argument\"><code>index</code></div><p>An index of an element in the array primvar.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success, or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the value of an element at index 2 in the array primvar.</code><code class=\"codeline\">usd_setprimvarelement(0, \"/geo/sphere\", \"float_arr_primvar\", 2, 0.25);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvar\">usd_primvar</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarelement\">usd_primvarelement</a></div></body>",
    "usd_setprimvarelementsize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setprimvarelementsize\">usd_setprimvarelementsize</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Sets the element size of a primvar.</p><div class=\"usage\"> <code>int usd_setprimvarelementsize(int stagehandle, string primpath, string name, int size)</code></div><p>This function sets the element size of a given primvar. </p><p>The primvar element size applies to array primvars, but it does not encode the length of the array. It specifies how many consecutive array elements should be taken as an atomic element to be interpolated over a gprim. So, on a mesh, array length relates to element size like this <code>array_length = element_size * face_count</code>.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><div class=\"argument\"><code>size</code></div><p>The new element size for the primvar.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success, or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the primvar's element size to 2.</code><code class=\"codeline\">usd_setprimvarelementsize(0, \"/geo/mesh\", \"primvar_name\", 2);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarelementsize\">usd_primvarelementsize</a></div></body>",
    "usd_setprimvarindices": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setprimvarindices\">usd_setprimvarindices</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Sets the indices for the given primvar.</p><div class=\"usage\"> <code>int usd_setprimvarindices(int stagehandle, string primpath, string name, int indices[])</code></div><p>This function sets the indices for a given primvar, thus making it an indexed primvar if it was not already.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><div class=\"argument\"><code>indices</code></div><p>The index array to set.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success, or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the primvar's value and indices.</code><code class=\"codeline\">float values[]  = array(0, 100, 200, 300, 400, 500);</code><code class=\"codeline\">int   indices[] = array(5,5,4,4,3,3,2,2,1,1,0,0);</code><code class=\"codeline\">usd_setprimvar(0, \"/geo/mesh\", \"primvar_name\", values); </code><code class=\"codeline\">usd_setprimvarindices(0, \"/geo/mesh\", \"primvar_name\", indices);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarindices\">usd_primvarindices</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_flattenedprimvar\">usd_flattenedprimvar</a></div></body>",
    "usd_setprimvarinterpolation": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setprimvarinterpolation\">usd_setprimvarinterpolation</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Sets the interpolation of a primvar.</p><div class=\"usage\"> <code>int usd_setprimvarinterpolation(int stagehandle, string primpath, string name, string interpolation)</code></div><p>This function sets the interpolation style of the given primvar.</p><div class=\"argument\"><code>name</code></div><p>Primvar name (without namespace).</p><div class=\"argument\"><code>interpolation</code></div><p>The new interpolation style for the primvar.</p><div class=\"argument\"><code>The standard interpolation styles are</code></div><div class=\"related\">constant - same value over the entire surface (i.e., detail)</div><div class=\"related\">uniform - one value for each uv patch or a face (i.e., primitive)</div><div class=\"related\">vertex - values interpolated between each vertex using surface\u2019s basis function (i.e., point)</div><div class=\"related\">varying - four values interpolated over uv patch or a face (i.e., vertex)</div><div class=\"related\">faceVarying - for polygons and subdivision surfaces, four values are interpolated over each face of the mesh (i.e., vertex)</div><h2>Returns</h2><p>The value of <code>stagehandle</code> on success, or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the primvar's interpolation style.</code><code class=\"codeline\">usd_setprimvarinterpolation(0, \"/geo/mesh\", \"primvar_name\", \"faceVarying\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_primvarinterpolation\">usd_primvarinterpolation</a></div></body>",
    "usd_setpurpose": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setpurpose\">usd_setpurpose</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Sets the primitive\u2019s purpose.</p><div class=\"usage\"> <code>int usd_setpurpose(int stagehandle, string primpath, string purpose)</code></div><p>This function sets the primitive\u2019s purpose, e.g., default, render, proxy, guide, etc.</p><div class=\"argument\"><code>purpose</code></div><p>The primitive\u2019s purpose to set.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the sphere primitive to be traversable only for rendering.</code><code class=\"codeline\">usd_setpurpose(0, \"/geo/sphere\", \"render\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_purpose\">usd_purpose</a></div></body>",
    "usd_setrelationshiptargets": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setrelationshiptargets\">usd_setrelationshiptargets</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Sets the targets in the primitive\u2019s relationship</p><div class=\"usage\"> <code>int usd_setrelationshiptargets(int stagehandle; string primpath; string name; string[] targets)</code></div><p>This function sets the targets in the primitive\u2019s relationship.</p><div class=\"argument\"><code>name</code></div><p>The relationship name.</p><div class=\"argument\"><code>targets</code></div><p>The the target paths to set the relationship to.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the cube's relationship.</code><code class=\"codeline\">usd_setrelationshiptargets(0, \"/geo/cube\", \"new_relation\", array(\"/geo/sphere6\", \"/geo/sphere7\"));</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isrelationship\">usd_isrelationship</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addrelationshiptarget\">usd_addrelationshiptarget</a></div></body>",
    "usd_settransformorder": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_settransformorder\">usd_settransformorder</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Sets the primitive\u2019s transform order</p><div class=\"usage\"> <code>int usd_settransformorder(int stagehandle, string primpath, string[] transformorder)</code></div><p>This function sets the primitive\u2019s transform order. Transform order is a sequence of transform operations, whose full names are stored in <code>xformOpOrder</code> attribute as a string array. Thus, this function sets that attribute.</p><div class=\"argument\"><code>transformorder</code></div><p>The transform order to set on the primitive. It is a list of transform operation full names.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">string  ops[] = {\"xformOp:translate:xform_cube_t\", \"xformOp:rotateZ:xform_cube_r\", \"xformOp:rotateXYZ:xform_cube_r\", \"xformOp:scale:xform_cube_s\"};</code><code class=\"codeline\">usd_settransformorder(0, \"/geo/cube\", ops);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformorder\">usd_transformorder</a></div></body>",
    "usd_settransformreset": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_settransformreset\">usd_settransformreset</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Sets/clears the primitive\u2019s transform reset flag</p><div class=\"usage\"> <code>int usd_settransformreset(int stagehandle, string primpath, int flag)</code></div><p>This function sets the primitive\u2019s transform reset flag, i.e., whether the primitive uses the world co-ordinate system as the initial space, or whether it inherits the space transformation from the parent (default).</p><div class=\"argument\"><code>flag</code></div><p>If <code>1</code>, the primitive will have its transform reset, i.e. will use the world co-ordinate system as the initial space. If <code>0</code> it will inherit the space transform from the parent.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Ignore parent's transform.</code><code class=\"codeline\">usd_settransformreset(0, \"/geo/cone\", 1);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformorder\">usd_transformorder</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_istransformreset\">usd_istransformreset</a></div></body>",
    "usd_setvariantselection": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setvariantselection\">usd_setvariantselection</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Sets the selected variant in the given variant set.</p><div class=\"usage\"> <code>int usd_setvariantselection(&lt;stage&gt;, string primpath, string variantset, string variant)</code></div><p>This function sets the selected variant in a given variant set.</p><div class=\"argument\"><code>variantset</code></div><p>The variant set name.</p><div class=\"argument\"><code>variant</code></div><p>The name of a variant to select.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the variant \"cone\" in a variant set \"shapes\" on the \"shape_shifter\" primitive.</code><code class=\"codeline\">usd_setvariantselection(0, \"/geo/shape_shifter\", \"shapes\", \"cone\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_variants\">usd_variants</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_variantselection\">usd_variantselection</a></div></body>",
    "usd_setvisibility": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setvisibility\">usd_setvisibility</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Configures the primitive to be visible, invisible, or to inherit visibility\nfrom the parent.</p><div class=\"usage\"> <code>int usd_setvisibility(int stagehandle, string primpath, int code)</code></div><p>This function makes the primitive visible or invisible, or configures it to inherit the visibility from the parent. </p><p>Making a primitive visible may require changing the visibility state of its ancestors, while making it invisible or configuring it to inherit the visibility from the parent only requires setting its attribute.</p><p>NOTE: This function is similar to <code>usd_setvisible()</code> which, is equivalent to calling this function with either visibility or invisibility code.</p><div class=\"argument\"><code>code</code></div><div class=\"argument\"><code>A numeric code for visibility</code></div><div class=\"related\">0 - make the primitive invisible</div><div class=\"related\">1 - configure the primitive to be visible</div><div class=\"related\">2 - mark the primitive to inherit visibility from the parent</div><p>Note, these numeric codes are reflected as defines in the usd.h header file, as USD_VISIBILITY_INVISIBLE, USD_VISIBILITY_VISIBLE, and USD_VISIBILITY_INHERIT.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">#include &lt;usd.h&gt;</code><code class=\"codeline\">// Make the sphere primitive visible.</code><code class=\"codeline\">usd_setvisibility(0, \"/geo/sphere\", USD_VISIBILITY_VISIBLE);</code><code class=\"codeline\"></code><code class=\"codeline\">// Configure the cube primitive to inherit visibility from parent.</code><code class=\"codeline\">usd_setvisibility(0, \"/geo/cube\", USD_VISIBILITY_INHERIT);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setvisible\">usd_setvisible</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isvisible\">usd_isvisible</a></div></body>",
    "usd_setvisible": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setvisible\">usd_setvisible</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Makes the primitive visible or invisible.</p><div class=\"usage\"> <code>int usd_setvisible(int stagehandle, string primpath, int flag)</code></div><p>This function makes the primitive visible or invisible, depending on the given flag parameter.</p><p>NOTE: This function is similar to <code>usd_setvisibility()</code> which, in addition to making a primitive visible or invisible, can also configure it to inherit visibility from the parent.</p><div class=\"argument\"><code>flag</code></div><p>Non-zero to make the primitive visible or 0 to make it invisible.</p><h2>Returns</h2><p>The value of <code>stagehandle</code> on success or <code>-1</code> on failure.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Set the sphere primitive as visible.</code><code class=\"codeline\">usd_setvisible(0, \"/geo/sphere\", true);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setvisibility\">usd_setvisibility</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isvisible\">usd_isvisible</a></div></body>",
    "usd_specifier": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_specifier\">usd_specifier</a></h1><span class=\"padder\"><span class=\"pillow\">19.0</span></span><p class=\"summary\">Returns the primitive\u2019s specifier.</p><div class=\"usage\"> <code>string usd_specifier(&lt;stage&gt;, string primpath)</code></div><p>This function returns the given primitive\u2019s specifier, e.g., def, class, etc.</p><h2>Returns</h2><p>The specifier of the given primitive.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the sphere primitive's specifier.</code><code class=\"codeline\">string specifier = usd_specifier(0, \"/geo/sphere\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_typename\">usd_typename</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isabstract\">usd_isabstract</a></div></body>",
    "usd_transformname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformname\">usd_transformname</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Constructs a full name of a transform operation</p><div class=\"usage\"> <code>string usd_transformname(int transformtype, string suffix)</code></div><p>This function returns the full name of a transform operation for the given type and suffix.</p><div class=\"argument\"><code>transformtype</code></div><p>The numerical code for the transformation type. See the VEX usd.h header for defines, such as <code>USD_XFORM_TRANSLATE</code>, <code>USD_XFORM_TRANSFORM</code>, or <code>USD_XFORM_ROTATE_XYZ</code>.</p><h2>Returns</h2><p>The full name of transform operation.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Construct a full name for a translation operation with suffix \"cone_pivot\"</code><code class=\"codeline\">string pivot_xform_name = usd_transformname(USD_XFORM_TRANSLATE, \"cone_pivot\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_uniquetransformname\">usd_uniquetransformname</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformtype\">usd_transformtype</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformsuffix\">usd_transformsuffix</a></div></body>",
    "usd_transformorder": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformorder\">usd_transformorder</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Obtains the primitive\u2019s transform order</p><div class=\"usage\"> <code>string[] usd_transformorder(&lt;stage&gt;, string primpath)</code></div><p>This function returns primitive\u2019s local transform. Transform order is a sequence of transform operations, whose full names are stored in <code>xformOpOrder</code> attribute as a string array.  Thus, this function returns the value of that attribute.</p><h2>Returns</h2><p>The primitive\u2019s transform order.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the cube's transform order.</code><code class=\"codeline\">string cube_xform_ops[] = usd_transformorder(0, \"/geo/cube\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_settransformorder\">usd_settransformorder</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_addtotransformorder\">usd_addtotransformorder</a></div></body>",
    "usd_transformsuffix": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformsuffix\">usd_transformsuffix</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Extracts the transform operation suffix from the full name</p><div class=\"usage\"> <code>string usd_transformsuffix(string name)</code></div><p>This function returns the suffix contained in the full name of a transform operation.</p><div class=\"argument\"><code>name</code></div><p>The full name of the transform operation, which includes the standard namespace, encodes transformation type, and optionally contains the suffix.</p><h2>Returns</h2><p>The suffix contained in the transform operation name.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the suffix of the first transform operation on the cube</code><code class=\"codeline\">string cube_xform_ops[] = usd_transformorder(0, \"/geo/cube\");</code><code class=\"codeline\">string suffix = usd_transformsuffix(cube_xform_ops[0]);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformname\">usd_transformname</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformtype\">usd_transformtype</a></div></body>",
    "usd_transformtype": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformtype\">usd_transformtype</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Infers the transform operation type from the full name</p><div class=\"usage\"> <code>int usd_transformtype(string name)</code></div><p>This function returns the transform operation type implied by the full name.</p><div class=\"argument\"><code>name</code></div><p>The full name of the transform operation, which includes the standard namespace, encodes transformation type, and optionally contains the suffix.</p><h2>Returns</h2><p>The the numerical code for the inferred transform operation type implied by the transform operation name.  See the VEX usd.h header for defines, such as <code>USD_XFORM_TRANSLATE</code>, <code>USD_XFORM_TRANSFORM</code>, or <code>USD_XFORM_ROTATE_XYZ</code>.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the type of the first transform operation on the cube</code><code class=\"codeline\">string cube_xform_ops[] = usd_transformorder(0, \"/geo/cube\");</code><code class=\"codeline\">int type = usd_transformtype(cube_xform_ops[0]);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformname\">usd_transformname</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformsuffix\">usd_transformsuffix</a></div></body>",
    "usd_typename": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_typename\">usd_typename</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Returns the name of the primitive\u2019s type.</p><div class=\"usage\"> <code>string usd_typename(&lt;stage&gt;, string primpath)</code></div><p>This function returns the type name of the given primitive.</p><h2>Returns</h2><p>The name of the primitive\u2019s type.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the primitive's type name, eg \"Cube\".</code><code class=\"codeline\">string type_name = usd_typename(0, \"/geo/cube\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_istype\">usd_istype</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_hasapi\">usd_hasapi</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_name\">usd_name</a></div></body>",
    "usd_uniquetransformname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_uniquetransformname\">usd_uniquetransformname</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Constructs a unique full name of a transform operation</p><div class=\"usage\"> <code>string usd_uniquetransformname(&lt;stage&gt;, string primpath, int transformtype, string suffix)</code></div><p>This function returns a unique full name for a transform operation, given its type and suffix, that is different from any name that currently exists on the given primitive. It can be useful to ensure that the suffix used for the operation name does not stomp on any existing one.</p><div class=\"argument\"><code>transformtype</code></div><p>The numerical code for the transformation type. See the VEX usd.h header for defines, such as <code>USD_XFORM_TRANSLATE</code>, <code>USD_XFORM_TRANSFORM</code>, or <code>USD_XFORM_ROTATE_XYZ</code>.</p><h2>Returns</h2><p>A unique full name of transform operation.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Construct a unique full name for a translation operation with suffix \"cone_pivot\"</code><code class=\"codeline\">string unique_xform_name  = usd_uniquetransformname(0, \"/geo/cone\", USD_XFORM_TRANSLATE, \"cone_pivot\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_transformname\">usd_transformname</a></div></body>",
    "usd_variants": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_variants\">usd_variants</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Returns the variants belonging to the given variant set on a primitive.</p><div class=\"usage\"> <code>string[] usd_variants(&lt;stage&gt;, string primpath, string variantset)</code></div><p>This function returns the variants available in the given variant set.</p><div class=\"argument\"><code>variantset</code></div><p>The variant set name.</p><h2>Returns</h2><p>The names of the variants available in a given variant set on a given primitive.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the variants in the variant set \"shapes\" on a \"shape_shifter\" primitive.</code><code class=\"codeline\">string variants[] = usd_variants(0, \"/geo/shape_shifter\", \"shapes\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_variantsets\">usd_variantsets</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_variantselection\">usd_variantselection</a></div></body>",
    "usd_variantselection": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_variantselection\">usd_variantselection</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Returns the currently selected variant in a given variant set.</p><div class=\"usage\"> <code>string usd_variantselection(&lt;stage&gt;, string primpath, string variantset)</code></div><p>This function returns the current variant in a given variant set on a given primitive.</p><div class=\"argument\"><code>variantset</code></div><p>The variant set name.</p><h2>Returns</h2><p>The currently selected variant in a given variant set on a given primitive.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the currently selected variant in the variant set \"shapes\" on a \"shape_shifter\" primitive.</code><code class=\"codeline\">string selected_variant = usd_variantselection(0, \"/geo/shape_shifter\", \"shapes\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_variants\">usd_variants</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_setvariantselection\">usd_setvariantselection</a></div></body>",
    "usd_variantsets": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_variantsets\">usd_variantsets</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Returns the variant sets available on a primitive.</p><div class=\"usage\"> <code>string[] usd_variantsets(&lt;stage&gt;, string primpath)</code></div><p>This function returns the variant sets for the given primitive.</p><h2>Returns</h2><p>The variant set names available on a given primitive.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the variant sets available on the \"shape_shifter\" primitive.</code><code class=\"codeline\">string variant_sets[] = usd_variantsets(0, \"/geo/shape_shifter\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_isprim\">usd_isprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_variants\">usd_variants</a></div></body>",
    "usd_worldtransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_worldtransform\">usd_worldtransform</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Obtains the primitive\u2019s world transform</p><div class=\"usage\"> <code>matrix usd_worldtransform(&lt;stage&gt;, string primpath)</code></div><div class=\"usage\"> <code>matrix usd_worldtransform(&lt;stage&gt;, string primpath, float timecode)</code></div><p>This function returns primitive\u2019s world transform.</p><h2>Returns</h2><p>The primitive\u2019s world transform.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// Get the cube's world transform.</code><code class=\"codeline\">matrix cube_world_xform = usd_worldtransform(0, \"/src/cube\");</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/usd_localtransform\">usd_localtransform</a></div></body>",
    "uvdist": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uvdist\">uvdist</a></h1><p class=\"summary\">Finds the distance of a uv coordinate to a geometry in uv space.</p><div class=\"usage\"> <code>float uvdist(&lt;geometry&gt;, string uvname, vector uv, int &amp;prim, vector &amp;primuv)</code></div><div class=\"usage\"> <code>float uvdist(&lt;geometry&gt;, string uvname, vector uv, int &amp;prim, vector &amp;primuv, float maxdist)</code></div><div class=\"usage\"> <code>float uvdist(&lt;geometry&gt;, string primgroup, string uvname, vector uv, int &amp;prim, vector &amp;primuv)</code></div><div class=\"usage\"> <code>float uvdist(&lt;geometry&gt;, string primgroup, string uvname, vector uv, int &amp;prim, vector &amp;primuv, float maxdist)</code></div><p>Returns the distance to the closest uv coordinate on the geometry in uv space.  This will find\npositions on the surfaces of the geometry, not just point positions.</p><div class=\"argument\"><code>primgroup</code></div><p>The name of a primitive group or a pattern to generate a primitive\n    group.  Uses the same semantics as a SOP group, so empty strings\n    will match all primitives.  Attribute groups like <code>@Cd.x&gt;0</code> can\n    also be used, but note that the <code>@</code> may need to be escaped with\n    a backslash in a <a href=\"https://www.sidefx.com/docs/houdini/nodes/vop/snippet\">Snippet VOP</a>.</p><div class=\"argument\"><code>uvname</code></div><p>The name of a point or vertex attribute on the <code class=\"var\">geometry</code> to\n    use as the uv space. The geometry will be unwrapped inplace based\n    on this attribute.\n    The attribute can be a 2D UV, 3D UVW, but also any vector attribute.</p><div class=\"argument\"><code>uv</code></div><p>The position in uv space to find the closest position on the geometry to.</p><div class=\"argument\"><code>prim</code></div><p>The number of the closest primitive.  -1 if no primitive found.</p><div class=\"argument\"><code>primuv</code></div><p>The primitive uv coordinates the closest primitive.  The <code>primuv</code> function\n    can be used to evaluate attributes at that location.</p><div class=\"argument\"><code>maxdist</code></div><p>The maximum distance to search in uv space. The operation can be sped up if it\n    is allowed to quit early.</p></body>",
    "uvintersect": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uvintersect\">uvintersect</a></h1><p class=\"summary\">This function computes the intersection of the specified ray with the geometry in uv space.</p><div class=\"usage\"> <code>int uvintersect(&lt;geometry&gt;, string uvname, vector orig, vector dir, vector &amp;pos, vector &amp;primuv)</code></div><div class=\"usage\"> <code>int uvintersect(&lt;geometry&gt;, string primgroup, string uvname, vector orig, vector dir, vector &amp;pos, vector &amp;primuv)</code></div><div class=\"argument\"><code>primgroup</code></div><p>The name of a primitive group or a pattern to generate a primitive\n    group.  Uses the same semantics as a SOP group, so empty strings\n    will match all primitives.  Attribute groups like <code>@Cd.x&gt;0</code> can\n    also be used, but note that the <code>@</code> may need to be escaped with\n    a backslash in a <a href=\"https://www.sidefx.com/docs/houdini/nodes/vop/snippet\">Snippet VOP</a>.</p><p>This function computes the intersection of the specified ray with the geometry in uv space. The primitive number is returned, or -1 if there is an error or no intersection found.</p><p>The position in uvspace of the intersection location is stored in <code class=\"var\">p</code>. The corresponding parametric location of the intersection is stored in <code class=\"var\">primuv</code>. In the case of multiple intersections, the intersection closest to the ray origin is used.</p><p>This function does not expect a normalized direction vector. Instead, it uses the length of the vector as the maximum distance. The integer result is the primitive hit.</p><h2>Note</h2><p>It can be hard to visualize a 3D intersection of a ray in a 3D UV space. One trick that can be used is to unwrap the geometry in SOP to get better visualization of the space. This can be done by using a <a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/splitvertex\">Split Vertex SOP</a> followed by a <a href=\"https://www.sidefx.com/docs/houdini/nodes/sop/attribcopy\">Attribute Copy SOP</a>. This will disconnect the faces at uv boundaries and stamp the uvw values on top of the <code>P</code> attribute.</p><h2>Note</h2><p>When intersections are performed against metaball geometry, it is impossible to determine the primitive number of the metaball which was hit. In this case, the function returns the number of primitives in the intersection geometry.</p></body>",
    "uvsample": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uvsample\">uvsample</a></h1><p class=\"summary\">Interpolates the value of an attribute at certain UV coordinates using a UV attribute.</p><p>This function specifies the position using UVs from a UV attribute. To use <em>intrinsic primitive UVs</em>, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primuv\">primuv</a> instead.</p><div class=\"usage\"> <code>&lt;type&gt; uvsample(&lt;geometry&gt;, string attr_name, string uv_attr_name, vector uvw)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] uvsample(&lt;geometry&gt;, string attr_name, string uv_attr_name, vector uvw)</code></div><div class=\"usage\"> <code>&lt;type&gt; uvsample(&lt;geometry&gt;, string primgroup, string attr_name, string uv_attr_name, vector uvw)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] uvsample(&lt;geometry&gt;, string primgroup, string attr_name, string uv_attr_name, vector uvw)</code></div><div class=\"argument\"><code>primgroup</code></div><p>The name of a primitive group or a pattern to generate a primitive\n    group.  Uses the same semantics as a SOP group, so empty strings\n    will match all primitives.  Attribute groups like <code>@Cd.x&gt;0</code> can\n    also be used, but note that the <code>@</code> may need to be escaped with\n    a backslash in a <a href=\"https://www.sidefx.com/docs/houdini/nodes/vop/snippet\">Snippet VOP</a>.</p><div class=\"argument\"><code>attr_name</code></div><p>The name of a point or vertex attribute to sample. For primitive attributes, the value is taken from the primitive under the given UVs. <strong>For point and vertex attributes, the value at the given UV coordinates will be interpolated from the surrounding points/vertices</strong>. The values are taken from the lowest level at which an attribute with this name exists.</p><p>This must be a 3-float attribute.</p><div class=\"argument\"><code>uv_attr_name</code></div><p>The name of a point or vertex attribute containing UVs. The default UVs created by Houdini are in an attribute named <code>uv</code>. The named attribute can be 2D (UV) or 3D (UVW) in any vector type.</p><div class=\"argument\"><code>uvw</code></div><p>The position in UV(W) space at which to sample the attribute.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primuv\">primuv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/prim_attribute\">prim_attribute</a></div></body>",
    "uvunwrap": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uvunwrap\">uvunwrap</a></h1><p class=\"summary\">Computes the position and normal at given (u, v) coordinates, for use in a lens shader.</p><div class=\"usage\"> <code>int uvunwrap( string object_path; float u; float v; float time; vector &amp;P; vector &amp;I )</code></div><div class=\"usage\"> <code>int uvunwrap( string object_path; float u; float v; float time; vector &amp;P; vector &amp;I; vector &amp;mikkelsenUtan; vector &amp;mikkelsenVtan )</code></div><p>This function <strong>only makes sense in a Mantra context</strong>, for use in <strong>texture baking</strong> or in a <strong>lens shader</strong>. The function unfortunately must be context-less so it\u2019s available to the CVEX lens shader, but in any other context it will fail and return <code>0</code>.</p><p>For any other kind of texture sampling, use the superior <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uvsample\">uvsample</a> or <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uvintersect\">uvintersect</a> functions instead of this.</p><div class=\"argument\"><code>object_path</code></div><p>The object being unwrapped.</p><div class=\"argument\"><code><code>u</code>, <code>v</code></code></div><p>The UV coordinates specifying where on the surface to get the position and normal.</p><div class=\"argument\"><code>time</code></div><p>The time along the timeline at which to measure the geometry, in seconds.</p><div class=\"argument\"><code>&amp;P</code></div><p>If it succeeds, the function overwrites this variable with the world space position of the given point.</p><div class=\"argument\"><code>&amp;I</code></div><p>If it succeeds, the function overwrites this variable with the normal at the given point.</p><div class=\"argument\"><code><code>&amp;mikkelsenUtan</code>, <code>&amp;mikkelsenVtan</code></code></div><p>The function overwrites these variables with the Mikkelsen tangent vectors.</p><h2>Returns</h2><p><code>1</code> if the UV coordinates specified a valid point on the surface, or <code>0</code> otherwise.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uvsample\">uvsample</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/uvintersect\">uvintersect</a></div></body>",
    "variance": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/variance\">variance</a></h1><p class=\"summary\">Computes the mean value and variance for a value.</p><div class=\"usage\"> <code>float variance(float variable, float &amp;mean, int &amp;sample_size)</code></div><p>This function will compute the mean and variance from nearby samples.  Similar to the way that VEX is able to compute derivatives, this function is able to inspect the <code>variable</code> for a nearby area and compute the mean and variance of the <code>variable</code>.</p><p>The function returns the <code>variance</code> (\u03c32).  The <code>mean</code> value will also be returned along with the <code>sample_size</code> indicating how many nearby samples were considered.</p></body>",
    "velocityname": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/velocityname\">velocityname</a></h1><span class=\"padder\"><span class=\"pillow\">cop</span></span><p class=\"summary\">Returns the default name of the velocity plane (as it appears in the\ncompositor preferences).</p><div class=\"usage\"> <code>string velocityname()</code></div><p>Returns the default name of the velocity plane (as it appears in the\ncompositor preferences). Using this instead of hardcoding the default\nmakes your code more portable. Default is V.</p></body>",
    "vertex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertex\">vertex</a></h1><p class=\"summary\">Reads a vertex attribute value from a geometry.</p><div class=\"usage\"> <code>&lt;type&gt; vertex(&lt;geometry&gt;, string attribute_name, int linear_vertex_index)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] vertex(&lt;geometry&gt;, string attribute_name, int linear_vertex_index)</code></div><p>Specifies the vertex using the linear index into the list of all vertices.</p><div class=\"usage\"> <code>&lt;type&gt; vertex(&lt;geometry&gt;, string attribute_name, int prim_num, int vertex_num)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] vertex(&lt;geometry&gt;, string attribute_name, int prim_num, int vertex_num)</code></div><p>Specifies the vertex as a primitive number and then an offset into the list of vertices on that primitive.</p><h2>Returns</h2><p>The value of the given attribute on the given vertex, or <code>0</code> if the attribute or vertex do not exist.</p></body>",
    "vertexattrib": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexattrib\">vertexattrib</a></h1><p class=\"summary\">Reads a vertex attribute value from a geometry.</p><div class=\"usage\"> <code>&lt;type&gt; vertexattrib(&lt;geometry&gt;, string attribute_name, int linear_vertex_index, int &amp;success)</code></div><div class=\"usage\"> <code>&lt;type&gt;[] vertexattrib(&lt;geometry&gt;, string attribute_name, int linear_vertex_index, int &amp;success)</code></div><p>Unlike <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertex\">vertex</a>, this function does not have a version that takes a primitive number and primitive vertex number. If you have a primitive number and primitive vertex number, you can convert them into a linear index using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexindex\">vertexindex</a>.</p><div class=\"argument\"><code>linear_vertex_index</code></div><p>A linear index into the list of all vertices. If you have a primitive number and primitive vertex number, you can convert them into a linear index using <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexindex\">vertexindex</a>.</p><div class=\"argument\"><code>success</code></div><p>The function overwrites this variable with <code>1</code> if the attribute exists and was read successfully, or <code>0</code> otherwise.</p><h2>Returns</h2><p>The value of the given attribute on the given point number. </p></body>",
    "vertexattribsize": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexattribsize\">vertexattribsize</a></h1><p class=\"summary\">Returns the size of a geometry vertex attribute.</p><div class=\"usage\"> <code>int vertexattribsize(&lt;geometry&gt;, string attribute_name)</code></div><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribsize\">attribsize</a> for more information.</p><p>Returns <code>0</code> if the attribute cannot be found.</p></body>",
    "vertexattribtype": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexattribtype\">vertexattribtype</a></h1><p class=\"summary\">Returns the type of a geometry vertex attribute.</p><div class=\"usage\"> <code>int vertexattribtype(&lt;geometry&gt;, string attribute_name)</code></div><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribtype\">attribtype</a> for more information.</p></body>",
    "vertexattribtypeinfo": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexattribtypeinfo\">vertexattribtypeinfo</a></h1><p class=\"summary\">Returns the type info of a geometry attribute.</p><div class=\"usage\"> <code>string vertexattribtypeinfo(&lt;geometry&gt;, string attribute_name)</code></div><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/attribtypeinfo\">attribtypeinfo</a> for more information.</p></body>",
    "vertexcurveparam": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexcurveparam\">vertexcurveparam</a></h1><p class=\"summary\">Returns the parametric coordinate of a vertex along the perimeter of\nits primitive.</p><div class=\"usage\"> <code>float vertexcurveparam(&lt;geometry&gt;, int linearindex)</code></div><div class=\"argument\"><code>linearindex</code></div><p>The linear index of a vertex</p><h2>Returns</h2><p>The parametric coordinate along the perimeter of the primitive. The\n    primitive is assumed to be a polygon. This is in unit space (See\n    <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primuv\">primuv</a> for a distription of parameter spaces).</p><p>For open polygons (polygon curves in other words), the returned value can\n    be used directly with <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primuv\">primuv</a>. It is in the range of <a href=\"https://www.sidefx.com/docs/houdini0,1\">0,1</a>.</p><p>For closed polygons the value is in the range of <a href=\"https://www.sidefx.com/docs/houdini0, (numvtx-1)/numvtx\">0, (numvtx-1)/numvtx</a>, so\n    there\u2019s no vertex with value 1. The value cannot be used directly with\n    <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primuv\">primuv</a>, but may be useful wherever you need a normalized value around\n    the perimeter of a polygon.</p><h2>Examples</h2><p>This is roughly equivalent to the following code:</p><div class=\"codeblock\"><code class=\"codeline\">int closed = primintrinsic(0, \"closed\", @primnum);</code><code class=\"codeline\">float u = float(vertexprimindex(opname, @vtxnum)) / (closed ? @numvtx : @numvtx-1);</code></div><p>Look up a ramp using the current point\u2019s location on the curve:</p><div class=\"codeblock\"><code class=\"codeline\">// Find the curve parameter of the current vertex and use it</code><code class=\"codeline\">// to look up a ramp parameter.</code><code class=\"codeline\">// Note that @vtxnum also works when iterating over points.</code><code class=\"codeline\">float u = vertexcurveparam(0, @vtxnum);</code><code class=\"codeline\">// convert to unitlen space, to correct for points unevenly distributed along</code><code class=\"codeline\">// the curve</code><code class=\"codeline\">u = primuvconvert(0, u, @primnum, PRIMUV_UNIT_TO_UNITLEN);</code><code class=\"codeline\">@width = chramp(\"width\", u);</code></div><p>Look up an attribute on another curve, at the equivalent location. This\ncorrects for unevenly distributed points on either curve.</p><div class=\"codeblock\"><code class=\"codeline\">// Note that @vtxnum also works when iterating over points.</code><code class=\"codeline\">float u = vertexcurveparam(0, @vtxnum);</code><code class=\"codeline\">// convert to unit length space, to correct for points unevenly distributed</code><code class=\"codeline\">// along the curve</code><code class=\"codeline\">u = primuvconvert(0, u, @primnum, PRIMUV_UNIT_TO_UNITLEN);</code><code class=\"codeline\"></code><code class=\"codeline\">// convert back to unit space on another curve. We're using the equivalent</code><code class=\"codeline\">// curve in the second input.</code><code class=\"codeline\">int otherinput = 1;</code><code class=\"codeline\">int otherprim = @primnum;</code><code class=\"codeline\">u = primuvconvert(otherinput, u, otherprim, PRIMUV_UNITLEN_TO_UNIT);</code><code class=\"codeline\"></code><code class=\"codeline\">// look up the value using the correct u coordinate.</code><code class=\"codeline\">@P = primuv(otherinput, \"P\", otherprim, u);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexprim\">vertexprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexindex\">vertexindex</a></div></body>",
    "vertexhedge": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexhedge\">vertexhedge</a></h1><p class=\"summary\">Returns the half-edge which has a vertex as source.</p><div class=\"usage\"> <code>int vertexhedge(&lt;geometry&gt;, int vertex)</code></div><div class=\"argument\"><code>vertex</code></div><p>The linear vertex number in the geometry.  <code>0</code> is the first vertex.</p><h2>Returns</h2><p>The number for the half-edge that has <code>vertex</code> as source and the vertex following <code>vertex</code> in the primitive of <code>vertex</code> as destination.\n    Returns <code>-1</code> if failed to find the corresponding vertex.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int vtxhedge;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the hedge out of vertex vertex number 2.</code><code class=\"codeline\">vtxhedge = vertexhedge(\"defgeo.bgeo\", 2);</code></div></body>",
    "vertexindex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexindex\">vertexindex</a></h1><p class=\"summary\">Converts a primitive/vertex pair into a linear vertex.</p><div class=\"usage\"> <code>int vertexindex(&lt;geometry&gt;, int primnum, int vertex)</code></div><div class=\"argument\"><code>primnum</code></div><p>The primitive number to get a vertex from.</p><div class=\"argument\"><code>vertex</code></div><p>The vertex number inside of a primitive.  0 is the first vertex.</p><h2>Returns</h2><p>The linear vertex index corresponding to the given primitive vertex.\n    Returns <code>-1</code> if the function could not find the equivalent linear vertex index.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int linearvtx;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the linear vertex value of vertex 2 of primitive 3.</code><code class=\"codeline\">linearvtx = vertexindex(\"defgeo.bgeo\", 3, 2);</code></div></body>",
    "vertexnext": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexnext\">vertexnext</a></h1><p class=\"summary\">Returns the linear vertex number of the next vertex sharing a point with a given vertex.</p><div class=\"usage\"> <code>int vertexnext(&lt;geometry&gt;, int linearvertex)</code></div><h2>Returns</h2><p>The linear index of the next vertex sharing the same point with the given vertex,\n    or <code>-1</code> if the vertex has no later shared vertices.\n    (To go in the other direction, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexprev\">vertexprev</a>.)</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int        vtx;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the next vertex of vertex 3</code><code class=\"codeline\">vtx = vertexnext(\"defgeo.bgeo\", 3);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointvertex\">pointvertex</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexprev\">vertexprev</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexindex\">vertexindex</a></div></body>",
    "vertexpoint": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexpoint\">vertexpoint</a></h1><p class=\"summary\">Returns the point number of linear vertex in a geometry.</p><div class=\"usage\"> <code>int vertexpoint(&lt;geometry&gt;, int linearvertex)</code></div><div class=\"argument\"><code>linearvertex</code></div><p>The linear vertex number.  The <code>vertexindex</code> function can be used\n    to compute a linear vertex from a primitive number and vertex\n    number pair.</p><h2>Returns</h2><p>The point number associated with the vertex, or <code>-1</code> if the vertex has no point.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int        pt;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the point of vertex 3</code><code class=\"codeline\">pt = vertexpoint(\"defgeo.bgeo\", 3);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointvertex\">pointvertex</a></div></body>",
    "vertexprev": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexprev\">vertexprev</a></h1><p class=\"summary\">Returns the linear vertex number of the previous vertex sharing a point with a given vertex.</p><div class=\"usage\"> <code>int vertexprev(&lt;geometry&gt;, int linearvertex)</code></div><h2>Returns</h2><p>The linear index of the previous vertex sharing the same point with the given vertex,\n    or <code>-1</code> if the vertex has no earlier shared vertices.\n    (To go in the other direction, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexnext\">vertexnext</a>.)</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int        vtx;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the previous vertex of vertex 3</code><code class=\"codeline\">vtx = vertexprev(\"defgeo.bgeo\", 3);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/pointvertex\">pointvertex</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexnext\">vertexnext</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexindex\">vertexindex</a></div></body>",
    "vertexprim": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexprim\">vertexprim</a></h1><p class=\"summary\">Returns the number of the primitive containing a given vertex.</p><div class=\"usage\"> <code>int vertexprim(&lt;geometry&gt;, int linearvertex)</code></div><h2>Note</h2><p>To convert the linear index into a primitive number and primitive vertex number,\n    use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexprim\">vertexprim</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexprimindex\">vertexprimindex</a>.</p><h2>Returns</h2><p>The primitive number of the primitive containing the vertex,\n    or <code>-1</code> if the vertex has no primitive.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int        pt;</code><code class=\"codeline\"></code><code class=\"codeline\">// Get the primitive of vertex 3</code><code class=\"codeline\">pt = vertexprim(\"defgeo.bgeo\", 3);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexpoint\">vertexpoint</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexindex\">vertexindex</a></div></body>",
    "vertexprimindex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexprimindex\">vertexprimindex</a></h1><p class=\"summary\">Converts a linear vertex index into a primitive vertex number.</p><div class=\"usage\"> <code>int vertexprimindex(&lt;geometry&gt;, int linearindex)</code></div><h2>Note</h2><p>To convert the linear index into a primitive number and primitive vertex number,\n    use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexprim\">vertexprim</a> and <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexprimindex\">vertexprimindex</a>.</p><div class=\"argument\"><code>linearindex</code></div><p>The linear index of a vertex</p><h2>Returns</h2><p>The vertex\u2019s number within the primitive that contains it, or\n    <code>-1</code> if the vertex has no primitive.</p><p>To get the primitive number of the containing primitive, use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexprim\">vertexprim</a>.</p><h2>Note</h2><p>Due to the nature of the geometry structure, the first time this is run on\n    a geometry it has to run over all primitives to find the look up table.\n    This will be amortized out if most vertices are invoking this function.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">int prim, vtx;</code><code class=\"codeline\"></code><code class=\"codeline\">// Find the primitive and vertex offset of the linear vertex 6.</code><code class=\"codeline\">prim = vertexprim(\"defgeo.bgeo\", 6);</code><code class=\"codeline\">vtx = vertexprimindex(\"defgeo.bgeo\", 6);</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexprim\">vertexprim</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vertexindex\">vertexindex</a></div></body>",
    "vnoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vnoise\">vnoise</a></h1><p class=\"summary\">Generates Voronoi (cellular) noise.</p><div class=\"usage\"> <code>void vnoise( float position; float jitter; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;pos1; float &amp;pos2 )</code></div><p>Generates 1D noise.</p><div class=\"usage\"> <code>void vnoise( float position; float jitter; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;pos1; float &amp;pos2; int period)</code></div><p>Generates periodic 1D noise.</p><div class=\"usage\"> <code>void vnoise( float posx; float posy; float jittx; float jitty; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;pos1x; float &amp;pos1y; float &amp;pos2x; float &amp;pos2y )</code></div><p>Generates 2D noise. This is similar to the other forms but uses pairs of floats instead of a vector.</p><div class=\"usage\"> <code>void vnoise( float posx; float posy; float jittx; float jitty; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;pos1x; float &amp;pos1y; float &amp;pos2x; float &amp;pos2; int periodx; int periody )</code></div><p>Generates periodic 2D noise.</p><div class=\"usage\"> <code>void vnoise( vector position; vector jitter; int &amp;seed; float &amp;f1; float &amp;f2; vector &amp;pos1; vector &amp;pos2 )</code></div><p>Generates 3D noise.</p><div class=\"usage\"> <code>void vnoise( vector position; vector jitter; int &amp;seed; float &amp;f1; float &amp;f2; vector &amp;pos1; vector &amp;pos2; int periodx; int periody; int periodz )</code></div><div class=\"usage\"> <code>void vnoise( vector position; vector jitter; int &amp;seed; float &amp;f1; float &amp;f2; vector &amp;pos1; vector &amp;pos2; vector period )</code></div><p>Generates periodic 3D noise.</p><div class=\"usage\"> <code>void vnoise( vector4 position; vector4 jitter; int &amp;seed; float &amp;f1; float &amp;f2; vector4 &amp;pos1; vector4 &amp;pos2 )</code></div><p>Generates 4D noise.</p><div class=\"usage\"> <code>void vnoise( vector4 position; vector4 jitter; int &amp;seed; float &amp;f1; float &amp;f2; vector4 &amp;pos1; vector4 &amp;pos2; int periodx; int periody; int periodz; int periodw )</code></div><div class=\"usage\"> <code>void vnoise( vector4 position; vector4 jitter; int &amp;seed; float &amp;f1; float &amp;f2; vector4 &amp;pos1; vector4 &amp;pos2; vector4 period )</code></div><p>Generates periodic 4D noise.</p><div class=\"argument\"><code>jitter</code></div><p>The amount of randomness to add to the noise in each axis.</p><div class=\"argument\"><code><code>pos1</code>, <code>pos2</code></code></div><p>These variables are overwritten with the positions of the two nearest seed points, in order of closeness.</p><div class=\"argument\"><code><code>f1</code>, <code>f2</code></code></div><p>Voronoi noise gives almost identical results to the Worley noise function (<a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wnoise\">wnoise</a>). However, this function has controls over jittering (i.e. how randomly the points are scattered through space) and also return the actual locations of the two nearest seed points, whereas <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wnoise\">wnoise</a> only returns the distances to the two nearest seed points.</p><p>Though this function is slightly more expensive than <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wnoise\">wnoise</a>, since it returns the actual point positions, you can overcome some of the artifacts of Worley noise. For example, to get even boundaries along the cell boundaries:</p><div class=\"codeblock\"><code class=\"codeline\">if (f2 - f1 &lt; tolerance * (distance(p1, p2) / (f1 + f2)) ...</code></div><p>This will normalize the boundary width based on the distance between the two random points in space.</p><p>There are also periodic forms of vnoise().</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">// 1D noise</code><code class=\"codeline\">float    fp0, fp1, p1x, p1y, p2x, p2y;</code><code class=\"codeline\">vector    vp0, vp1;</code><code class=\"codeline\">vnoise(s*10, 0.8, seed, f1, f2, fp0, fp1);</code><code class=\"codeline\">vnoise(s*10, t*10, 0.8, 0.8, seed, f1, f2, p1x, p1y, p2x, p2y);</code><code class=\"codeline\">vnoise(P*10, {.8, .8, .8}, seed, f1, f2, vp0, vp1);</code></div><h2>Related</h2></body>",
    "volume": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volume\">volume</a></h1><p class=\"summary\">Returns the volume of the microvoxel containing a variable such as P.</p><div class=\"usage\"> <code>float volume(vector pos, ...)</code></div><h2>Note</h2><p>This function relies on the fact that VEX knows that <code>pos</code> has\n    derivatives (<code>dPdu</code>, <code>dPdv</code>, and <code>dPdz</code>).\n    Passing a literal vector instead of a special variables such as <code>P</code>\n    will return <code>0</code> since VEX will not be able to access the derivatives.</p><h2>Examples</h2><p>Return the volume of the current micro-voxel in camera space:</p><div class=\"codeblock\"><code class=\"codeline\">volume(P)</code></div><p>Returns <code>0</code>, since the argument is not a variable VEX knows the derivatives for:</p><div class=\"codeblock\"><code class=\"codeline\">volume({0.1, 2.3, 4.5})</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/area\">area</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/gradient\">gradient</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Du\">Du</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dv\">Dv</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/Dw\">Dw</a></div></body>",
    "volumecubicsample": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volumecubicsample\">volumecubicsample</a></h1><p class=\"summary\">Samples the volume primitive\u2019s value.</p><div class=\"usage\"> <code>float volumecubicsample(&lt;geometry&gt;, int primnum, vector pos)</code></div><div class=\"usage\"> <code>float volumecubicsample(&lt;geometry&gt;, string volumename, vector pos)</code></div><div class=\"usage\"> <code>float volumecubicsample(&lt;geometry&gt;, int primnum, vector pos, vector &amp;grad)</code></div><div class=\"usage\"> <code>float volumecubicsample(&lt;geometry&gt;, string volumename, vector pos, vector &amp;grad)</code></div><div class=\"usage\"> <code>float volumecubicsample(&lt;geometry&gt;, int primnum, vector pos, vector &amp;grad, matrix3 &amp;hess)</code></div><div class=\"usage\"> <code>float volumecubicsample(&lt;geometry&gt;, string volumename, vector pos, vector &amp;grad, matrix3 &amp;hess)</code></div><h2>Returns</h2><p>The volume primitive\u2019s sampled value at the given position. Values between voxels are evaluated with tri-cubic interpolation.</p><p>The <code>grad</code> and <code>hess</code> arguments return the gradient or the hessian of this sampling function which can be computed at the same time as the value.</p><p>Returns 0 if <code>primnum</code> or <code>inputnum</code> is out of range, the geometry is invalid, or the given primitive is not a volume or vdb primitive.</p><p><a href=\"https://www.sidefx.com/docs/houdini/images/vex/volumecubicsample.png\">/images/vex/volumecubicsample.png</a></p><p>Example of interpolation of one and two dimensional data using <code>volumecubicsample</code>. The visualized normal is computed using the <code>grad</code> parameter.</p><h2>Examples</h2><p>Approximating a volume value at the point <code>P + u</code> using volume values at the point <code>P</code>.</p><div class=\"codeblock\"><code class=\"codeline\">vector  P = {1.0, 2.0, 3.0};</code><code class=\"codeline\">vector grad;</code><code class=\"codeline\">matrix3 hess;</code><code class=\"codeline\">float val1 = volumecubicsample(0, \"density\", P, grad, hess);</code><code class=\"codeline\"></code><code class=\"codeline\">vector u = {0.1, 0.01, 0.001};</code><code class=\"codeline\">float val2 = volumecubicsample(0, \"density\", P + u);</code><code class=\"codeline\"></code><code class=\"codeline\">// By Taylor expansion we have:</code><code class=\"codeline\">// `val1 + dot(u, grad)` is approximately equal to `val2`</code><code class=\"codeline\"></code><code class=\"codeline\">// And the second order approximation:</code><code class=\"codeline\">// `val1 + (u, grad) + 0.5 * dot(u, u*hess)`</code><code class=\"codeline\">// is appriximately equal to `val2`</code></div></body>",
    "volumecubicsamplev": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volumecubicsamplev\">volumecubicsamplev</a></h1><p class=\"summary\">Samples the volume primitive\u2019s value.</p><div class=\"usage\"> <code>vector volumecubicsamplev(&lt;geometry&gt;, int primnum, vector pos)</code></div><div class=\"usage\"> <code>vector volumecubicsamplev(&lt;geometry&gt;, string volumename, vector pos)</code></div><div class=\"usage\"> <code>vector volumecubicsamplev(&lt;geometry&gt;, int primnum, vector pos, matrix3 &amp;grad)</code></div><div class=\"usage\"> <code>vector volumecubicsamplev(&lt;geometry&gt;, string volumename, vector pos, matrix3 &amp;grad)</code></div><div class=\"usage\"> <code>vector volumecubicsamplev(&lt;geometry&gt;, int primnum, vector pos, matrix3 &amp;grad, matrix3 &amp;hessX, matrix3 &amp;hessY, matrix3 &amp;hessZ)</code></div><div class=\"usage\"> <code>vector volumecubicsamplev(&lt;geometry&gt;, string volumename, vector pos, matrix3 &amp;grad, matrix3 &amp;hessX, matrix3 &amp;hessY, matrix3 &amp;hessZ)</code></div><h2>Returns</h2><p>The volume primitive\u2019s sampled value at the given position. Values between voxels are evaluated with tri-cubic interpolation.</p><p>The <code>grad</code> is a matrix whose i-th column is the gradient of the i-th component of the volume.</p><p>Matrices <code>hessX</code>, <code>hessY</code>, <code>hessZ</code> are second derivatives of x, y and z component respectively.</p><p>Returns 0 if <code>primnum</code> or <code>inputnum</code> is out of range, the geometry is invalid, or the given primitive is not a volume or vdb primitive.</p><h2>Examples</h2><p>Approximating a volume value at the point <code>P + u</code> using volume values at the point <code>P</code>.</p><div class=\"codeblock\"><code class=\"codeline\">vector  P = {1.0, 2.0, 3.0};</code><code class=\"codeline\">matrix3 grad, hessX, hessY, hessZ;</code><code class=\"codeline\">vector val1 = volumecubicsamplev(0, \"vel\", P, grad, hessX, hessY, hessZ));</code><code class=\"codeline\"></code><code class=\"codeline\">vector u = {0.1, 0.01, 0.001};</code><code class=\"codeline\">vector val2 = volumecubicsamplev(0, \"vel\", P + u);</code><code class=\"codeline\"></code><code class=\"codeline\">// By Taylor expansion we have:</code><code class=\"codeline\">// `val1 + u * grad` is approximately equal to `val2`</code><code class=\"codeline\"></code><code class=\"codeline\">// And the second order approximation:</code><code class=\"codeline\">// `val1 + u * grad + 0.5 * set(dot(u, u*hessX), dot(u, u*hessY), dot(u, u*hessZ))`</code><code class=\"codeline\">// is appriximately equal to `val2`</code></div></body>",
    "volumegradient": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volumegradient\">volumegradient</a></h1><p class=\"summary\">Calculates the volume primitive\u2019s gradient.</p><div class=\"usage\"> <code>vector volumegradient(&lt;geometry&gt;, int primnum, vector pos)</code></div><div class=\"usage\"> <code>vector volumegradient(&lt;geometry&gt;, string volumename, vector pos)</code></div><h2>Returns</h2><p>The volume primitive\u2019s gradient. The gradient is a vector pointing in the direction of increasing value.</p><p>Returns 0 if <code>primnum</code> is out of range, the geometry is invalid, or the given primitive is not a volume primitive.</p></body>",
    "volumeindex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volumeindex\">volumeindex</a></h1><p class=\"summary\">Gets the value of a specific voxel.</p><div class=\"usage\"> <code>float volumeindex(&lt;geometry&gt;, int primnum, vector voxel)</code></div><div class=\"usage\"> <code>float volumeindex(&lt;geometry&gt;, string volumename, vector voxel)</code></div><h2>Returns</h2><p>The value of a specific voxel in a volume primitive.</p><p>Returns 0 if <code>primnum</code> is out of range, the geometry is invalid, or the given primitive is not a volume primitive.</p></body>",
    "volumeindexactive": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volumeindexactive\">volumeindexactive</a></h1><span class=\"padder\"><span class=\"pillow\">17.5</span></span><p class=\"summary\">Gets the active setting of a specific voxel.</p><div class=\"usage\"> <code>int volumeindexactive(&lt;geometry&gt;, int primnum, vector voxel)</code></div><div class=\"usage\"> <code>int volumeindexactive(&lt;geometry&gt;, string volumename, vector voxel)</code></div><h2>Returns</h2><p>Whether a specific voxel in a volume primitive is active.</p><p>While <code>volumesample</code> and <code>volumeindex</code> will always return values for any location in space, the actual voxel array is only defined for a subset of space.  For volumes, this is a square grid.   For VDBs, the shape of the active area can be arbitrary.</p><p>Returns 0 if <code>primnum</code> is out of range, the geometry is invalid, or the given primitive is not a volume primitive.</p></body>",
    "volumeindexorigin": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volumeindexorigin\">volumeindexorigin</a></h1><p class=\"summary\">Gets the index of the bottom left of a volume primitive.</p><div class=\"usage\"> <code>vector volumeindexorigin(&lt;geometry&gt;, int primnum)</code></div><div class=\"usage\"> <code>vector volumeindexorigin(&lt;geometry&gt;, string volumename)</code></div><h2>Returns</h2><p>The index of the bottom left of a volume primitive.\n    For Volume primitives, this is always zero.  However, for VDB primitives,\n    this represents the bottom left of their active bounding box of voxels.</p><p>Returns 0 if <code>primnum</code> is out of range, the geometry is invalid, or the given primitive is not a volume primitive.</p></body>",
    "volumeindextopos": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volumeindextopos\">volumeindextopos</a></h1><p class=\"summary\">Converts a volume voxel index into a position.</p><div class=\"usage\"> <code>vector volumeindextopos(&lt;geometry&gt;, int primnum, vector voxel)</code></div><div class=\"usage\"> <code>vector volumeindextopos(&lt;geometry&gt;, string volumename, vector voxel)</code></div><h2>Returns</h2><p>The position of the center of a voxel.</p><p>Returns 0 if <code>primnum</code> is out of range, the geometry is invalid, or the given primitive is not a volume primitive.</p></body>",
    "volumeindexv": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volumeindexv\">volumeindexv</a></h1><p class=\"summary\">Gets the vector value of a specific voxel.</p><div class=\"usage\"> <code>vector volumeindexv(&lt;geometry&gt;, int primnum, vector voxel)</code></div><div class=\"usage\"> <code>vector volumeindexv(&lt;geometry&gt;, string volumename, vector voxel)</code></div><h2>Returns</h2><p>The vector value of a specific voxel in a volume primitive.</p><p>Returns 0 if <code>primnum</code> or <code>inputnum</code> is out of range, the geometry is invalid, or the given primitive is not a vector volume primitive.</p></body>",
    "volumepostoindex": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volumepostoindex\">volumepostoindex</a></h1><p class=\"summary\">Converts a position into a volume voxel index.</p><div class=\"usage\"> <code>vector volumepostoindex(&lt;geometry&gt;, int primnum, vector position)</code></div><div class=\"usage\"> <code>vector volumepostoindex(&lt;geometry&gt;, string volumename, vector position)</code></div><h2>Returns</h2><p>The index of a voxel at the given position.</p><p>Returns 0 if <code>primnum</code> or <code>inputnum</code> is out of range, the geometry is invalid, or the given primitive is not a vector volume primitive.</p></body>",
    "volumeres": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volumeres\">volumeres</a></h1><p class=\"summary\">Gets the resolution of a volume primitive.</p><div class=\"usage\"> <code>vector volumeres(&lt;geometry&gt;, int primnum)</code></div><div class=\"usage\"> <code>vector volumeres(&lt;geometry&gt;, string volumename)</code></div><h2>Returns</h2><p>The resolution of the volume primitive.</p><p>For VDBs, the valid range of indices is not <code>0..res-1</code>, but\n    <code>volumeindexorigin..volumeindexorigin+res-1</code></p><p>Returns 0 if <code>primnum</code> or <code>inputnum</code> is out of range, the geometry is invalid, or the given primitive is not a vector volume primitive.</p></body>",
    "volumesample": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volumesample\">volumesample</a></h1><p class=\"summary\">Samples the volume primitive\u2019s value.</p><div class=\"usage\"> <code>float volumesample(&lt;geometry&gt;, int primnum, vector pos)</code></div><div class=\"usage\"> <code>float volumesample(&lt;geometry&gt;, string volumename, vector pos)</code></div><h2>Returns</h2><p>The volume primitive\u2019s sampled value at the given position.  Values between voxels will be trilinearly interpolated.</p><p>Returns 0 if <code>primnum</code> or <code>inputnum</code> is out of range, the geometry is invalid, or the given primitive is not a volume or vdb primitive.</p><p><a href=\"https://www.sidefx.com/docs/houdini/images/vex/volumesample.png\">/images/vex/volumesample.png</a></p><p>Example of interpolation of one and two dimensional data using <code>volumesample</code>. The visualized normal is computed using the <code>volumegradient</code> function.</p></body>",
    "volumesamplev": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volumesamplev\">volumesamplev</a></h1><p class=\"summary\">Samples the volume primitive\u2019s vector value.</p><div class=\"usage\"> <code>vector volumesamplev(&lt;geometry&gt;, int primnum, vector pos)</code></div><div class=\"usage\"> <code>vector volumesamplev(&lt;geometry&gt;, string volumename, vector pos)</code></div><h2>Returns</h2><p>The volume primitive\u2019s sampled value at the given position.  Values between voxels will be trilinearly interpolated.</p><p>VDBs can have vector data which will be reported by this.  Volumes are always scalar, but if <code>Cd</code> is the volumename, the function will try to evaluate <code>Cd.x</code>, <code>Cd.y</code>, and <code>Cd.z</code> and report the joined values.  (rgb can also be used as extensions)</p><p>Returns 0 if <code>primnum</code> or <code>inputnum</code> is out of range, the geometry is invalid, or the given primitive is not a vector volume primitive.</p></body>",
    "volumesmoothsample": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volumesmoothsample\">volumesmoothsample</a></h1><p class=\"summary\">Samples the volume primitive\u2019s value.</p><div class=\"usage\"> <code>float volumesmoothsample(&lt;geometry&gt;, int primnum, vector pos)</code></div><div class=\"usage\"> <code>float volumesmoothsample(&lt;geometry&gt;, string volumename, vector pos)</code></div><div class=\"usage\"> <code>float volumesmoothsample(&lt;geometry&gt;, int primnum, vector pos, vector &amp;grad)</code></div><div class=\"usage\"> <code>float volumesmoothsample(&lt;geometry&gt;, string volumename, vector pos, vector &amp;grad)</code></div><div class=\"usage\"> <code>float volumesmoothsample(&lt;geometry&gt;, int primnum, vector pos, vector &amp;grad, matrix3 &amp;hess)</code></div><div class=\"usage\"> <code>float volumesmoothsample(&lt;geometry&gt;, string volumename, vector pos, vector &amp;grad, matrix3 &amp;hess)</code></div><h2>Returns</h2><p>The volume primitive\u2019s sampled value at the given position. Values between voxels are evaluated with smooth interpolation.</p><p>The <code>grad</code> and <code>hess</code> arguments return the gradient or the hessian of this sampling function which can be computed at the same time as the value.</p><p>Returns 0 if <code>primnum</code> or <code>inputnum</code> is out of range, the geometry is invalid, or the given primitive is not a volume or vdb primitive.</p><p><a href=\"https://www.sidefx.com/docs/houdini/images/vex/volumesmoothsample.png\">/images/vex/volumesmoothsample.png</a></p><p>Example of interpolation of one and two dimensional data using <code>volumesmoothsample</code>. The visualized normal is computed using the <code>grad</code> parameter.</p><h2>Examples</h2><p>Approximating a volume value at the point <code>P + u</code> using volume values at the point <code>P</code>.</p><div class=\"codeblock\"><code class=\"codeline\">vector  P = {1.0, 2.0, 3.0};</code><code class=\"codeline\">vector grad;</code><code class=\"codeline\">matrix3 hess;</code><code class=\"codeline\">float val1 = volumesmoothsample(0, \"density\", P, grad, hess);</code><code class=\"codeline\"></code><code class=\"codeline\">vector u = {0.1, 0.01, 0.001};</code><code class=\"codeline\">float val2 = volumesmoothsample(0, \"density\", P + u);</code><code class=\"codeline\"></code><code class=\"codeline\">// By Taylor expansion we have:</code><code class=\"codeline\">// `val1 + dot(u, grad)` is approximately equal to `val2`</code><code class=\"codeline\"></code><code class=\"codeline\">// And the second order approximation:</code><code class=\"codeline\">// `val1 + (u, grad) + 0.5 * dot(u, u*hess)`</code><code class=\"codeline\">// is appriximately equal to `val2`</code></div></body>",
    "volumesmoothsamplev": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volumesmoothsamplev\">volumesmoothsamplev</a></h1><p class=\"summary\">Samples the volume primitive\u2019s value.</p><div class=\"usage\"> <code>vector volumesmoothsamplev(&lt;geometry&gt;, int primnum, vector pos)</code></div><div class=\"usage\"> <code>vector volumesmoothsamplev(&lt;geometry&gt;, string volumename, vector pos)</code></div><div class=\"usage\"> <code>vector volumesmoothsamplev(&lt;geometry&gt;, int primnum, vector pos, matrix3 &amp;grad)</code></div><div class=\"usage\"> <code>vector volumesmoothsamplev(&lt;geometry&gt;, string volumename, vector pos, matrix3 &amp;grad)</code></div><div class=\"usage\"> <code>vector volumesmoothsamplev(&lt;geometry&gt;, int primnum, vector pos, matrix3 &amp;grad, matrix3 &amp;hessX, matrix3 &amp;hessY, matrix3 &amp;hessZ)</code></div><div class=\"usage\"> <code>vector volumesmoothsamplev(&lt;geometry&gt;, string volumename, vector pos, matrix3 &amp;grad, matrix3 &amp;hessX, matrix3 &amp;hessY, matrix3 &amp;hessZ)</code></div><h2>Returns</h2><p>The volume primitive\u2019s sampled value at the given position. Values between voxels are evaluated with smooth interpolation.</p><p>The <code>grad</code> is a matrix whose i-th column is the gradient of the i-th component of the volume.</p><p>Matrices <code>hessX</code>, <code>hessY</code>, <code>hessZ</code> are second derivatives of x, y and z component respectively.</p><p>Returns 0 if <code>primnum</code> or <code>inputnum</code> is out of range, the geometry is invalid, or the given primitive is not a volume or vdb primitive.</p><h2>Examples</h2><p>Approximating a volume value at the point <code>P + u</code> using volume values at the point <code>P</code>.</p><div class=\"codeblock\"><code class=\"codeline\">vector  P = {1.0, 2.0, 3.0};</code><code class=\"codeline\">matrix3 grad, hessX, hessY, hessZ;</code><code class=\"codeline\">vector val1 = volumesmoothsamplev(0, \"vel\", P, grad, hessX, hessY, hessZ);</code><code class=\"codeline\"></code><code class=\"codeline\">vector u = {0.1, 0.01, 0.001};</code><code class=\"codeline\">vector val2 = volumesmoothsamplev(0, \"vel\", P + u);</code><code class=\"codeline\"></code><code class=\"codeline\">// By Taylor expansion we have:</code><code class=\"codeline\">// `val1 + u * grad` is approximately equal to `val2`</code><code class=\"codeline\"></code><code class=\"codeline\">// And the second order approximation:</code><code class=\"codeline\">// `val1 + u * grad + 0.5 * set(dot(u, u*hessX), dot(u, u*hessY), dot(u, u*hessZ))`</code><code class=\"codeline\">// is appriximately equal to `val2`</code></div></body>",
    "volumevoxeldiameter": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/volumevoxeldiameter\">volumevoxeldiameter</a></h1><p class=\"summary\">Computes the approximate diameter of a voxel.</p><div class=\"usage\"> <code>float volumevoxeldiameter(&lt;geometry&gt;, int primnum)</code></div><div class=\"usage\"> <code>float volumevoxeldiameter(&lt;geometry&gt;, string primname)</code></div><h2>Returns</h2><p>The diameter of a voxel in the given primitive.\n    To find the length of a side of a voxel, divide by <code>sqrt(3)</code>.</p><p>Returns 0 if <code>primnum</code> or <code>inputnum</code> is out of range, the geometry is invalid, or the given primitive is not a vector volume primitive.</p></body>",
    "vtransform": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/vtransform\">vtransform</a></h1><p class=\"summary\">Transforms a directional vector.</p><div class=\"usage\"> <code>vector vtransform(vector v, matrix transform)</code></div><div class=\"usage\"> <code>vector vtransform(string tospace, vector v)</code></div><div class=\"usage\"> <code>vector vtransform(string fromspace, string tospace, vector v)</code></div><p>Transforms a vector representing a direction. See <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a> for more information.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ntransform\">ntransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/ptransform\">ptransform</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/getspace\">getspace</a></div></body>",
    "warning": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/warning\">warning</a></h1><p class=\"summary\">Reports a custom runtime VEX warning.</p><div class=\"usage\"> <code>void warning(string format, ...)</code></div><p>Reports a custom runtime VEX warning.  This uses the same format string syntax as <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/printf\">printf</a>.</p><p>If something is so problematic that there is no acceptable fallback behavior, it may be worth reporting an <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/error\">error</a>, instead of a warning. </p><h2>Note</h2><p>It\u2019s quite easy to accidentally report thousands of different warnings.</p><h2>Examples</h2><div class=\"codeblock\"><code class=\"codeline\">if (primintrinsic(0,\"typeid\",@primnum) != 1) {</code><code class=\"codeline\">    warning(\"Primitives that aren't polygons are being ignored.\");</code><code class=\"codeline\">    return;</code><code class=\"codeline\">}</code><code class=\"codeline\">if (primintrinsic(0,\"closed\",@primnum) == 0 || @numvtx &lt; 3) {</code><code class=\"codeline\">    warning(\"Open or degenerate polygons are being ignored.\");</code><code class=\"codeline\">    return;</code><code class=\"codeline\">}</code><code class=\"codeline\">float minimumValue = chf(\"min\");</code><code class=\"codeline\">float maximumValue = chf(\"max\");</code><code class=\"codeline\">if (minimumValue &gt; maximumValue) {</code><code class=\"codeline\">    warning(\"Minimum (%f) can't be greater than maximum (%f); replacing minimum with maximum.\", minimumValue, maximumValue);</code><code class=\"codeline\">    minimumValue = maximumValue;</code><code class=\"codeline\">}</code></div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/error\">error</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/printf\">printf</a></div></body>",
    "wireblinn": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wireblinn\">wireblinn</a></h1><div class=\"usage\"> <code>bsdf wireblinn(vector tangent, float exponent, ...)</code></div><p><a href=\"https://www.sidefx.com/docs/houdini/images/rendering/wireblinn.png\">/images/rendering/wireblinn.png</a></p><p>Blinn function defined around a tangent vector. You can use this to produce the average specular illumination for thin wire-like primitives such as hair.</p><div class=\"related\"><code>tangent</code> \u2013 tangent vector along the hair.</div><div class=\"related\"><code>exponent</code> \u2013 blinn exponent.</div><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wirediffuse\">wirediffuse</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "wirediffuse": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wirediffuse\">wirediffuse</a></h1><div class=\"usage\"> <code>bsdf wirediffuse(vector tangent, ...)</code></div><p><a href=\"https://www.sidefx.com/docs/houdini/images/rendering/wirediffuse.png\">/images/rendering/wirediffuse.png</a></p><p>Diffuse function defined around a tangent vector. This can be used to produce the average diffuse illumination for thin wire-like primitives such as hair.</p><div class=\"argument\"><code>tangent</code></div><p>tangent vector along the hair.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wireblinn\">wireblinn</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/pbr\">Writing a PBR shader</a></div></body>",
    "wnoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wnoise\">wnoise</a></h1><p class=\"summary\">Generates Worley (cellular) noise.</p><div class=\"usage\"> <code>void wnoise( float position; int &amp;seed; float &amp;f1; float &amp;f2 )</code></div><div class=\"usage\"> <code>void wnoise( float position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4 )</code></div><p>Generates 1D noise.</p><div class=\"usage\"> <code>void wnoise( float position; int &amp;seed; float &amp;f1; float &amp;f2; int peiod)</code></div><div class=\"usage\"> <code>void wnoise( float position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f4; float &amp;f4; int period)</code></div><p>Generates periodic 1D noise.</p><div class=\"usage\"> <code>void wnoise( float posx; float posy; int &amp;seed; float &amp;f1; float &amp;f2 )</code></div><div class=\"usage\"> <code>void wnoise( float posx; float posy; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4 )</code></div><p>Generates 2D noise. This is similar to the other forms but uses pairs of floats instead of a vector.</p><div class=\"usage\"> <code>void wnoise( float posx; float posy; int &amp;seed; float &amp;f1; float &amp;f2; int periodx; int periody )</code></div><div class=\"usage\"> <code>void wnoise( float posx; float posy; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4; int periodx; int periody)</code></div><p>Generates periodic 2D noise.</p><div class=\"usage\"> <code>void wnoise( vector2 position; int &amp;seed; float &amp;f1; float &amp;f2 )</code></div><div class=\"usage\"> <code>void wnoise( vector2 position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4 )</code></div><p>Generates 2D noise.</p><div class=\"usage\"> <code>void wnoise( vector2 position; int &amp;seed; float &amp;f1; float &amp;f2; int periodx; int periody )</code></div><div class=\"usage\"> <code>void wnoise( vector2 position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4; int periodx; int periody)</code></div><p>Generates periodic 2D noise.</p><div class=\"usage\"> <code>void wnoise( vector position; int &amp;seed; float &amp;f1; float &amp;f2 )</code></div><div class=\"usage\"> <code>void wnoise( vector position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4 )</code></div><p>Generates 3D noise.</p><div class=\"usage\"> <code>void wnoise( vector position; int &amp;seed; float &amp;f1; float &amp;f2; int periodx; int periody; int periodx )</code></div><div class=\"usage\"> <code>void wnoise( vector position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4; int periodx; int periody; int periodz )</code></div><p>Generates periodic 3D noise.</p><div class=\"usage\"> <code>void wnoise( vector4 position; int &amp;seed; float &amp;f1; float &amp;f2 )</code></div><div class=\"usage\"> <code>void wnoise( vector4 position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4 )</code></div><p>Generates 4D noise.</p><div class=\"usage\"> <code>void wnoise( vector4 position; int &amp;seed; float &amp;f1; float &amp;f2; int periodx; int periody; int periodz; int periodw )</code></div><div class=\"usage\"> <code>void wnoise( vector4 position; int &amp;seed; float &amp;f1; float &amp;f2; float &amp;f3; float &amp;f4; int periodx; int periody; int periodz; int periodw )</code></div><p>Generates periodic 4D noise.</p><div class=\"argument\"><code>position</code></div><p>The position at which to sample the noise.</p><div class=\"argument\"><code>seed</code></div><p>Outputs an integer value associated with the nearest seed point. This seed is pretty much guaranteed to be unique for every point (meaning that it\u2019s unlikely that two points close by have the same seed associated with them).</p><div class=\"argument\"><code><code>f1</code>, <code>f2</code>, <code>f3</code>, <code>f4</code></code></div><p>These variables are overwritten with the distances to the nearest seed points, in order of closeness.</p><p>You can combine these distances to generate noise patterns. The noise generated tends to be very cellular in nature. In fact, one of the nice things is that you can determine cell boundaries by using the expression: <code>if (f2 - f1)</code> which will be true if the point in space is crossing the boundary between two cells.</p><div class=\"argument\"><code><code>period</code>, <code>periodx</code>, <code>periody</code>, <code>periodz</code>, <code>periodw</code></code></div><p>If you include the period argument(s), the function generates repeating (periodic) noise.</p><p>Worley noise scatters seed points randomly through space (according to a nice Poisson distribution). The functions outputs the distances to the 2 (or 4) seed points nearest to the sample position.</p><h2>Related</h2></body>",
    "wo_nspace": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wo_nspace\">wo_nspace</a></h1><p class=\"summary\">Transforms a normal vector from World to Object space.</p><div class=\"usage\"> <code>vector wo_nspace(vector v)</code></div><p>Transforms a normal vector from <em>World</em> to <em>Object</em> space.</p></body>",
    "wo_space": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wo_space\">wo_space</a></h1><p class=\"summary\">Transforms a position value from World to Object space.</p><div class=\"usage\"> <code>matrix wo_space()</code></div><p>In <a href=\"https://www.sidefx.com/docs/houdini/vex/contexts/shading_contexts\">shading contexts</a>, this transforms the current position.</p><div class=\"usage\"> <code>vector wo_space(vector pos)</code></div><div class=\"usage\"> <code>vector4 wo_space(vector4 pos)</code></div><p>Transforms a position value from <em>World</em> to <em>Object</em> space.</p></body>",
    "wo_vspace": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wo_vspace\">wo_vspace</a></h1><p class=\"summary\">Transforms a direction vector from World to Object space.</p><div class=\"usage\"> <code>vector wo_vspace(vector v)</code></div><p>Transforms a direction vector from <em>World</em> to <em>Object</em> space.</p></body>",
    "writepixel": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/writepixel\">writepixel</a></h1><span class=\"padder\"><span class=\"pillow\">shading</span></span><p class=\"summary\">Writes color information to a pixel in the output image </p><div class=\"usage\"> <code>void writepixel(string channel, float ndc_x, float ndc_y, vector clr)</code></div><p>This is an experimental function which can be used by the generator rendering engine to write pixel values into the image.</p></body>",
    "wt_nspace": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wt_nspace\">wt_nspace</a></h1><p class=\"summary\">Transforms a normal vector from World to Texture space.</p><div class=\"usage\"> <code>vector wt_nspace(vector v)</code></div><p>Transforms a normal vector from <em>World</em> to <em>Texture</em> space.</p></body>",
    "wt_space": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wt_space\">wt_space</a></h1><p class=\"summary\">Transforms a position value from World to Texture space.</p><div class=\"usage\"> <code>matrix wt_space()</code></div><div class=\"usage\"> <code>vector wt_space(vector v)</code></div><div class=\"usage\"> <code>vector4 wt_space(vector4 v)</code></div><p>Transforms a position value from <em>World</em> to <em>Texture</em> space.</p></body>",
    "wt_vspace": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/wt_vspace\">wt_vspace</a></h1><p class=\"summary\">Transforms a direction vector from World to Texture space.</p><div class=\"usage\"> <code>vector wt_vspace(vector v)</code></div><p>Transforms a direction vector from <em>World</em> to <em>Texture</em> space.</p></body>",
    "xnoise": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xnoise\">xnoise</a></h1><p class=\"summary\">Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid.  This results in less grid artifacts.  It also uses a higher order bspline to provide better derivatives.</p><div class=\"usage\"> <code>float xnoise(float x)</code></div><div class=\"usage\"> <code>vector xnoise(float x)</code></div><div class=\"usage\"> <code>float xnoise(float x, float y)</code></div><div class=\"usage\"> <code>vector xnoise(float x, float y)</code></div><div class=\"usage\"> <code>float xnoise(vector xyz)</code></div><div class=\"usage\"> <code>vector xnoise(vector xyz)</code></div><div class=\"usage\"> <code>float xnoise(vector4 xyzt)</code></div><div class=\"usage\"> <code>vector xnoise(vector4 xyzt)</code></div><p>Simplex noise is very close to Perlin noise, except with the samples on a\nsimplex mesh rather than a grid.  This results in less grid artifacts.  It also\nuses a higher order <code>bspline</code> to provide better derivatives.</p><p>The various functions return the noise value at a 4D (vector4 argument),\n3D (vector argument), 2D (two float arguments) or 1D (float argument)\nposition. You can get a random float value or a vector of three random\nvalues.</p><p>The noise is in the range 0-1 with a median of 0.5. The distribution of\nthe noise depends on the dimension, with higher dimensions approaching a\nGaussian distribution of noise values.</p><h2>Related</h2></body>",
    "xnoised": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xnoised\">xnoised</a></h1><p class=\"summary\">Derivatives of Simplex Noise.</p><div class=\"usage\"> <code>void xnoised(float x, float &amp;v, float &amp;dvdx)</code></div><div class=\"usage\"> <code>void xnoised(float x, vector &amp;v, vector &amp;dvdx)</code></div><div class=\"usage\"> <code>void xnoised(float x, float y, float &amp;v, float &amp;dvdx, float &amp;dvdy)</code></div><div class=\"usage\"> <code>void xnoised(float x, float y, vector &amp;v, vector &amp;dvdx, vector &amp;dvdy)</code></div><div class=\"usage\"> <code>void xnoised(vector xyz, float &amp;v, float &amp;dvdx, float &amp;dvdy, float &amp;dvdz)</code></div><div class=\"usage\"> <code>void xnoised(vector xyz, vector &amp;v, vector &amp;dvdx, vector &amp;dvdy, vector &amp;dvdz)</code></div><div class=\"usage\"> <code>void xnoised(vector4 xyzw, float &amp;v, float &amp;dvdx, float &amp;dvdy, float &amp;dvdz, float &amp;dvdw)</code></div><div class=\"usage\"> <code>void xnoised(vector4 xyzw, vector &amp;v, vector &amp;dvdx, vector &amp;dvdy, vector &amp;dvdz, vector &amp;dvdw)</code></div><p>This computes both the simplex noise value, and the derivatives of the\nnoise along each axis.  This can be performed quite efficiently as\nthere are analytic derivatives available.</p><p>See <a href=\"https://www.sidefx.com/docs/houdini/vex/random\">noise and randomness</a>  in the VEX language\nguide for more information.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xnoise\">xnoise</a></div></body>",
    "xyzdist": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xyzdist\">xyzdist</a></h1><p class=\"summary\">Finds the distance from a point to the closest location on surface geometry.</p><div class=\"usage\"> <code>float xyzdist(&lt;geometry&gt;, vector origin)</code></div><p>Finds the distance from <code class=\"var\">origin</code> to the closest location on the given geometry.</p><div class=\"usage\"> <code>float xyzdist(&lt;geometry&gt;, vector origin, int &amp;prim, vector &amp;uv)</code></div><div class=\"usage\"> <code>float xyzdist(&lt;geometry&gt;, vector origin, int &amp;prim, vector &amp;uv, float maxdist)</code></div><p>Finds the distance from <code class=\"var\">origin</code> to the closest location on the geometry, and\n    writes the primitive number and UV coordinates of the closest location into the output arguments.</p><div class=\"usage\"> <code>float xyzdist(&lt;geometry&gt;, string primgroup, vector origin)</code></div><div class=\"usage\"> <code>float xyzdist(&lt;geometry&gt;, string primgroup, vector origin, int &amp;prim, vector &amp;uv)</code></div><div class=\"usage\"> <code>float xyzdist(&lt;geometry&gt;, string primgroup, vector origin, int &amp;prim, vector &amp;uv, float maxdist)</code></div><p>Finds the distance from <code class=\"var\">origin</code> to the closest location in the given primitive group on the given geometry,\n    and writes the primitive number and UV coordinates of the closest location into the output arguments.</p><p>Note: Distances to packed primitives and sphere/tube/circle primitives with\nnon-uniform scales may not represent the actual closest point as the closest\npoint is found in the untransformed space.</p><div class=\"argument\"><code>primgroup</code></div><p>The name of a primitive group or a pattern to generate a primitive\n    group.  Uses the same semantics as a SOP group, so empty strings\n    will match all primitives.  Attribute groups like <code>@Cd.x&gt;0</code> can\n    also be used, but note that the <code>@</code> may need to be escaped with\n    a backslash in a <a href=\"https://www.sidefx.com/docs/houdini/nodes/vop/snippet\">Snippet VOP</a>.</p><div class=\"argument\"><code>origin</code></div><p>The position in space to find the closest position on the geometry to.</p><div class=\"argument\"><code>&amp;prim</code></div><p>The function overwrites this variable with the number of the closest primitive, or <code>-1</code> if no primitive was found.</p><div class=\"argument\"><code>&amp;uv</code></div><p>The function overwrites this variable with the UV coordinates of the closest point on the closest primitive.\n    You can use <a href=\"https://www.sidefx.com/docs/houdini/vex/functions/primuv\">primuv</a> to sample an attribute value at this location.</p><div class=\"argument\"><code>maxdist</code></div><p>The maximum distance to search. Specifying this can speed up the function by allowing it to quit early.</p><h2>Returns</h2><p>The distance from the origin point to the closest location on the geometry.</p></body>",
    "xyztorgb": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/xyztorgb\">xyztorgb</a></h1><p class=\"summary\">Convert CIE XYZ tristimulus values to a linear sRGB triplet.</p><div class=\"usage\"> <code>vector xyztorgb(vector xyz)</code></div><p>Convert CIE XYZ tristimulus values to linear sRGB (Rec. 709) triplet.\nXYZ can be thought of as a 'universal color space'.</p><h2>Related</h2><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/rgbtoxyz\">rgbtoxyz</a></div><div class=\"related\"><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/blackbody\">blackbody</a></div></body>",
    "__uniform_mul": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/__uniform_mul\">__uniform_mul</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Multiply matrices.</p><div class=\"usage\"> <code>void __uniform_mul(matrix2 &amp;a, matrix2 b)</code></div><div class=\"usage\"> <code>void __uniform_mul(matrix &amp;a, matrix b)</code></div><div class=\"usage\"> <code>void __uniform_mul(matrix3 &amp;a, matrix3 b)</code></div><div class=\"usage\"> <code>void __uniform_mul(matrix2 &amp;a, float b)</code></div><div class=\"usage\"> <code>void __uniform_mul(matrix &amp;a, float b)</code></div><div class=\"usage\"> <code>void __uniform_mul(matrix3 &amp;a, float b)</code></div><div class=\"usage\"> <code>void __uniform_mul(matrix2 &amp;m, matrix2 a, matrix2 b)</code></div><div class=\"usage\"> <code>void __uniform_mul(matrix &amp;m, matrix a, matrix b)</code></div><div class=\"usage\"> <code>void __uniform_mul(matrix3 &amp;m, matrix3 a, matrix3 b)</code></div><div class=\"usage\"> <code>void __uniform_mul(vector2 &amp;a, matrix2 b)</code></div><div class=\"usage\"> <code>void __uniform_mul(vector &amp;a, matrix b)</code></div><div class=\"usage\"> <code>void __uniform_mul(vector &amp;a, matrix3 b)</code></div><div class=\"usage\"> <code>void __uniform_mul(vector4 &amp;a, matrix b)</code></div><p>Multiplies two matrices and returns modify the first matrix.</p><p>This version of mul can be faster when running over a single\nprocessor, like for detail attributes or doing matrix multiplication\nfor CHOP constraints.</p></body>",
    "__uniform_premul": "<body><h1><a href=\"https://www.sidefx.com/docs/houdini/vex/functions/__uniform_premul\">__uniform_premul</a></h1><span class=\"padder\"><span class=\"pillow\">18.0</span></span><p class=\"summary\">Pre multiply matrices.</p><div class=\"usage\"> <code>void __uniform_premul(matrix2 &amp;a, matrix2 b)</code></div><div class=\"usage\"> <code>void __uniform_premul(matrix3 &amp;a, matrix3 b)</code></div><div class=\"usage\"> <code>void __uniform_premul(matrix &amp;a, matrix b)</code></div><div class=\"usage\"> <code>void __uniform_premul(matrix2 &amp;m, matrix2 a, matrix2 b)</code></div><div class=\"usage\"> <code>void __uniform_premul(matrix3 &amp;m, matrix3 a, matrix3 b)</code></div><div class=\"usage\"> <code>void __uniform_premul(matrix &amp;m, matrix a, matrix b)</code></div><p>Multiplies two matrices and returns modify the first matrix.</p><p>This version of premul can be faster when running over a single\nprocessor, like for detail attributes or doing matrix multiplication\nfor CHOP constraints.</p></body>"
}