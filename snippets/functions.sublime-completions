{
    "scope": "source.vex -string -comment -source.hscript",
    "completions": [
        {
            "trigger": "abs(n)",
            "contents": "abs(${1:n})",
            "kind": "function",
            "details": "Returns the absolute value of the argument"
        },
        {
            "trigger": "abs(v)",
            "contents": "abs(${1:v})",
            "kind": "function",
            "details": "Returns the absolute value of the argument"
        },
        {
            "trigger": "abspath(relpath)",
            "contents": "abspath(${1:relpath})",
            "kind": "function",
            "details": "Returns the full path of a file"
        },
        {
            "trigger": "accessframe(frame)",
            "contents": "accessframe(${1:frame})",
            "kind": "function",
            "details": "Tells the COP manager that you need access to the given frame"
        },
        {
            "trigger": "acos(v)",
            "contents": "acos(${1:v})",
            "kind": "function",
            "details": "Returns the inverse cosine of the argument"
        },
        {
            "trigger": "addattrib(geohandle, attribclass, name, defvalue)",
            "contents": "addattrib(${1:geohandle}, ${2:attribclass}, ${3:name}, ${4:defvalue})",
            "kind": "function",
            "details": "Adds an attribute to a geometry"
        },
        {
            "trigger": "adddetailattrib(geohandle, name, defvalue)",
            "contents": "adddetailattrib(${1:geohandle}, ${2:name}, ${3:defvalue})",
            "kind": "function",
            "details": "Adds a detail attribute to a geometry"
        },
        {
            "trigger": "adddetailattrib(geohandle, name, defvalue, typeinfo)",
            "contents": "adddetailattrib(${1:geohandle}, ${2:name}, ${3:defvalue}, ${4:typeinfo})",
            "kind": "function",
            "details": "Adds a detail attribute to a geometry"
        },
        {
            "trigger": "addpoint(geohandle, point_number)",
            "contents": "addpoint(${1:geohandle}, ${2:point_number})",
            "kind": "function",
            "details": "Adds a point to the geometry"
        },
        {
            "trigger": "addpoint(geohandle, pos)",
            "contents": "addpoint(${1:geohandle}, ${2:pos})",
            "kind": "function",
            "details": "Adds a point to the geometry"
        },
        {
            "trigger": "addpointattrib(geohandle, name, defvalue)",
            "contents": "addpointattrib(${1:geohandle}, ${2:name}, ${3:defvalue})",
            "kind": "function",
            "details": "Adds a point attribute to a geometry"
        },
        {
            "trigger": "addpointattrib(geohandle, name, defvalue, typeinfo)",
            "contents": "addpointattrib(${1:geohandle}, ${2:name}, ${3:defvalue}, ${4:typeinfo})",
            "kind": "function",
            "details": "Adds a point attribute to a geometry"
        },
        {
            "trigger": "addprim(geohandle, type)",
            "contents": "addprim(${1:geohandle}, ${2:type})",
            "kind": "function",
            "details": "Adds a primitive to the geometry"
        },
        {
            "trigger": "addprim(geohandle, type, pt0)",
            "contents": "addprim(${1:geohandle}, ${2:type}, ${3:pt0})",
            "kind": "function",
            "details": "Adds a primitive to the geometry"
        },
        {
            "trigger": "addprim(geohandle, type, pt0, pt1)",
            "contents": "addprim(${1:geohandle}, ${2:type}, ${3:pt0}, ${4:pt1})",
            "kind": "function",
            "details": "Adds a primitive to the geometry"
        },
        {
            "trigger": "addprim(geohandle, type, pt0, pt1, pt2)",
            "contents": "addprim(${1:geohandle}, ${2:type}, ${3:pt0}, ${4:pt1}, ${5:pt2})",
            "kind": "function",
            "details": "Adds a primitive to the geometry"
        },
        {
            "trigger": "addprim(geohandle, type, pt0, pt1, pt2, pt3)",
            "contents": "addprim(${1:geohandle}, ${2:type}, ${3:pt0}, ${4:pt1}, ${5:pt2}, ${6:pt3})",
            "kind": "function",
            "details": "Adds a primitive to the geometry"
        },
        {
            "trigger": "addprim(geohandle, type, pt0, pt1, pt2, pt3, pt4, pt5, pt6, pt7)",
            "contents": "addprim(${1:geohandle}, ${2:type}, ${3:pt0}, ${4:pt1}, ${5:pt2}, ${6:pt3}, ${7:pt4}, ${8:pt5}, ${9:pt6}, ${10:pt7})",
            "kind": "function",
            "details": "Adds a primitive to the geometry"
        },
        {
            "trigger": "addprim(geohandle, type, points)",
            "contents": "addprim(${1:geohandle}, ${2:type}, ${3:points})",
            "kind": "function",
            "details": "Adds a primitive to the geometry"
        },
        {
            "trigger": "addprim(prim_num, geohandle, type, pt0, vertices)",
            "contents": "addprim(${1:prim_num}, ${2:geohandle}, ${3:type}, ${4:pt0}, ${5:vertices})",
            "kind": "function",
            "details": "Adds a primitive to the geometry"
        },
        {
            "trigger": "addprim(prim_num, geohandle, type, pt0, pt1, vertices)",
            "contents": "addprim(${1:prim_num}, ${2:geohandle}, ${3:type}, ${4:pt0}, ${5:pt1}, ${6:vertices})",
            "kind": "function",
            "details": "Adds a primitive to the geometry"
        },
        {
            "trigger": "addprim(prim_num, geohandle, type, pt0, pt1, pt2, vertices)",
            "contents": "addprim(${1:prim_num}, ${2:geohandle}, ${3:type}, ${4:pt0}, ${5:pt1}, ${6:pt2}, ${7:vertices})",
            "kind": "function",
            "details": "Adds a primitive to the geometry"
        },
        {
            "trigger": "addprim(prim_num, geohandle, type, pt0, pt1, pt2, pt3, vertices)",
            "contents": "addprim(${1:prim_num}, ${2:geohandle}, ${3:type}, ${4:pt0}, ${5:pt1}, ${6:pt2}, ${7:pt3}, ${8:vertices})",
            "kind": "function",
            "details": "Adds a primitive to the geometry"
        },
        {
            "trigger": "addprim(prim_num, geohandle, type, pt0, pt1, pt2, pt3, pt4, pt5, pt6, pt7, vertices)",
            "contents": "addprim(${1:prim_num}, ${2:geohandle}, ${3:type}, ${4:pt0}, ${5:pt1}, ${6:pt2}, ${7:pt3}, ${8:pt4}, ${9:pt5}, ${10:pt6}, ${11:pt7}, ${12:vertices})",
            "kind": "function",
            "details": "Adds a primitive to the geometry"
        },
        {
            "trigger": "addprim(prim_num, geohandle, type, points, vertices)",
            "contents": "addprim(${1:prim_num}, ${2:geohandle}, ${3:type}, ${4:points}, ${5:vertices})",
            "kind": "function",
            "details": "Adds a primitive to the geometry"
        },
        {
            "trigger": "addprimattrib(geohandle, name, defvalue)",
            "contents": "addprimattrib(${1:geohandle}, ${2:name}, ${3:defvalue})",
            "kind": "function",
            "details": "Adds a primitive attribute to a geometry"
        },
        {
            "trigger": "addprimattrib(geohandle, name, defvalue, typeinfo)",
            "contents": "addprimattrib(${1:geohandle}, ${2:name}, ${3:defvalue}, ${4:typeinfo})",
            "kind": "function",
            "details": "Adds a primitive attribute to a geometry"
        },
        {
            "trigger": "addvariablename(aname, vname)",
            "contents": "addvariablename(${1:aname}, ${2:vname})",
            "kind": "function",
            "details": "Adds a mapping for an attribute to a local variable"
        },
        {
            "trigger": "addvariablename(geohandle, aname, vname)",
            "contents": "addvariablename(${1:geohandle}, ${2:aname}, ${3:vname})",
            "kind": "function",
            "details": "Adds a mapping for an attribute to a local variable"
        },
        {
            "trigger": "addvertex(geohandle, prim_num, point_num)",
            "contents": "addvertex(${1:geohandle}, ${2:prim_num}, ${3:point_num})",
            "kind": "function",
            "details": "Adds a vertex to a primitive in a geometry"
        },
        {
            "trigger": "addvertexattrib(geohandle, name, defvalue)",
            "contents": "addvertexattrib(${1:geohandle}, ${2:name}, ${3:defvalue})",
            "kind": "function",
            "details": "Adds a vertex attribute to a geometry"
        },
        {
            "trigger": "addvertexattrib(geohandle, name, defvalue, typeinfo)",
            "contents": "addvertexattrib(${1:geohandle}, ${2:name}, ${3:defvalue}, ${4:typeinfo})",
            "kind": "function",
            "details": "Adds a vertex attribute to a geometry"
        },
        {
            "trigger": "addvisualizer(geohandle, op_url)",
            "contents": "addvisualizer(${1:geohandle}, ${2:op_url})",
            "kind": "function",
            "details": "Appends to a geometry\u2019s visualizer detail attribute"
        },
        {
            "trigger": "agentaddclip(geohandle, prim, clipname, clippath, keepref)",
            "contents": "agentaddclip(${1:geohandle}, ${2:prim}, ${3:clipname}, ${4:clippath}, ${5:keepref})",
            "kind": "function",
            "details": "Add a clip into an agent\u2019s definition"
        },
        {
            "trigger": "agentchannelcount(geometry, prim)",
            "contents": "agentchannelcount(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns the number of channels in an agent primitive\u2019s rig"
        },
        {
            "trigger": "agentchannelnames(geometry, prim)",
            "contents": "agentchannelnames(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns the names of the channels in an agent primitive\u2019s rig"
        },
        {
            "trigger": "agentchannelvalue(geometry, prim, channel)",
            "contents": "agentchannelvalue(${1:geometry}, ${2:prim}, ${3:channel})",
            "kind": "function",
            "details": "Returns the current value of an agent primitive\u2019s channel"
        },
        {
            "trigger": "agentchannelvalues(geometry, prim)",
            "contents": "agentchannelvalues(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns the current values of an agent primitive\u2019s channels"
        },
        {
            "trigger": "agentclipcatalog(geometry, prim)",
            "contents": "agentclipcatalog(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns all of the animation clips that have been loaded for an agent primitive"
        },
        {
            "trigger": "agentclipchannel(geometry, prim, clipname, channel)",
            "contents": "agentclipchannel(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:channel})",
            "kind": "function",
            "details": "Finds the index of a channel in an agent\u2019s animation clip"
        },
        {
            "trigger": "agentclipchannel(geometry, prim, clipindex, channel)",
            "contents": "agentclipchannel(${1:geometry}, ${2:prim}, ${3:clipindex}, ${4:channel})",
            "kind": "function",
            "details": "Finds the index of a channel in an agent\u2019s animation clip"
        },
        {
            "trigger": "agentclipchannelnames(geometry, prim, clipname)",
            "contents": "agentclipchannelnames(${1:geometry}, ${2:prim}, ${3:clipname})",
            "kind": "function",
            "details": "Returns the names of the channels in an agent\u2019s animation clip"
        },
        {
            "trigger": "agentclipchannelnames(geometry, prim, clipindex)",
            "contents": "agentclipchannelnames(${1:geometry}, ${2:prim}, ${3:clipindex})",
            "kind": "function",
            "details": "Returns the names of the channels in an agent\u2019s animation clip"
        },
        {
            "trigger": "agentcliplayerblend(values, value_weights, value_layer_ids, layer_blend_modes, layer_weights, layer_parent_ids)",
            "contents": "agentcliplayerblend(${1:values}, ${2:value_weights}, ${3:value_layer_ids}, ${4:layer_blend_modes}, ${5:layer_weights}, ${6:layer_parent_ids})",
            "kind": "function",
            "details": "Blends values according to an agent\u2019s animation layers"
        },
        {
            "trigger": "agentcliplength(geometry, prim, clipname)",
            "contents": "agentcliplength(${1:geometry}, ${2:prim}, ${3:clipname})",
            "kind": "function",
            "details": "Returns the length (in seconds) of an agent\u2019s animation clip"
        },
        {
            "trigger": "agentcliplength(geometry, prim, clipindex)",
            "contents": "agentcliplength(${1:geometry}, ${2:prim}, ${3:clipindex})",
            "kind": "function",
            "details": "Returns the length (in seconds) of an agent\u2019s animation clip"
        },
        {
            "trigger": "agentclipnames(geometry, prim)",
            "contents": "agentclipnames(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns an agent primitive\u2019s current animation clips"
        },
        {
            "trigger": "agentclipsample(geometry, prim, clipname, time, channel_index)",
            "contents": "agentclipsample(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:time}, ${5:channel_index})",
            "kind": "function",
            "details": "Samples a channel of an agent\u2019s clip at a specific time"
        },
        {
            "trigger": "agentclipsample(geometry, prim, clipname, time, channel)",
            "contents": "agentclipsample(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:time}, ${5:channel})",
            "kind": "function",
            "details": "Samples a channel of an agent\u2019s clip at a specific time"
        },
        {
            "trigger": "agentclipsample(geometry, prim, clipindex, time, channel_index)",
            "contents": "agentclipsample(${1:geometry}, ${2:prim}, ${3:clipindex}, ${4:time}, ${5:channel_index})",
            "kind": "function",
            "details": "Samples a channel of an agent\u2019s clip at a specific time"
        },
        {
            "trigger": "agentclipsample(geometry, prim, clipindex, time, channel)",
            "contents": "agentclipsample(${1:geometry}, ${2:prim}, ${3:clipindex}, ${4:time}, ${5:channel})",
            "kind": "function",
            "details": "Samples a channel of an agent\u2019s clip at a specific time"
        },
        {
            "trigger": "agentclipsamplelocal(geometry, prim, clipname, time)",
            "contents": "agentclipsamplelocal(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:time})",
            "kind": "function",
            "details": "Samples an agent\u2019s animation clip at a specific time"
        },
        {
            "trigger": "agentclipsamplelocal(geometry, prim, clipindex, time)",
            "contents": "agentclipsamplelocal(${1:geometry}, ${2:prim}, ${3:clipindex}, ${4:time})",
            "kind": "function",
            "details": "Samples an agent\u2019s animation clip at a specific time"
        },
        {
            "trigger": "agentclipsamplelocal(geometry, prim, clipname, time, transform)",
            "contents": "agentclipsamplelocal(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:time}, ${5:transform})",
            "kind": "function",
            "details": "Samples an agent\u2019s animation clip at a specific time"
        },
        {
            "trigger": "agentclipsamplelocal(geometry, prim, clipindex, time, transform)",
            "contents": "agentclipsamplelocal(${1:geometry}, ${2:prim}, ${3:clipindex}, ${4:time}, ${5:transform})",
            "kind": "function",
            "details": "Samples an agent\u2019s animation clip at a specific time"
        },
        {
            "trigger": "agentclipsamplerate(geometry, prim, clipname)",
            "contents": "agentclipsamplerate(${1:geometry}, ${2:prim}, ${3:clipname})",
            "kind": "function",
            "details": "Returns the sample rate of an agent\u2019s animation clip"
        },
        {
            "trigger": "agentclipsamplerate(geometry, prim, clipindex)",
            "contents": "agentclipsamplerate(${1:geometry}, ${2:prim}, ${3:clipindex})",
            "kind": "function",
            "details": "Returns the sample rate of an agent\u2019s animation clip"
        },
        {
            "trigger": "agentclipsampleworld(geometry, prim, clipname, time)",
            "contents": "agentclipsampleworld(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:time})",
            "kind": "function",
            "details": "Samples an agent\u2019s animation clip at a specific time"
        },
        {
            "trigger": "agentclipsampleworld(geometry, prim, clipindex, time)",
            "contents": "agentclipsampleworld(${1:geometry}, ${2:prim}, ${3:clipindex}, ${4:time})",
            "kind": "function",
            "details": "Samples an agent\u2019s animation clip at a specific time"
        },
        {
            "trigger": "agentclipsampleworld(geometry, prim, clipname, time, transform)",
            "contents": "agentclipsampleworld(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:time}, ${5:transform})",
            "kind": "function",
            "details": "Samples an agent\u2019s animation clip at a specific time"
        },
        {
            "trigger": "agentclipsampleworld(geometry, prim, clipindex, time, transform)",
            "contents": "agentclipsampleworld(${1:geometry}, ${2:prim}, ${3:clipindex}, ${4:time}, ${5:transform})",
            "kind": "function",
            "details": "Samples an agent\u2019s animation clip at a specific time"
        },
        {
            "trigger": "agentclipstarttime(geometry, prim, clipname)",
            "contents": "agentclipstarttime(${1:geometry}, ${2:prim}, ${3:clipname})",
            "kind": "function",
            "details": "Returns the start time (in seconds) of an agent\u2019s animation clip"
        },
        {
            "trigger": "agentclipstarttime(geometry, prim, clipindex)",
            "contents": "agentclipstarttime(${1:geometry}, ${2:prim}, ${3:clipindex})",
            "kind": "function",
            "details": "Returns the start time (in seconds) of an agent\u2019s animation clip"
        },
        {
            "trigger": "agentcliptimes(geometry, prim)",
            "contents": "agentcliptimes(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns the current times for an agent primitive\u2019s animation clips"
        },
        {
            "trigger": "agentcliptransformgroups(geometry, prim)",
            "contents": "agentcliptransformgroups(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns the transform groups for an agent primitive\u2019s current animation clips"
        },
        {
            "trigger": "agentclipweights(geometry, prim)",
            "contents": "agentclipweights(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns the blend weights for an agent primitive\u2019s animation clips"
        },
        {
            "trigger": "agentcollisionlayer(geometry, prim)",
            "contents": "agentcollisionlayer(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns the name of the collision layer of an agent primitive"
        },
        {
            "trigger": "agentcollisionlayers(geometry, prim)",
            "contents": "agentcollisionlayers(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns the names of an agent primitive\u2019s collision layers"
        },
        {
            "trigger": "agentcurrentlayer(geometry, prim)",
            "contents": "agentcurrentlayer(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns the name of the current layer of an agent primitive"
        },
        {
            "trigger": "agentcurrentlayers(geometry, prim)",
            "contents": "agentcurrentlayers(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns the names of an agent primitive\u2019s current layers"
        },
        {
            "trigger": "agentfindclip(geometry, prim, clipname)",
            "contents": "agentfindclip(${1:geometry}, ${2:prim}, ${3:clipname})",
            "kind": "function",
            "details": "Finds the index of a clip in an agent\u2019s definition"
        },
        {
            "trigger": "agentfindlayer(geometry, prim, layername)",
            "contents": "agentfindlayer(${1:geometry}, ${2:prim}, ${3:layername})",
            "kind": "function",
            "details": "Finds the index of a layer in an agent\u2019s definition"
        },
        {
            "trigger": "agentfindtransformgroup(geometry, prim, transformgroup)",
            "contents": "agentfindtransformgroup(${1:geometry}, ${2:prim}, ${3:transformgroup})",
            "kind": "function",
            "details": "Finds the index of a transform group in an agent\u2019s definition"
        },
        {
            "trigger": "agentlayerbindings(geometry, prim, layername, shapetype)",
            "contents": "agentlayerbindings(${1:geometry}, ${2:prim}, ${3:layername}, ${4:shapetype})",
            "kind": "function",
            "details": "Returns the transform that each shape in an agent\u2019s layer is bound to"
        },
        {
            "trigger": "agentlayerbindings(geometry, prim, layerindex, shapetype)",
            "contents": "agentlayerbindings(${1:geometry}, ${2:prim}, ${3:layerindex}, ${4:shapetype})",
            "kind": "function",
            "details": "Returns the transform that each shape in an agent\u2019s layer is bound to"
        },
        {
            "trigger": "agentlayers(geometry, prim)",
            "contents": "agentlayers(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns all of the layers that have been loaded for an agent primitive"
        },
        {
            "trigger": "agentlayershapes(geometry, prim, layername, shapetype)",
            "contents": "agentlayershapes(${1:geometry}, ${2:prim}, ${3:layername}, ${4:shapetype})",
            "kind": "function",
            "details": "Returns the names of the shapes referenced by an agent primitive\u2019s layer"
        },
        {
            "trigger": "agentlayershapes(geometry, prim, layerindex, shapetype)",
            "contents": "agentlayershapes(${1:geometry}, ${2:prim}, ${3:layerindex}, ${4:shapetype})",
            "kind": "function",
            "details": "Returns the names of the shapes referenced by an agent primitive\u2019s layer"
        },
        {
            "trigger": "agentlayershapes(geometry, prim, layername, transform)",
            "contents": "agentlayershapes(${1:geometry}, ${2:prim}, ${3:layername}, ${4:transform})",
            "kind": "function",
            "details": "Returns the names of the shapes referenced by an agent primitive\u2019s layer"
        },
        {
            "trigger": "agentlayershapes(geometry, prim, layerindex, transform)",
            "contents": "agentlayershapes(${1:geometry}, ${2:prim}, ${3:layerindex}, ${4:transform})",
            "kind": "function",
            "details": "Returns the names of the shapes referenced by an agent primitive\u2019s layer"
        },
        {
            "trigger": "agentlocaltransform(geometry, prim, transform)",
            "contents": "agentlocaltransform(${1:geometry}, ${2:prim}, ${3:transform})",
            "kind": "function",
            "details": "Returns the current local space transform of an agent primitive\u2019s bone"
        },
        {
            "trigger": "agentlocaltransforms(geometry, prim)",
            "contents": "agentlocaltransforms(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns the current local space transforms of an agent primitive"
        },
        {
            "trigger": "agentmetadata(geometry, prim)",
            "contents": "agentmetadata(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns the agent definition\u2019s metadata dictionary"
        },
        {
            "trigger": "agentrestlocaltransform(geometry, prim, transform)",
            "contents": "agentrestlocaltransform(${1:geometry}, ${2:prim}, ${3:transform})",
            "kind": "function",
            "details": "Returns the local space rest transform for an agent primitive\u2019s joint"
        },
        {
            "trigger": "agentrestworldtransform(geometry, prim, transform)",
            "contents": "agentrestworldtransform(${1:geometry}, ${2:prim}, ${3:transform})",
            "kind": "function",
            "details": "Returns the world space rest transform for an agent primitive\u2019s joint"
        },
        {
            "trigger": "agentrigchildren(geometry, prim, transform)",
            "contents": "agentrigchildren(${1:geometry}, ${2:prim}, ${3:transform})",
            "kind": "function",
            "details": "Returns the child transforms of a transform in an agent primitive\u2019s rig"
        },
        {
            "trigger": "agentrigfind(geometry, prim, transformname)",
            "contents": "agentrigfind(${1:geometry}, ${2:prim}, ${3:transformname})",
            "kind": "function",
            "details": "Finds the index of a transform in an agent primitive\u2019s rig"
        },
        {
            "trigger": "agentrigfindchannel(geometry, prim, channelname)",
            "contents": "agentrigfindchannel(${1:geometry}, ${2:prim}, ${3:channelname})",
            "kind": "function",
            "details": "Finds the index of a channel in an agent primitive\u2019s rig"
        },
        {
            "trigger": "agentrigparent(geometry, prim, transform)",
            "contents": "agentrigparent(${1:geometry}, ${2:prim}, ${3:transform})",
            "kind": "function",
            "details": "Returns the parent transform of a transform in an agent primitive\u2019s rig"
        },
        {
            "trigger": "agentsolvefbik(geometry, outgeo, prim, targets, targetxforms, xformgroup, iters)",
            "contents": "agentsolvefbik(${1:geometry}, ${2:outgeo}, ${3:prim}, ${4:targets}, ${5:targetxforms}, ${6:xformgroup}, ${7:iters})",
            "kind": "function",
            "details": "Applies a full-body inverse kinematics algorithm to an agent\u2019s skeleton"
        },
        {
            "trigger": "agentsolvefbik(geometry, outgeo, prim, targets, targetxforms, xformgroup, iters, tolerance, pinroot)",
            "contents": "agentsolvefbik(${1:geometry}, ${2:outgeo}, ${3:prim}, ${4:targets}, ${5:targetxforms}, ${6:xformgroup}, ${7:iters}, ${8:tolerance}, ${9:pinroot})",
            "kind": "function",
            "details": "Applies a full-body inverse kinematics algorithm to an agent\u2019s skeleton"
        },
        {
            "trigger": "agentsolvefbik(geometry, outgeo, prim, targets, targetxforms, xformgroup, iters, tolerance, pinroot, targetweights, targetpriorities, targetdepths)",
            "contents": "agentsolvefbik(${1:geometry}, ${2:outgeo}, ${3:prim}, ${4:targets}, ${5:targetxforms}, ${6:xformgroup}, ${7:iters}, ${8:tolerance}, ${9:pinroot}, ${10:targetweights}, ${11:targetpriorities}, ${12:targetdepths})",
            "kind": "function",
            "details": "Applies a full-body inverse kinematics algorithm to an agent\u2019s skeleton"
        },
        {
            "trigger": "agentsolvefbik(geometry, outgeo, prim, targets, targetxforms, xformgroup, iters, tolerance, pinroot, targetweights, targetpriorities, targetdepths, targettypes, targetoffsets)",
            "contents": "agentsolvefbik(${1:geometry}, ${2:outgeo}, ${3:prim}, ${4:targets}, ${5:targetxforms}, ${6:xformgroup}, ${7:iters}, ${8:tolerance}, ${9:pinroot}, ${10:targetweights}, ${11:targetpriorities}, ${12:targetdepths}, ${13:targettypes}, ${14:targetoffsets})",
            "kind": "function",
            "details": "Applies a full-body inverse kinematics algorithm to an agent\u2019s skeleton"
        },
        {
            "trigger": "agentsolvefbik(geometry, outgeo, prim, targets, targetxforms, xformgroup, iters, tolerance, pinroot, targetweights, targetpriorities, targetdepths, goalxformattrib, constrainedxformattrib, jointlimitsattrib)",
            "contents": "agentsolvefbik(${1:geometry}, ${2:outgeo}, ${3:prim}, ${4:targets}, ${5:targetxforms}, ${6:xformgroup}, ${7:iters}, ${8:tolerance}, ${9:pinroot}, ${10:targetweights}, ${11:targetpriorities}, ${12:targetdepths}, ${13:goalxformattrib}, ${14:constrainedxformattrib}, ${15:jointlimitsattrib})",
            "kind": "function",
            "details": "Applies a full-body inverse kinematics algorithm to an agent\u2019s skeleton"
        },
        {
            "trigger": "agentsolvefbik(geometry, outgeo, prim, targets, targetxforms, xformgroup, iters, tolerance, pinroot, targetweights, targetpriorities, targetdepths, targettypes, targetoffsets, goalxformattrib, constrainedxformattrib, jointlimitsattrib)",
            "contents": "agentsolvefbik(${1:geometry}, ${2:outgeo}, ${3:prim}, ${4:targets}, ${5:targetxforms}, ${6:xformgroup}, ${7:iters}, ${8:tolerance}, ${9:pinroot}, ${10:targetweights}, ${11:targetpriorities}, ${12:targetdepths}, ${13:targettypes}, ${14:targetoffsets}, ${15:goalxformattrib}, ${16:constrainedxformattrib}, ${17:jointlimitsattrib})",
            "kind": "function",
            "details": "Applies a full-body inverse kinematics algorithm to an agent\u2019s skeleton"
        },
        {
            "trigger": "agenttransformcount(geometry, prim)",
            "contents": "agenttransformcount(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns the number of transforms in an agent primitive\u2019s rig"
        },
        {
            "trigger": "agenttransformgroupmember(geometry, prim, transformgroup, transform)",
            "contents": "agenttransformgroupmember(${1:geometry}, ${2:prim}, ${3:transformgroup}, ${4:transform})",
            "kind": "function",
            "details": "Returns whether a transform is a member of the specified transform group"
        },
        {
            "trigger": "agenttransformgroupmember(geometry, prim, transformgroupidx, transform)",
            "contents": "agenttransformgroupmember(${1:geometry}, ${2:prim}, ${3:transformgroupidx}, ${4:transform})",
            "kind": "function",
            "details": "Returns whether a transform is a member of the specified transform group"
        },
        {
            "trigger": "agenttransformgroupmemberchannel(geometry, prim, transformgroupidx, channel)",
            "contents": "agenttransformgroupmemberchannel(${1:geometry}, ${2:prim}, ${3:transformgroupidx}, ${4:channel})",
            "kind": "function",
            "details": "Returns whether a channel is a member of the specified transform group"
        },
        {
            "trigger": "agenttransformgroups(geometry, prim)",
            "contents": "agenttransformgroups(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns the names of the transform groups in an agent\u2019s definition"
        },
        {
            "trigger": "agenttransformgroupweight(geometry, prim, transformgroup, transform)",
            "contents": "agenttransformgroupweight(${1:geometry}, ${2:prim}, ${3:transformgroup}, ${4:transform})",
            "kind": "function",
            "details": "Returns the weight of a member of the specified transform group"
        },
        {
            "trigger": "agenttransformnames(geometry, prim)",
            "contents": "agenttransformnames(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns the name of each transform in an agent primitive\u2019s rig"
        },
        {
            "trigger": "agenttransformtolocal(geometry, prim, transforms)",
            "contents": "agenttransformtolocal(${1:geometry}, ${2:prim}, ${3:transforms})",
            "kind": "function",
            "details": "Converts transforms from world space to local space for an agent primitive"
        },
        {
            "trigger": "agenttransformtoworld(geometry, prim, transforms)",
            "contents": "agenttransformtoworld(${1:geometry}, ${2:prim}, ${3:transforms})",
            "kind": "function",
            "details": "Converts transforms from local space to world space for an agent primitive"
        },
        {
            "trigger": "agentworldtransform(geometry, prim, transform)",
            "contents": "agentworldtransform(${1:geometry}, ${2:prim}, ${3:transform})",
            "kind": "function",
            "details": "Returns the current world space transform of an agent primitive\u2019s bone"
        },
        {
            "trigger": "agentworldtransforms(geometry, prim)",
            "contents": "agentworldtransforms(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns the current world space transforms of an agent primitive"
        },
        {
            "trigger": "albedo(b, ...)",
            "contents": "albedo(${1:b}, ${2:...})",
            "kind": "function",
            "details": "Returns the albedo (percentage of reflected light) for a bsdf given the outgoing light direction"
        },
        {
            "trigger": "albedo(b, mask, ...)",
            "contents": "albedo(${1:b}, ${2:mask}, ${3:...})",
            "kind": "function",
            "details": "Returns the albedo (percentage of reflected light) for a bsdf given the outgoing light direction"
        },
        {
            "trigger": "albedo(b, viewer, ...)",
            "contents": "albedo(${1:b}, ${2:viewer}, ${3:...})",
            "kind": "function",
            "details": "Returns the albedo (percentage of reflected light) for a bsdf given the outgoing light direction"
        },
        {
            "trigger": "albedo(b, viewer, mask, ...)",
            "contents": "albedo(${1:b}, ${2:viewer}, ${3:mask}, ${4:...})",
            "kind": "function",
            "details": "Returns the albedo (percentage of reflected light) for a bsdf given the outgoing light direction"
        },
        {
            "trigger": "alphaname()",
            "contents": "alphaname()",
            "kind": "function",
            "details": "Returns the default name of the alpha plane (as it appears in the compositor preferences)"
        },
        {
            "trigger": "ambient(...)",
            "contents": "ambient(${1:...})",
            "kind": "function",
            "details": "Returns the color of ambient light in the scene"
        },
        {
            "trigger": "anoise(pos)",
            "contents": "anoise(${1:pos})",
            "kind": "function",
            "details": "Generates alligator noise"
        },
        {
            "trigger": "anoise(pos, turbulence, rough, atten)",
            "contents": "anoise(${1:pos}, ${2:turbulence}, ${3:rough}, ${4:atten})",
            "kind": "function",
            "details": "Generates alligator noise"
        },
        {
            "trigger": "anoise(pos, periodX, periodY, periodZ)",
            "contents": "anoise(${1:pos}, ${2:periodX}, ${3:periodY}, ${4:periodZ})",
            "kind": "function",
            "details": "Generates alligator noise"
        },
        {
            "trigger": "anoise(pos, periodX, periodY, periodZ, turbulence, rough, atten)",
            "contents": "anoise(${1:pos}, ${2:periodX}, ${3:periodY}, ${4:periodZ}, ${5:turbulence}, ${6:rough}, ${7:atten})",
            "kind": "function",
            "details": "Generates alligator noise"
        },
        {
            "trigger": "append(array, value)",
            "contents": "append(${1:array}, ${2:value})",
            "kind": "function",
            "details": "Adds an item to an array or string"
        },
        {
            "trigger": "append(array, values)",
            "contents": "append(${1:array}, ${2:values})",
            "kind": "function",
            "details": "Adds an item to an array or string"
        },
        {
            "trigger": "area(p, ...)",
            "contents": "area(${1:p}, ${2:...})",
            "kind": "function",
            "details": "Returns the area of the micropolygon containing a variable such as P"
        },
        {
            "trigger": "argsort(value)",
            "contents": "argsort(${1:value})",
            "kind": "function",
            "details": "Returns the indices of a sorted version of an array"
        },
        {
            "trigger": "array(...)",
            "contents": "array(${1:...})",
            "kind": "function",
            "details": "Efficiently creates an array from its arguments"
        },
        {
            "trigger": "ashikhmin(exponentx, exponenty, framex, framey, ...)",
            "contents": "ashikhmin(${1:exponentx}, ${2:exponenty}, ${3:framex}, ${4:framey}, ${5:...})",
            "kind": "function",
            "details": "Returns a specular BSDF using the Ashikhmin shading model"
        },
        {
            "trigger": "ashikhmin(nml, exponentx, exponenty, framex, framey, ...)",
            "contents": "ashikhmin(${1:nml}, ${2:exponentx}, ${3:exponenty}, ${4:framex}, ${5:framey}, ${6:...})",
            "kind": "function",
            "details": "Returns a specular BSDF using the Ashikhmin shading model"
        },
        {
            "trigger": "asin(n)",
            "contents": "asin(${1:n})",
            "kind": "function",
            "details": "Returns the inverse sine of the argument"
        },
        {
            "trigger": "assert_enabled()",
            "contents": "assert_enabled()",
            "kind": "function",
            "details": "Returns 1 if the VEX assertions are enabled (see HOUDINI_VEX_ASSERT) or 0 if assertions are disabled. Used the implement the assert macro"
        },
        {
            "trigger": "assign(c1, c2, source)",
            "contents": "assign(${1:c1}, ${2:c2}, ${3:source})",
            "kind": "function",
            "details": "An efficient way of extracting the components of a vector or matrix into float variables"
        },
        {
            "trigger": "assign(c1, c2, c3, source)",
            "contents": "assign(${1:c1}, ${2:c2}, ${3:c3}, ${4:source})",
            "kind": "function",
            "details": "An efficient way of extracting the components of a vector or matrix into float variables"
        },
        {
            "trigger": "assign(c1, c2, c3, c4, source)",
            "contents": "assign(${1:c1}, ${2:c2}, ${3:c3}, ${4:c4}, ${5:source})",
            "kind": "function",
            "details": "An efficient way of extracting the components of a vector or matrix into float variables"
        },
        {
            "trigger": "assign(c1, c2, c3, c4, c5, c6, c7, c8, c9, source)",
            "contents": "assign(${1:c1}, ${2:c2}, ${3:c3}, ${4:c4}, ${5:c5}, ${6:c6}, ${7:c7}, ${8:c8}, ${9:c9}, ${10:source})",
            "kind": "function",
            "details": "An efficient way of extracting the components of a vector or matrix into float variables"
        },
        {
            "trigger": "assign(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, source)",
            "contents": "assign(${1:c1}, ${2:c2}, ${3:c3}, ${4:c4}, ${5:c5}, ${6:c6}, ${7:c7}, ${8:c8}, ${9:c9}, ${10:c10}, ${11:c11}, ${12:c12}, ${13:c13}, ${14:c14}, ${15:c15}, ${16:c16}, ${17:source})",
            "kind": "function",
            "details": "An efficient way of extracting the components of a vector or matrix into float variables"
        },
        {
            "trigger": "atan(n)",
            "contents": "atan(${1:n})",
            "kind": "function",
            "details": "Returns the inverse tangent of the argument"
        },
        {
            "trigger": "atan(y, x)",
            "contents": "atan(${1:y}, ${2:x})",
            "kind": "function",
            "details": "Returns the inverse tangent of the argument"
        },
        {
            "trigger": "atan(v)",
            "contents": "atan(${1:v})",
            "kind": "function",
            "details": "Returns the inverse tangent of the argument"
        },
        {
            "trigger": "atan2(y, x)",
            "contents": "atan2(${1:y}, ${2:x})",
            "kind": "function",
            "details": "Returns the inverse tangent of y/x"
        },
        {
            "trigger": "atof(str)",
            "contents": "atof(${1:str})",
            "kind": "function",
            "details": "Converts a string to a float"
        },
        {
            "trigger": "atoi(str)",
            "contents": "atoi(${1:str})",
            "kind": "function",
            "details": "Converts a string to an integer"
        },
        {
            "trigger": "atoi(str, base)",
            "contents": "atoi(${1:str}, ${2:base})",
            "kind": "function",
            "details": "Converts a string to an integer"
        },
        {
            "trigger": "atten(attenuation, distance)",
            "contents": "atten(${1:attenuation}, ${2:distance})",
            "kind": "function",
            "details": "Computes attenuated falloff"
        },
        {
            "trigger": "attrib(geometry, attribclass, name, elemnum)",
            "contents": "attrib(${1:geometry}, ${2:attribclass}, ${3:name}, ${4:elemnum})",
            "kind": "function",
            "details": "Reads the value of an attribute from geometry"
        },
        {
            "trigger": "attribclass(geometry, attribute_name)",
            "contents": "attribclass(${1:geometry}, ${2:attribute_name})",
            "kind": "function",
            "details": "Returns the class of a geometry attribute"
        },
        {
            "trigger": "attribdataid(geometry, attribclass, attribute_name)",
            "contents": "attribdataid(${1:geometry}, ${2:attribclass}, ${3:attribute_name})",
            "kind": "function",
            "details": "Returns the data id of a geometry attribute"
        },
        {
            "trigger": "attribsize(geometry, attribclass, attribute_name)",
            "contents": "attribsize(${1:geometry}, ${2:attribclass}, ${3:attribute_name})",
            "kind": "function",
            "details": "Returns the size of a geometry attribute"
        },
        {
            "trigger": "attribtype(geometry, attribclass, attribute_name)",
            "contents": "attribtype(${1:geometry}, ${2:attribclass}, ${3:attribute_name})",
            "kind": "function",
            "details": "Returns the type of a geometry attribute"
        },
        {
            "trigger": "attribtypeinfo(geometry, attribclass, attribute_name)",
            "contents": "attribtypeinfo(${1:geometry}, ${2:attribclass}, ${3:attribute_name})",
            "kind": "function",
            "details": "Returns the transformation metadata of a geometry attribute"
        },
        {
            "trigger": "avg(a)",
            "contents": "avg(${1:a})",
            "kind": "function",
            "details": "Returns the average value of the input(s)"
        },
        {
            "trigger": "avg(a, b, ...)",
            "contents": "avg(${1:a}, ${2:b}, ${3:...})",
            "kind": "function",
            "details": "Returns the average value of the input(s)"
        },
        {
            "trigger": "avg(v)",
            "contents": "avg(${1:v})",
            "kind": "function",
            "details": "Returns the average value of the input(s)"
        },
        {
            "trigger": "avg(arr)",
            "contents": "avg(${1:arr})",
            "kind": "function",
            "details": "Returns the average value of the input(s)"
        },
        {
            "trigger": "binput(u, v, ...)",
            "contents": "binput(${1:u}, ${2:v}, ${3:...})",
            "kind": "function",
            "details": "Samples a 2\u00d72 pixel block around the given UV position, and bilinearly interpolates these pixels"
        },
        {
            "trigger": "binput(comp, u, v, ...)",
            "contents": "binput(${1:comp}, ${2:u}, ${3:v}, ${4:...})",
            "kind": "function",
            "details": "Samples a 2\u00d72 pixel block around the given UV position, and bilinearly interpolates these pixels"
        },
        {
            "trigger": "binput(opinput, plane, u, v, ...)",
            "contents": "binput(${1:opinput}, ${2:plane}, ${3:u}, ${4:v}, ${5:...})",
            "kind": "function",
            "details": "Samples a 2\u00d72 pixel block around the given UV position, and bilinearly interpolates these pixels"
        },
        {
            "trigger": "binput(opinput, plane, comp, u, v, ...)",
            "contents": "binput(${1:opinput}, ${2:plane}, ${3:comp}, ${4:u}, ${5:v}, ${6:...})",
            "kind": "function",
            "details": "Samples a 2\u00d72 pixel block around the given UV position, and bilinearly interpolates these pixels"
        },
        {
            "trigger": "binput(opinput, plane, array_index, comp, u, v, frame, ...)",
            "contents": "binput(${1:opinput}, ${2:plane}, ${3:array_index}, ${4:comp}, ${5:u}, ${6:v}, ${7:frame}, ${8:...})",
            "kind": "function",
            "details": "Samples a 2\u00d72 pixel block around the given UV position, and bilinearly interpolates these pixels"
        },
        {
            "trigger": "binput(opinput, plane, array_index, u, v, frame, ...)",
            "contents": "binput(${1:opinput}, ${2:plane}, ${3:array_index}, ${4:u}, ${5:v}, ${6:frame}, ${7:...})",
            "kind": "function",
            "details": "Samples a 2\u00d72 pixel block around the given UV position, and bilinearly interpolates these pixels"
        },
        {
            "trigger": "blackbody(temperature, luminance)",
            "contents": "blackbody(${1:temperature}, ${2:luminance})",
            "kind": "function",
            "details": "Compute the color value of an incandescent black body"
        },
        {
            "trigger": "blinn(exponent, ...)",
            "contents": "blinn(${1:exponent}, ${2:...})",
            "kind": "function",
            "details": "Returns a Blinn BSDF or computes Blinn shading"
        },
        {
            "trigger": "blinn(nml, exponent, ...)",
            "contents": "blinn(${1:nml}, ${2:exponent}, ${3:...})",
            "kind": "function",
            "details": "Returns a Blinn BSDF or computes Blinn shading"
        },
        {
            "trigger": "blinn(nml, V, roughness, ...)",
            "contents": "blinn(${1:nml}, ${2:V}, ${3:roughness}, ${4:...})",
            "kind": "function",
            "details": "Returns a Blinn BSDF or computes Blinn shading"
        },
        {
            "trigger": "blinnBRDF(L, N, V, rough)",
            "contents": "blinnBRDF(${1:L}, ${2:N}, ${3:V}, ${4:rough})",
            "kind": "function"
        },
        {
            "trigger": "bouncelabel(mask)",
            "contents": "bouncelabel(${1:mask})",
            "kind": "function"
        },
        {
            "trigger": "bouncemask(labels)",
            "contents": "bouncemask(${1:labels})",
            "kind": "function"
        },
        {
            "trigger": "bumpname()",
            "contents": "bumpname()",
            "kind": "function",
            "details": "Returns the default name of the bump plane (as it appears in the compositor preferences)"
        },
        {
            "trigger": "cbrt(n)",
            "contents": "cbrt(${1:n})",
            "kind": "function",
            "details": "Returns the cube root of the argument"
        },
        {
            "trigger": "cbrt(v)",
            "contents": "cbrt(${1:v})",
            "kind": "function",
            "details": "Returns the cube root of the argument"
        },
        {
            "trigger": "ceil(n)",
            "contents": "ceil(${1:n})",
            "kind": "function",
            "details": "Returns the smallest integer greater than or equal to the argument"
        },
        {
            "trigger": "ceil(v)",
            "contents": "ceil(${1:v})",
            "kind": "function",
            "details": "Returns the smallest integer greater than or equal to the argument"
        },
        {
            "trigger": "ch(channel)",
            "contents": "ch(${1:channel})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "ch(channel, time_in_sec)",
            "contents": "ch(${1:channel}, ${2:time_in_sec})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "ch(op_id, parm_index, vector_index)",
            "contents": "ch(${1:op_id}, ${2:parm_index}, ${3:vector_index})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "ch(op_id, parm_index, vector_index, time_in_sec)",
            "contents": "ch(${1:op_id}, ${2:parm_index}, ${3:vector_index}, ${4:time_in_sec})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "ch2(channel)",
            "contents": "ch2(${1:channel})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "ch2(channel, time)",
            "contents": "ch2(${1:channel}, ${2:time})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "ch3(channel)",
            "contents": "ch3(${1:channel})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "ch3(channel, time)",
            "contents": "ch3(${1:channel}, ${2:time})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "ch4(channel)",
            "contents": "ch4(${1:channel})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "ch4(channel, time)",
            "contents": "ch4(${1:channel}, ${2:time})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "chadd(channel_names)",
            "contents": "chadd(${1:channel_names})",
            "kind": "function",
            "details": "Adds new channels to a CHOP node"
        },
        {
            "trigger": "chattr(attrname, success)",
            "contents": "chattr(${1:attrname}, ${2:success})",
            "kind": "function",
            "details": "Reads from a CHOP attribute"
        },
        {
            "trigger": "chattr(opinput, attrname, success)",
            "contents": "chattr(${1:opinput}, ${2:attrname}, ${3:success})",
            "kind": "function",
            "details": "Reads from a CHOP attribute"
        },
        {
            "trigger": "chattr(attrname, channel, success)",
            "contents": "chattr(${1:attrname}, ${2:channel}, ${3:success})",
            "kind": "function",
            "details": "Reads from a CHOP attribute"
        },
        {
            "trigger": "chattr(opinput, attrname, channel, success)",
            "contents": "chattr(${1:opinput}, ${2:attrname}, ${3:channel}, ${4:success})",
            "kind": "function",
            "details": "Reads from a CHOP attribute"
        },
        {
            "trigger": "chattr(attrname, channel, sample, success)",
            "contents": "chattr(${1:attrname}, ${2:channel}, ${3:sample}, ${4:success})",
            "kind": "function",
            "details": "Reads from a CHOP attribute"
        },
        {
            "trigger": "chattr(opinput, attrname, channel, sample, success)",
            "contents": "chattr(${1:opinput}, ${2:attrname}, ${3:channel}, ${4:sample}, ${5:success})",
            "kind": "function",
            "details": "Reads from a CHOP attribute"
        },
        {
            "trigger": "chattr(attrclass, attrname, channel, sample, success)",
            "contents": "chattr(${1:attrclass}, ${2:attrname}, ${3:channel}, ${4:sample}, ${5:success})",
            "kind": "function",
            "details": "Reads from a CHOP attribute"
        },
        {
            "trigger": "chattr(opinput, attribclass, attrname, channel, sample, success)",
            "contents": "chattr(${1:opinput}, ${2:attribclass}, ${3:attrname}, ${4:channel}, ${5:sample}, ${6:success})",
            "kind": "function",
            "details": "Reads from a CHOP attribute"
        },
        {
            "trigger": "chattrnames(opinput, attribclass)",
            "contents": "chattrnames(${1:opinput}, ${2:attribclass})",
            "kind": "function",
            "details": "Reads CHOP attribute names of a given attribute class from a CHOP input"
        },
        {
            "trigger": "chattrnames(attrclass)",
            "contents": "chattrnames(${1:attrclass})",
            "kind": "function",
            "details": "Reads CHOP attribute names of a given attribute class from a CHOP input"
        },
        {
            "trigger": "chdict(channel)",
            "contents": "chdict(${1:channel})",
            "kind": "function",
            "details": "Evaluates a key-value dictionary parameter and return its value"
        },
        {
            "trigger": "chend(opinput)",
            "contents": "chend(${1:opinput})",
            "kind": "function",
            "details": "Returns the sample number of the last sample in a given CHOP input"
        },
        {
            "trigger": "chendf(opinput)",
            "contents": "chendf(${1:opinput})",
            "kind": "function",
            "details": "Returns the frame corresponding to the last sample of the input specified"
        },
        {
            "trigger": "chendt(opinput)",
            "contents": "chendt(${1:opinput})",
            "kind": "function",
            "details": "Returns the time corresponding to the last sample of the input specified"
        },
        {
            "trigger": "chexpr(channel, new_expr_function)",
            "contents": "chexpr(${1:channel}, ${2:new_expr_function})",
            "kind": "function",
            "details": "Evaluates a channel with a new segment expression"
        },
        {
            "trigger": "chexprf(channel, new_expr_function, frame)",
            "contents": "chexprf(${1:channel}, ${2:new_expr_function}, ${3:frame})",
            "kind": "function",
            "details": "Evaluates a channel with a new segment expression at a given frame"
        },
        {
            "trigger": "chexprt(channel, new_expr_function, time_in_seconds)",
            "contents": "chexprt(${1:channel}, ${2:new_expr_function}, ${3:time_in_seconds})",
            "kind": "function",
            "details": "Evaluates a channel with a new segment expression at a given time"
        },
        {
            "trigger": "chf(channel)",
            "contents": "chf(${1:channel})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "chf(channel, time_in_sec)",
            "contents": "chf(${1:channel}, ${2:time_in_sec})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "chf(op_id, parm_index, vector_index)",
            "contents": "chf(${1:op_id}, ${2:parm_index}, ${3:vector_index})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "chf(op_id, parm_index, vector_index, time_in_sec)",
            "contents": "chf(${1:op_id}, ${2:parm_index}, ${3:vector_index}, ${4:time_in_sec})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "chi(channel)",
            "contents": "chi(${1:channel})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "chi(channel, time)",
            "contents": "chi(${1:channel}, ${2:time})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "chiang(nn, tanV, R_v, R_s, TT_v, TT_s, TRT_v, TRT_s, shift, absorption_coeff, ior, ...)",
            "contents": "chiang(${1:nn}, ${2:tanV}, ${3:R_v}, ${4:R_s}, ${5:TT_v}, ${6:TT_s}, ${7:TRT_v}, ${8:TRT_s}, ${9:shift}, ${10:absorption_coeff}, ${11:ior}, ${12:...})",
            "kind": "function",
            "details": "Returns a chiang BSDF"
        },
        {
            "trigger": "chiang_fur(nn, tanV, mask, cuticle, R_v, R_s, TT_v, TT_s, TRT_v, TRT_s, shift, absorption_coeff, ior, R2_v, R2_s, R2_color, ...)",
            "contents": "chiang_fur(${1:nn}, ${2:tanV}, ${3:mask}, ${4:cuticle}, ${5:R_v}, ${6:R_s}, ${7:TT_v}, ${8:TT_s}, ${9:TRT_v}, ${10:TRT_s}, ${11:shift}, ${12:absorption_coeff}, ${13:ior}, ${14:R2_v}, ${15:R2_s}, ${16:R2_color}, ${17:...})",
            "kind": "function",
            "details": "Returns a chiang_fur BSDF"
        },
        {
            "trigger": "chid(channel_path, op_id, parm_index, vector_index)",
            "contents": "chid(${1:channel_path}, ${2:op_id}, ${3:parm_index}, ${4:vector_index})",
            "kind": "function",
            "details": "Resolves a channel string (or parameter) and return op_id, parm_index and vector_index"
        },
        {
            "trigger": "chid(op_path, channel_name, op_id, parm_index, vector_index)",
            "contents": "chid(${1:op_path}, ${2:channel_name}, ${3:op_id}, ${4:parm_index}, ${5:vector_index})",
            "kind": "function",
            "details": "Resolves a channel string (or parameter) and return op_id, parm_index and vector_index"
        },
        {
            "trigger": "chid(op_id, parm_index, vector_index)",
            "contents": "chid(${1:op_id}, ${2:parm_index}, ${3:vector_index})",
            "kind": "function",
            "details": "Resolves a channel string (or parameter) and return op_id, parm_index and vector_index"
        },
        {
            "trigger": "chindex(opinput, name)",
            "contents": "chindex(${1:opinput}, ${2:name})",
            "kind": "function",
            "details": "Returns the channel index from a input given a channel name"
        },
        {
            "trigger": "chindex(name)",
            "contents": "chindex(${1:name})",
            "kind": "function",
            "details": "Returns the channel index from a input given a channel name"
        },
        {
            "trigger": "chindex(names)",
            "contents": "chindex(${1:names})",
            "kind": "function",
            "details": "Returns the channel index from a input given a channel name"
        },
        {
            "trigger": "chinput(channel_index, sample)",
            "contents": "chinput(${1:channel_index}, ${2:sample})",
            "kind": "function",
            "details": "Returns the value of a channel at the specified sample"
        },
        {
            "trigger": "chinput(opinput, channel_index, sample)",
            "contents": "chinput(${1:opinput}, ${2:channel_index}, ${3:sample})",
            "kind": "function",
            "details": "Returns the value of a channel at the specified sample"
        },
        {
            "trigger": "chinput(channel_name, sample)",
            "contents": "chinput(${1:channel_name}, ${2:sample})",
            "kind": "function",
            "details": "Returns the value of a channel at the specified sample"
        },
        {
            "trigger": "chinput(opinput, channel_name, sample)",
            "contents": "chinput(${1:opinput}, ${2:channel_name}, ${3:sample})",
            "kind": "function",
            "details": "Returns the value of a channel at the specified sample"
        },
        {
            "trigger": "chinput(channel_index, sample, t, r, s)",
            "contents": "chinput(${1:channel_index}, ${2:sample}, ${3:t}, ${4:r}, ${5:s})",
            "kind": "function",
            "details": "Returns the value of a channel at the specified sample"
        },
        {
            "trigger": "chinput(opinput, channel_index, sample, t, r, s)",
            "contents": "chinput(${1:opinput}, ${2:channel_index}, ${3:sample}, ${4:t}, ${5:r}, ${6:s})",
            "kind": "function",
            "details": "Returns the value of a channel at the specified sample"
        },
        {
            "trigger": "chinput(channel_name, sample, t, r, s)",
            "contents": "chinput(${1:channel_name}, ${2:sample}, ${3:t}, ${4:r}, ${5:s})",
            "kind": "function",
            "details": "Returns the value of a channel at the specified sample"
        },
        {
            "trigger": "chinput(opinput, channel_name, sample, t, r, s)",
            "contents": "chinput(${1:opinput}, ${2:channel_name}, ${3:sample}, ${4:t}, ${5:r}, ${6:s})",
            "kind": "function",
            "details": "Returns the value of a channel at the specified sample"
        },
        {
            "trigger": "chinputlimits(opinput, channel, channel_min, channel_max)",
            "contents": "chinputlimits(${1:opinput}, ${2:channel}, ${3:channel_min}, ${4:channel_max})",
            "kind": "function",
            "details": "Computes the minimum and maximum value of samples in an input channel"
        },
        {
            "trigger": "chname(plane_index, chindex)",
            "contents": "chname(${1:plane_index}, ${2:chindex})",
            "kind": "function",
            "details": "Returns the name of a numbered channel"
        },
        {
            "trigger": "chname(channel_index)",
            "contents": "chname(${1:channel_index})",
            "kind": "function",
            "details": "Returns the name of a numbered channel"
        },
        {
            "trigger": "chname(opinput, channel_index)",
            "contents": "chname(${1:opinput}, ${2:channel_index})",
            "kind": "function",
            "details": "Returns the name of a numbered channel"
        },
        {
            "trigger": "chnames()",
            "contents": "chnames()",
            "kind": "function",
            "details": "Returns all the CHOP channel names of a given CHOP input"
        },
        {
            "trigger": "chnames(opinput)",
            "contents": "chnames(${1:opinput})",
            "kind": "function",
            "details": "Returns all the CHOP channel names of a given CHOP input"
        },
        {
            "trigger": "chnumchan()",
            "contents": "chnumchan()",
            "kind": "function",
            "details": "Returns the number of channels in the input specified"
        },
        {
            "trigger": "chnumchan(opinput)",
            "contents": "chnumchan(${1:opinput})",
            "kind": "function",
            "details": "Returns the number of channels in the input specified"
        },
        {
            "trigger": "chop(filename, channel, sample)",
            "contents": "chop(${1:filename}, ${2:channel}, ${3:sample})",
            "kind": "function",
            "details": "Returns the value of a CHOP channel at the specified sample"
        },
        {
            "trigger": "choplocal(filename, channel, sample)",
            "contents": "choplocal(${1:filename}, ${2:channel}, ${3:sample})",
            "kind": "function",
            "details": "Returns the value of a CHOP local transform channel at the specified sample"
        },
        {
            "trigger": "choplocalt(filename, channel, sample, time)",
            "contents": "choplocalt(${1:filename}, ${2:channel}, ${3:sample}, ${4:time})",
            "kind": "function",
            "details": "Returns the value of a CHOP local transform channel at the specified sample and evaluation time"
        },
        {
            "trigger": "chopt(filename, channel, sample, time)",
            "contents": "chopt(${1:filename}, ${2:channel}, ${3:sample}, ${4:time})",
            "kind": "function",
            "details": "Returns the value of a CHOP channel at the specified sample and evaluation time"
        },
        {
            "trigger": "chp(channel)",
            "contents": "chp(${1:channel})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "chp(channel, time)",
            "contents": "chp(${1:channel}, ${2:time})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "chprim_clear(geohandle, prim)",
            "contents": "chprim_clear(${1:geohandle}, ${2:prim})",
            "kind": "function",
            "details": "Clears a channel primitive, removing all keys"
        },
        {
            "trigger": "chprim_destroykey(geohandle, prim, time)",
            "contents": "chprim_destroykey(${1:geohandle}, ${2:prim}, ${3:time})",
            "kind": "function",
            "details": "Destroy an existing key from a channel primitive"
        },
        {
            "trigger": "chprim_end(geometry, prim)",
            "contents": "chprim_end(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Get the end time of a channel primitive"
        },
        {
            "trigger": "chprim_eval(geometry, prim, time)",
            "contents": "chprim_eval(${1:geometry}, ${2:prim}, ${3:time})",
            "kind": "function",
            "details": "Evaluate a channel primitive at the given time"
        },
        {
            "trigger": "chprim_insertkey(geohandle, prim, time)",
            "contents": "chprim_insertkey(${1:geohandle}, ${2:prim}, ${3:time})",
            "kind": "function",
            "details": "Insert a key into a channel primitive"
        },
        {
            "trigger": "chprim_keycount(geometry, prim)",
            "contents": "chprim_keycount(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Get the number of keys in a channel primitive"
        },
        {
            "trigger": "chprim_keytimes(geometry, prim)",
            "contents": "chprim_keytimes(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Get the key times of a channel primitive"
        },
        {
            "trigger": "chprim_keyvalues(geometry, prim)",
            "contents": "chprim_keyvalues(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Get the key values of a channel primitive"
        },
        {
            "trigger": "chprim_length(geometry, prim)",
            "contents": "chprim_length(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Get the length of a channel primitive"
        },
        {
            "trigger": "chprim_setkeyaccel(geohandle, prim, time, accel)",
            "contents": "chprim_setkeyaccel(${1:geohandle}, ${2:prim}, ${3:time}, ${4:accel})",
            "kind": "function",
            "details": "Set the acceleration of a channel primitive key"
        },
        {
            "trigger": "chprim_setkeyaccel(geohandle, prim, time, accel, half)",
            "contents": "chprim_setkeyaccel(${1:geohandle}, ${2:prim}, ${3:time}, ${4:accel}, ${5:half})",
            "kind": "function",
            "details": "Set the acceleration of a channel primitive key"
        },
        {
            "trigger": "chprim_setkeyslope(geohandle, prim, time, slope)",
            "contents": "chprim_setkeyslope(${1:geohandle}, ${2:prim}, ${3:time}, ${4:slope})",
            "kind": "function",
            "details": "Set the slope of a channel primitive key"
        },
        {
            "trigger": "chprim_setkeyslope(geohandle, prim, time, slope, half)",
            "contents": "chprim_setkeyslope(${1:geohandle}, ${2:prim}, ${3:time}, ${4:slope}, ${5:half})",
            "kind": "function",
            "details": "Set the slope of a channel primitive key"
        },
        {
            "trigger": "chprim_setkeyvalue(geohandle, prim, time, value)",
            "contents": "chprim_setkeyvalue(${1:geohandle}, ${2:prim}, ${3:time}, ${4:value})",
            "kind": "function",
            "details": "Set the value of a channel primitive key"
        },
        {
            "trigger": "chprim_setkeyvalue(geohandle, prim, time, value, half)",
            "contents": "chprim_setkeyvalue(${1:geohandle}, ${2:prim}, ${3:time}, ${4:value}, ${5:half})",
            "kind": "function",
            "details": "Set the value of a channel primitive key"
        },
        {
            "trigger": "chprim_start(geometry, prim)",
            "contents": "chprim_start(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Get the start time of a channel primitive"
        },
        {
            "trigger": "chr(value)",
            "contents": "chr(${1:value})",
            "kind": "function",
            "details": "Converts an unicode codepoint to a UTF8 string"
        },
        {
            "trigger": "chramp(channel, ramppos)",
            "contents": "chramp(${1:channel}, ${2:ramppos})",
            "kind": "function",
            "details": "Evaluates a ramp parameter and return its value"
        },
        {
            "trigger": "chramp(channel, ramppos, time)",
            "contents": "chramp(${1:channel}, ${2:ramppos}, ${3:time})",
            "kind": "function",
            "details": "Evaluates a ramp parameter and return its value"
        },
        {
            "trigger": "chrampderiv(channel, ramppos)",
            "contents": "chrampderiv(${1:channel}, ${2:ramppos})",
            "kind": "function",
            "details": "Evaluates the derivative of a parm parameter with respect to position"
        },
        {
            "trigger": "chrampderiv(channel, ramppos, time)",
            "contents": "chrampderiv(${1:channel}, ${2:ramppos}, ${3:time})",
            "kind": "function",
            "details": "Evaluates the derivative of a parm parameter with respect to position"
        },
        {
            "trigger": "chrate()",
            "contents": "chrate()",
            "kind": "function",
            "details": "Returns the sample rate of the input specified"
        },
        {
            "trigger": "chrate(opinput)",
            "contents": "chrate(${1:opinput})",
            "kind": "function",
            "details": "Returns the sample rate of the input specified"
        },
        {
            "trigger": "chreadbuf(index)",
            "contents": "chreadbuf(${1:index})",
            "kind": "function",
            "details": "Returns the value of CHOP context temporary buffer at the specified index"
        },
        {
            "trigger": "chremove(channel_index)",
            "contents": "chremove(${1:channel_index})",
            "kind": "function",
            "details": "Removes channels from a CHOP node"
        },
        {
            "trigger": "chremove(channel_indices)",
            "contents": "chremove(${1:channel_indices})",
            "kind": "function",
            "details": "Removes channels from a CHOP node"
        },
        {
            "trigger": "chremove(channel_name)",
            "contents": "chremove(${1:channel_name})",
            "kind": "function",
            "details": "Removes channels from a CHOP node"
        },
        {
            "trigger": "chremove(channel_names)",
            "contents": "chremove(${1:channel_names})",
            "kind": "function",
            "details": "Removes channels from a CHOP node"
        },
        {
            "trigger": "chremoveattr(attrclass, attrname)",
            "contents": "chremoveattr(${1:attrclass}, ${2:attrname})",
            "kind": "function",
            "details": "Removes a CHOP attribute"
        },
        {
            "trigger": "chremoveattr(attrclass, attrnames)",
            "contents": "chremoveattr(${1:attrclass}, ${2:attrnames})",
            "kind": "function",
            "details": "Removes a CHOP attribute"
        },
        {
            "trigger": "chremoveattr(attrname)",
            "contents": "chremoveattr(${1:attrname})",
            "kind": "function",
            "details": "Removes a CHOP attribute"
        },
        {
            "trigger": "chremoveattr(attrnames)",
            "contents": "chremoveattr(${1:attrnames})",
            "kind": "function",
            "details": "Removes a CHOP attribute"
        },
        {
            "trigger": "chrename(channel_index, new_name)",
            "contents": "chrename(${1:channel_index}, ${2:new_name})",
            "kind": "function",
            "details": "Renames a CHOP channel"
        },
        {
            "trigger": "chrename(channel_name, new_name)",
            "contents": "chrename(${1:channel_name}, ${2:new_name})",
            "kind": "function",
            "details": "Renames a CHOP channel"
        },
        {
            "trigger": "chresizebuf(size)",
            "contents": "chresizebuf(${1:size})",
            "kind": "function",
            "details": "Resize the CHOP context temporary buffer"
        },
        {
            "trigger": "chs(channel)",
            "contents": "chs(${1:channel})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "chs(channel, time)",
            "contents": "chs(${1:channel}, ${2:time})",
            "kind": "function",
            "details": "Evaluates a channel (or parameter) and return its value"
        },
        {
            "trigger": "chsetattr(attrclass, attrname, channel, sample, value)",
            "contents": "chsetattr(${1:attrclass}, ${2:attrname}, ${3:channel}, ${4:sample}, ${5:value})",
            "kind": "function",
            "details": "Sets the value of a CHOP attribute"
        },
        {
            "trigger": "chsetattr(attrname, channel, sample, value)",
            "contents": "chsetattr(${1:attrname}, ${2:channel}, ${3:sample}, ${4:value})",
            "kind": "function",
            "details": "Sets the value of a CHOP attribute"
        },
        {
            "trigger": "chsetlength(clip_length)",
            "contents": "chsetlength(${1:clip_length})",
            "kind": "function",
            "details": "Sets the length of the CHOP channel data"
        },
        {
            "trigger": "chsetrate(clip_rate)",
            "contents": "chsetrate(${1:clip_rate})",
            "kind": "function",
            "details": "Sets the sampling rate of the CHOP channel data"
        },
        {
            "trigger": "chsetstart(start)",
            "contents": "chsetstart(${1:start})",
            "kind": "function",
            "details": "Sets the CHOP start sample in the channel data"
        },
        {
            "trigger": "chsop(channel)",
            "contents": "chsop(${1:channel})",
            "kind": "function",
            "details": "Evaluates an operator path parameter and return the path to the operator"
        },
        {
            "trigger": "chsop(channel, time)",
            "contents": "chsop(${1:channel}, ${2:time})",
            "kind": "function",
            "details": "Evaluates an operator path parameter and return the path to the operator"
        },
        {
            "trigger": "chsraw(channel)",
            "contents": "chsraw(${1:channel})",
            "kind": "function",
            "details": "Returns the raw string channel (or parameter)"
        },
        {
            "trigger": "chstart()",
            "contents": "chstart()",
            "kind": "function",
            "details": "Returns the start sample of the input specified"
        },
        {
            "trigger": "chstart(opinput)",
            "contents": "chstart(${1:opinput})",
            "kind": "function",
            "details": "Returns the start sample of the input specified"
        },
        {
            "trigger": "chstartf()",
            "contents": "chstartf()",
            "kind": "function",
            "details": "Returns the frame corresponding to the first sample of the input specified"
        },
        {
            "trigger": "chstartf(opinput)",
            "contents": "chstartf(${1:opinput})",
            "kind": "function",
            "details": "Returns the frame corresponding to the first sample of the input specified"
        },
        {
            "trigger": "chstartt()",
            "contents": "chstartt()",
            "kind": "function",
            "details": "Returns the time corresponding to the first sample of the input specified"
        },
        {
            "trigger": "chstartt(opinput)",
            "contents": "chstartt(${1:opinput})",
            "kind": "function",
            "details": "Returns the time corresponding to the first sample of the input specified"
        },
        {
            "trigger": "chu(channel)",
            "contents": "chu(${1:channel})",
            "kind": "function",
            "details": "Evaluates a channel or parameter, and return its value"
        },
        {
            "trigger": "chu(channel, time)",
            "contents": "chu(${1:channel}, ${2:time})",
            "kind": "function",
            "details": "Evaluates a channel or parameter, and return its value"
        },
        {
            "trigger": "chv(channel)",
            "contents": "chv(${1:channel})",
            "kind": "function",
            "details": "Evaluates a channel or parameter, and return its value"
        },
        {
            "trigger": "chv(channel, time)",
            "contents": "chv(${1:channel}, ${2:time})",
            "kind": "function",
            "details": "Evaluates a channel or parameter, and return its value"
        },
        {
            "trigger": "chv(opid, pid)",
            "contents": "chv(${1:opid}, ${2:pid})",
            "kind": "function",
            "details": "Evaluates a channel or parameter, and return its value"
        },
        {
            "trigger": "chv(opid, pid, time)",
            "contents": "chv(${1:opid}, ${2:pid}, ${3:time})",
            "kind": "function",
            "details": "Evaluates a channel or parameter, and return its value"
        },
        {
            "trigger": "chwritebuf(index, value)",
            "contents": "chwritebuf(${1:index}, ${2:value})",
            "kind": "function",
            "details": "Writes a value of CHOP context temporary buffer at the specified index"
        },
        {
            "trigger": "chwritebuf(index, t, r, s)",
            "contents": "chwritebuf(${1:index}, ${2:t}, ${3:r}, ${4:s})",
            "kind": "function",
            "details": "Writes a value of CHOP context temporary buffer at the specified index"
        },
        {
            "trigger": "cinput(u, v, ...)",
            "contents": "cinput(${1:u}, ${2:v}, ${3:...})",
            "kind": "function",
            "details": "Samples the exact (unfiltered) pixel color at the given coordinates"
        },
        {
            "trigger": "cinput(component, u, v, ...)",
            "contents": "cinput(${1:component}, ${2:u}, ${3:v}, ${4:...})",
            "kind": "function",
            "details": "Samples the exact (unfiltered) pixel color at the given coordinates"
        },
        {
            "trigger": "cinput(opinput, planeindex, u, v, ...)",
            "contents": "cinput(${1:opinput}, ${2:planeindex}, ${3:u}, ${4:v}, ${5:...})",
            "kind": "function",
            "details": "Samples the exact (unfiltered) pixel color at the given coordinates"
        },
        {
            "trigger": "cinput(opinput, planeindex, component, u, v, ...)",
            "contents": "cinput(${1:opinput}, ${2:planeindex}, ${3:component}, ${4:u}, ${5:v}, ${6:...})",
            "kind": "function",
            "details": "Samples the exact (unfiltered) pixel color at the given coordinates"
        },
        {
            "trigger": "cinput(opinput, planeindex, arrayindex, u, v, frame, ...)",
            "contents": "cinput(${1:opinput}, ${2:planeindex}, ${3:arrayindex}, ${4:u}, ${5:v}, ${6:frame}, ${7:...})",
            "kind": "function",
            "details": "Samples the exact (unfiltered) pixel color at the given coordinates"
        },
        {
            "trigger": "cinput(opinput, planeindex, arrayindex, component, u, v, frame, ...)",
            "contents": "cinput(${1:opinput}, ${2:planeindex}, ${3:arrayindex}, ${4:component}, ${5:u}, ${6:v}, ${7:frame}, ${8:...})",
            "kind": "function",
            "details": "Samples the exact (unfiltered) pixel color at the given coordinates"
        },
        {
            "trigger": "ckspline(t, value, pos, ...)",
            "contents": "ckspline(${1:t}, ${2:value}, ${3:pos}, ${4:...})",
            "kind": "function",
            "details": "Samples a Catmull-Rom (Cardinal) spline defined by position/value keys"
        },
        {
            "trigger": "clamp(value, min, max)",
            "contents": "clamp(${1:value}, ${2:min}, ${3:max})",
            "kind": "function",
            "details": "Returns value clamped between min and max"
        },
        {
            "trigger": "clip(result, p0, p1, plane)",
            "contents": "clip(${1:result}, ${2:p0}, ${3:p1}, ${4:plane})",
            "kind": "function",
            "details": "Clip the line segment between p0 and p1"
        },
        {
            "trigger": "clip(result, p0, p1, min, max)",
            "contents": "clip(${1:result}, ${2:p0}, ${3:p1}, ${4:min}, ${5:max})",
            "kind": "function",
            "details": "Clip the line segment between p0 and p1"
        },
        {
            "trigger": "colormap(filename, uvw, ...)",
            "contents": "colormap(${1:filename}, ${2:uvw}, ${3:...})",
            "kind": "function",
            "details": "Looks up a (filtered) color from a texture file"
        },
        {
            "trigger": "colormap(filename, u, v, ...)",
            "contents": "colormap(${1:filename}, ${2:u}, ${3:v}, ${4:...})",
            "kind": "function",
            "details": "Looks up a (filtered) color from a texture file"
        },
        {
            "trigger": "colormap(filename, uv, du, dv, samples, ...)",
            "contents": "colormap(${1:filename}, ${2:uv}, ${3:du}, ${4:dv}, ${5:samples}, ${6:...})",
            "kind": "function",
            "details": "Looks up a (filtered) color from a texture file"
        },
        {
            "trigger": "colormap(filename, uv0, uv1, uv2, uv3, ...)",
            "contents": "colormap(${1:filename}, ${2:uv0}, ${3:uv1}, ${4:uv2}, ${5:uv3}, ${6:...})",
            "kind": "function",
            "details": "Looks up a (filtered) color from a texture file"
        },
        {
            "trigger": "colormap(filename, uv0, uv1, uv2, uv3, samples, ...)",
            "contents": "colormap(${1:filename}, ${2:uv0}, ${3:uv1}, ${4:uv2}, ${5:uv3}, ${6:samples}, ${7:...})",
            "kind": "function",
            "details": "Looks up a (filtered) color from a texture file"
        },
        {
            "trigger": "colormap(filename, u0, v0, u1, v1, u2, v2, u3, v3, samples, ...)",
            "contents": "colormap(${1:filename}, ${2:u0}, ${3:v0}, ${4:u1}, ${5:v1}, ${6:u2}, ${7:v2}, ${8:u3}, ${9:v3}, ${10:samples}, ${11:...})",
            "kind": "function",
            "details": "Looks up a (filtered) color from a texture file"
        },
        {
            "trigger": "colorname()",
            "contents": "colorname()",
            "kind": "function",
            "details": "Returns the default name of the color plane (as it appears in the compositor preferences)"
        },
        {
            "trigger": "combinelocaltransform(local, parent_world, parent_local, scale_inherit_mode)",
            "contents": "combinelocaltransform(${1:local}, ${2:parent_world}, ${3:parent_local}, ${4:scale_inherit_mode})",
            "kind": "function",
            "details": "Combines Local and Parent Transforms with Scale Inheritance"
        },
        {
            "trigger": "combinelocaltransform(local, parent_world, parent_local, scale_inherit_mode, effective_local_transform)",
            "contents": "combinelocaltransform(${1:local}, ${2:parent_world}, ${3:parent_local}, ${4:scale_inherit_mode}, ${5:effective_local_transform})",
            "kind": "function",
            "details": "Combines Local and Parent Transforms with Scale Inheritance"
        },
        {
            "trigger": "computenormal(P, ...)",
            "contents": "computenormal(${1:P}, ${2:...})",
            "kind": "function",
            "details": "In shading contexts, computes a normal. In the SOP contexts, sets how/whether to recompute normals"
        },
        {
            "trigger": "computenormal(P, N, Ng, ...)",
            "contents": "computenormal(${1:P}, ${2:N}, ${3:Ng}, ${4:...})",
            "kind": "function",
            "details": "In shading contexts, computes a normal. In the SOP contexts, sets how/whether to recompute normals"
        },
        {
            "trigger": "computenormal(i)",
            "contents": "computenormal(${1:i})",
            "kind": "function",
            "details": "In shading contexts, computes a normal. In the SOP contexts, sets how/whether to recompute normals"
        },
        {
            "trigger": "concat(s1, s2, ...)",
            "contents": "concat(${1:s1}, ${2:s2}, ${3:...})",
            "kind": "function",
            "details": "Concatenate all the strings specified to form a single string"
        },
        {
            "trigger": "cone(normal, dir, angle, ...)",
            "contents": "cone(${1:normal}, ${2:dir}, ${3:angle}, ${4:...})",
            "kind": "function",
            "details": "Returns a cone reflection BSDF"
        },
        {
            "trigger": "cone(dir, angle, ...)",
            "contents": "cone(${1:dir}, ${2:angle}, ${3:...})",
            "kind": "function",
            "details": "Returns a cone reflection BSDF"
        },
        {
            "trigger": "cos(n)",
            "contents": "cos(${1:n})",
            "kind": "function",
            "details": "Returns the cosine of the argument"
        },
        {
            "trigger": "cosh(n)",
            "contents": "cosh(${1:n})",
            "kind": "function",
            "details": "Returns the hyperbolic cosine of the argument"
        },
        {
            "trigger": "cosh(v)",
            "contents": "cosh(${1:v})",
            "kind": "function",
            "details": "Returns the hyperbolic cosine of the argument"
        },
        {
            "trigger": "cracktransform(trs, xyz, c, pivot, pivot_rotate, xform)",
            "contents": "cracktransform(${1:trs}, ${2:xyz}, ${3:c}, ${4:pivot}, ${5:pivot_rotate}, ${6:xform})",
            "kind": "function",
            "details": "Depending on the value of c, returns the translate (c=0), rotate (c=1), scale (c=2), or shears (c=3) component of the transform (xform)"
        },
        {
            "trigger": "cracktransform(trs, xyz, c, pivot, xform)",
            "contents": "cracktransform(${1:trs}, ${2:xyz}, ${3:c}, ${4:pivot}, ${5:xform})",
            "kind": "function",
            "details": "Depending on the value of c, returns the translate (c=0), rotate (c=1), scale (c=2), or shears (c=3) component of the transform (xform)"
        },
        {
            "trigger": "cracktransform(trs, xyz, pivot, pivot_rotate, xform, t, r, s, shears)",
            "contents": "cracktransform(${1:trs}, ${2:xyz}, ${3:pivot}, ${4:pivot_rotate}, ${5:xform}, ${6:t}, ${7:r}, ${8:s}, ${9:shears})",
            "kind": "function",
            "details": "Depending on the value of c, returns the translate (c=0), rotate (c=1), scale (c=2), or shears (c=3) component of the transform (xform)"
        },
        {
            "trigger": "cracktransform(trs, xyz, pivot, xform, t, r, s)",
            "contents": "cracktransform(${1:trs}, ${2:xyz}, ${3:pivot}, ${4:xform}, ${5:t}, ${6:r}, ${7:s})",
            "kind": "function",
            "details": "Depending on the value of c, returns the translate (c=0), rotate (c=1), scale (c=2), or shears (c=3) component of the transform (xform)"
        },
        {
            "trigger": "create_cdf(pdf)",
            "contents": "create_cdf(${1:pdf})",
            "kind": "function",
            "details": "Creates a cumulative distribution function (CDF) from an array of probability density function (PDF) values"
        },
        {
            "trigger": "create_pdf(values)",
            "contents": "create_pdf(${1:values})",
            "kind": "function",
            "details": "Creates a probability density function from an array of input values"
        },
        {
            "trigger": "cregioncapturetransform(path)",
            "contents": "cregioncapturetransform(${1:path})",
            "kind": "function",
            "details": "Returns the capture transform associated with a Capture Region SOP"
        },
        {
            "trigger": "cregioncapturetransform(path, time)",
            "contents": "cregioncapturetransform(${1:path}, ${2:time})",
            "kind": "function",
            "details": "Returns the capture transform associated with a Capture Region SOP"
        },
        {
            "trigger": "cregioncapturetransform(op_id)",
            "contents": "cregioncapturetransform(${1:op_id})",
            "kind": "function",
            "details": "Returns the capture transform associated with a Capture Region SOP"
        },
        {
            "trigger": "cregioncapturetransform(op_id, time)",
            "contents": "cregioncapturetransform(${1:op_id}, ${2:time})",
            "kind": "function",
            "details": "Returns the capture transform associated with a Capture Region SOP"
        },
        {
            "trigger": "cregiondeformtransform(path)",
            "contents": "cregiondeformtransform(${1:path})",
            "kind": "function",
            "details": "Returns the deform transform associated with a Capture Region SOP"
        },
        {
            "trigger": "cregiondeformtransform(path, time)",
            "contents": "cregiondeformtransform(${1:path}, ${2:time})",
            "kind": "function",
            "details": "Returns the deform transform associated with a Capture Region SOP"
        },
        {
            "trigger": "cregiondeformtransform(op_id)",
            "contents": "cregiondeformtransform(${1:op_id})",
            "kind": "function",
            "details": "Returns the deform transform associated with a Capture Region SOP"
        },
        {
            "trigger": "cregiondeformtransform(op_id, time)",
            "contents": "cregiondeformtransform(${1:op_id}, ${2:time})",
            "kind": "function",
            "details": "Returns the deform transform associated with a Capture Region SOP"
        },
        {
            "trigger": "cregionoverridetransform(path)",
            "contents": "cregionoverridetransform(${1:path})",
            "kind": "function",
            "details": "Returns the capture or deform transform associated with a Capture Region SOP based on the global capture override flag"
        },
        {
            "trigger": "cregionoverridetransform(path, time)",
            "contents": "cregionoverridetransform(${1:path}, ${2:time})",
            "kind": "function",
            "details": "Returns the capture or deform transform associated with a Capture Region SOP based on the global capture override flag"
        },
        {
            "trigger": "cregionoverridetransform(op_id)",
            "contents": "cregionoverridetransform(${1:op_id})",
            "kind": "function",
            "details": "Returns the capture or deform transform associated with a Capture Region SOP based on the global capture override flag"
        },
        {
            "trigger": "cregionoverridetransform(op_id, time)",
            "contents": "cregionoverridetransform(${1:op_id}, ${2:time})",
            "kind": "function",
            "details": "Returns the capture or deform transform associated with a Capture Region SOP based on the global capture override flag"
        },
        {
            "trigger": "cross(a, b)",
            "contents": "cross(${1:a}, ${2:b})",
            "kind": "function",
            "details": "Returns the cross product between the two vectors"
        },
        {
            "trigger": "cspline(t, val1, ...)",
            "contents": "cspline(${1:t}, ${2:val1}, ${3:...})",
            "kind": "function",
            "details": "Samples a Catmull-Rom (Cardinal) spline defined by uniformly spaced keys"
        },
        {
            "trigger": "ctransform(fromspace, tospace, clr)",
            "contents": "ctransform(${1:fromspace}, ${2:tospace}, ${3:clr})",
            "kind": "function",
            "details": "Transforms between color spaces"
        },
        {
            "trigger": "ctransform(tospace, clr)",
            "contents": "ctransform(${1:tospace}, ${2:clr})",
            "kind": "function",
            "details": "Transforms between color spaces"
        },
        {
            "trigger": "curlgxnoise(xyz)",
            "contents": "curlgxnoise(${1:xyz})",
            "kind": "function",
            "details": "Computes divergence free noise based on simplex noise"
        },
        {
            "trigger": "curlgxnoise(xyzt)",
            "contents": "curlgxnoise(${1:xyzt})",
            "kind": "function",
            "details": "Computes divergence free noise based on simplex noise"
        },
        {
            "trigger": "curlgxnoise2d(xy)",
            "contents": "curlgxnoise2d(${1:xy})",
            "kind": "function",
            "details": "Computes divergence free noise in the plane based on simplex noise"
        },
        {
            "trigger": "curlgxnoise2d(x, y)",
            "contents": "curlgxnoise2d(${1:x}, ${2:y})",
            "kind": "function",
            "details": "Computes divergence free noise in the plane based on simplex noise"
        },
        {
            "trigger": "curlgxnoise2d(xyz)",
            "contents": "curlgxnoise2d(${1:xyz})",
            "kind": "function",
            "details": "Computes divergence free noise in the plane based on simplex noise"
        },
        {
            "trigger": "curlgxnoise2d(xyzt)",
            "contents": "curlgxnoise2d(${1:xyzt})",
            "kind": "function",
            "details": "Computes divergence free noise in the plane based on simplex noise"
        },
        {
            "trigger": "curlnoise(xyz)",
            "contents": "curlnoise(${1:xyz})",
            "kind": "function",
            "details": "Computes divergence free noise based on Perlin noise"
        },
        {
            "trigger": "curlnoise(xyzt)",
            "contents": "curlnoise(${1:xyzt})",
            "kind": "function",
            "details": "Computes divergence free noise based on Perlin noise"
        },
        {
            "trigger": "curlnoise2d(x, y)",
            "contents": "curlnoise2d(${1:x}, ${2:y})",
            "kind": "function",
            "details": "Computes 2d divergence free noise based on Perlin noise"
        },
        {
            "trigger": "curlnoise2d(xyt)",
            "contents": "curlnoise2d(${1:xyt})",
            "kind": "function",
            "details": "Computes 2d divergence free noise based on Perlin noise"
        },
        {
            "trigger": "curlxnoise(xyz)",
            "contents": "curlxnoise(${1:xyz})",
            "kind": "function",
            "details": "Computes divergence free noise based on Simplex noise"
        },
        {
            "trigger": "curlxnoise(xyzt)",
            "contents": "curlxnoise(${1:xyzt})",
            "kind": "function",
            "details": "Computes divergence free noise based on Simplex noise"
        },
        {
            "trigger": "curlxnoise2d(x, y)",
            "contents": "curlxnoise2d(${1:x}, ${2:y})",
            "kind": "function",
            "details": "Computes 2d divergence free noise based on simplex noise"
        },
        {
            "trigger": "curlxnoise2d(xyt)",
            "contents": "curlxnoise2d(${1:xyt})",
            "kind": "function",
            "details": "Computes 2d divergence free noise based on simplex noise"
        },
        {
            "trigger": "curvearclen(positions, uv1, uv2, closedflag, fmt, order)",
            "contents": "curvearclen(${1:positions}, ${2:uv1}, ${3:uv2}, ${4:closedflag}, ${5:fmt}, ${6:order})",
            "kind": "function",
            "details": "Evaluates the length of an arc on a primitive defined by an array of points using parametric uv coordinates"
        },
        {
            "trigger": "curvearclen(positions, uv1, uv2, closedflag, fmt, order, divs)",
            "contents": "curvearclen(${1:positions}, ${2:uv1}, ${3:uv2}, ${4:closedflag}, ${5:fmt}, ${6:order}, ${7:divs})",
            "kind": "function",
            "details": "Evaluates the length of an arc on a primitive defined by an array of points using parametric uv coordinates"
        },
        {
            "trigger": "curvearclen(positions, uv1, uv2, closedflag, fmt, order, divs, primuvmode)",
            "contents": "curvearclen(${1:positions}, ${2:uv1}, ${3:uv2}, ${4:closedflag}, ${5:fmt}, ${6:order}, ${7:divs}, ${8:primuvmode})",
            "kind": "function",
            "details": "Evaluates the length of an arc on a primitive defined by an array of points using parametric uv coordinates"
        },
        {
            "trigger": "curvearclen(positions, uv1, uv2, closedflag, fmt, order, divs, primuvmode, primuvtol)",
            "contents": "curvearclen(${1:positions}, ${2:uv1}, ${3:uv2}, ${4:closedflag}, ${5:fmt}, ${6:order}, ${7:divs}, ${8:primuvmode}, ${9:primuvtol})",
            "kind": "function",
            "details": "Evaluates the length of an arc on a primitive defined by an array of points using parametric uv coordinates"
        },
        {
            "trigger": "cvex_bsdf(eval_cvex_shader, sampler_cvex_shader, ...)",
            "contents": "cvex_bsdf(${1:eval_cvex_shader}, ${2:sampler_cvex_shader}, ${3:...})",
            "kind": "function",
            "details": "Creates a bsdf object from two CVEX shader strings"
        },
        {
            "trigger": "cwnoise(position, seed, f1, f2)",
            "contents": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Chebyshev distance metric"
        },
        {
            "trigger": "cwnoise(position, seed, f1, f2, f3, f4)",
            "contents": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Chebyshev distance metric"
        },
        {
            "trigger": "cwnoise(position, seed, f1, f2, peiod)",
            "contents": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:peiod})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Chebyshev distance metric"
        },
        {
            "trigger": "cwnoise(position, seed, f1, f2, f4, f4, period)",
            "contents": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f4}, ${6:f4}, ${7:period})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Chebyshev distance metric"
        },
        {
            "trigger": "cwnoise(posx, posy, seed, f1, f2)",
            "contents": "cwnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Chebyshev distance metric"
        },
        {
            "trigger": "cwnoise(posx, posy, seed, f1, f2, f3, f4)",
            "contents": "cwnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:f3}, ${7:f4})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Chebyshev distance metric"
        },
        {
            "trigger": "cwnoise(posx, posy, seed, f1, f2, periodx, periody)",
            "contents": "cwnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:periodx}, ${7:periody})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Chebyshev distance metric"
        },
        {
            "trigger": "cwnoise(posx, posy, seed, f1, f2, f3, f4, periodx, periody)",
            "contents": "cwnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:f3}, ${7:f4}, ${8:periodx}, ${9:periody})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Chebyshev distance metric"
        },
        {
            "trigger": "cwnoise(position, seed, f1, f2, periodx, periody)",
            "contents": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Chebyshev distance metric"
        },
        {
            "trigger": "cwnoise(position, seed, f1, f2, f3, f4, periodx, periody)",
            "contents": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Chebyshev distance metric"
        },
        {
            "trigger": "cwnoise(position, seed, f1, f2, periodx, periody, periodx)",
            "contents": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody}, ${7:periodx})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Chebyshev distance metric"
        },
        {
            "trigger": "cwnoise(position, seed, f1, f2, f3, f4, periodx, periody, periodz)",
            "contents": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody}, ${9:periodz})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Chebyshev distance metric"
        },
        {
            "trigger": "cwnoise(position, seed, f1, f2, periodx, periody, periodz, periodw)",
            "contents": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody}, ${7:periodz}, ${8:periodw})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Chebyshev distance metric"
        },
        {
            "trigger": "cwnoise(position, seed, f1, f2, f3, f4, periodx, periody, periodz, periodw)",
            "contents": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody}, ${9:periodz}, ${10:periodw})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Chebyshev distance metric"
        },
        {
            "trigger": "decode(str)",
            "contents": "decode(${1:str})",
            "kind": "function",
            "details": "Decodes a variable name that was previously encoded"
        },
        {
            "trigger": "decodeattrib(str)",
            "contents": "decodeattrib(${1:str})",
            "kind": "function",
            "details": "Decodes a geometry attribute name that was previously encoded"
        },
        {
            "trigger": "decodeparm(str)",
            "contents": "decodeparm(${1:str})",
            "kind": "function",
            "details": "Decodes a node parameter name that was previously encoded"
        },
        {
            "trigger": "decodeutf8(str)",
            "contents": "decodeutf8(${1:str})",
            "kind": "function",
            "details": "Decodes a UTF8 string into a series of codepoints"
        },
        {
            "trigger": "degrees(num_in_rads)",
            "contents": "degrees(${1:num_in_rads})",
            "kind": "function",
            "details": "Converts the argument from radians into degrees"
        },
        {
            "trigger": "degrees(nums_in_rads)",
            "contents": "degrees(${1:nums_in_rads})",
            "kind": "function",
            "details": "Converts the argument from radians into degrees"
        },
        {
            "trigger": "depthmap(filename, uvw)",
            "contents": "depthmap(${1:filename}, ${2:uvw})",
            "kind": "function",
            "details": "The depthmap functions work on an image which was rendered as a z-depth image from mantra"
        },
        {
            "trigger": "depthmap(filename, u, v)",
            "contents": "depthmap(${1:filename}, ${2:u}, ${3:v})",
            "kind": "function",
            "details": "The depthmap functions work on an image which was rendered as a z-depth image from mantra"
        },
        {
            "trigger": "depthname()",
            "contents": "depthname()",
            "kind": "function",
            "details": "Returns the default name of the depth plane (as it appears in the compositor preferences)"
        },
        {
            "trigger": "detail(geometry, attribute_name, ignored)",
            "contents": "detail(${1:geometry}, ${2:attribute_name}, ${3:ignored})",
            "kind": "function",
            "details": "Reads the value of a detail attribute value from a geometry"
        },
        {
            "trigger": "detailattrib(geometry, attribute_name, ignored, success)",
            "contents": "detailattrib(${1:geometry}, ${2:attribute_name}, ${3:ignored}, ${4:success})",
            "kind": "function",
            "details": "Reads a detail attribute value from a geometry"
        },
        {
            "trigger": "detailattribsize(geometry, attribute_name)",
            "contents": "detailattribsize(${1:geometry}, ${2:attribute_name})",
            "kind": "function",
            "details": "Returns the size of a geometry detail attribute"
        },
        {
            "trigger": "detailattribtype(geometry, attribute_name)",
            "contents": "detailattribtype(${1:geometry}, ${2:attribute_name})",
            "kind": "function",
            "details": "Returns the type of a geometry detail attribute"
        },
        {
            "trigger": "detailattribtypeinfo(geometry, attribute_name)",
            "contents": "detailattribtypeinfo(${1:geometry}, ${2:attribute_name})",
            "kind": "function",
            "details": "Returns the type info of a geometry attribute"
        },
        {
            "trigger": "detailintrinsic(geometry, intrinsic_name)",
            "contents": "detailintrinsic(${1:geometry}, ${2:intrinsic_name})",
            "kind": "function",
            "details": "Reads the value of a detail intrinsic from a geometry"
        },
        {
            "trigger": "determinant(m)",
            "contents": "determinant(${1:m})",
            "kind": "function",
            "details": "Computes the determinant of the matrix"
        },
        {
            "trigger": "diag(m)",
            "contents": "diag(${1:m})",
            "kind": "function",
            "details": "Extracts diagonal entries or constructs a diagonal matrix"
        },
        {
            "trigger": "diag(v)",
            "contents": "diag(${1:v})",
            "kind": "function",
            "details": "Extracts diagonal entries or constructs a diagonal matrix"
        },
        {
            "trigger": "diagonalizesymmetric(symmat, diag)",
            "contents": "diagonalizesymmetric(${1:symmat}, ${2:diag})",
            "kind": "function",
            "details": "Diagonalizes Symmetric Matrices"
        },
        {
            "trigger": "diffuse(...)",
            "contents": "diffuse(${1:...})",
            "kind": "function",
            "details": "Returns a diffuse BSDF or computes diffuse shading"
        },
        {
            "trigger": "diffuse(roughness, ...)",
            "contents": "diffuse(${1:roughness}, ${2:...})",
            "kind": "function",
            "details": "Returns a diffuse BSDF or computes diffuse shading"
        },
        {
            "trigger": "diffuse(nml, ...)",
            "contents": "diffuse(${1:nml}, ${2:...})",
            "kind": "function",
            "details": "Returns a diffuse BSDF or computes diffuse shading"
        },
        {
            "trigger": "diffuse(nml, roughness, ...)",
            "contents": "diffuse(${1:nml}, ${2:roughness}, ${3:...})",
            "kind": "function",
            "details": "Returns a diffuse BSDF or computes diffuse shading"
        },
        {
            "trigger": "diffuse(nml, geo_normal, ...)",
            "contents": "diffuse(${1:nml}, ${2:geo_normal}, ${3:...})",
            "kind": "function",
            "details": "Returns a diffuse BSDF or computes diffuse shading"
        },
        {
            "trigger": "diffuse(nml, geo_normal, roughness, ...)",
            "contents": "diffuse(${1:nml}, ${2:geo_normal}, ${3:roughness}, ${4:...})",
            "kind": "function",
            "details": "Returns a diffuse BSDF or computes diffuse shading"
        },
        {
            "trigger": "diffuse(nml, V, roughness, ...)",
            "contents": "diffuse(${1:nml}, ${2:V}, ${3:roughness}, ${4:...})",
            "kind": "function",
            "details": "Returns a diffuse BSDF or computes diffuse shading"
        },
        {
            "trigger": "diffuseBRDF(L, N)",
            "contents": "diffuseBRDF(${1:L}, ${2:N})",
            "kind": "function"
        },
        {
            "trigger": "diffuseBRDF(L, N, V, rough)",
            "contents": "diffuseBRDF(${1:L}, ${2:N}, ${3:V}, ${4:rough})",
            "kind": "function"
        },
        {
            "trigger": "dihedral(a, b)",
            "contents": "dihedral(${1:a}, ${2:b})",
            "kind": "function",
            "details": "Computes the rotation matrix or quaternion which rotates the vector a onto the vector b"
        },
        {
            "trigger": "dimport(name, out)",
            "contents": "dimport(${1:name}, ${2:out})",
            "kind": "function",
            "details": "Reads a variable from the displacement shader for the surface"
        },
        {
            "trigger": "distance(a, b)",
            "contents": "distance(${1:a}, ${2:b})",
            "kind": "function",
            "details": "Returns the distance between two points"
        },
        {
            "trigger": "distance2(a, b)",
            "contents": "distance2(${1:a}, ${2:b})",
            "kind": "function",
            "details": "Returns the squared distance between the two points"
        },
        {
            "trigger": "distance_pointline(Q, O, D)",
            "contents": "distance_pointline(${1:Q}, ${2:O}, ${3:D})",
            "kind": "function",
            "details": "This function returns the closest distance between the point Q and the infinite line going through O parallel to vector D"
        },
        {
            "trigger": "distance_pointray(Q, O, D)",
            "contents": "distance_pointray(${1:Q}, ${2:O}, ${3:D})",
            "kind": "function",
            "details": "This function returns the closest distance between the point Q and the semi-finite ray starting at O and extending in the direction D"
        },
        {
            "trigger": "distance_pointsegment(Q, P0, P1)",
            "contents": "distance_pointsegment(${1:Q}, ${2:P0}, ${3:P1})",
            "kind": "function",
            "details": "This function returns the closest distance between the point Q and a finite line segment between points P0 and P1"
        },
        {
            "trigger": "dot(a, b)",
            "contents": "dot(${1:a}, ${2:b})",
            "kind": "function",
            "details": "Returns the dot product between the arguments"
        },
        {
            "trigger": "dsmpixel(map, channel, x, y, values)",
            "contents": "dsmpixel(${1:map}, ${2:channel}, ${3:x}, ${4:y}, ${5:values})",
            "kind": "function",
            "details": "Reads the z-records stored in a pixel of a deep shadow map or deep camera map"
        },
        {
            "trigger": "Du(n, ...)",
            "contents": "Du(${1:n}, ${2:...})",
            "kind": "function",
            "details": "Returns the derivative of the given value with respect to U"
        },
        {
            "trigger": "Dv(n, ...)",
            "contents": "Dv(${1:n}, ${2:...})",
            "kind": "function",
            "details": "Returns the derivative of the given value with respect to V"
        },
        {
            "trigger": "Dw(p, ...)",
            "contents": "Dw(${1:p}, ${2:...})",
            "kind": "function",
            "details": "Returns the derivative of the given value with respect to the 3rd axis (for volume rendering)"
        },
        {
            "trigger": "efit(value, omin, omax, nmin, nmax)",
            "contents": "efit(${1:value}, ${2:omin}, ${3:omax}, ${4:nmin}, ${5:nmax})",
            "kind": "function",
            "details": "Takes the value in one range and shifts it to the corresponding value in a new range"
        },
        {
            "trigger": "eigenvalues(nroot, mat, real, imaginary)",
            "contents": "eigenvalues(${1:nroot}, ${2:mat}, ${3:real}, ${4:imaginary})",
            "kind": "function",
            "details": "Computes the eigenvalues of a 3\u00d73 matrix"
        },
        {
            "trigger": "encode(str)",
            "contents": "encode(${1:str})",
            "kind": "function",
            "details": "Encodes any string into a valid variable name"
        },
        {
            "trigger": "encodeattrib(str)",
            "contents": "encodeattrib(${1:str})",
            "kind": "function",
            "details": "Encodes any string into a valid geometry attribute name"
        },
        {
            "trigger": "encodeparm(str)",
            "contents": "encodeparm(${1:str})",
            "kind": "function",
            "details": "Encodes any string into a valid node parameter name"
        },
        {
            "trigger": "encodeutf8(codepoints)",
            "contents": "encodeutf8(${1:codepoints})",
            "kind": "function",
            "details": "Encodes a UTF8 string from a series of codepoints"
        },
        {
            "trigger": "endswith(haystack, needle)",
            "contents": "endswith(${1:haystack}, ${2:needle})",
            "kind": "function",
            "details": "Indicates the string ends with the specified string"
        },
        {
            "trigger": "environment(texture_filename, reflect_dir, ...)",
            "contents": "environment(${1:texture_filename}, ${2:reflect_dir}, ${3:...})",
            "kind": "function",
            "details": "Returns the color of the environment texture"
        },
        {
            "trigger": "environment(texture_filename, reflect_dir0, reflect_dir1, reflect_dir2, reflect_dir3, ...)",
            "contents": "environment(${1:texture_filename}, ${2:reflect_dir0}, ${3:reflect_dir1}, ${4:reflect_dir2}, ${5:reflect_dir3}, ${6:...})",
            "kind": "function",
            "details": "Returns the color of the environment texture"
        },
        {
            "trigger": "environment(texture_filename, reflect_dir, filter_angle, ...)",
            "contents": "environment(${1:texture_filename}, ${2:reflect_dir}, ${3:filter_angle}, ${4:...})",
            "kind": "function",
            "details": "Returns the color of the environment texture"
        },
        {
            "trigger": "erf(v)",
            "contents": "erf(${1:v})",
            "kind": "function",
            "details": "Gauss error function"
        },
        {
            "trigger": "erfc(v)",
            "contents": "erfc(${1:v})",
            "kind": "function",
            "details": "Gauss error function\u2019s complement"
        },
        {
            "trigger": "erf_inv(v)",
            "contents": "erf_inv(${1:v})",
            "kind": "function",
            "details": "Inverse Gauss error function"
        },
        {
            "trigger": "error(format, ...)",
            "contents": "error(${1:format}, ${2:...})",
            "kind": "function",
            "details": "Reports a custom runtime VEX error"
        },
        {
            "trigger": "eulertoquaternion(rotations, order)",
            "contents": "eulertoquaternion(${1:rotations}, ${2:order})",
            "kind": "function",
            "details": "Creates a vector4 representing a quaternion from euler angles"
        },
        {
            "trigger": "eval_bsdf(b, viewer, light, ...)",
            "contents": "eval_bsdf(${1:b}, ${2:viewer}, ${3:light}, ${4:...})",
            "kind": "function",
            "details": "Evaluates a bsdf given two vectors"
        },
        {
            "trigger": "eval_bsdf(b, viewer, light, mask, ...)",
            "contents": "eval_bsdf(${1:b}, ${2:viewer}, ${3:light}, ${4:mask}, ${5:...})",
            "kind": "function",
            "details": "Evaluates a bsdf given two vectors"
        },
        {
            "trigger": "eval_bsdf(b, viewer, light, pdf, mask, ...)",
            "contents": "eval_bsdf(${1:b}, ${2:viewer}, ${3:light}, ${4:pdf}, ${5:mask}, ${6:...})",
            "kind": "function",
            "details": "Evaluates a bsdf given two vectors"
        },
        {
            "trigger": "eval_bsdf(b, viewer, light, normal, ...)",
            "contents": "eval_bsdf(${1:b}, ${2:viewer}, ${3:light}, ${4:normal}, ${5:...})",
            "kind": "function",
            "details": "Evaluates a bsdf given two vectors"
        },
        {
            "trigger": "eval_bsdf(b, viewer, light, normal, mask, ...)",
            "contents": "eval_bsdf(${1:b}, ${2:viewer}, ${3:light}, ${4:normal}, ${5:mask}, ${6:...})",
            "kind": "function",
            "details": "Evaluates a bsdf given two vectors"
        },
        {
            "trigger": "eval_bsdf(b, viewer, light, normal, pdf, mask, ...)",
            "contents": "eval_bsdf(${1:b}, ${2:viewer}, ${3:light}, ${4:normal}, ${5:pdf}, ${6:mask}, ${7:...})",
            "kind": "function",
            "details": "Evaluates a bsdf given two vectors"
        },
        {
            "trigger": "exp(n)",
            "contents": "exp(${1:n})",
            "kind": "function",
            "details": "Returns the exponential function of the argument"
        },
        {
            "trigger": "expandedgegroup(geometry, groupname)",
            "contents": "expandedgegroup(${1:geometry}, ${2:groupname})",
            "kind": "function"
        },
        {
            "trigger": "expandedgegroup(geometry, groupname, mode)",
            "contents": "expandedgegroup(${1:geometry}, ${2:groupname}, ${3:mode})",
            "kind": "function"
        },
        {
            "trigger": "expandpointgroup(geometry, groupname)",
            "contents": "expandpointgroup(${1:geometry}, ${2:groupname})",
            "kind": "function",
            "details": "Returns an array of point numbers corresponding to a group string"
        },
        {
            "trigger": "expandpointgroup(geometry, groupname, mode)",
            "contents": "expandpointgroup(${1:geometry}, ${2:groupname}, ${3:mode})",
            "kind": "function",
            "details": "Returns an array of point numbers corresponding to a group string"
        },
        {
            "trigger": "expandprimgroup(geometry, groupname)",
            "contents": "expandprimgroup(${1:geometry}, ${2:groupname})",
            "kind": "function",
            "details": "Returns an array of prim numbers corresponding to a group string"
        },
        {
            "trigger": "expandprimgroup(geometry, groupname, mode)",
            "contents": "expandprimgroup(${1:geometry}, ${2:groupname}, ${3:mode})",
            "kind": "function",
            "details": "Returns an array of prim numbers corresponding to a group string"
        },
        {
            "trigger": "expandvertexgroup(geometry, groupname)",
            "contents": "expandvertexgroup(${1:geometry}, ${2:groupname})",
            "kind": "function",
            "details": "Returns an array of linear vertex numbers corresponding to a group string"
        },
        {
            "trigger": "expandvertexgroup(geometry, groupname, mode)",
            "contents": "expandvertexgroup(${1:geometry}, ${2:groupname}, ${3:mode})",
            "kind": "function",
            "details": "Returns an array of linear vertex numbers corresponding to a group string"
        },
        {
            "trigger": "expand_udim(u, v, path, ...)",
            "contents": "expand_udim(${1:u}, ${2:v}, ${3:path}, ${4:...})",
            "kind": "function",
            "details": "Perform UDIM or UVTILE texture filename expansion"
        },
        {
            "trigger": "extractlocaltransform(world, parent_world, parent_local, scale_inherit_mode)",
            "contents": "extractlocaltransform(${1:world}, ${2:parent_world}, ${3:parent_local}, ${4:scale_inherit_mode})",
            "kind": "function",
            "details": "Extracts Local Transform from a World Transform with Scale Inheritance"
        },
        {
            "trigger": "extractlocaltransform(world, parent_world, parent_local, mode, effective_local_transform)",
            "contents": "extractlocaltransform(${1:world}, ${2:parent_world}, ${3:parent_local}, ${4:mode}, ${5:effective_local_transform})",
            "kind": "function",
            "details": "Extracts Local Transform from a World Transform with Scale Inheritance"
        },
        {
            "trigger": "fastshadow(P, D, bias, ...)",
            "contents": "fastshadow(${1:P}, ${2:D}, ${3:bias}, ${4:...})",
            "kind": "function",
            "details": "Sends a ray from the position P along the direction specified by the direction D"
        },
        {
            "trigger": "filamentsample(geometry, position)",
            "contents": "filamentsample(${1:geometry}, ${2:position})",
            "kind": "function",
            "details": "Samples the velocity field defined by a set of vortex filaments"
        },
        {
            "trigger": "file_stat(filename, stat_data, ...)",
            "contents": "file_stat(${1:filename}, ${2:stat_data}, ${3:...})",
            "kind": "function",
            "details": "Returns file system status for a given file"
        },
        {
            "trigger": "filtershadow(P, D, bias, ...)",
            "contents": "filtershadow(${1:P}, ${2:D}, ${3:bias}, ${4:...})",
            "kind": "function",
            "details": "Sends a ray from the position P along direction D"
        },
        {
            "trigger": "filterstep(edge, x, ...)",
            "contents": "filterstep(${1:edge}, ${2:x}, ${3:...})",
            "kind": "function",
            "details": "Returns the anti-aliased weight of the step function"
        },
        {
            "trigger": "filterstep(edge, x0, x1, ...)",
            "contents": "filterstep(${1:edge}, ${2:x0}, ${3:x1}, ${4:...})",
            "kind": "function",
            "details": "Returns the anti-aliased weight of the step function"
        },
        {
            "trigger": "filter_remap(uv, filter, width, ...)",
            "contents": "filter_remap(${1:uv}, ${2:filter}, ${3:width}, ${4:...})",
            "kind": "function",
            "details": "Computes an importance sample based on the given filter type and input uv"
        },
        {
            "trigger": "find(haystack, needle)",
            "contents": "find(${1:haystack}, ${2:needle})",
            "kind": "function",
            "details": "Finds an item in an array or string"
        },
        {
            "trigger": "find(haystack, needle, start)",
            "contents": "find(${1:haystack}, ${2:needle}, ${3:start})",
            "kind": "function",
            "details": "Finds an item in an array or string"
        },
        {
            "trigger": "find(haystack, needle, start, end)",
            "contents": "find(${1:haystack}, ${2:needle}, ${3:start}, ${4:end})",
            "kind": "function",
            "details": "Finds an item in an array or string"
        },
        {
            "trigger": "find(array, target)",
            "contents": "find(${1:array}, ${2:target})",
            "kind": "function",
            "details": "Finds an item in an array or string"
        },
        {
            "trigger": "find(array, target, start)",
            "contents": "find(${1:array}, ${2:target}, ${3:start})",
            "kind": "function",
            "details": "Finds an item in an array or string"
        },
        {
            "trigger": "find(array, target, start, end)",
            "contents": "find(${1:array}, ${2:target}, ${3:start}, ${4:end})",
            "kind": "function",
            "details": "Finds an item in an array or string"
        },
        {
            "trigger": "findattribval(geometry, attribclass, attribute_name, value, which)",
            "contents": "findattribval(${1:geometry}, ${2:attribclass}, ${3:attribute_name}, ${4:value}, ${5:which})",
            "kind": "function",
            "details": "Finds a primitive/point/vertex that has a certain attribute value"
        },
        {
            "trigger": "findattribval(geometry, attribclass, attribute_name, value)",
            "contents": "findattribval(${1:geometry}, ${2:attribclass}, ${3:attribute_name}, ${4:value})",
            "kind": "function",
            "details": "Finds a primitive/point/vertex that has a certain attribute value"
        },
        {
            "trigger": "findattribvalcount(geometry, attribclass, attribute_name, value)",
            "contents": "findattribvalcount(${1:geometry}, ${2:attribclass}, ${3:attribute_name}, ${4:value})",
            "kind": "function",
            "details": "Returns number of elements where an integer or string attribute has a certain value"
        },
        {
            "trigger": "finput(u, v, ...)",
            "contents": "finput(${1:u}, ${2:v}, ${3:...})",
            "kind": "function",
            "details": "Returns fully filtered pixel input"
        },
        {
            "trigger": "finput(component, u, v, ...)",
            "contents": "finput(${1:component}, ${2:u}, ${3:v}, ${4:...})",
            "kind": "function",
            "details": "Returns fully filtered pixel input"
        },
        {
            "trigger": "finput(opinput, planeindex, u, v, ...)",
            "contents": "finput(${1:opinput}, ${2:planeindex}, ${3:u}, ${4:v}, ${5:...})",
            "kind": "function",
            "details": "Returns fully filtered pixel input"
        },
        {
            "trigger": "finput(opinput, planeindex, component, u, v, ...)",
            "contents": "finput(${1:opinput}, ${2:planeindex}, ${3:component}, ${4:u}, ${5:v}, ${6:...})",
            "kind": "function",
            "details": "Returns fully filtered pixel input"
        },
        {
            "trigger": "finput(opinput, planeindex, arrayindex, u, v, frame, ...)",
            "contents": "finput(${1:opinput}, ${2:planeindex}, ${3:arrayindex}, ${4:u}, ${5:v}, ${6:frame}, ${7:...})",
            "kind": "function",
            "details": "Returns fully filtered pixel input"
        },
        {
            "trigger": "finput(opinput, planeindex, arrayindex, component, u, v, frame, ...)",
            "contents": "finput(${1:opinput}, ${2:planeindex}, ${3:arrayindex}, ${4:component}, ${5:u}, ${6:v}, ${7:frame}, ${8:...})",
            "kind": "function",
            "details": "Returns fully filtered pixel input"
        },
        {
            "trigger": "fit(value, omin, omax, nmin, nmax)",
            "contents": "fit(${1:value}, ${2:omin}, ${3:omax}, ${4:nmin}, ${5:nmax})",
            "kind": "function",
            "details": "Takes the value in one range and shifts it to the corresponding value in a new range"
        },
        {
            "trigger": "fit01(value, nmin, nmax)",
            "contents": "fit01(${1:value}, ${2:nmin}, ${3:nmax})",
            "kind": "function",
            "details": "Takes the value in the range (0, 1) and shifts it to the corresponding value in a new range"
        },
        {
            "trigger": "fit10(value, nmin, nmax)",
            "contents": "fit10(${1:value}, ${2:nmin}, ${3:nmax})",
            "kind": "function",
            "details": "Takes the value in the range (1, 0) and shifts it to the corresponding value in a new range"
        },
        {
            "trigger": "fit11(value, nmin, nmax)",
            "contents": "fit11(${1:value}, ${2:nmin}, ${3:nmax})",
            "kind": "function",
            "details": "Takes the value in the range (-1, 1) and shifts it to the corresponding value in a new range"
        },
        {
            "trigger": "floor(n)",
            "contents": "floor(${1:n})",
            "kind": "function",
            "details": "Returns the largest integer less than or equal to the argument"
        },
        {
            "trigger": "floor(v)",
            "contents": "floor(${1:v})",
            "kind": "function",
            "details": "Returns the largest integer less than or equal to the argument"
        },
        {
            "trigger": "flownoise(xyz, flow)",
            "contents": "flownoise(${1:xyz}, ${2:flow})",
            "kind": "function",
            "details": "Generates 1D and 3D Perlin Flow Noise from 3D and 4D data"
        },
        {
            "trigger": "flownoise(xyzt, flow)",
            "contents": "flownoise(${1:xyzt}, ${2:flow})",
            "kind": "function",
            "details": "Generates 1D and 3D Perlin Flow Noise from 3D and 4D data"
        },
        {
            "trigger": "flownoise(x, y, flow)",
            "contents": "flownoise(${1:x}, ${2:y}, ${3:flow})",
            "kind": "function",
            "details": "Generates 1D and 3D Perlin Flow Noise from 3D and 4D data"
        },
        {
            "trigger": "flowpnoise(xyz, p, flow)",
            "contents": "flowpnoise(${1:xyz}, ${2:p}, ${3:flow})",
            "kind": "function",
            "details": "There are two forms of Perlin-style noise: a non-periodic noise which changes randomly throughout N-dimensional space, and a periodic form which repeats over a given range of space"
        },
        {
            "trigger": "flowpnoise(xyzt, p, flow)",
            "contents": "flowpnoise(${1:xyzt}, ${2:p}, ${3:flow})",
            "kind": "function",
            "details": "There are two forms of Perlin-style noise: a non-periodic noise which changes randomly throughout N-dimensional space, and a periodic form which repeats over a given range of space"
        },
        {
            "trigger": "flowpnoise(x, y, px, py, flow)",
            "contents": "flowpnoise(${1:x}, ${2:y}, ${3:px}, ${4:py}, ${5:flow})",
            "kind": "function",
            "details": "There are two forms of Perlin-style noise: a non-periodic noise which changes randomly throughout N-dimensional space, and a periodic form which repeats over a given range of space"
        },
        {
            "trigger": "flowpnoise(xyz, px, py, pz, flow)",
            "contents": "flowpnoise(${1:xyz}, ${2:px}, ${3:py}, ${4:pz}, ${5:flow})",
            "kind": "function",
            "details": "There are two forms of Perlin-style noise: a non-periodic noise which changes randomly throughout N-dimensional space, and a periodic form which repeats over a given range of space"
        },
        {
            "trigger": "flowpnoise(xyzt, px, py, pz, pt, flow)",
            "contents": "flowpnoise(${1:xyzt}, ${2:px}, ${3:py}, ${4:pz}, ${5:pt}, ${6:flow})",
            "kind": "function",
            "details": "There are two forms of Perlin-style noise: a non-periodic noise which changes randomly throughout N-dimensional space, and a periodic form which repeats over a given range of space"
        },
        {
            "trigger": "frac(n)",
            "contents": "frac(${1:n})",
            "kind": "function",
            "details": "Returns the fractional component of the floating point number"
        },
        {
            "trigger": "frac(v)",
            "contents": "frac(${1:v})",
            "kind": "function",
            "details": "Returns the fractional component of the floating point number"
        },
        {
            "trigger": "fresnel(i, n, eta, kr, kt)",
            "contents": "fresnel(${1:i}, ${2:n}, ${3:eta}, ${4:kr}, ${5:kt})",
            "kind": "function",
            "details": "Computes the fresnel reflection/refraction contributions given an incoming vector, surface normal (both normalized), and an index of refraction (eta)"
        },
        {
            "trigger": "fresnel(i, n, eta, kr, kt, R, T)",
            "contents": "fresnel(${1:i}, ${2:n}, ${3:eta}, ${4:kr}, ${5:kt}, ${6:R}, ${7:T})",
            "kind": "function",
            "details": "Computes the fresnel reflection/refraction contributions given an incoming vector, surface normal (both normalized), and an index of refraction (eta)"
        },
        {
            "trigger": "fromNDC(v)",
            "contents": "fromNDC(${1:v})",
            "kind": "function",
            "details": "Transforms a position from normal device coordinates to the coordinates in the appropriate space"
        },
        {
            "trigger": "fromNDC(space, v)",
            "contents": "fromNDC(${1:space}, ${2:v})",
            "kind": "function",
            "details": "Transforms a position from normal device coordinates to the coordinates in the appropriate space"
        },
        {
            "trigger": "frontface(N, I)",
            "contents": "frontface(${1:N}, ${2:I})",
            "kind": "function",
            "details": "If dot(I, Nref) is less than zero, N will be negated"
        },
        {
            "trigger": "frontface(N, I, Nref)",
            "contents": "frontface(${1:N}, ${2:I}, ${3:Nref})",
            "kind": "function",
            "details": "If dot(I, Nref) is less than zero, N will be negated"
        },
        {
            "trigger": "fuzzify(ramp_basis, ramp_values, ramp_positions, crisp_value, min_value, max_value)",
            "contents": "fuzzify(${1:ramp_basis}, ${2:ramp_values}, ${3:ramp_positions}, ${4:crisp_value}, ${5:min_value}, ${6:max_value})",
            "kind": "function"
        },
        {
            "trigger": "fuzzy_and(a, b, ...)",
            "contents": "fuzzy_and(${1:a}, ${2:b}, ${3:...})",
            "kind": "function"
        },
        {
            "trigger": "fuzzy_defuzz_centroid(aggregated_membership, min_value, max_value)",
            "contents": "fuzzy_defuzz_centroid(${1:aggregated_membership}, ${2:min_value}, ${3:max_value})",
            "kind": "function"
        },
        {
            "trigger": "fuzzy_nand(a, b, ...)",
            "contents": "fuzzy_nand(${1:a}, ${2:b}, ${3:...})",
            "kind": "function"
        },
        {
            "trigger": "fuzzy_nor(a, b, ...)",
            "contents": "fuzzy_nor(${1:a}, ${2:b}, ${3:...})",
            "kind": "function"
        },
        {
            "trigger": "fuzzy_not(n)",
            "contents": "fuzzy_not(${1:n})",
            "kind": "function"
        },
        {
            "trigger": "fuzzy_nxor(a, b, ...)",
            "contents": "fuzzy_nxor(${1:a}, ${2:b}, ${3:...})",
            "kind": "function"
        },
        {
            "trigger": "fuzzy_or(a, b, ...)",
            "contents": "fuzzy_or(${1:a}, ${2:b}, ${3:...})",
            "kind": "function"
        },
        {
            "trigger": "fuzzy_xor(a, b, ...)",
            "contents": "fuzzy_xor(${1:a}, ${2:b}, ${3:...})",
            "kind": "function"
        },
        {
            "trigger": "geoself()",
            "contents": "geoself()",
            "kind": "function",
            "details": "Returns a handle to the current geometry"
        },
        {
            "trigger": "geounwrap(geometry, unwrap_attribute)",
            "contents": "geounwrap(${1:geometry}, ${2:unwrap_attribute})",
            "kind": "function",
            "details": "Returns an oppath: string to unwrap the geometry in-place"
        },
        {
            "trigger": "getattrib(geometry, attribclass, attribute_name, elemnum, success)",
            "contents": "getattrib(${1:geometry}, ${2:attribclass}, ${3:attribute_name}, ${4:elemnum}, ${5:success})",
            "kind": "function",
            "details": "Reads an attribute value from geometry, with validity check"
        },
        {
            "trigger": "getattribute(geometry, value, attribclass, attribute_name, element_number, vertex_number)",
            "contents": "getattribute(${1:geometry}, ${2:value}, ${3:attribclass}, ${4:attribute_name}, ${5:element_number}, ${6:vertex_number})",
            "kind": "function",
            "details": "Copies the value of a geometry attribute into a variable and returns a success flag"
        },
        {
            "trigger": "getbbox(geometry, min, max)",
            "contents": "getbbox(${1:geometry}, ${2:min}, ${3:max})",
            "kind": "function",
            "details": "Sets two vectors to the minimum and maximum corners of the bounding box for the geometry"
        },
        {
            "trigger": "getbbox(geometry, primgroup, min, max)",
            "contents": "getbbox(${1:geometry}, ${2:primgroup}, ${3:min}, ${4:max})",
            "kind": "function",
            "details": "Sets two vectors to the minimum and maximum corners of the bounding box for the geometry"
        },
        {
            "trigger": "getbbox(min, max)",
            "contents": "getbbox(${1:min}, ${2:max})",
            "kind": "function",
            "details": "Sets two vectors to the minimum and maximum corners of the bounding box for the geometry"
        },
        {
            "trigger": "getbbox_center(geometry)",
            "contents": "getbbox_center(${1:geometry})",
            "kind": "function",
            "details": "Returns the center of the bounding box for the geometry"
        },
        {
            "trigger": "getbbox_center(geometry, primgroup)",
            "contents": "getbbox_center(${1:geometry}, ${2:primgroup})",
            "kind": "function",
            "details": "Returns the center of the bounding box for the geometry"
        },
        {
            "trigger": "getbbox_max(geometry)",
            "contents": "getbbox_max(${1:geometry})",
            "kind": "function",
            "details": "Returns the maximum of the bounding box for the geometry"
        },
        {
            "trigger": "getbbox_max(geometry, primgroup)",
            "contents": "getbbox_max(${1:geometry}, ${2:primgroup})",
            "kind": "function",
            "details": "Returns the maximum of the bounding box for the geometry"
        },
        {
            "trigger": "getbbox_min(geometry)",
            "contents": "getbbox_min(${1:geometry})",
            "kind": "function",
            "details": "Returns the minimum of the bounding box for the geometry"
        },
        {
            "trigger": "getbbox_min(geometry, primgroup)",
            "contents": "getbbox_min(${1:geometry}, ${2:primgroup})",
            "kind": "function",
            "details": "Returns the minimum of the bounding box for the geometry"
        },
        {
            "trigger": "getbbox_size(geometry)",
            "contents": "getbbox_size(${1:geometry})",
            "kind": "function",
            "details": "Returns the size of the bounding box for the geometry"
        },
        {
            "trigger": "getbbox_size(geometry, primgroup)",
            "contents": "getbbox_size(${1:geometry}, ${2:primgroup})",
            "kind": "function",
            "details": "Returns the size of the bounding box for the geometry"
        },
        {
            "trigger": "getblurP(delta)",
            "contents": "getblurP(${1:delta})",
            "kind": "function",
            "details": "Returns the blurred point position (P) vector at a fractional time within the motion blur exposure"
        },
        {
            "trigger": "getbounces(b)",
            "contents": "getbounces(${1:b})",
            "kind": "function"
        },
        {
            "trigger": "getbounds(filename, min, max)",
            "contents": "getbounds(${1:filename}, ${2:min}, ${3:max})",
            "kind": "function",
            "details": "Returns the bounding box of the geometry specified by the filename"
        },
        {
            "trigger": "getbounds(filename, group, min, max)",
            "contents": "getbounds(${1:filename}, ${2:group}, ${3:min}, ${4:max})",
            "kind": "function",
            "details": "Returns the bounding box of the geometry specified by the filename"
        },
        {
            "trigger": "getcomp(v, index)",
            "contents": "getcomp(${1:v}, ${2:index})",
            "kind": "function",
            "details": "Extracts a single component of a vector type, matrix type, or array"
        },
        {
            "trigger": "getcomp(m, row, column)",
            "contents": "getcomp(${1:m}, ${2:row}, ${3:column})",
            "kind": "function",
            "details": "Extracts a single component of a vector type, matrix type, or array"
        },
        {
            "trigger": "getcomp(array, index)",
            "contents": "getcomp(${1:array}, ${2:index})",
            "kind": "function",
            "details": "Extracts a single component of a vector type, matrix type, or array"
        },
        {
            "trigger": "getcomp(array, i, j)",
            "contents": "getcomp(${1:array}, ${2:i}, ${3:j})",
            "kind": "function",
            "details": "Extracts a single component of a vector type, matrix type, or array"
        },
        {
            "trigger": "getcomp(array, i, j, k)",
            "contents": "getcomp(${1:array}, ${2:i}, ${3:j}, ${4:k})",
            "kind": "function",
            "details": "Extracts a single component of a vector type, matrix type, or array"
        },
        {
            "trigger": "getcomp(d, index)",
            "contents": "getcomp(${1:d}, ${2:index})",
            "kind": "function",
            "details": "Extracts a single component of a vector type, matrix type, or array"
        },
        {
            "trigger": "getcomp(d, index, defvalue)",
            "contents": "getcomp(${1:d}, ${2:index}, ${3:defvalue})",
            "kind": "function",
            "details": "Extracts a single component of a vector type, matrix type, or array"
        },
        {
            "trigger": "getcomp(value, index)",
            "contents": "getcomp(${1:value}, ${2:index})",
            "kind": "function",
            "details": "Extracts a single component of a vector type, matrix type, or array"
        },
        {
            "trigger": "getcomponents()",
            "contents": "getcomponents()",
            "kind": "function"
        },
        {
            "trigger": "getderiv(attr, attrName, isVertexAttr, s, t, du, dv, ...)",
            "contents": "getderiv(${1:attr}, ${2:attrName}, ${3:isVertexAttr}, ${4:s}, ${5:t}, ${6:du}, ${7:dv}, ${8:...})",
            "kind": "function",
            "details": "Evaluates surface derivatives of an attribute"
        },
        {
            "trigger": "getfogname()",
            "contents": "getfogname()",
            "kind": "function",
            "details": "Returns the name of the current object whose shader is being run"
        },
        {
            "trigger": "getglobalraylevel()",
            "contents": "getglobalraylevel()",
            "kind": "function",
            "details": "Returns the depth of the ray tree for computing global illumination"
        },
        {
            "trigger": "getgroupid()",
            "contents": "getgroupid()",
            "kind": "function",
            "details": "Returns group id containing current primitive"
        },
        {
            "trigger": "getlight(lid)",
            "contents": "getlight(${1:lid})",
            "kind": "function",
            "details": "Returns a light struct for the specified light identifier"
        },
        {
            "trigger": "getlightid(lightname)",
            "contents": "getlightid(${1:lightname})",
            "kind": "function",
            "details": "Returns the light id for a named light (or -1 for an invalid name)"
        },
        {
            "trigger": "getlightname()",
            "contents": "getlightname()",
            "kind": "function",
            "details": "Returns the name of the current light when called from within an illuminance loop, or converts an integer light ID into the light\u2019s name"
        },
        {
            "trigger": "getlightname(lightid)",
            "contents": "getlightname(${1:lightid})",
            "kind": "function",
            "details": "Returns the name of the current light when called from within an illuminance loop, or converts an integer light ID into the light\u2019s name"
        },
        {
            "trigger": "getlights(...)",
            "contents": "getlights(${1:...})",
            "kind": "function",
            "details": "Returns an array of light identifiers for the currently shaded surface"
        },
        {
            "trigger": "getlights(P, ...)",
            "contents": "getlights(${1:P}, ${2:...})",
            "kind": "function",
            "details": "Returns an array of light identifiers for the currently shaded surface"
        },
        {
            "trigger": "getlights(mat, P, ...)",
            "contents": "getlights(${1:mat}, ${2:P}, ${3:...})",
            "kind": "function",
            "details": "Returns an array of light identifiers for the currently shaded surface"
        },
        {
            "trigger": "getlightscope(mat, scope, categories)",
            "contents": "getlightscope(${1:mat}, ${2:scope}, ${3:categories})",
            "kind": "function",
            "details": "Returns a selection of lights that illuminate a given material"
        },
        {
            "trigger": "getlocalcurvature(s, t)",
            "contents": "getlocalcurvature(${1:s}, ${2:t})",
            "kind": "function",
            "details": "Evaluates local curvature of primitive grid, using the same curvature evaluation method as Measure SOPs"
        },
        {
            "trigger": "getmaterial()",
            "contents": "getmaterial()",
            "kind": "function",
            "details": "Returns a material struct for the current surface"
        },
        {
            "trigger": "getmaterialid()",
            "contents": "getmaterialid()",
            "kind": "function",
            "details": "Returns material id of shaded primitive"
        },
        {
            "trigger": "getobjectid()",
            "contents": "getobjectid()",
            "kind": "function",
            "details": "Returns the object id for the current shading context"
        },
        {
            "trigger": "getobjectname()",
            "contents": "getobjectname()",
            "kind": "function",
            "details": "Returns the name of the current object whose shader is being run"
        },
        {
            "trigger": "getpackedtransform(input, primnum)",
            "contents": "getpackedtransform(${1:input}, ${2:primnum})",
            "kind": "function",
            "details": "Gets the transform of a packed primitive"
        },
        {
            "trigger": "getphotonlight()",
            "contents": "getphotonlight()",
            "kind": "function",
            "details": "Returns the integer ID of the light being used for photon shading"
        },
        {
            "trigger": "getpointbbox(geometry, min, max)",
            "contents": "getpointbbox(${1:geometry}, ${2:min}, ${3:max})",
            "kind": "function",
            "details": "Sets two vectors to the minimum and maximum corners of the bounding box for the geometry"
        },
        {
            "trigger": "getpointbbox(geometry, pointgroup, min, max)",
            "contents": "getpointbbox(${1:geometry}, ${2:pointgroup}, ${3:min}, ${4:max})",
            "kind": "function",
            "details": "Sets two vectors to the minimum and maximum corners of the bounding box for the geometry"
        },
        {
            "trigger": "getpointbbox_center(geometry)",
            "contents": "getpointbbox_center(${1:geometry})",
            "kind": "function",
            "details": "Returns the center of the bounding box for the geometry"
        },
        {
            "trigger": "getpointbbox_center(geometry, pointgroup)",
            "contents": "getpointbbox_center(${1:geometry}, ${2:pointgroup})",
            "kind": "function",
            "details": "Returns the center of the bounding box for the geometry"
        },
        {
            "trigger": "getpointbbox_max(geometry)",
            "contents": "getpointbbox_max(${1:geometry})",
            "kind": "function",
            "details": "Returns the maximum of the bounding box for the geometry"
        },
        {
            "trigger": "getpointbbox_max(geometry, pointgroup)",
            "contents": "getpointbbox_max(${1:geometry}, ${2:pointgroup})",
            "kind": "function",
            "details": "Returns the maximum of the bounding box for the geometry"
        },
        {
            "trigger": "getpointbbox_min(geometry)",
            "contents": "getpointbbox_min(${1:geometry})",
            "kind": "function",
            "details": "Returns the minimum of the bounding box for the geometry"
        },
        {
            "trigger": "getpointbbox_min(geometry, pointgroup)",
            "contents": "getpointbbox_min(${1:geometry}, ${2:pointgroup})",
            "kind": "function",
            "details": "Returns the minimum of the bounding box for the geometry"
        },
        {
            "trigger": "getpointbbox_size(geometry)",
            "contents": "getpointbbox_size(${1:geometry})",
            "kind": "function",
            "details": "Returns the size of the bounding box for the geometry"
        },
        {
            "trigger": "getpointbbox_size(geometry, pointgroup)",
            "contents": "getpointbbox_size(${1:geometry}, ${2:pointgroup})",
            "kind": "function",
            "details": "Returns the size of the bounding box for the geometry"
        },
        {
            "trigger": "getprimid()",
            "contents": "getprimid()",
            "kind": "function",
            "details": "Returns the number of the current primitive"
        },
        {
            "trigger": "getptextureid()",
            "contents": "getptextureid()",
            "kind": "function",
            "details": "Returns the ptexture face id for the current primitive"
        },
        {
            "trigger": "getraylevel()",
            "contents": "getraylevel()",
            "kind": "function",
            "details": "Returns the depth of the ray tree for the current shading"
        },
        {
            "trigger": "getrayweight()",
            "contents": "getrayweight()",
            "kind": "function",
            "details": "Returns an approximation to the contribution of the ray to the final pixel color"
        },
        {
            "trigger": "getsamplestore(channel, P, value)",
            "contents": "getsamplestore(${1:channel}, ${2:P}, ${3:value})",
            "kind": "function",
            "details": "Looks up sample data in a channel, referenced by a point"
        },
        {
            "trigger": "getscope(mat, raystyle, scope, categories)",
            "contents": "getscope(${1:mat}, ${2:raystyle}, ${3:scope}, ${4:categories})",
            "kind": "function",
            "details": "Returns a selection of objects visible to rays for a given material"
        },
        {
            "trigger": "getsmoothP(smoothP, ray_origin, ...)",
            "contents": "getsmoothP(${1:smoothP}, ${2:ray_origin}, ${3:...})",
            "kind": "function",
            "details": "Returns modified surface position based on a smoothing function"
        },
        {
            "trigger": "getsmoothP(...)",
            "contents": "getsmoothP(${1:...})",
            "kind": "function",
            "details": "Returns modified surface position based on a smoothing function"
        },
        {
            "trigger": "getspace(fromspace, tospace)",
            "contents": "getspace(${1:fromspace}, ${2:tospace})",
            "kind": "function",
            "details": "Returns a transform from one space to another"
        },
        {
            "trigger": "getuvtangents(objName, P, dir, Tu, Tv)",
            "contents": "getuvtangents(${1:objName}, ${2:P}, ${3:dir}, ${4:Tu}, ${5:Tv})",
            "kind": "function",
            "details": "Evaluates UV tangents at a point on an arbitrary object"
        },
        {
            "trigger": "getuvtangents(objName, P, dir, Tu, Tv, Tn)",
            "contents": "getuvtangents(${1:objName}, ${2:P}, ${3:dir}, ${4:Tu}, ${5:Tv}, ${6:Tn})",
            "kind": "function",
            "details": "Evaluates UV tangents at a point on an arbitrary object"
        },
        {
            "trigger": "ggx(ng, nn, xg, yg, F0, F90, alphax, alphay, masking, fresblend, eta, reflect, refract, reflectmask, refractmask, dispersion, ...)",
            "contents": "ggx(${1:ng}, ${2:nn}, ${3:xg}, ${4:yg}, ${5:F0}, ${6:F90}, ${7:alphax}, ${8:alphay}, ${9:masking}, ${10:fresblend}, ${11:eta}, ${12:reflect}, ${13:refract}, ${14:reflectmask}, ${15:refractmask}, ${16:dispersion}, ${17:...})",
            "kind": "function",
            "details": "Returns a ggx BSDF"
        },
        {
            "trigger": "gradient(val, ...)",
            "contents": "gradient(${1:val}, ${2:...})",
            "kind": "function",
            "details": "Returns the gradient of a field"
        },
        {
            "trigger": "gradient(P, val, ...)",
            "contents": "gradient(${1:P}, ${2:val}, ${3:...})",
            "kind": "function",
            "details": "Returns the gradient of a field"
        },
        {
            "trigger": "gxnoise(xy)",
            "contents": "gxnoise(${1:xy})",
            "kind": "function",
            "details": "Evaluates a simplex noise field"
        },
        {
            "trigger": "gxnoise(x, y)",
            "contents": "gxnoise(${1:x}, ${2:y})",
            "kind": "function",
            "details": "Evaluates a simplex noise field"
        },
        {
            "trigger": "gxnoise(xyz)",
            "contents": "gxnoise(${1:xyz})",
            "kind": "function",
            "details": "Evaluates a simplex noise field"
        },
        {
            "trigger": "gxnoise(xyzt)",
            "contents": "gxnoise(${1:xyzt})",
            "kind": "function",
            "details": "Evaluates a simplex noise field"
        },
        {
            "trigger": "gxnoised(xy, deriv)",
            "contents": "gxnoised(${1:xy}, ${2:deriv})",
            "kind": "function",
            "details": "Evaluates a simplex noise field and its derivatives"
        },
        {
            "trigger": "gxnoised(x, y, dx, dy)",
            "contents": "gxnoised(${1:x}, ${2:y}, ${3:dx}, ${4:dy})",
            "kind": "function",
            "details": "Evaluates a simplex noise field and its derivatives"
        },
        {
            "trigger": "gxnoised(xyz, deriv)",
            "contents": "gxnoised(${1:xyz}, ${2:deriv})",
            "kind": "function",
            "details": "Evaluates a simplex noise field and its derivatives"
        },
        {
            "trigger": "gxnoised(xyzt, deriv)",
            "contents": "gxnoised(${1:xyzt}, ${2:deriv})",
            "kind": "function",
            "details": "Evaluates a simplex noise field and its derivatives"
        },
        {
            "trigger": "hair(N, tip, lobe_shift, lobe_width_lon, ...)",
            "contents": "hair(${1:N}, ${2:tip}, ${3:lobe_shift}, ${4:lobe_width_lon}, ${5:...})",
            "kind": "function",
            "details": "Returns a BSDF for shading hair"
        },
        {
            "trigger": "hair(N, tip, lobe_shift, lobe_width_lon, lobe_with_azi, ...)",
            "contents": "hair(${1:N}, ${2:tip}, ${3:lobe_shift}, ${4:lobe_width_lon}, ${5:lobe_with_azi}, ${6:...})",
            "kind": "function",
            "details": "Returns a BSDF for shading hair"
        },
        {
            "trigger": "hair(N, tip, lobe_shift, lobe_width_lon, lobe_with_azi, glint_shift, glint_intensity, ...)",
            "contents": "hair(${1:N}, ${2:tip}, ${3:lobe_shift}, ${4:lobe_width_lon}, ${5:lobe_with_azi}, ${6:glint_shift}, ${7:glint_intensity}, ${8:...})",
            "kind": "function",
            "details": "Returns a BSDF for shading hair"
        },
        {
            "trigger": "hasattrib(geometry, attribclass, attribute_name)",
            "contents": "hasattrib(${1:geometry}, ${2:attribclass}, ${3:attribute_name})",
            "kind": "function",
            "details": "Checks whether a geometry attribute exists"
        },
        {
            "trigger": "hasdetailattrib(geometry, attribute_name)",
            "contents": "hasdetailattrib(${1:geometry}, ${2:attribute_name})",
            "kind": "function",
            "details": "Returns if a geometry detail attribute exists"
        },
        {
            "trigger": "haslight(mat, P, light, ...)",
            "contents": "haslight(${1:mat}, ${2:P}, ${3:light}, ${4:...})",
            "kind": "function",
            "details": "Returns whether a light illuminates the given material"
        },
        {
            "trigger": "hasmetadata(opinput, name)",
            "contents": "hasmetadata(${1:opinput}, ${2:name})",
            "kind": "function",
            "details": "Queries if metadata exists on a composite operator"
        },
        {
            "trigger": "hasplane(planename)",
            "contents": "hasplane(${1:planename})",
            "kind": "function",
            "details": "Returns 1 if the plane specified by the parameter exists in this COP"
        },
        {
            "trigger": "haspointattrib(geometry, attribute_name)",
            "contents": "haspointattrib(${1:geometry}, ${2:attribute_name})",
            "kind": "function",
            "details": "Returns if a geometry point attribute exists"
        },
        {
            "trigger": "hasprimattrib(geometry, attribute_name)",
            "contents": "hasprimattrib(${1:geometry}, ${2:attribute_name})",
            "kind": "function",
            "details": "Returns if a geometry prim attribute exists"
        },
        {
            "trigger": "hasvertexattrib(geometry, attribute_name)",
            "contents": "hasvertexattrib(${1:geometry}, ${2:attribute_name})",
            "kind": "function",
            "details": "Returns if a geometry vertex attribute exists"
        },
        {
            "trigger": "has_udim(path)",
            "contents": "has_udim(${1:path})",
            "kind": "function",
            "details": "Test string for UDIM or UVTILE patterns"
        },
        {
            "trigger": "hedge_dstpoint(geometry, hedge)",
            "contents": "hedge_dstpoint(${1:geometry}, ${2:hedge})",
            "kind": "function",
            "details": "Returns the destination point of a half-edge"
        },
        {
            "trigger": "hedge_dstvertex(geometry, hedge)",
            "contents": "hedge_dstvertex(${1:geometry}, ${2:hedge})",
            "kind": "function",
            "details": "Returns the destination vertex of a half-edge"
        },
        {
            "trigger": "hedge_equivcount(geometry, hedge)",
            "contents": "hedge_equivcount(${1:geometry}, ${2:hedge})",
            "kind": "function",
            "details": "Returns the number of half-edges equivalent to a given half-edge"
        },
        {
            "trigger": "hedge_isequiv(geometry, hedge1, hedge2)",
            "contents": "hedge_isequiv(${1:geometry}, ${2:hedge1}, ${3:hedge2})",
            "kind": "function",
            "details": "Determines whether a two half-edges are equivalent (represent the same edge)"
        },
        {
            "trigger": "hedge_isprimary(geometry, hedge)",
            "contents": "hedge_isprimary(${1:geometry}, ${2:hedge})",
            "kind": "function",
            "details": "Determines whether a half-edge number corresponds to a primary half-edge"
        },
        {
            "trigger": "hedge_isprimary(opinput, hendge)",
            "contents": "hedge_isprimary(${1:opinput}, ${2:hendge})",
            "kind": "function",
            "details": "Determines whether a half-edge number corresponds to a primary half-edge"
        },
        {
            "trigger": "hedge_isvalid(geometry, hedge)",
            "contents": "hedge_isvalid(${1:geometry}, ${2:hedge})",
            "kind": "function",
            "details": "Determines whether a half-edge number corresponds to a valid half-edge"
        },
        {
            "trigger": "hedge_next(geometry, hedge)",
            "contents": "hedge_next(${1:geometry}, ${2:hedge})",
            "kind": "function",
            "details": "Returns the half-edge that follows a given half-edge in its polygon"
        },
        {
            "trigger": "hedge_nextequiv(geometry, hedge)",
            "contents": "hedge_nextequiv(${1:geometry}, ${2:hedge})",
            "kind": "function",
            "details": "Returns the next half-edges equivalent to a given half-edge"
        },
        {
            "trigger": "hedge_postdstpoint(geometry, hedge)",
            "contents": "hedge_postdstpoint(${1:geometry}, ${2:hedge})",
            "kind": "function",
            "details": "Returns the point into which the vertex following the destination vertex of a half-edge in its primitive is wired"
        },
        {
            "trigger": "hedge_postdstvertex(geometry, hedge)",
            "contents": "hedge_postdstvertex(${1:geometry}, ${2:hedge})",
            "kind": "function",
            "details": "Returns the vertex following the destination vertex of a half-edge in its primitive"
        },
        {
            "trigger": "hedge_presrcpoint(geometry, hedge)",
            "contents": "hedge_presrcpoint(${1:geometry}, ${2:hedge})",
            "kind": "function",
            "details": "Returns the point into which the vertex that precedes the source vertex of a half-edge in its primitive is wired"
        },
        {
            "trigger": "hedge_presrcvertex(geometry, hedge)",
            "contents": "hedge_presrcvertex(${1:geometry}, ${2:hedge})",
            "kind": "function",
            "details": "Returns the vertex that precedes the source vertex of a half-edge in its primitive"
        },
        {
            "trigger": "hedge_prev(geometry, hedge)",
            "contents": "hedge_prev(${1:geometry}, ${2:hedge})",
            "kind": "function",
            "details": "Returns the half-edge that precedes a given half-edge in its polygon"
        },
        {
            "trigger": "hedge_prim(geometry, hedge)",
            "contents": "hedge_prim(${1:geometry}, ${2:hedge})",
            "kind": "function",
            "details": "Returns the primitive that contains a half-edge"
        },
        {
            "trigger": "hedge_primary(geometry, hedge)",
            "contents": "hedge_primary(${1:geometry}, ${2:hedge})",
            "kind": "function",
            "details": "Returns the primary half-edge equivalent to a given half-edge"
        },
        {
            "trigger": "hedge_srcpoint(geometry, hedge)",
            "contents": "hedge_srcpoint(${1:geometry}, ${2:hedge})",
            "kind": "function",
            "details": "Returns the source point of a half-edge"
        },
        {
            "trigger": "hedge_srcvertex(geometry, hedge)",
            "contents": "hedge_srcvertex(${1:geometry}, ${2:hedge})",
            "kind": "function",
            "details": "Returns the source vertex of a half-edge"
        },
        {
            "trigger": "henyeygreenstein(anisotropic_bias, ...)",
            "contents": "henyeygreenstein(${1:anisotropic_bias}, ${2:...})",
            "kind": "function",
            "details": "Returns an anisotropic volumetric BSDF, which can scatter light forward or backward"
        },
        {
            "trigger": "hex_adjacent(geometry, primindex, faceno)",
            "contents": "hex_adjacent(${1:geometry}, ${2:primindex}, ${3:faceno})",
            "kind": "function",
            "details": "Returns primitive number of an adjacent hexahedron"
        },
        {
            "trigger": "hex_faceindex(faceno, vtxno)",
            "contents": "hex_faceindex(${1:faceno}, ${2:vtxno})",
            "kind": "function",
            "details": "Returns vertex indices of each face of a hexahedron"
        },
        {
            "trigger": "hscript_noise(pos)",
            "contents": "hscript_noise(${1:pos})",
            "kind": "function",
            "details": "Generates noise matching the output of the Hscript noise() expression function"
        },
        {
            "trigger": "hscript_rand(seed)",
            "contents": "hscript_rand(${1:seed})",
            "kind": "function",
            "details": "Produces the exact same results as the Houdini expression function of the same name"
        },
        {
            "trigger": "hscript_snoise(pos)",
            "contents": "hscript_snoise(${1:pos})",
            "kind": "function"
        },
        {
            "trigger": "hscript_sturb(pos, turbulence)",
            "contents": "hscript_sturb(${1:pos}, ${2:turbulence})",
            "kind": "function"
        },
        {
            "trigger": "hscript_turb(pos, depth)",
            "contents": "hscript_turb(${1:pos}, ${2:depth})",
            "kind": "function",
            "details": "Generates turbulence matching the output of the HScript turb() expression function"
        },
        {
            "trigger": "hsvtorgb(hsv)",
            "contents": "hsvtorgb(${1:hsv})",
            "kind": "function",
            "details": "Convert HSV color space into RGB color space"
        },
        {
            "trigger": "hsvtorgb(hue, sat, val)",
            "contents": "hsvtorgb(${1:hue}, ${2:sat}, ${3:val})",
            "kind": "function",
            "details": "Convert HSV color space into RGB color space"
        },
        {
            "trigger": "iaspect(opinput)",
            "contents": "iaspect(${1:opinput})",
            "kind": "function",
            "details": "Returns the aspect ratio of the specified input"
        },
        {
            "trigger": "ichname(inputnum, plane_index, component_index)",
            "contents": "ichname(${1:inputnum}, ${2:plane_index}, ${3:component_index})",
            "kind": "function",
            "details": "Returns the channel name of the indexed plane of the given input"
        },
        {
            "trigger": "ident()",
            "contents": "ident()",
            "kind": "function",
            "details": "Returns an identity matrix"
        },
        {
            "trigger": "idtopoint(geometry, id)",
            "contents": "idtopoint(${1:geometry}, ${2:id})",
            "kind": "function",
            "details": "Finds a point by its id attribute"
        },
        {
            "trigger": "idtoprim(geometry, id)",
            "contents": "idtoprim(${1:geometry}, ${2:id})",
            "kind": "function",
            "details": "Finds a primitive by its id attribute"
        },
        {
            "trigger": "iend(opinput)",
            "contents": "iend(${1:opinput})",
            "kind": "function",
            "details": "Returns the last frame of the specified input"
        },
        {
            "trigger": "iendtime(opinput)",
            "contents": "iendtime(${1:opinput})",
            "kind": "function",
            "details": "Returns the end time of the specified input"
        },
        {
            "trigger": "ihasplane(opinput, planename)",
            "contents": "ihasplane(${1:opinput}, ${2:planename})",
            "kind": "function",
            "details": "Returns 1 if the specified input has a plane named planename"
        },
        {
            "trigger": "importance_remap(map, uv, ...)",
            "contents": "importance_remap(${1:map}, ${2:uv}, ${3:...})",
            "kind": "function",
            "details": "Remaps a texture coordinate to another coordinate in the map to optimize sampling of brighter areas"
        },
        {
            "trigger": "inedgegroup(filename, groupname, pointnum0, pointnum1)",
            "contents": "inedgegroup(${1:filename}, ${2:groupname}, ${3:pointnum0}, ${4:pointnum1})",
            "kind": "function",
            "details": "Returns 1 if the edge specified by the point pair is in the group specified by the string"
        },
        {
            "trigger": "inedgegroup(input, groupname, pointnum0, pointnum1)",
            "contents": "inedgegroup(${1:input}, ${2:groupname}, ${3:pointnum0}, ${4:pointnum1})",
            "kind": "function",
            "details": "Returns 1 if the edge specified by the point pair is in the group specified by the string"
        },
        {
            "trigger": "inpointgroup(geometry, groupname, pointnum)",
            "contents": "inpointgroup(${1:geometry}, ${2:groupname}, ${3:pointnum})",
            "kind": "function",
            "details": "Returns 1 if the point specified by the point number is in the group specified by the string"
        },
        {
            "trigger": "inprimgroup(geometry, groupname, primnum)",
            "contents": "inprimgroup(${1:geometry}, ${2:groupname}, ${3:primnum})",
            "kind": "function",
            "details": "Returns 1 if the primitive specified by the primitive number is in the group specified by the string"
        },
        {
            "trigger": "insert(str, index, value)",
            "contents": "insert(${1:str}, ${2:index}, ${3:value})",
            "kind": "function",
            "details": "Inserts an item, array, or string into an array or string"
        },
        {
            "trigger": "insert(array, index, value)",
            "contents": "insert(${1:array}, ${2:index}, ${3:value})",
            "kind": "function",
            "details": "Inserts an item, array, or string into an array or string"
        },
        {
            "trigger": "insert(array, index, values)",
            "contents": "insert(${1:array}, ${2:index}, ${3:values})",
            "kind": "function",
            "details": "Inserts an item, array, or string into an array or string"
        },
        {
            "trigger": "insert(dstdict, dstkey, srcdict, srckey)",
            "contents": "insert(${1:dstdict}, ${2:dstkey}, ${3:srcdict}, ${4:srckey})",
            "kind": "function",
            "details": "Inserts an item, array, or string into an array or string"
        },
        {
            "trigger": "insert(dstdict, srcdict)",
            "contents": "insert(${1:dstdict}, ${2:srcdict})",
            "kind": "function",
            "details": "Inserts an item, array, or string into an array or string"
        },
        {
            "trigger": "instance(P, N)",
            "contents": "instance(${1:P}, ${2:N})",
            "kind": "function",
            "details": "Creates an instance transform matrix"
        },
        {
            "trigger": "instance(P, N, scale)",
            "contents": "instance(${1:P}, ${2:N}, ${3:scale})",
            "kind": "function",
            "details": "Creates an instance transform matrix"
        },
        {
            "trigger": "instance(P, N, scale, pivot)",
            "contents": "instance(${1:P}, ${2:N}, ${3:scale}, ${4:pivot})",
            "kind": "function",
            "details": "Creates an instance transform matrix"
        },
        {
            "trigger": "instance(P, N, scale, rotate, up)",
            "contents": "instance(${1:P}, ${2:N}, ${3:scale}, ${4:rotate}, ${5:up})",
            "kind": "function",
            "details": "Creates an instance transform matrix"
        },
        {
            "trigger": "instance(P, N, scale, rotate, up, pivot)",
            "contents": "instance(${1:P}, ${2:N}, ${3:scale}, ${4:rotate}, ${5:up}, ${6:pivot})",
            "kind": "function",
            "details": "Creates an instance transform matrix"
        },
        {
            "trigger": "instance(P, N, scale, rotate, orient)",
            "contents": "instance(${1:P}, ${2:N}, ${3:scale}, ${4:rotate}, ${5:orient})",
            "kind": "function",
            "details": "Creates an instance transform matrix"
        },
        {
            "trigger": "instance(P, N, scale, rotate, orient, pivot)",
            "contents": "instance(${1:P}, ${2:N}, ${3:scale}, ${4:rotate}, ${5:orient}, ${6:pivot})",
            "kind": "function",
            "details": "Creates an instance transform matrix"
        },
        {
            "trigger": "integratehoseksky(solar_altitude, solar_azimuth, turbidity, ground_albedo, number_of_samples)",
            "contents": "integratehoseksky(${1:solar_altitude}, ${2:solar_azimuth}, ${3:turbidity}, ${4:ground_albedo}, ${5:number_of_samples})",
            "kind": "function",
            "details": "Computes irradiance from the given Hosek Sky on a horizontal surface"
        },
        {
            "trigger": "interpolate(val, sx, sy)",
            "contents": "interpolate(${1:val}, ${2:sx}, ${3:sy})",
            "kind": "function",
            "details": "Interpolates a value across the currently shaded micropolygon"
        },
        {
            "trigger": "intersect(geometry, orig, dir, p, u, v)",
            "contents": "intersect(${1:geometry}, ${2:orig}, ${3:dir}, ${4:p}, ${5:u}, ${6:v})",
            "kind": "function",
            "details": "This function computes the first intersection of a ray with geometry"
        },
        {
            "trigger": "intersect(geometry, orig, dir, p, u, v, ...)",
            "contents": "intersect(${1:geometry}, ${2:orig}, ${3:dir}, ${4:p}, ${5:u}, ${6:v}, ${7:...})",
            "kind": "function",
            "details": "This function computes the first intersection of a ray with geometry"
        },
        {
            "trigger": "intersect(geometry, orig, dir, p, uvw)",
            "contents": "intersect(${1:geometry}, ${2:orig}, ${3:dir}, ${4:p}, ${5:uvw})",
            "kind": "function",
            "details": "This function computes the first intersection of a ray with geometry"
        },
        {
            "trigger": "intersect(geometry, group, orig, dir, p, uvw)",
            "contents": "intersect(${1:geometry}, ${2:group}, ${3:orig}, ${4:dir}, ${5:p}, ${6:uvw})",
            "kind": "function",
            "details": "This function computes the first intersection of a ray with geometry"
        },
        {
            "trigger": "intersect_all(geometry, group, orig, dir, pos, prim, uvw, tol, ttol)",
            "contents": "intersect_all(${1:geometry}, ${2:group}, ${3:orig}, ${4:dir}, ${5:pos}, ${6:prim}, ${7:uvw}, ${8:tol}, ${9:ttol})",
            "kind": "function",
            "details": "Computes all intersections of the specified ray with geometry"
        },
        {
            "trigger": "intersect_lights(lightids, pos, dir, time, idx, dist, clr, scale, ...)",
            "contents": "intersect_lights(${1:lightids}, ${2:pos}, ${3:dir}, ${4:time}, ${5:idx}, ${6:dist}, ${7:clr}, ${8:scale}, ${9:...})",
            "kind": "function",
            "details": "Finds the nearest intersection of a ray with any of a list of (area) lights and runs the light shader at the intersection point"
        },
        {
            "trigger": "inumplanes(opinput)",
            "contents": "inumplanes(${1:opinput})",
            "kind": "function",
            "details": "Returns the number of planes in the given input"
        },
        {
            "trigger": "invert(m)",
            "contents": "invert(${1:m})",
            "kind": "function",
            "details": "Inverts a matrix"
        },
        {
            "trigger": "invertexgroup(filename, groupname, vertexnum)",
            "contents": "invertexgroup(${1:filename}, ${2:groupname}, ${3:vertexnum})",
            "kind": "function",
            "details": "Returns 1 if the vertex specified by the vertex number is in the group specified by the string"
        },
        {
            "trigger": "invertexgroup(opinput, groupname, vertexnum)",
            "contents": "invertexgroup(${1:opinput}, ${2:groupname}, ${3:vertexnum})",
            "kind": "function",
            "details": "Returns 1 if the vertex specified by the vertex number is in the group specified by the string"
        },
        {
            "trigger": "invlerp(a, min, max)",
            "contents": "invlerp(${1:a}, ${2:min}, ${3:max})",
            "kind": "function",
            "details": "Inverses a linear interpolation between the values"
        },
        {
            "trigger": "iplaneindex(opinput, planename)",
            "contents": "iplaneindex(${1:opinput}, ${2:planename})",
            "kind": "function",
            "details": "Returns the index of the plane named 'planename' in the specified input"
        },
        {
            "trigger": "iplanename(opinput, planeindex)",
            "contents": "iplanename(${1:opinput}, ${2:planeindex})",
            "kind": "function",
            "details": "Returns the name of the plane specified by the planeindex of the given input"
        },
        {
            "trigger": "iplanesize(opinput, planeindex)",
            "contents": "iplanesize(${1:opinput}, ${2:planeindex})",
            "kind": "function",
            "details": "Returns the number of components in the plane named planename in the specified input"
        },
        {
            "trigger": "irate(opinput)",
            "contents": "irate(${1:opinput})",
            "kind": "function",
            "details": "Returns the frame rate of the specified input"
        },
        {
            "trigger": "irradiance(P, N, ...)",
            "contents": "irradiance(${1:P}, ${2:N}, ${3:...})",
            "kind": "function",
            "details": "Computes irradiance (global illumination) at the point P with the normal N"
        },
        {
            "trigger": "isalpha(str)",
            "contents": "isalpha(${1:str})",
            "kind": "function",
            "details": "Returns 1 if all the characters in the string are alphabetic"
        },
        {
            "trigger": "isbound(variable_name)",
            "contents": "isbound(${1:variable_name})",
            "kind": "function",
            "details": "Parameters in VEX can be overridden by geometry attributes (if the attributes exist on the surface being rendered)"
        },
        {
            "trigger": "isconnected(opinput)",
            "contents": "isconnected(${1:opinput})",
            "kind": "function",
            "details": "Returns 1 if input_number is connected, or 0 if the input is not connected"
        },
        {
            "trigger": "isdigit(str)",
            "contents": "isdigit(${1:str})",
            "kind": "function",
            "details": "Returns 1 if all the characters in the string are numeric"
        },
        {
            "trigger": "isfinite(x)",
            "contents": "isfinite(${1:x})",
            "kind": "function",
            "details": "Checks whether a value is a normal finite number"
        },
        {
            "trigger": "isfogray()",
            "contents": "isfogray()",
            "kind": "function",
            "details": "Returns 1 if the shader is being called to evaluate illumination for fog objects, or 0 if the light or shadow shader is being called to evaluate surface illumination"
        },
        {
            "trigger": "isframes()",
            "contents": "isframes()",
            "kind": "function",
            "details": "Returns 1 if the Vex CHOP\u2019s Unit Menu is currently set to 'frames', 0 otherwise"
        },
        {
            "trigger": "islpeactive()",
            "contents": "islpeactive()",
            "kind": "function",
            "details": "Returns 1 if Light Path Expressions are enabled. 0 Otherwise"
        },
        {
            "trigger": "isnan(x)",
            "contents": "isnan(${1:x})",
            "kind": "function",
            "details": "Checks whether a value is not a number"
        },
        {
            "trigger": "isotropic(...)",
            "contents": "isotropic(${1:...})",
            "kind": "function",
            "details": "Returns an isotropic BSDF, which scatters light equally in all directions"
        },
        {
            "trigger": "israytracing()",
            "contents": "israytracing()",
            "kind": "function",
            "details": "Indicates whether a shader is being executed for ray tracing"
        },
        {
            "trigger": "issamples()",
            "contents": "issamples()",
            "kind": "function",
            "details": "Returns 1 if the Vex CHOP\u2019s Unit Menu is currently set to 'samples', 0 otherwise"
        },
        {
            "trigger": "isseconds()",
            "contents": "isseconds()",
            "kind": "function",
            "details": "Returns 1 if the Vex CHOP\u2019s Unit Menu is currently set to 'seconds', 0 otherwise"
        },
        {
            "trigger": "isshadingRHS()",
            "contents": "isshadingRHS()",
            "kind": "function",
            "details": "Detects the orientation of default shading space"
        },
        {
            "trigger": "isshadowray()",
            "contents": "isshadowray()",
            "kind": "function",
            "details": "Returns 1 if the shader is being called to evaluate opacity for shadow rays, or 0 if the shader is being called to evaluate for surface color"
        },
        {
            "trigger": "istart(opinput)",
            "contents": "istart(${1:opinput})",
            "kind": "function",
            "details": "Returns the starting frame of the specified input"
        },
        {
            "trigger": "istarttime(opinput)",
            "contents": "istarttime(${1:opinput})",
            "kind": "function",
            "details": "Returns the start time of the specified input"
        },
        {
            "trigger": "isuvrendering()",
            "contents": "isuvrendering()",
            "kind": "function",
            "details": "Indicates whether the shader is being evaluated while doing UV rendering (e.g. texture unwrapping)"
        },
        {
            "trigger": "isvalidindex(array, index)",
            "contents": "isvalidindex(${1:array}, ${2:index})",
            "kind": "function",
            "details": "Checks if the index given is valid for the array or string given"
        },
        {
            "trigger": "isvalidindex(str, index)",
            "contents": "isvalidindex(${1:str}, ${2:index})",
            "kind": "function",
            "details": "Checks if the index given is valid for the array or string given"
        },
        {
            "trigger": "isvalidindex(d, key)",
            "contents": "isvalidindex(${1:d}, ${2:key})",
            "kind": "function",
            "details": "Checks if the index given is valid for the array or string given"
        },
        {
            "trigger": "isvarying(x)",
            "contents": "isvarying(${1:x})",
            "kind": "function",
            "details": "Check whether a VEX variable is varying or uniform"
        },
        {
            "trigger": "itoa(number)",
            "contents": "itoa(${1:number})",
            "kind": "function",
            "details": "Converts an integer to a string"
        },
        {
            "trigger": "ixres(opinput)",
            "contents": "ixres(${1:opinput})",
            "kind": "function",
            "details": "Returns the X resolution of the specified input"
        },
        {
            "trigger": "iyres(opinput)",
            "contents": "iyres(${1:opinput})",
            "kind": "function",
            "details": "Returns the Y resolution of the specified input"
        },
        {
            "trigger": "join(s, spacer)",
            "contents": "join(${1:s}, ${2:spacer})",
            "kind": "function",
            "details": "Concatenate all the strings of an array inserting a common spacer"
        },
        {
            "trigger": "json_dumps(d, flags)",
            "contents": "json_dumps(${1:d}, ${2:flags})",
            "kind": "function",
            "details": "Converts a VEX dictionary into a JSON string"
        },
        {
            "trigger": "json_loads(json, flags)",
            "contents": "json_loads(${1:json}, ${2:flags})",
            "kind": "function",
            "details": "Converts a JSON string into a VEX dictionary"
        },
        {
            "trigger": "keys(d)",
            "contents": "keys(${1:d})",
            "kind": "function",
            "details": "Returns all the keys in a dictionary"
        },
        {
            "trigger": "kspline(basis, sample_pos, value1, key_pos1, ...)",
            "contents": "kspline(${1:basis}, ${2:sample_pos}, ${3:value1}, ${4:key_pos1}, ${5:...})",
            "kind": "function",
            "details": "Returns an interpolated value along a curve defined by a basis and key/position pairs"
        },
        {
            "trigger": "len(v)",
            "contents": "len(${1:v})",
            "kind": "function",
            "details": "Returns the length of an array"
        },
        {
            "trigger": "len(m)",
            "contents": "len(${1:m})",
            "kind": "function",
            "details": "Returns the length of an array"
        },
        {
            "trigger": "len(array)",
            "contents": "len(${1:array})",
            "kind": "function",
            "details": "Returns the length of an array"
        },
        {
            "trigger": "len(s)",
            "contents": "len(${1:s})",
            "kind": "function",
            "details": "Returns the length of an array"
        },
        {
            "trigger": "len(d)",
            "contents": "len(${1:d})",
            "kind": "function",
            "details": "Returns the length of an array"
        },
        {
            "trigger": "length(f)",
            "contents": "length(${1:f})",
            "kind": "function",
            "details": "Returns the magnitude of a vector"
        },
        {
            "trigger": "length(v)",
            "contents": "length(${1:v})",
            "kind": "function",
            "details": "Returns the magnitude of a vector"
        },
        {
            "trigger": "length2(v)",
            "contents": "length2(${1:v})",
            "kind": "function",
            "details": "Returns the squared distance of the vector or vector4"
        },
        {
            "trigger": "lerp(value1, value2, amount)",
            "contents": "lerp(${1:value1}, ${2:value2}, ${3:amount})",
            "kind": "function",
            "details": "Performs linear interpolation between the values"
        },
        {
            "trigger": "lerp(bsdf1, bsdf2, amount)",
            "contents": "lerp(${1:bsdf1}, ${2:bsdf2}, ${3:amount})",
            "kind": "function",
            "details": "Performs linear interpolation between the values"
        },
        {
            "trigger": "lightbounces(lp)",
            "contents": "lightbounces(${1:lp})",
            "kind": "function",
            "details": "Returns the bounce mask for a light struct"
        },
        {
            "trigger": "lightid(lp)",
            "contents": "lightid(${1:lp})",
            "kind": "function",
            "details": "Returns the light id for a light struct"
        },
        {
            "trigger": "lightstate(query, value)",
            "contents": "lightstate(${1:query}, ${2:value})",
            "kind": "function",
            "details": "Queries the renderer for a named property"
        },
        {
            "trigger": "limit_sample_space(minu, maxu, u)",
            "contents": "limit_sample_space(${1:minu}, ${2:maxu}, ${3:u})",
            "kind": "function",
            "details": "Limits a unit value in a way that maintains uniformity and in-range consistency"
        },
        {
            "trigger": "limit_sample_space(maxu, u)",
            "contents": "limit_sample_space(${1:maxu}, ${2:u})",
            "kind": "function",
            "details": "Limits a unit value in a way that maintains uniformity and in-range consistency"
        },
        {
            "trigger": "limport(name, value)",
            "contents": "limport(${1:name}, ${2:value})",
            "kind": "function",
            "details": "Imports a variable from the light shader for the surface"
        },
        {
            "trigger": "lkspline(sample_pos, value1, key_pos1, ...)",
            "contents": "lkspline(${1:sample_pos}, ${2:value1}, ${3:key_pos1}, ${4:...})",
            "kind": "function",
            "details": "Samples a polyline between the key points"
        },
        {
            "trigger": "log(n)",
            "contents": "log(${1:n})",
            "kind": "function",
            "details": "Returns the natural logarithm of the argument"
        },
        {
            "trigger": "log(v)",
            "contents": "log(${1:v})",
            "kind": "function",
            "details": "Returns the natural logarithm of the argument"
        },
        {
            "trigger": "log10(n)",
            "contents": "log10(${1:n})",
            "kind": "function",
            "details": "Returns the logarithm (base 10) of the argument"
        },
        {
            "trigger": "lookat(from, to)",
            "contents": "lookat(${1:from}, ${2:to})",
            "kind": "function",
            "details": "Computes a rotation matrix or angles to orient the negative z-axis along the vector (to-from) under the transformation"
        },
        {
            "trigger": "lookat(from, to, roll)",
            "contents": "lookat(${1:from}, ${2:to}, ${3:roll})",
            "kind": "function",
            "details": "Computes a rotation matrix or angles to orient the negative z-axis along the vector (to-from) under the transformation"
        },
        {
            "trigger": "lookat(from, to, up)",
            "contents": "lookat(${1:from}, ${2:to}, ${3:up})",
            "kind": "function",
            "details": "Computes a rotation matrix or angles to orient the negative z-axis along the vector (to-from) under the transformation"
        },
        {
            "trigger": "lookat(from, to, roll, xyz)",
            "contents": "lookat(${1:from}, ${2:to}, ${3:roll}, ${4:xyz})",
            "kind": "function",
            "details": "Computes a rotation matrix or angles to orient the negative z-axis along the vector (to-from) under the transformation"
        },
        {
            "trigger": "lookat(from, to, up, xyz)",
            "contents": "lookat(${1:from}, ${2:to}, ${3:up}, ${4:xyz})",
            "kind": "function",
            "details": "Computes a rotation matrix or angles to orient the negative z-axis along the vector (to-from) under the transformation"
        },
        {
            "trigger": "lspline(sample_pos, value1, ...)",
            "contents": "lspline(${1:sample_pos}, ${2:value1}, ${3:...})",
            "kind": "function",
            "details": "Samples a polyline defined by linearly spaced values"
        },
        {
            "trigger": "lstrip(value)",
            "contents": "lstrip(${1:value})",
            "kind": "function",
            "details": "Strips leading whitespace from a string"
        },
        {
            "trigger": "lstrip(value, whitespace)",
            "contents": "lstrip(${1:value}, ${2:whitespace})",
            "kind": "function",
            "details": "Strips leading whitespace from a string"
        },
        {
            "trigger": "luminance(rgb)",
            "contents": "luminance(${1:rgb})",
            "kind": "function",
            "details": "Compute the luminance of the RGB color specified by the parameters"
        },
        {
            "trigger": "luminance(r, g, b)",
            "contents": "luminance(${1:r}, ${2:g}, ${3:b})",
            "kind": "function",
            "details": "Compute the luminance of the RGB color specified by the parameters"
        },
        {
            "trigger": "lumname()",
            "contents": "lumname()",
            "kind": "function",
            "details": "Returns the default name of the luminaence plane (as it appears in the compositor preferences)"
        },
        {
            "trigger": "makebasis(xaxis, yaxis, zaxis)",
            "contents": "makebasis(${1:xaxis}, ${2:yaxis}, ${3:zaxis})",
            "kind": "function",
            "details": "Creates an orthonormal basis given a z-axis vector"
        },
        {
            "trigger": "makebasis(xaxis, yaxis, zaxis, u)",
            "contents": "makebasis(${1:xaxis}, ${2:yaxis}, ${3:zaxis}, ${4:u})",
            "kind": "function",
            "details": "Creates an orthonormal basis given a z-axis vector"
        },
        {
            "trigger": "maketransform(zaxis, yaxis)",
            "contents": "maketransform(${1:zaxis}, ${2:yaxis})",
            "kind": "function",
            "details": "Builds a 3\u00d73 or 4\u00d74 transform matrix"
        },
        {
            "trigger": "maketransform(xyz, angles)",
            "contents": "maketransform(${1:xyz}, ${2:angles})",
            "kind": "function",
            "details": "Builds a 3\u00d73 or 4\u00d74 transform matrix"
        },
        {
            "trigger": "maketransform(zaxis, yaxis, translate)",
            "contents": "maketransform(${1:zaxis}, ${2:yaxis}, ${3:translate})",
            "kind": "function",
            "details": "Builds a 3\u00d73 or 4\u00d74 transform matrix"
        },
        {
            "trigger": "maketransform(trs, xyz, t, r)",
            "contents": "maketransform(${1:trs}, ${2:xyz}, ${3:t}, ${4:r})",
            "kind": "function",
            "details": "Builds a 3\u00d73 or 4\u00d74 transform matrix"
        },
        {
            "trigger": "maketransform(trs, xyz, t, r, s)",
            "contents": "maketransform(${1:trs}, ${2:xyz}, ${3:t}, ${4:r}, ${5:s})",
            "kind": "function",
            "details": "Builds a 3\u00d73 or 4\u00d74 transform matrix"
        },
        {
            "trigger": "maketransform(trs, xyz, t, r, s, p)",
            "contents": "maketransform(${1:trs}, ${2:xyz}, ${3:t}, ${4:r}, ${5:s}, ${6:p})",
            "kind": "function",
            "details": "Builds a 3\u00d73 or 4\u00d74 transform matrix"
        },
        {
            "trigger": "maketransform(trs, xyz, t, r, s, p, pr)",
            "contents": "maketransform(${1:trs}, ${2:xyz}, ${3:t}, ${4:r}, ${5:s}, ${6:p}, ${7:pr})",
            "kind": "function",
            "details": "Builds a 3\u00d73 or 4\u00d74 transform matrix"
        },
        {
            "trigger": "maketransform(trs, xyz, t, r, s, p, pr, shears)",
            "contents": "maketransform(${1:trs}, ${2:xyz}, ${3:t}, ${4:r}, ${5:s}, ${6:p}, ${7:pr}, ${8:shears})",
            "kind": "function",
            "details": "Builds a 3\u00d73 or 4\u00d74 transform matrix"
        },
        {
            "trigger": "makevalidvarname(name)",
            "contents": "makevalidvarname(${1:name})",
            "kind": "function",
            "details": "Forces a string to conform to the rules for variable names"
        },
        {
            "trigger": "makevalidvarname(name, safe_chars)",
            "contents": "makevalidvarname(${1:name}, ${2:safe_chars})",
            "kind": "function",
            "details": "Forces a string to conform to the rules for variable names"
        },
        {
            "trigger": "maskname()",
            "contents": "maskname()",
            "kind": "function",
            "details": "Returns the default name of the mask plane (as it appears in the compositor preferences)"
        },
        {
            "trigger": "mask_bsdf(b, mask)",
            "contents": "mask_bsdf(${1:b}, ${2:mask})",
            "kind": "function",
            "details": "Returns new BSDF that only includes the components specified by the mask"
        },
        {
            "trigger": "match(pattern, subject)",
            "contents": "match(${1:pattern}, ${2:subject})",
            "kind": "function",
            "details": "This function returns 1 if the subject matches the pattern specified, or 0 if the subject doesn\u2019t match"
        },
        {
            "trigger": "matchvex_blinn(exponent, ...)",
            "contents": "matchvex_blinn(${1:exponent}, ${2:...})",
            "kind": "function",
            "details": "Returns a BSDF that matches the output of the traditional VEX blinn function"
        },
        {
            "trigger": "matchvex_blinn(nml, exponent, ...)",
            "contents": "matchvex_blinn(${1:nml}, ${2:exponent}, ${3:...})",
            "kind": "function",
            "details": "Returns a BSDF that matches the output of the traditional VEX blinn function"
        },
        {
            "trigger": "matchvex_specular(exponent, ...)",
            "contents": "matchvex_specular(${1:exponent}, ${2:...})",
            "kind": "function",
            "details": "Returns a BSDF that matches the output of the traditional VEX specular function"
        },
        {
            "trigger": "matchvex_specular(nml, exponent, ...)",
            "contents": "matchvex_specular(${1:nml}, ${2:exponent}, ${3:...})",
            "kind": "function",
            "details": "Returns a BSDF that matches the output of the traditional VEX specular function"
        },
        {
            "trigger": "mattrib(name, P)",
            "contents": "mattrib(${1:name}, ${2:P})",
            "kind": "function",
            "details": "Returns the value of the point attribute for the metaballs if metaball geometry is specified to i3dgen"
        },
        {
            "trigger": "max(value1, value2, ...)",
            "contents": "max(${1:value1}, ${2:value2}, ${3:...})",
            "kind": "function"
        },
        {
            "trigger": "max(values)",
            "contents": "max(${1:values})",
            "kind": "function"
        },
        {
            "trigger": "max(value)",
            "contents": "max(${1:value})",
            "kind": "function"
        },
        {
            "trigger": "mdensity(P)",
            "contents": "mdensity(${1:P})",
            "kind": "function",
            "details": "Returns the density of the metaball field if metaball geometry is specified to i3dgen"
        },
        {
            "trigger": "metadata(opinput, name)",
            "contents": "metadata(${1:opinput}, ${2:name})",
            "kind": "function",
            "details": "Returns a metadata value from a composite operator"
        },
        {
            "trigger": "metadata(opinput, name, index)",
            "contents": "metadata(${1:opinput}, ${2:name}, ${3:index})",
            "kind": "function",
            "details": "Returns a metadata value from a composite operator"
        },
        {
            "trigger": "metaimport(handle, attrib, P, value)",
            "contents": "metaimport(${1:handle}, ${2:attrib}, ${3:P}, ${4:value})",
            "kind": "function",
            "details": "Once you get a handle to a metaball using metastart and metanext, you can query attributes of the metaball with metaimport"
        },
        {
            "trigger": "metaimport(file, attribute, P)",
            "contents": "metaimport(${1:file}, ${2:attribute}, ${3:P})",
            "kind": "function",
            "details": "Once you get a handle to a metaball using metastart and metanext, you can query attributes of the metaball with metaimport"
        },
        {
            "trigger": "metamarch(index, filename, p0, p1, displace_bound)",
            "contents": "metamarch(${1:index}, ${2:filename}, ${3:p0}, ${4:p1}, ${5:displace_bound})",
            "kind": "function",
            "details": "Takes the ray defined by p0 and p1 and partitions it into zero or more sub-intervals where each interval intersects a cluster of metaballs from filename"
        },
        {
            "trigger": "metanext(handle)",
            "contents": "metanext(${1:handle})",
            "kind": "function",
            "details": "Iterate to the next metaball in the list of metaballs returned by the metastart() function"
        },
        {
            "trigger": "metastart(filename, p)",
            "contents": "metastart(${1:filename}, ${2:p})",
            "kind": "function",
            "details": "Open a geometry file and return a handle for the metaballs of interest, at the position p"
        },
        {
            "trigger": "metaweight(geometry, p)",
            "contents": "metaweight(${1:geometry}, ${2:p})",
            "kind": "function",
            "details": "Returns the metaweight of the geometry at position p"
        },
        {
            "trigger": "min(value1, value2, ...)",
            "contents": "min(${1:value1}, ${2:value2}, ${3:...})",
            "kind": "function"
        },
        {
            "trigger": "min(values)",
            "contents": "min(${1:values})",
            "kind": "function"
        },
        {
            "trigger": "min(v)",
            "contents": "min(${1:v})",
            "kind": "function"
        },
        {
            "trigger": "min(value)",
            "contents": "min(${1:value})",
            "kind": "function"
        },
        {
            "trigger": "minpos(geometry, point)",
            "contents": "minpos(${1:geometry}, ${2:point})",
            "kind": "function",
            "details": "Given a position in world space, returns the position of the closest point on a given geometry"
        },
        {
            "trigger": "minpos(geometry, point, maxdist)",
            "contents": "minpos(${1:geometry}, ${2:point}, ${3:maxdist})",
            "kind": "function",
            "details": "Given a position in world space, returns the position of the closest point on a given geometry"
        },
        {
            "trigger": "minpos(geometry, primgroup, point)",
            "contents": "minpos(${1:geometry}, ${2:primgroup}, ${3:point})",
            "kind": "function",
            "details": "Given a position in world space, returns the position of the closest point on a given geometry"
        },
        {
            "trigger": "minpos(geometry, primgroup, point, maxdist)",
            "contents": "minpos(${1:geometry}, ${2:primgroup}, ${3:point}, ${4:maxdist})",
            "kind": "function",
            "details": "Given a position in world space, returns the position of the closest point on a given geometry"
        },
        {
            "trigger": "mspace(P)",
            "contents": "mspace(${1:P})",
            "kind": "function",
            "details": "Transforms the position specified into the local space of the metaball"
        },
        {
            "trigger": "mwnoise(position, seed, f1, f2)",
            "contents": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Manhattan distance metric"
        },
        {
            "trigger": "mwnoise(position, seed, f1, f2, f3, f4)",
            "contents": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Manhattan distance metric"
        },
        {
            "trigger": "mwnoise(position, seed, f1, f2, peiod)",
            "contents": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:peiod})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Manhattan distance metric"
        },
        {
            "trigger": "mwnoise(position, seed, f1, f2, f4, f4, period)",
            "contents": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f4}, ${6:f4}, ${7:period})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Manhattan distance metric"
        },
        {
            "trigger": "mwnoise(posx, posy, seed, f1, f2)",
            "contents": "mwnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Manhattan distance metric"
        },
        {
            "trigger": "mwnoise(posx, posy, seed, f1, f2, f3, f4)",
            "contents": "mwnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:f3}, ${7:f4})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Manhattan distance metric"
        },
        {
            "trigger": "mwnoise(posx, posy, seed, f1, f2, periodx, periody)",
            "contents": "mwnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:periodx}, ${7:periody})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Manhattan distance metric"
        },
        {
            "trigger": "mwnoise(posx, posy, seed, f1, f2, f3, f4, periodx, periody)",
            "contents": "mwnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:f3}, ${7:f4}, ${8:periodx}, ${9:periody})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Manhattan distance metric"
        },
        {
            "trigger": "mwnoise(position, seed, f1, f2, periodx, periody)",
            "contents": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Manhattan distance metric"
        },
        {
            "trigger": "mwnoise(position, seed, f1, f2, f3, f4, periodx, periody)",
            "contents": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Manhattan distance metric"
        },
        {
            "trigger": "mwnoise(position, seed, f1, f2, periodx, periody, periodx)",
            "contents": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody}, ${7:periodx})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Manhattan distance metric"
        },
        {
            "trigger": "mwnoise(position, seed, f1, f2, f3, f4, periodx, periody, periodz)",
            "contents": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody}, ${9:periodz})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Manhattan distance metric"
        },
        {
            "trigger": "mwnoise(position, seed, f1, f2, periodx, periody, periodz, periodw)",
            "contents": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody}, ${7:periodz}, ${8:periodw})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Manhattan distance metric"
        },
        {
            "trigger": "mwnoise(position, seed, f1, f2, f3, f4, periodx, periody, periodz, periodw)",
            "contents": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody}, ${9:periodz}, ${10:periodw})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise using a Manhattan distance metric"
        },
        {
            "trigger": "mx_cellnoise(pos)",
            "contents": "mx_cellnoise(${1:pos})",
            "kind": "function",
            "details": "MaterialX compatible cellnoise"
        },
        {
            "trigger": "mx_cellnoise(pos, periodx)",
            "contents": "mx_cellnoise(${1:pos}, ${2:periodx})",
            "kind": "function",
            "details": "MaterialX compatible cellnoise"
        },
        {
            "trigger": "mx_cellnoise(pos, periodx, periody)",
            "contents": "mx_cellnoise(${1:pos}, ${2:periodx}, ${3:periody})",
            "kind": "function",
            "details": "MaterialX compatible cellnoise"
        },
        {
            "trigger": "mx_cellnoise(pos, periodx, periody, periodz)",
            "contents": "mx_cellnoise(${1:pos}, ${2:periodx}, ${3:periody}, ${4:periodz})",
            "kind": "function",
            "details": "MaterialX compatible cellnoise"
        },
        {
            "trigger": "mx_cellnoise(pos, periodx, periody, periodz, periodw)",
            "contents": "mx_cellnoise(${1:pos}, ${2:periodx}, ${3:periody}, ${4:periodz}, ${5:periodw})",
            "kind": "function",
            "details": "MaterialX compatible cellnoise"
        },
        {
            "trigger": "mx_perlin(pos)",
            "contents": "mx_perlin(${1:pos})",
            "kind": "function",
            "details": "MaterialX compatible Perlin noise"
        },
        {
            "trigger": "mx_perlin(pos, periodx, periody, periodz)",
            "contents": "mx_perlin(${1:pos}, ${2:periodx}, ${3:periody}, ${4:periodz})",
            "kind": "function",
            "details": "MaterialX compatible Perlin noise"
        },
        {
            "trigger": "mx_perlin(pos, periodx, periody)",
            "contents": "mx_perlin(${1:pos}, ${2:periodx}, ${3:periody})",
            "kind": "function",
            "details": "MaterialX compatible Perlin noise"
        },
        {
            "trigger": "mx_voronoi(position, jitter, metric, d1, d2, d3, p1, p2, p3)",
            "contents": "mx_voronoi(${1:position}, ${2:jitter}, ${3:metric}, ${4:d1}, ${5:d2}, ${6:d3}, ${7:p1}, ${8:p2}, ${9:p3})",
            "kind": "function",
            "details": "MaterialX compatible Voronoi noise"
        },
        {
            "trigger": "mx_voronoi(position, jitter, metric, d1, d2, p1, p2)",
            "contents": "mx_voronoi(${1:position}, ${2:jitter}, ${3:metric}, ${4:d1}, ${5:d2}, ${6:p1}, ${7:p2})",
            "kind": "function",
            "details": "MaterialX compatible Voronoi noise"
        },
        {
            "trigger": "mx_voronoi(position, jitter, metric, d1, p1)",
            "contents": "mx_voronoi(${1:position}, ${2:jitter}, ${3:metric}, ${4:d1}, ${5:p1})",
            "kind": "function",
            "details": "MaterialX compatible Voronoi noise"
        },
        {
            "trigger": "mx_voronoi(position, jitter, metric, d1, d2, d3, p1, p2, p3, periodx, periody)",
            "contents": "mx_voronoi(${1:position}, ${2:jitter}, ${3:metric}, ${4:d1}, ${5:d2}, ${6:d3}, ${7:p1}, ${8:p2}, ${9:p3}, ${10:periodx}, ${11:periody})",
            "kind": "function",
            "details": "MaterialX compatible Voronoi noise"
        },
        {
            "trigger": "mx_voronoi(position, jitter, metric, d1, d2, p1, p2, periodx, periody)",
            "contents": "mx_voronoi(${1:position}, ${2:jitter}, ${3:metric}, ${4:d1}, ${5:d2}, ${6:p1}, ${7:p2}, ${8:periodx}, ${9:periody})",
            "kind": "function",
            "details": "MaterialX compatible Voronoi noise"
        },
        {
            "trigger": "mx_voronoi(position, jitter, metric, d1, p1, periodx, periody)",
            "contents": "mx_voronoi(${1:position}, ${2:jitter}, ${3:metric}, ${4:d1}, ${5:p1}, ${6:periodx}, ${7:periody})",
            "kind": "function",
            "details": "MaterialX compatible Voronoi noise"
        },
        {
            "trigger": "mx_voronoi(position, jitter, metric, d1, d2, d3, p1, p2, p3, periodx, periody, periodz)",
            "contents": "mx_voronoi(${1:position}, ${2:jitter}, ${3:metric}, ${4:d1}, ${5:d2}, ${6:d3}, ${7:p1}, ${8:p2}, ${9:p3}, ${10:periodx}, ${11:periody}, ${12:periodz})",
            "kind": "function",
            "details": "MaterialX compatible Voronoi noise"
        },
        {
            "trigger": "mx_voronoi(position, jitter, metric, d1, d2, p1, p2, periodx, periody, periodz)",
            "contents": "mx_voronoi(${1:position}, ${2:jitter}, ${3:metric}, ${4:d1}, ${5:d2}, ${6:p1}, ${7:p2}, ${8:periodx}, ${9:periody}, ${10:periodz})",
            "kind": "function",
            "details": "MaterialX compatible Voronoi noise"
        },
        {
            "trigger": "mx_voronoi(position, jitter, metric, d1, p1, periodx, periody, periodz)",
            "contents": "mx_voronoi(${1:position}, ${2:jitter}, ${3:metric}, ${4:d1}, ${5:p1}, ${6:periodx}, ${7:periody}, ${8:periodz})",
            "kind": "function",
            "details": "MaterialX compatible Voronoi noise"
        },
        {
            "trigger": "mx_worley(pos, jitter, metric)",
            "contents": "mx_worley(${1:pos}, ${2:jitter}, ${3:metric})",
            "kind": "function",
            "details": "MaterialX compatible Worley noise"
        },
        {
            "trigger": "mx_worley(pos, jitter, periodx, periody, periodz)",
            "contents": "mx_worley(${1:pos}, ${2:jitter}, ${3:periodx}, ${4:periody}, ${5:periodz})",
            "kind": "function",
            "details": "MaterialX compatible Worley noise"
        },
        {
            "trigger": "mx_worley(pos, jitter, periodx, periody, periodz, periodw)",
            "contents": "mx_worley(${1:pos}, ${2:jitter}, ${3:periodx}, ${4:periody}, ${5:periodz}, ${6:periodw})",
            "kind": "function",
            "details": "MaterialX compatible Worley noise"
        },
        {
            "trigger": "nametopoint(geometry, name)",
            "contents": "nametopoint(${1:geometry}, ${2:name})",
            "kind": "function",
            "details": "Finds a point by its name attribute"
        },
        {
            "trigger": "nametoprim(geometry, name)",
            "contents": "nametoprim(${1:geometry}, ${2:name})",
            "kind": "function",
            "details": "Finds a primitive by its name attribute"
        },
        {
            "trigger": "nbouncetypes()",
            "contents": "nbouncetypes()",
            "kind": "function"
        },
        {
            "trigger": "ndcdepth(z)",
            "contents": "ndcdepth(${1:z})",
            "kind": "function",
            "details": "Returns the camera space z-depth of the NDC z-depth value"
        },
        {
            "trigger": "nearpoint(geometry, pt)",
            "contents": "nearpoint(${1:geometry}, ${2:pt})",
            "kind": "function",
            "details": "Finds the closest point in a geometry"
        },
        {
            "trigger": "nearpoint(geometry, pt, maxdist)",
            "contents": "nearpoint(${1:geometry}, ${2:pt}, ${3:maxdist})",
            "kind": "function",
            "details": "Finds the closest point in a geometry"
        },
        {
            "trigger": "nearpoint(geometry, ptgroup, pt)",
            "contents": "nearpoint(${1:geometry}, ${2:ptgroup}, ${3:pt})",
            "kind": "function",
            "details": "Finds the closest point in a geometry"
        },
        {
            "trigger": "nearpoint(geometry, ptgroup, pt, maxdist)",
            "contents": "nearpoint(${1:geometry}, ${2:ptgroup}, ${3:pt}, ${4:maxdist})",
            "kind": "function",
            "details": "Finds the closest point in a geometry"
        },
        {
            "trigger": "nearpoints(geometry, pt, maxdist)",
            "contents": "nearpoints(${1:geometry}, ${2:pt}, ${3:maxdist})",
            "kind": "function",
            "details": "Finds the all the closest point in a geometry"
        },
        {
            "trigger": "nearpoints(geometry, pt, maxdist, maxpts)",
            "contents": "nearpoints(${1:geometry}, ${2:pt}, ${3:maxdist}, ${4:maxpts})",
            "kind": "function",
            "details": "Finds the all the closest point in a geometry"
        },
        {
            "trigger": "nearpoints(geometry, ptgroup, pt, maxdist)",
            "contents": "nearpoints(${1:geometry}, ${2:ptgroup}, ${3:pt}, ${4:maxdist})",
            "kind": "function",
            "details": "Finds the all the closest point in a geometry"
        },
        {
            "trigger": "nearpoints(geometry, ptgroup, pt, maxdist, maxpts)",
            "contents": "nearpoints(${1:geometry}, ${2:ptgroup}, ${3:pt}, ${4:maxdist}, ${5:maxpts})",
            "kind": "function",
            "details": "Finds the all the closest point in a geometry"
        },
        {
            "trigger": "nedgesgroup(geometry, groupname)",
            "contents": "nedgesgroup(${1:geometry}, ${2:groupname})",
            "kind": "function",
            "details": "Returns the number of edges in the group"
        },
        {
            "trigger": "neighbour(geometry, point_num, neighbour_num)",
            "contents": "neighbour(${1:geometry}, ${2:point_num}, ${3:neighbour_num})",
            "kind": "function",
            "details": "Returns the point number of the next point connected to a given point"
        },
        {
            "trigger": "neighbourcount(geometry, point_num)",
            "contents": "neighbourcount(${1:geometry}, ${2:point_num})",
            "kind": "function",
            "details": "Returns the number of points that are connected to the specified point"
        },
        {
            "trigger": "neighbours(geometry, ptnum)",
            "contents": "neighbours(${1:geometry}, ${2:ptnum})",
            "kind": "function",
            "details": "Returns an array of the point numbers of the neighbours of a point"
        },
        {
            "trigger": "newsampler(...)",
            "contents": "newsampler(${1:...})",
            "kind": "function",
            "details": "Initializes a sampling sequence for the nextsample function"
        },
        {
            "trigger": "newsampler(seed, ...)",
            "contents": "newsampler(${1:seed}, ${2:...})",
            "kind": "function",
            "details": "Initializes a sampling sequence for the nextsample function"
        },
        {
            "trigger": "nextsample(sid, sx, sy, ...)",
            "contents": "nextsample(${1:sid}, ${2:sx}, ${3:sy}, ${4:...})",
            "kind": "function"
        },
        {
            "trigger": "nextsample(sid, svec, ...)",
            "contents": "nextsample(${1:sid}, ${2:svec}, ${3:...})",
            "kind": "function"
        },
        {
            "trigger": "ninput(opinput, plane, component, array_index, u, v, frame, ...)",
            "contents": "ninput(${1:opinput}, ${2:plane}, ${3:component}, ${4:array_index}, ${5:u}, ${6:v}, ${7:frame}, ${8:...})",
            "kind": "function",
            "details": "Reads a component from a pixel and its eight neighbors"
        },
        {
            "trigger": "ninputs()",
            "contents": "ninputs()",
            "kind": "function",
            "details": "Returns the number of inputs"
        },
        {
            "trigger": "noise(pos)",
            "contents": "noise(${1:pos})",
            "kind": "function",
            "details": "There are two forms of Perlin-style noise: a non-periodic noise which changes randomly throughout N-dimensional space, and a periodic form which repeats over a given range of space"
        },
        {
            "trigger": "noise(posx, posy)",
            "contents": "noise(${1:posx}, ${2:posy})",
            "kind": "function",
            "details": "There are two forms of Perlin-style noise: a non-periodic noise which changes randomly throughout N-dimensional space, and a periodic form which repeats over a given range of space"
        },
        {
            "trigger": "noised(x, v, dvdx)",
            "contents": "noised(${1:x}, ${2:v}, ${3:dvdx})",
            "kind": "function",
            "details": "Derivatives of Perlin Noise"
        },
        {
            "trigger": "noised(x, y, v, dvdx, dvdy)",
            "contents": "noised(${1:x}, ${2:y}, ${3:v}, ${4:dvdx}, ${5:dvdy})",
            "kind": "function",
            "details": "Derivatives of Perlin Noise"
        },
        {
            "trigger": "noised(xyz, v, dvdx, dvdy, dvdz)",
            "contents": "noised(${1:xyz}, ${2:v}, ${3:dvdx}, ${4:dvdy}, ${5:dvdz})",
            "kind": "function",
            "details": "Derivatives of Perlin Noise"
        },
        {
            "trigger": "noised(xyzw, v, dvdx, dvdy, dvdz, dvdw)",
            "contents": "noised(${1:xyzw}, ${2:v}, ${3:dvdx}, ${4:dvdy}, ${5:dvdz}, ${6:dvdw})",
            "kind": "function",
            "details": "Derivatives of Perlin Noise"
        },
        {
            "trigger": "normalize(v)",
            "contents": "normalize(${1:v})",
            "kind": "function",
            "details": "Returns a normalized vector"
        },
        {
            "trigger": "normalname()",
            "contents": "normalname()",
            "kind": "function",
            "details": "Returns the default name of the normal plane (as it appears in the compositor preferences)"
        },
        {
            "trigger": "normal_bsdf(b)",
            "contents": "normal_bsdf(${1:b})",
            "kind": "function",
            "details": "Returns the normal for the diffuse component of a BSDF"
        },
        {
            "trigger": "norm_1(m)",
            "contents": "norm_1(${1:m})",
            "kind": "function",
            "details": "Returns the matrix 1-norm"
        },
        {
            "trigger": "norm_fro(m)",
            "contents": "norm_fro(${1:m})",
            "kind": "function",
            "details": "Returns the Frobenius norm of a matrix"
        },
        {
            "trigger": "norm_inf(m)",
            "contents": "norm_inf(${1:m})",
            "kind": "function",
            "details": "Returns the matrix inf-norm"
        },
        {
            "trigger": "norm_max(m)",
            "contents": "norm_max(${1:m})",
            "kind": "function",
            "details": "Returns the matrix max-norm"
        },
        {
            "trigger": "npoints(geometry)",
            "contents": "npoints(${1:geometry})",
            "kind": "function",
            "details": "Returns the number of points in the input or geometry file"
        },
        {
            "trigger": "npointsgroup(geometry, groupname)",
            "contents": "npointsgroup(${1:geometry}, ${2:groupname})",
            "kind": "function",
            "details": "Returns the number of points in the group"
        },
        {
            "trigger": "nprimitives(geometry)",
            "contents": "nprimitives(${1:geometry})",
            "kind": "function",
            "details": "Returns the number of primitives in the input or geometry file"
        },
        {
            "trigger": "nprimitivesgroup(geometry, groupname)",
            "contents": "nprimitivesgroup(${1:geometry}, ${2:groupname})",
            "kind": "function",
            "details": "Returns the number of primitives in the group"
        },
        {
            "trigger": "nrandom(...)",
            "contents": "nrandom(${1:...})",
            "kind": "function",
            "details": "Non-deterministic random number generation function"
        },
        {
            "trigger": "nrandom(x, y, ...)",
            "contents": "nrandom(${1:x}, ${2:y}, ${3:...})",
            "kind": "function",
            "details": "Non-deterministic random number generation function"
        },
        {
            "trigger": "ntransform(v, transform)",
            "contents": "ntransform(${1:v}, ${2:transform})",
            "kind": "function",
            "details": "Transforms a normal vector"
        },
        {
            "trigger": "ntransform(tospace, v)",
            "contents": "ntransform(${1:tospace}, ${2:v})",
            "kind": "function",
            "details": "Transforms a normal vector"
        },
        {
            "trigger": "ntransform(fromspace, tospace, v)",
            "contents": "ntransform(${1:fromspace}, ${2:tospace}, ${3:v})",
            "kind": "function",
            "details": "Transforms a normal vector"
        },
        {
            "trigger": "nuniqueval(geometry, attribclass, attribute_name)",
            "contents": "nuniqueval(${1:geometry}, ${2:attribclass}, ${3:attribute_name})",
            "kind": "function",
            "details": "Returns the number of unique values from an integer or string attribute"
        },
        {
            "trigger": "nvertices(geometry)",
            "contents": "nvertices(${1:geometry})",
            "kind": "function",
            "details": "Returns the number of vertices in the input or geometry file"
        },
        {
            "trigger": "nverticesgroup(geometry, groupname)",
            "contents": "nverticesgroup(${1:geometry}, ${2:groupname})",
            "kind": "function",
            "details": "Returns the number of vertices in the group"
        },
        {
            "trigger": "objectstate(query, value)",
            "contents": "objectstate(${1:query}, ${2:value})",
            "kind": "function",
            "details": "Queries the renderer for a named property"
        },
        {
            "trigger": "occlusion(P, N, ...)",
            "contents": "occlusion(${1:P}, ${2:N}, ${3:...})",
            "kind": "function",
            "details": "Computes ambient occlusion"
        },
        {
            "trigger": "occlusion(coverage, missed_direction, P, N, ...)",
            "contents": "occlusion(${1:coverage}, ${2:missed_direction}, ${3:P}, ${4:N}, ${5:...})",
            "kind": "function",
            "details": "Computes ambient occlusion"
        },
        {
            "trigger": "ocean_sample(geometry, phase, frequency, amplitude, hscale, time, mode, downsample, pos)",
            "contents": "ocean_sample(${1:geometry}, ${2:phase}, ${3:frequency}, ${4:amplitude}, ${5:hscale}, ${6:time}, ${7:mode}, ${8:downsample}, ${9:pos})",
            "kind": "function",
            "details": "Evaluates an ocean spectrum and samples the result at a given time and location"
        },
        {
            "trigger": "ocio_activedisplays()",
            "contents": "ocio_activedisplays()",
            "kind": "function",
            "details": "Returns the names of active displays supported in Open Color IO"
        },
        {
            "trigger": "ocio_activeviews()",
            "contents": "ocio_activeviews()",
            "kind": "function",
            "details": "Returns the names of active views supported in Open Color IO"
        },
        {
            "trigger": "ocio_import(space, property, value)",
            "contents": "ocio_import(${1:space}, ${2:property}, ${3:value})",
            "kind": "function",
            "details": "Imports attributes from OpenColorIO spaces"
        },
        {
            "trigger": "ocio_parsecolorspace(input)",
            "contents": "ocio_parsecolorspace(${1:input})",
            "kind": "function",
            "details": "Parse the color space from a string"
        },
        {
            "trigger": "ocio_roles()",
            "contents": "ocio_roles()",
            "kind": "function",
            "details": "Returns the names of roles supported in Open Color IO"
        },
        {
            "trigger": "ocio_spaces()",
            "contents": "ocio_spaces()",
            "kind": "function",
            "details": "Returns the names of color spaces supported in Open Color IO"
        },
        {
            "trigger": "ocio_transform(dest, clr)",
            "contents": "ocio_transform(${1:dest}, ${2:clr})",
            "kind": "function",
            "details": "Transform colors using Open Color IO"
        },
        {
            "trigger": "ocio_transform(src, dest, clr)",
            "contents": "ocio_transform(${1:src}, ${2:dest}, ${3:clr})",
            "kind": "function",
            "details": "Transform colors using Open Color IO"
        },
        {
            "trigger": "ocio_transform(src, dest, looks, clr)",
            "contents": "ocio_transform(${1:src}, ${2:dest}, ${3:looks}, ${4:clr})",
            "kind": "function",
            "details": "Transform colors using Open Color IO"
        },
        {
            "trigger": "ocio_transformview(src, display, view, clr)",
            "contents": "ocio_transformview(${1:src}, ${2:display}, ${3:view}, ${4:clr})",
            "kind": "function",
            "details": "Transform colors to a view using Open Color IO"
        },
        {
            "trigger": "onoise(pos)",
            "contents": "onoise(${1:pos})",
            "kind": "function",
            "details": "These functions are similar to wnoise and vnoise"
        },
        {
            "trigger": "onoise(pos, turbulence, rough, atten)",
            "contents": "onoise(${1:pos}, ${2:turbulence}, ${3:rough}, ${4:atten})",
            "kind": "function",
            "details": "These functions are similar to wnoise and vnoise"
        },
        {
            "trigger": "onoise(pos, periodX, periodY, periodZ)",
            "contents": "onoise(${1:pos}, ${2:periodX}, ${3:periodY}, ${4:periodZ})",
            "kind": "function",
            "details": "These functions are similar to wnoise and vnoise"
        },
        {
            "trigger": "onoise(pos, periodX, periodY, periodZ, turbulence, rough, atten)",
            "contents": "onoise(${1:pos}, ${2:periodX}, ${3:periodY}, ${4:periodZ}, ${5:turbulence}, ${6:rough}, ${7:atten})",
            "kind": "function",
            "details": "These functions are similar to wnoise and vnoise"
        },
        {
            "trigger": "opdigits(str)",
            "contents": "opdigits(${1:str})",
            "kind": "function",
            "details": "Returns the integer value of the last sequence of digits of a string"
        },
        {
            "trigger": "opdigits()",
            "contents": "opdigits()",
            "kind": "function",
            "details": "Returns the integer value of the last sequence of digits of a string"
        },
        {
            "trigger": "opend(handle)",
            "contents": "opend(${1:handle})",
            "kind": "function",
            "details": "Ends a long operation"
        },
        {
            "trigger": "opfullpath(relative_path)",
            "contents": "opfullpath(${1:relative_path})",
            "kind": "function",
            "details": "Returns the full path for the given relative path"
        },
        {
            "trigger": "opid(op_path)",
            "contents": "opid(${1:op_path})",
            "kind": "function",
            "details": "Resolves an operator path string and return its op_id"
        },
        {
            "trigger": "opid(op_id)",
            "contents": "opid(${1:op_id})",
            "kind": "function",
            "details": "Resolves an operator path string and return its op_id"
        },
        {
            "trigger": "opparentbonetransform(path)",
            "contents": "opparentbonetransform(${1:path})",
            "kind": "function",
            "details": "Returns the parent bone transform associated with an OP"
        },
        {
            "trigger": "opparentbonetransform(path, time)",
            "contents": "opparentbonetransform(${1:path}, ${2:time})",
            "kind": "function",
            "details": "Returns the parent bone transform associated with an OP"
        },
        {
            "trigger": "opparentbonetransform(opid)",
            "contents": "opparentbonetransform(${1:opid})",
            "kind": "function",
            "details": "Returns the parent bone transform associated with an OP"
        },
        {
            "trigger": "opparentbonetransform(opid, time)",
            "contents": "opparentbonetransform(${1:opid}, ${2:time})",
            "kind": "function",
            "details": "Returns the parent bone transform associated with an OP"
        },
        {
            "trigger": "opparenttransform(path)",
            "contents": "opparenttransform(${1:path})",
            "kind": "function",
            "details": "Returns the parent transform associated with an OP"
        },
        {
            "trigger": "opparenttransform(path, time)",
            "contents": "opparenttransform(${1:path}, ${2:time})",
            "kind": "function",
            "details": "Returns the parent transform associated with an OP"
        },
        {
            "trigger": "opparenttransform(opid)",
            "contents": "opparenttransform(${1:opid})",
            "kind": "function",
            "details": "Returns the parent transform associated with an OP"
        },
        {
            "trigger": "opparenttransform(opid, time)",
            "contents": "opparenttransform(${1:opid}, ${2:time})",
            "kind": "function",
            "details": "Returns the parent transform associated with an OP"
        },
        {
            "trigger": "opparmtransform(path)",
            "contents": "opparmtransform(${1:path})",
            "kind": "function",
            "details": "Returns the parm transform associated with an OP"
        },
        {
            "trigger": "opparmtransform(path, time)",
            "contents": "opparmtransform(${1:path}, ${2:time})",
            "kind": "function",
            "details": "Returns the parm transform associated with an OP"
        },
        {
            "trigger": "opparmtransform(opid)",
            "contents": "opparmtransform(${1:opid})",
            "kind": "function",
            "details": "Returns the parm transform associated with an OP"
        },
        {
            "trigger": "opparmtransform(opid, time)",
            "contents": "opparmtransform(${1:opid}, ${2:time})",
            "kind": "function",
            "details": "Returns the parm transform associated with an OP"
        },
        {
            "trigger": "oppreconstrainttransform(path)",
            "contents": "oppreconstrainttransform(${1:path})",
            "kind": "function",
            "details": "Returns the preconstraint transform associated with an OP"
        },
        {
            "trigger": "oppreconstrainttransform(path, time)",
            "contents": "oppreconstrainttransform(${1:path}, ${2:time})",
            "kind": "function",
            "details": "Returns the preconstraint transform associated with an OP"
        },
        {
            "trigger": "oppreconstrainttransform(opid)",
            "contents": "oppreconstrainttransform(${1:opid})",
            "kind": "function",
            "details": "Returns the preconstraint transform associated with an OP"
        },
        {
            "trigger": "oppreconstrainttransform(opid, time)",
            "contents": "oppreconstrainttransform(${1:opid}, ${2:time})",
            "kind": "function",
            "details": "Returns the preconstraint transform associated with an OP"
        },
        {
            "trigger": "oppreparmtransform(path)",
            "contents": "oppreparmtransform(${1:path})",
            "kind": "function",
            "details": "Returns the pre and parm transform associated with an OP"
        },
        {
            "trigger": "oppreparmtransform(path, time)",
            "contents": "oppreparmtransform(${1:path}, ${2:time})",
            "kind": "function",
            "details": "Returns the pre and parm transform associated with an OP"
        },
        {
            "trigger": "oppreparmtransform(opid)",
            "contents": "oppreparmtransform(${1:opid})",
            "kind": "function",
            "details": "Returns the pre and parm transform associated with an OP"
        },
        {
            "trigger": "oppreparmtransform(opid, time)",
            "contents": "oppreparmtransform(${1:opid}, ${2:time})",
            "kind": "function",
            "details": "Returns the pre and parm transform associated with an OP"
        },
        {
            "trigger": "opprerawparmtransform(path)",
            "contents": "opprerawparmtransform(${1:path})",
            "kind": "function",
            "details": "Returns the pre and raw parm transform associated with an OP"
        },
        {
            "trigger": "opprerawparmtransform(path, time)",
            "contents": "opprerawparmtransform(${1:path}, ${2:time})",
            "kind": "function",
            "details": "Returns the pre and raw parm transform associated with an OP"
        },
        {
            "trigger": "opprerawparmtransform(opid)",
            "contents": "opprerawparmtransform(${1:opid})",
            "kind": "function",
            "details": "Returns the pre and raw parm transform associated with an OP"
        },
        {
            "trigger": "opprerawparmtransform(opid, time)",
            "contents": "opprerawparmtransform(${1:opid}, ${2:time})",
            "kind": "function",
            "details": "Returns the pre and raw parm transform associated with an OP"
        },
        {
            "trigger": "opprerawparmtransform(opid, trsorder, xyzorder, mask)",
            "contents": "opprerawparmtransform(${1:opid}, ${2:trsorder}, ${3:xyzorder}, ${4:mask})",
            "kind": "function",
            "details": "Returns the pre and raw parm transform associated with an OP"
        },
        {
            "trigger": "oppretransform(path)",
            "contents": "oppretransform(${1:path})",
            "kind": "function",
            "details": "Returns the pretransform associated with an OP"
        },
        {
            "trigger": "oppretransform(path, time)",
            "contents": "oppretransform(${1:path}, ${2:time})",
            "kind": "function",
            "details": "Returns the pretransform associated with an OP"
        },
        {
            "trigger": "oppretransform(opid)",
            "contents": "oppretransform(${1:opid})",
            "kind": "function",
            "details": "Returns the pretransform associated with an OP"
        },
        {
            "trigger": "oppretransform(opid, time)",
            "contents": "oppretransform(${1:opid}, ${2:time})",
            "kind": "function",
            "details": "Returns the pretransform associated with an OP"
        },
        {
            "trigger": "oprawparmtransform(path)",
            "contents": "oprawparmtransform(${1:path})",
            "kind": "function",
            "details": "Returns the raw parm transform associated with an OP"
        },
        {
            "trigger": "oprawparmtransform(path, time)",
            "contents": "oprawparmtransform(${1:path}, ${2:time})",
            "kind": "function",
            "details": "Returns the raw parm transform associated with an OP"
        },
        {
            "trigger": "oprawparmtransform(opid)",
            "contents": "oprawparmtransform(${1:opid})",
            "kind": "function",
            "details": "Returns the raw parm transform associated with an OP"
        },
        {
            "trigger": "oprawparmtransform(opid, time)",
            "contents": "oprawparmtransform(${1:opid}, ${2:time})",
            "kind": "function",
            "details": "Returns the raw parm transform associated with an OP"
        },
        {
            "trigger": "oprawparmtransform(opid, trsorder, xyzorder, mask)",
            "contents": "oprawparmtransform(${1:opid}, ${2:trsorder}, ${3:xyzorder}, ${4:mask})",
            "kind": "function",
            "details": "Returns the raw parm transform associated with an OP"
        },
        {
            "trigger": "opstart(message)",
            "contents": "opstart(${1:message})",
            "kind": "function",
            "details": "Start a long operation"
        },
        {
            "trigger": "optransform(path)",
            "contents": "optransform(${1:path})",
            "kind": "function",
            "details": "Returns the transform associated with an OP"
        },
        {
            "trigger": "optransform(path, time)",
            "contents": "optransform(${1:path}, ${2:time})",
            "kind": "function",
            "details": "Returns the transform associated with an OP"
        },
        {
            "trigger": "optransform(op_id)",
            "contents": "optransform(${1:op_id})",
            "kind": "function",
            "details": "Returns the transform associated with an OP"
        },
        {
            "trigger": "optransform(op_id, time)",
            "contents": "optransform(${1:op_id}, ${2:time})",
            "kind": "function",
            "details": "Returns the transform associated with an OP"
        },
        {
            "trigger": "ord(value)",
            "contents": "ord(${1:value})",
            "kind": "function",
            "details": "Converts an UTF8 string into a codepoint"
        },
        {
            "trigger": "orthographic(zoom, orthowidth, image_aspect, pixel_aspect, clip_near, clip_far)",
            "contents": "orthographic(${1:zoom}, ${2:orthowidth}, ${3:image_aspect}, ${4:pixel_aspect}, ${5:clip_near}, ${6:clip_far})",
            "kind": "function",
            "details": "Create an orthographic projection matrix"
        },
        {
            "trigger": "orthographic(zoom, orthowidth, image_aspect, pixel_aspect, clip_near, clip_far, window)",
            "contents": "orthographic(${1:zoom}, ${2:orthowidth}, ${3:image_aspect}, ${4:pixel_aspect}, ${5:clip_near}, ${6:clip_far}, ${7:window})",
            "kind": "function",
            "details": "Create an orthographic projection matrix"
        },
        {
            "trigger": "osd_facecount(geometry)",
            "contents": "osd_facecount(${1:geometry})",
            "kind": "function"
        },
        {
            "trigger": "osd_firstpatch(geometry, face_id)",
            "contents": "osd_firstpatch(${1:geometry}, ${2:face_id})",
            "kind": "function"
        },
        {
            "trigger": "osd_limitsurface(geometry, attrib_name, patch_id, u, v, result)",
            "contents": "osd_limitsurface(${1:geometry}, ${2:attrib_name}, ${3:patch_id}, ${4:u}, ${5:v}, ${6:result})",
            "kind": "function",
            "details": "Evaluates a point attribute at the subdivision limit surface using Open Subdiv"
        },
        {
            "trigger": "osd_limitsurfacevertex(geometry, attrib_name, face_id, u, v, result)",
            "contents": "osd_limitsurfacevertex(${1:geometry}, ${2:attrib_name}, ${3:face_id}, ${4:u}, ${5:v}, ${6:result})",
            "kind": "function",
            "details": "Evaluates a vertex attribute at the subdivision limit surface using Open Subdiv"
        },
        {
            "trigger": "osd_lookupface(geometry, patch_id, patch_u, patch_v, face_id, face_u, face_v)",
            "contents": "osd_lookupface(${1:geometry}, ${2:patch_id}, ${3:patch_u}, ${4:patch_v}, ${5:face_id}, ${6:face_u}, ${7:face_v})",
            "kind": "function",
            "details": "Outputs the Houdini face and UV coordinates corresponding to the given coordinates on an OSD patch"
        },
        {
            "trigger": "osd_lookupface(geometry, patch_id, patch_u, patch_v, face_id, face_u, face_v, attribute)",
            "contents": "osd_lookupface(${1:geometry}, ${2:patch_id}, ${3:patch_u}, ${4:patch_v}, ${5:face_id}, ${6:face_u}, ${7:face_v}, ${8:attribute})",
            "kind": "function",
            "details": "Outputs the Houdini face and UV coordinates corresponding to the given coordinates on an OSD patch"
        },
        {
            "trigger": "osd_lookuppatch(geometry, face_id, face_u, face_v, patch_id, patch_u, patch_v)",
            "contents": "osd_lookuppatch(${1:geometry}, ${2:face_id}, ${3:face_u}, ${4:face_v}, ${5:patch_id}, ${6:patch_u}, ${7:patch_v})",
            "kind": "function",
            "details": "Outputs the OSD patch and UV coordinates corresponding to the given coordinates on a Houdini polygon face"
        },
        {
            "trigger": "osd_lookuppatch(geometry, face_id, face_u, face_v, patch_id, patch_u, patch_v, attribute)",
            "contents": "osd_lookuppatch(${1:geometry}, ${2:face_id}, ${3:face_u}, ${4:face_v}, ${5:patch_id}, ${6:patch_u}, ${7:patch_v}, ${8:attribute})",
            "kind": "function",
            "details": "Outputs the OSD patch and UV coordinates corresponding to the given coordinates on a Houdini polygon face"
        },
        {
            "trigger": "osd_patchcount(geometry)",
            "contents": "osd_patchcount(${1:geometry})",
            "kind": "function"
        },
        {
            "trigger": "osd_patchcount(geometry, face_id)",
            "contents": "osd_patchcount(${1:geometry}, ${2:face_id})",
            "kind": "function"
        },
        {
            "trigger": "osd_patches(geometry, face_id)",
            "contents": "osd_patches(${1:geometry}, ${2:face_id})",
            "kind": "function",
            "details": "Returns a list of patch IDs for the patches in a subdivision hull"
        },
        {
            "trigger": "outerproduct(v, v)",
            "contents": "outerproduct(${1:v}, ${2:v})",
            "kind": "function",
            "details": "Returns the outer product between the arguments"
        },
        {
            "trigger": "ow_nspace(v)",
            "contents": "ow_nspace(${1:v})",
            "kind": "function",
            "details": "Transforms a normal vector from Object to World space"
        },
        {
            "trigger": "ow_space()",
            "contents": "ow_space()",
            "kind": "function",
            "details": "Transforms a position value from Object to World space"
        },
        {
            "trigger": "ow_space(v)",
            "contents": "ow_space(${1:v})",
            "kind": "function",
            "details": "Transforms a position value from Object to World space"
        },
        {
            "trigger": "ow_vspace(v)",
            "contents": "ow_vspace(${1:v})",
            "kind": "function",
            "details": "Transforms a direction vector from Object to World space"
        },
        {
            "trigger": "packedtransform(input, primnum, transform)",
            "contents": "packedtransform(${1:input}, ${2:primnum}, ${3:transform})",
            "kind": "function",
            "details": "Transforms a packed primitive"
        },
        {
            "trigger": "pack_inttosafefloat(i)",
            "contents": "pack_inttosafefloat(${1:i})",
            "kind": "function",
            "details": "Reversibly packs an integer into a finite, non-denormal float"
        },
        {
            "trigger": "pathtrace(P, N, ...)",
            "contents": "pathtrace(${1:P}, ${2:N}, ${3:...})",
            "kind": "function",
            "details": "Computes global illumination using PBR for secondary bounces"
        },
        {
            "trigger": "pcclose(handle)",
            "contents": "pcclose(${1:handle})",
            "kind": "function",
            "details": "This function closes the handle associated with a pcopen function"
        },
        {
            "trigger": "pccone(geometry, PChannel, P, dir, angle, max_distance, maxpoints)",
            "contents": "pccone(${1:geometry}, ${2:PChannel}, ${3:P}, ${4:dir}, ${5:angle}, ${6:max_distance}, ${7:maxpoints})",
            "kind": "function",
            "details": "Returns a list of closest points from a file within a specified cone"
        },
        {
            "trigger": "pccone(geometry, ptgroup, PChannel, P, dir, angle, max_distance, maxpoints)",
            "contents": "pccone(${1:geometry}, ${2:ptgroup}, ${3:PChannel}, ${4:P}, ${5:dir}, ${6:angle}, ${7:max_distance}, ${8:maxpoints})",
            "kind": "function",
            "details": "Returns a list of closest points from a file within a specified cone"
        },
        {
            "trigger": "pccone_radius(geometry, PChannel, RadChannel, radscale, P, dir, angle, max_distance, maxpoints)",
            "contents": "pccone_radius(${1:geometry}, ${2:PChannel}, ${3:RadChannel}, ${4:radscale}, ${5:P}, ${6:dir}, ${7:angle}, ${8:max_distance}, ${9:maxpoints})",
            "kind": "function",
            "details": "Returns a list of closest points from a file in a cone, taking into account their radii"
        },
        {
            "trigger": "pccone_radius(geometry, ptgroup, PChannel, RadChannel, radscale, P, dir, angle, max_distance, maxpoints)",
            "contents": "pccone_radius(${1:geometry}, ${2:ptgroup}, ${3:PChannel}, ${4:RadChannel}, ${5:radscale}, ${6:P}, ${7:dir}, ${8:angle}, ${9:max_distance}, ${10:maxpoints})",
            "kind": "function",
            "details": "Returns a list of closest points from a file in a cone, taking into account their radii"
        },
        {
            "trigger": "pcconvex(handle, channel, N)",
            "contents": "pcconvex(${1:handle}, ${2:channel}, ${3:N})",
            "kind": "function"
        },
        {
            "trigger": "pcexport(handle, channel_name, value, ...)",
            "contents": "pcexport(${1:handle}, ${2:channel_name}, ${3:value}, ${4:...})",
            "kind": "function",
            "details": "Writes data to a point cloud inside a pciterate or a pcunshaded loop"
        },
        {
            "trigger": "pcexport(handle, channel_name, value, radius, ...)",
            "contents": "pcexport(${1:handle}, ${2:channel_name}, ${3:value}, ${4:radius}, ${5:...})",
            "kind": "function",
            "details": "Writes data to a point cloud inside a pciterate or a pcunshaded loop"
        },
        {
            "trigger": "pcfarthest(handle)",
            "contents": "pcfarthest(${1:handle})",
            "kind": "function",
            "details": "Returns the distance to the farthest point found in the search performed by pcopen"
        },
        {
            "trigger": "pcfilter(handle, channel_name, ...)",
            "contents": "pcfilter(${1:handle}, ${2:channel_name}, ${3:...})",
            "kind": "function",
            "details": "Filters points found by pcopen using a simple reconstruction filter"
        },
        {
            "trigger": "pcfind(geometry, Pchannel, P, radius, maxpoints)",
            "contents": "pcfind(${1:geometry}, ${2:Pchannel}, ${3:P}, ${4:radius}, ${5:maxpoints})",
            "kind": "function",
            "details": "Returns a list of closest points from a file"
        },
        {
            "trigger": "pcfind(geometry, ptgroup, Pchannel, P, radius, maxpoints)",
            "contents": "pcfind(${1:geometry}, ${2:ptgroup}, ${3:Pchannel}, ${4:P}, ${5:radius}, ${6:maxpoints})",
            "kind": "function",
            "details": "Returns a list of closest points from a file"
        },
        {
            "trigger": "pcfind(geometry, Pchannel, P, radius, maxpoints, distances)",
            "contents": "pcfind(${1:geometry}, ${2:Pchannel}, ${3:P}, ${4:radius}, ${5:maxpoints}, ${6:distances})",
            "kind": "function",
            "details": "Returns a list of closest points from a file"
        },
        {
            "trigger": "pcfind(geometry, ptgroup, Pchannel, P, radius, maxpoints, distances)",
            "contents": "pcfind(${1:geometry}, ${2:ptgroup}, ${3:Pchannel}, ${4:P}, ${5:radius}, ${6:maxpoints}, ${7:distances})",
            "kind": "function",
            "details": "Returns a list of closest points from a file"
        },
        {
            "trigger": "pcfind_radius(geometry, Pchannel, RadChannel, radscale, P, radius, maxpoints)",
            "contents": "pcfind_radius(${1:geometry}, ${2:Pchannel}, ${3:RadChannel}, ${4:radscale}, ${5:P}, ${6:radius}, ${7:maxpoints})",
            "kind": "function",
            "details": "Returns a list of closest points from a file taking into account their radii"
        },
        {
            "trigger": "pcfind_radius(geometry, ptgroup, Pchannel, RadChannel, radscale, P, radius, maxpoints)",
            "contents": "pcfind_radius(${1:geometry}, ${2:ptgroup}, ${3:Pchannel}, ${4:RadChannel}, ${5:radscale}, ${6:P}, ${7:radius}, ${8:maxpoints})",
            "kind": "function",
            "details": "Returns a list of closest points from a file taking into account their radii"
        },
        {
            "trigger": "pcfind_radius(geometry, Pchannel, RadChannel, radscale, P, radius, maxpoints, distances)",
            "contents": "pcfind_radius(${1:geometry}, ${2:Pchannel}, ${3:RadChannel}, ${4:radscale}, ${5:P}, ${6:radius}, ${7:maxpoints}, ${8:distances})",
            "kind": "function",
            "details": "Returns a list of closest points from a file taking into account their radii"
        },
        {
            "trigger": "pcfind_radius(geometry, ptgroup, Pchannel, RadChannel, radscale, P, radius, maxpoints, distances)",
            "contents": "pcfind_radius(${1:geometry}, ${2:ptgroup}, ${3:Pchannel}, ${4:RadChannel}, ${5:radscale}, ${6:P}, ${7:radius}, ${8:maxpoints}, ${9:distances})",
            "kind": "function",
            "details": "Returns a list of closest points from a file taking into account their radii"
        },
        {
            "trigger": "pcgenerate(filename, npoints)",
            "contents": "pcgenerate(${1:filename}, ${2:npoints})",
            "kind": "function",
            "details": "Generates a point cloud"
        },
        {
            "trigger": "pcimport(handle, channel_name, value)",
            "contents": "pcimport(${1:handle}, ${2:channel_name}, ${3:value})",
            "kind": "function",
            "details": "Imports channel data from a point cloud inside a pciterate or a pcunshaded loop"
        },
        {
            "trigger": "pcimportbyidx3(handle, channel_name, idx)",
            "contents": "pcimportbyidx3(${1:handle}, ${2:channel_name}, ${3:idx})",
            "kind": "function",
            "details": "Imports channel data from a point cloud outside a pciterate or a pcunshaded loop"
        },
        {
            "trigger": "pcimportbyidx4(handle, channel_name, idx)",
            "contents": "pcimportbyidx4(${1:handle}, ${2:channel_name}, ${3:idx})",
            "kind": "function",
            "details": "Imports channel data from a point cloud outside a pciterate or a pcunshaded loop"
        },
        {
            "trigger": "pcimportbyidxf(handle, channel_name, idx)",
            "contents": "pcimportbyidxf(${1:handle}, ${2:channel_name}, ${3:idx})",
            "kind": "function",
            "details": "Imports channel data from a point cloud outside a pciterate or a pcunshaded loop"
        },
        {
            "trigger": "pcimportbyidxi(handle, channel_name, idx)",
            "contents": "pcimportbyidxi(${1:handle}, ${2:channel_name}, ${3:idx})",
            "kind": "function",
            "details": "Imports channel data from a point cloud outside a pciterate or a pcunshaded loop"
        },
        {
            "trigger": "pcimportbyidxp(handle, channel_name, idx)",
            "contents": "pcimportbyidxp(${1:handle}, ${2:channel_name}, ${3:idx})",
            "kind": "function",
            "details": "Imports channel data from a point cloud outside a pciterate or a pcunshaded loop"
        },
        {
            "trigger": "pcimportbyidxs(handle, channel_name, idx)",
            "contents": "pcimportbyidxs(${1:handle}, ${2:channel_name}, ${3:idx})",
            "kind": "function",
            "details": "Imports channel data from a point cloud outside a pciterate or a pcunshaded loop"
        },
        {
            "trigger": "pcimportbyidxv(handle, channel_name, idx)",
            "contents": "pcimportbyidxv(${1:handle}, ${2:channel_name}, ${3:idx})",
            "kind": "function",
            "details": "Imports channel data from a point cloud outside a pciterate or a pcunshaded loop"
        },
        {
            "trigger": "pciterate(handle)",
            "contents": "pciterate(${1:handle})",
            "kind": "function",
            "details": "This function can be used to iterate over all the points which were found in the pcopen query"
        },
        {
            "trigger": "pcline(geometry, PChannel, P, dir, max_distance, maxpoints)",
            "contents": "pcline(${1:geometry}, ${2:PChannel}, ${3:P}, ${4:dir}, ${5:max_distance}, ${6:maxpoints})",
            "kind": "function",
            "details": "Returns a list of closest points to an infinite line from a specified file"
        },
        {
            "trigger": "pcline(geometry, ptgroup, PChannel, P, dir, max_distance, maxpoints)",
            "contents": "pcline(${1:geometry}, ${2:ptgroup}, ${3:PChannel}, ${4:P}, ${5:dir}, ${6:max_distance}, ${7:maxpoints})",
            "kind": "function",
            "details": "Returns a list of closest points to an infinite line from a specified file"
        },
        {
            "trigger": "pcline_radius(geometry, PChannel, RadChannel, radscale, P, dir, max_distance, maxpoints)",
            "contents": "pcline_radius(${1:geometry}, ${2:PChannel}, ${3:RadChannel}, ${4:radscale}, ${5:P}, ${6:dir}, ${7:max_distance}, ${8:maxpoints})",
            "kind": "function",
            "details": "Returns a list of closest points to an infinite line from a specified file"
        },
        {
            "trigger": "pcline_radius(geometry, ptgroup, PChannel, RadChannel, radscale, P, dir, max_distance, maxpoints)",
            "contents": "pcline_radius(${1:geometry}, ${2:ptgroup}, ${3:PChannel}, ${4:RadChannel}, ${5:radscale}, ${6:P}, ${7:dir}, ${8:max_distance}, ${9:maxpoints})",
            "kind": "function",
            "details": "Returns a list of closest points to an infinite line from a specified file"
        },
        {
            "trigger": "pcnumfound(handle)",
            "contents": "pcnumfound(${1:handle})",
            "kind": "function",
            "details": "This node returns the number of points found by pcopen"
        },
        {
            "trigger": "pcopen(filename, channel, shaded, ...)",
            "contents": "pcopen(${1:filename}, ${2:channel}, ${3:shaded}, ${4:...})",
            "kind": "function",
            "details": "Returns a handle to a point cloud file"
        },
        {
            "trigger": "pcopen(filename, Pchannel, P, radius, maxpoints, ...)",
            "contents": "pcopen(${1:filename}, ${2:Pchannel}, ${3:P}, ${4:radius}, ${5:maxpoints}, ${6:...})",
            "kind": "function",
            "details": "Returns a handle to a point cloud file"
        },
        {
            "trigger": "pcopen(filename, Pchannel, P, Nchannel, N, radius, maxpoints, ...)",
            "contents": "pcopen(${1:filename}, ${2:Pchannel}, ${3:P}, ${4:Nchannel}, ${5:N}, ${6:radius}, ${7:maxpoints}, ${8:...})",
            "kind": "function",
            "details": "Returns a handle to a point cloud file"
        },
        {
            "trigger": "pcopen(opinput, Pchannel, P, radius, maxpoints)",
            "contents": "pcopen(${1:opinput}, ${2:Pchannel}, ${3:P}, ${4:radius}, ${5:maxpoints})",
            "kind": "function",
            "details": "Returns a handle to a point cloud file"
        },
        {
            "trigger": "pcopenlod(filename, Pchannel, P, min_pts, ...)",
            "contents": "pcopenlod(${1:filename}, ${2:Pchannel}, ${3:P}, ${4:min_pts}, ${5:...})",
            "kind": "function",
            "details": "Returns a handle to a point cloud file"
        },
        {
            "trigger": "pcsampleleaf(handle, sample)",
            "contents": "pcsampleleaf(${1:handle}, ${2:sample})",
            "kind": "function",
            "details": "Changes the current iteration point to a leaf descendant of the current aggregate point"
        },
        {
            "trigger": "pcsegment(geometry, PChannel, P0, P1, max_distance, maxpoints)",
            "contents": "pcsegment(${1:geometry}, ${2:PChannel}, ${3:P0}, ${4:P1}, ${5:max_distance}, ${6:maxpoints})",
            "kind": "function",
            "details": "Returns a list of closest points to a line segment from a specified file"
        },
        {
            "trigger": "pcsegment(geometry, ptgroup, PChannel, P0, P1, max_distance, maxpoints)",
            "contents": "pcsegment(${1:geometry}, ${2:ptgroup}, ${3:PChannel}, ${4:P0}, ${5:P1}, ${6:max_distance}, ${7:maxpoints})",
            "kind": "function",
            "details": "Returns a list of closest points to a line segment from a specified file"
        },
        {
            "trigger": "pcsegment(geometry, PChannel, P0, P1, max_distance, maxpoints, distances)",
            "contents": "pcsegment(${1:geometry}, ${2:PChannel}, ${3:P0}, ${4:P1}, ${5:max_distance}, ${6:maxpoints}, ${7:distances})",
            "kind": "function",
            "details": "Returns a list of closest points to a line segment from a specified file"
        },
        {
            "trigger": "pcsegment(geometry, ptgroup, PChannel, P0, P1, max_distance, maxpoints, distances)",
            "contents": "pcsegment(${1:geometry}, ${2:ptgroup}, ${3:PChannel}, ${4:P0}, ${5:P1}, ${6:max_distance}, ${7:maxpoints}, ${8:distances})",
            "kind": "function",
            "details": "Returns a list of closest points to a line segment from a specified file"
        },
        {
            "trigger": "pcsegment_radius(geometry, PChannel, RadChannel, radscale, P0, P1, max_distance, maxpoints)",
            "contents": "pcsegment_radius(${1:geometry}, ${2:PChannel}, ${3:RadChannel}, ${4:radscale}, ${5:P0}, ${6:P1}, ${7:max_distance}, ${8:maxpoints})",
            "kind": "function",
            "details": "Returns a list of closest points to a line segment from a specified file"
        },
        {
            "trigger": "pcsegment_radius(geometry, ptgroup, PChannel, RadChannel, radscale, P0, P1, max_distance, maxpoints)",
            "contents": "pcsegment_radius(${1:geometry}, ${2:ptgroup}, ${3:PChannel}, ${4:RadChannel}, ${5:radscale}, ${6:P0}, ${7:P1}, ${8:max_distance}, ${9:maxpoints})",
            "kind": "function",
            "details": "Returns a list of closest points to a line segment from a specified file"
        },
        {
            "trigger": "pcsegment_radius(geometry, PChannel, RadChannel, radscale, P0, P1, max_distance, maxpoints, distances)",
            "contents": "pcsegment_radius(${1:geometry}, ${2:PChannel}, ${3:RadChannel}, ${4:radscale}, ${5:P0}, ${6:P1}, ${7:max_distance}, ${8:maxpoints}, ${9:distances})",
            "kind": "function",
            "details": "Returns a list of closest points to a line segment from a specified file"
        },
        {
            "trigger": "pcsegment_radius(geometry, ptgroup, PChannel, RadChannel, radscale, P0, P1, max_distance, maxpoints, distances)",
            "contents": "pcsegment_radius(${1:geometry}, ${2:ptgroup}, ${3:PChannel}, ${4:RadChannel}, ${5:radscale}, ${6:P0}, ${7:P1}, ${8:max_distance}, ${9:maxpoints}, ${10:distances})",
            "kind": "function",
            "details": "Returns a list of closest points to a line segment from a specified file"
        },
        {
            "trigger": "pcsize(handle)",
            "contents": "pcsize(${1:handle})",
            "kind": "function"
        },
        {
            "trigger": "pcunshaded(handle, channel_name)",
            "contents": "pcunshaded(${1:handle}, ${2:channel_name})",
            "kind": "function",
            "details": "Iterate over all of the points of a read-write channel which haven\u2019t had any data written to the channel yet"
        },
        {
            "trigger": "pcwrite(filename, ...)",
            "contents": "pcwrite(${1:filename}, ${2:...})",
            "kind": "function",
            "details": "Writes data to a point cloud file"
        },
        {
            "trigger": "perspective(zoom, image_aspect, pixel_aspect, clip_near, clip_far)",
            "contents": "perspective(${1:zoom}, ${2:image_aspect}, ${3:pixel_aspect}, ${4:clip_near}, ${5:clip_far})",
            "kind": "function",
            "details": "Create a perspective projection matrix"
        },
        {
            "trigger": "perspective(zoom, image_aspect, pixel_aspect, clip_near, clip_far, window)",
            "contents": "perspective(${1:zoom}, ${2:image_aspect}, ${3:pixel_aspect}, ${4:clip_near}, ${5:clip_far}, ${6:window})",
            "kind": "function",
            "details": "Create a perspective projection matrix"
        },
        {
            "trigger": "pgfind(geometry, P, radius, maxpoints, divsize)",
            "contents": "pgfind(${1:geometry}, ${2:P}, ${3:radius}, ${4:maxpoints}, ${5:divsize})",
            "kind": "function",
            "details": "Returns a list of closest points from a file"
        },
        {
            "trigger": "pgfind(geometry, ptgroup, P, radius, maxpoints, divsize)",
            "contents": "pgfind(${1:geometry}, ${2:ptgroup}, ${3:P}, ${4:radius}, ${5:maxpoints}, ${6:divsize})",
            "kind": "function",
            "details": "Returns a list of closest points from a file"
        },
        {
            "trigger": "phong(exponent, ...)",
            "contents": "phong(${1:exponent}, ${2:...})",
            "kind": "function",
            "details": "Returns a Phong BSDF or computes Phong shading"
        },
        {
            "trigger": "phong(nml, exponent, ...)",
            "contents": "phong(${1:nml}, ${2:exponent}, ${3:...})",
            "kind": "function",
            "details": "Returns a Phong BSDF or computes Phong shading"
        },
        {
            "trigger": "phong(nml, V, shinyness, ...)",
            "contents": "phong(${1:nml}, ${2:V}, ${3:shinyness}, ${4:...})",
            "kind": "function",
            "details": "Returns a Phong BSDF or computes Phong shading"
        },
        {
            "trigger": "phongBRDF(L, N, V, rough)",
            "contents": "phongBRDF(${1:L}, ${2:N}, ${3:V}, ${4:rough})",
            "kind": "function"
        },
        {
            "trigger": "phonglobe(dir, exponent, ...)",
            "contents": "phonglobe(${1:dir}, ${2:exponent}, ${3:...})",
            "kind": "function"
        },
        {
            "trigger": "phonglobe(nml, dir, exponent, ...)",
            "contents": "phonglobe(${1:nml}, ${2:dir}, ${3:exponent}, ${4:...})",
            "kind": "function"
        },
        {
            "trigger": "phonglobe(dir, exponentx, exponenty, framex, framey, ...)",
            "contents": "phonglobe(${1:dir}, ${2:exponentx}, ${3:exponenty}, ${4:framex}, ${5:framey}, ${6:...})",
            "kind": "function"
        },
        {
            "trigger": "phonglobe(nml, dir, exponentx, exponenty, framex, framey, ...)",
            "contents": "phonglobe(${1:nml}, ${2:dir}, ${3:exponentx}, ${4:exponenty}, ${5:framex}, ${6:framey}, ${7:...})",
            "kind": "function"
        },
        {
            "trigger": "photonmap(mapname, position, normal, ...)",
            "contents": "photonmap(${1:mapname}, ${2:position}, ${3:normal}, ${4:...})",
            "kind": "function",
            "details": "Samples a color from a photon map"
        },
        {
            "trigger": "photonmap(mapname, position, normal, color, area, ...)",
            "contents": "photonmap(${1:mapname}, ${2:position}, ${3:normal}, ${4:color}, ${5:area}, ${6:...})",
            "kind": "function",
            "details": "Samples a color from a photon map"
        },
        {
            "trigger": "pinvert(m)",
            "contents": "pinvert(${1:m})",
            "kind": "function",
            "details": "Computes the pseudo-inverse of a matrix"
        },
        {
            "trigger": "planeindex(planename)",
            "contents": "planeindex(${1:planename})",
            "kind": "function",
            "details": "Returns the index of the plane specified by the parameter, starting at zero"
        },
        {
            "trigger": "planename(planeindex)",
            "contents": "planename(${1:planeindex})",
            "kind": "function",
            "details": "Returns the name of the plane specified by the index (e"
        },
        {
            "trigger": "planepointdistance(plane_pos, plane_normal, point_pos, intersect_pos)",
            "contents": "planepointdistance(${1:plane_pos}, ${2:plane_normal}, ${3:point_pos}, ${4:intersect_pos})",
            "kind": "function",
            "details": "Computes the distance and closest point of a point to an infinite plane"
        },
        {
            "trigger": "planesize(planeindex)",
            "contents": "planesize(${1:planeindex})",
            "kind": "function",
            "details": "Returns the number of components in the plane (1 for scalar planes and up to 4 for vector planes)"
        },
        {
            "trigger": "planesphereintersect(plane_pos, plane_normal, sphere_pos, sphere_radius, intersect_pos, intersect_radius, intersect_distance)",
            "contents": "planesphereintersect(${1:plane_pos}, ${2:plane_normal}, ${3:sphere_pos}, ${4:sphere_radius}, ${5:intersect_pos}, ${6:intersect_radius}, ${7:intersect_distance})",
            "kind": "function",
            "details": "Computes the intersection of a 3D sphere and an infinite 3D plane"
        },
        {
            "trigger": "pluralize(noun)",
            "contents": "pluralize(${1:noun})",
            "kind": "function",
            "details": "Converts an English noun to its plural"
        },
        {
            "trigger": "pnoise(x, px)",
            "contents": "pnoise(${1:x}, ${2:px})",
            "kind": "function",
            "details": "There are two forms of Perlin-style noise: a non-periodic noise which changes randomly throughout N-dimensional space, and a periodic form which repeats over a given range of space"
        },
        {
            "trigger": "pnoise(x, p)",
            "contents": "pnoise(${1:x}, ${2:p})",
            "kind": "function",
            "details": "There are two forms of Perlin-style noise: a non-periodic noise which changes randomly throughout N-dimensional space, and a periodic form which repeats over a given range of space"
        },
        {
            "trigger": "pnoise(xyzt, p)",
            "contents": "pnoise(${1:xyzt}, ${2:p})",
            "kind": "function",
            "details": "There are two forms of Perlin-style noise: a non-periodic noise which changes randomly throughout N-dimensional space, and a periodic form which repeats over a given range of space"
        },
        {
            "trigger": "pnoise(x, y, px, py)",
            "contents": "pnoise(${1:x}, ${2:y}, ${3:px}, ${4:py})",
            "kind": "function",
            "details": "There are two forms of Perlin-style noise: a non-periodic noise which changes randomly throughout N-dimensional space, and a periodic form which repeats over a given range of space"
        },
        {
            "trigger": "pnoise(xyz, px, py, pz)",
            "contents": "pnoise(${1:xyz}, ${2:px}, ${3:py}, ${4:pz})",
            "kind": "function",
            "details": "There are two forms of Perlin-style noise: a non-periodic noise which changes randomly throughout N-dimensional space, and a periodic form which repeats over a given range of space"
        },
        {
            "trigger": "pnoise(xyzt, px, py, pz, pt)",
            "contents": "pnoise(${1:xyzt}, ${2:px}, ${3:py}, ${4:pz}, ${5:pt})",
            "kind": "function",
            "details": "There are two forms of Perlin-style noise: a non-periodic noise which changes randomly throughout N-dimensional space, and a periodic form which repeats over a given range of space"
        },
        {
            "trigger": "point(geometry, attribute_name, pointnumber)",
            "contents": "point(${1:geometry}, ${2:attribute_name}, ${3:pointnumber})",
            "kind": "function",
            "details": "Reads a point attribute value from a geometry"
        },
        {
            "trigger": "pointattrib(geometry, attribute_name, pointnumber, success)",
            "contents": "pointattrib(${1:geometry}, ${2:attribute_name}, ${3:pointnumber}, ${4:success})",
            "kind": "function",
            "details": "Reads a point attribute value from a geometry and outputs a success/fail flag"
        },
        {
            "trigger": "pointattribsize(geometry, attribute_name)",
            "contents": "pointattribsize(${1:geometry}, ${2:attribute_name})",
            "kind": "function",
            "details": "Returns the size of a geometry point attribute"
        },
        {
            "trigger": "pointattribtype(geometry, attribute_name)",
            "contents": "pointattribtype(${1:geometry}, ${2:attribute_name})",
            "kind": "function",
            "details": "Returns the type of a geometry point attribute"
        },
        {
            "trigger": "pointattribtypeinfo(geometry, attribute_name)",
            "contents": "pointattribtypeinfo(${1:geometry}, ${2:attribute_name})",
            "kind": "function",
            "details": "Returns the type info of a geometry attribute"
        },
        {
            "trigger": "pointedge(geometry, point1, point2)",
            "contents": "pointedge(${1:geometry}, ${2:point1}, ${3:point2})",
            "kind": "function",
            "details": "Finds and returns a half-edge with the given endpoints"
        },
        {
            "trigger": "pointhedge(geometry, point)",
            "contents": "pointhedge(${1:geometry}, ${2:point})",
            "kind": "function",
            "details": "Finds and returns a half-edge with a given source point or with given source and destination points"
        },
        {
            "trigger": "pointhedge(geometry, srcpoint, dstpoint)",
            "contents": "pointhedge(${1:geometry}, ${2:srcpoint}, ${3:dstpoint})",
            "kind": "function",
            "details": "Finds and returns a half-edge with a given source point or with given source and destination points"
        },
        {
            "trigger": "pointhedgenext(geometry, hedge)",
            "contents": "pointhedgenext(${1:geometry}, ${2:hedge})",
            "kind": "function",
            "details": "Returns the next half-edge with the same source as a given half-edge"
        },
        {
            "trigger": "pointlocaltransforms(geometry, pnts)",
            "contents": "pointlocaltransforms(${1:geometry}, ${2:pnts})",
            "kind": "function",
            "details": "Returns an array of point localtransforms from an array of point indices"
        },
        {
            "trigger": "pointname()",
            "contents": "pointname()",
            "kind": "function",
            "details": "Returns the default name of the point plane (as it appears in the compositor preferences)"
        },
        {
            "trigger": "pointprims(geometry, ptnum)",
            "contents": "pointprims(${1:geometry}, ${2:ptnum})",
            "kind": "function",
            "details": "Returns the list of primitives containing a point"
        },
        {
            "trigger": "pointtransform(geometry, pnt)",
            "contents": "pointtransform(${1:geometry}, ${2:pnt})",
            "kind": "function",
            "details": "Returns a point transform from a point index"
        },
        {
            "trigger": "pointtransformrigid(geometry, pnt)",
            "contents": "pointtransformrigid(${1:geometry}, ${2:pnt})",
            "kind": "function",
            "details": "Returns a rigid point transform from a point index"
        },
        {
            "trigger": "pointtransforms(geometry, pnts)",
            "contents": "pointtransforms(${1:geometry}, ${2:pnts})",
            "kind": "function",
            "details": "Returns an array of point transforms from an array of point indices"
        },
        {
            "trigger": "pointtransforms(geometry)",
            "contents": "pointtransforms(${1:geometry})",
            "kind": "function",
            "details": "Returns an array of point transforms from an array of point indices"
        },
        {
            "trigger": "pointtransformsrigid(geometry, pnts)",
            "contents": "pointtransformsrigid(${1:geometry}, ${2:pnts})",
            "kind": "function",
            "details": "Returns an array of rigid point transforms from an array of point indices"
        },
        {
            "trigger": "pointtransformsrigid(geometry)",
            "contents": "pointtransformsrigid(${1:geometry})",
            "kind": "function",
            "details": "Returns an array of rigid point transforms from an array of point indices"
        },
        {
            "trigger": "pointvertex(geometry, point_num)",
            "contents": "pointvertex(${1:geometry}, ${2:point_num})",
            "kind": "function",
            "details": "Returns a linear vertex number of a point in a geometry"
        },
        {
            "trigger": "pointvertices(geometry, ptnum)",
            "contents": "pointvertices(${1:geometry}, ${2:ptnum})",
            "kind": "function",
            "details": "Returns the list of vertices connected to a point"
        },
        {
            "trigger": "polardecomp(transform)",
            "contents": "polardecomp(${1:transform})",
            "kind": "function",
            "details": "Computes the polar decomposition of a matrix"
        },
        {
            "trigger": "polardecomp(transform, rot, stretch, check_determinant)",
            "contents": "polardecomp(${1:transform}, ${2:rot}, ${3:stretch}, ${4:check_determinant})",
            "kind": "function",
            "details": "Computes the polar decomposition of a matrix"
        },
        {
            "trigger": "polyneighbours(geometry, primnum)",
            "contents": "polyneighbours(${1:geometry}, ${2:primnum})",
            "kind": "function",
            "details": "Returns an array of the primitive numbers of the edge-neighbours of a polygon"
        },
        {
            "trigger": "pop(array)",
            "contents": "pop(${1:array})",
            "kind": "function",
            "details": "Removes the last element of an array and returns it"
        },
        {
            "trigger": "pop(array, index)",
            "contents": "pop(${1:array}, ${2:index})",
            "kind": "function",
            "details": "Removes the last element of an array and returns it"
        },
        {
            "trigger": "pow(n, exponent)",
            "contents": "pow(${1:n}, ${2:exponent})",
            "kind": "function",
            "details": "Raises the first argument to the power of the second argument"
        },
        {
            "trigger": "pow(v, exponent)",
            "contents": "pow(${1:v}, ${2:exponent})",
            "kind": "function",
            "details": "Raises the first argument to the power of the second argument"
        },
        {
            "trigger": "predicate_incircle(a, b, c, d)",
            "contents": "predicate_incircle(${1:a}, ${2:b}, ${3:c}, ${4:d})",
            "kind": "function",
            "details": "Determines if a point is inside or outside a triangle circumcircle"
        },
        {
            "trigger": "predicate_insphere(a, b, c, d, e)",
            "contents": "predicate_insphere(${1:a}, ${2:b}, ${3:c}, ${4:d}, ${5:e})",
            "kind": "function",
            "details": "Determines if a point is inside or outside a tetrahedron circumsphere"
        },
        {
            "trigger": "predicate_orient2d(a, b, c)",
            "contents": "predicate_orient2d(${1:a}, ${2:b}, ${3:c})",
            "kind": "function",
            "details": "Determines the orientation of a point with respect to a line"
        },
        {
            "trigger": "predicate_orient3d(a, b, c, d)",
            "contents": "predicate_orient3d(${1:a}, ${2:b}, ${3:c}, ${4:d})",
            "kind": "function",
            "details": "Determines the orientation of a point with respect to a plane"
        },
        {
            "trigger": "premul(a, b)",
            "contents": "premul(${1:a}, ${2:b})",
            "kind": "function",
            "details": "Pre multiply matrices"
        },
        {
            "trigger": "premul(m, a, b)",
            "contents": "premul(${1:m}, ${2:a}, ${3:b})",
            "kind": "function",
            "details": "Pre multiply matrices"
        },
        {
            "trigger": "prerotate(m, amount, axis)",
            "contents": "prerotate(${1:m}, ${2:amount}, ${3:axis})",
            "kind": "function",
            "details": "Applies a pre rotation to the given matrix"
        },
        {
            "trigger": "prerotate(m, angles, xyz)",
            "contents": "prerotate(${1:m}, ${2:angles}, ${3:xyz})",
            "kind": "function",
            "details": "Applies a pre rotation to the given matrix"
        },
        {
            "trigger": "prerotate(m, angle, axis)",
            "contents": "prerotate(${1:m}, ${2:angle}, ${3:axis})",
            "kind": "function",
            "details": "Applies a pre rotation to the given matrix"
        },
        {
            "trigger": "prescale(m, scale_vector)",
            "contents": "prescale(${1:m}, ${2:scale_vector})",
            "kind": "function",
            "details": "Prescales the given matrix in three directions simultaneously (X, Y, Z - given by the components of the scale_vector)"
        },
        {
            "trigger": "pretranslate(m, amount)",
            "contents": "pretranslate(${1:m}, ${2:amount})",
            "kind": "function",
            "details": "Pretranslates a matrix by a vector"
        },
        {
            "trigger": "prim(geometry, attribute_name, primnumber)",
            "contents": "prim(${1:geometry}, ${2:attribute_name}, ${3:primnumber})",
            "kind": "function",
            "details": "Reads a primitive attribute value from a geometry"
        },
        {
            "trigger": "primarclen(geometry, uv1, uv2, prim_num)",
            "contents": "primarclen(${1:geometry}, ${2:uv1}, ${3:uv2}, ${4:prim_num})",
            "kind": "function",
            "details": "Evaluates the length of an arc on a primitive using parametric uv coordinates"
        },
        {
            "trigger": "primarclen(geometry, uv1, uv2, prim_num, divs)",
            "contents": "primarclen(${1:geometry}, ${2:uv1}, ${3:uv2}, ${4:prim_num}, ${5:divs})",
            "kind": "function",
            "details": "Evaluates the length of an arc on a primitive using parametric uv coordinates"
        },
        {
            "trigger": "primarclen(geometry, uv1, uv2, prim_num, divs, primuvmode)",
            "contents": "primarclen(${1:geometry}, ${2:uv1}, ${3:uv2}, ${4:prim_num}, ${5:divs}, ${6:primuvmode})",
            "kind": "function",
            "details": "Evaluates the length of an arc on a primitive using parametric uv coordinates"
        },
        {
            "trigger": "primarclen(geometry, uv1, uv2, prim_num, divs, primuvmode, primuvtol)",
            "contents": "primarclen(${1:geometry}, ${2:uv1}, ${3:uv2}, ${4:prim_num}, ${5:divs}, ${6:primuvmode}, ${7:primuvtol})",
            "kind": "function",
            "details": "Evaluates the length of an arc on a primitive using parametric uv coordinates"
        },
        {
            "trigger": "primattrib(geometry, attribute_name, prim, success)",
            "contents": "primattrib(${1:geometry}, ${2:attribute_name}, ${3:prim}, ${4:success})",
            "kind": "function",
            "details": "Reads a primitive attribute value from a geometry, outputting a success flag"
        },
        {
            "trigger": "primattribsize(geometry, attribute_name)",
            "contents": "primattribsize(${1:geometry}, ${2:attribute_name})",
            "kind": "function",
            "details": "Returns the size of a geometry prim attribute"
        },
        {
            "trigger": "primattribtype(geometry, attribute_name)",
            "contents": "primattribtype(${1:geometry}, ${2:attribute_name})",
            "kind": "function",
            "details": "Returns the type of a geometry prim attribute"
        },
        {
            "trigger": "primattribtypeinfo(geometry, attribute_name)",
            "contents": "primattribtypeinfo(${1:geometry}, ${2:attribute_name})",
            "kind": "function",
            "details": "Returns the type info of a geometry attribute"
        },
        {
            "trigger": "primduv(geometry, prim_number, uv, du, dv)",
            "contents": "primduv(${1:geometry}, ${2:prim_number}, ${3:uv}, ${4:du}, ${5:dv})",
            "kind": "function",
            "details": "Returns position derivative on a primitive at a certain parametric (u, v) position"
        },
        {
            "trigger": "primfind(geometry, min, max)",
            "contents": "primfind(${1:geometry}, ${2:min}, ${3:max})",
            "kind": "function",
            "details": "Returns a list of primitives potentially intersecting a given bounding box"
        },
        {
            "trigger": "primfind(geometry, group, min, max)",
            "contents": "primfind(${1:geometry}, ${2:group}, ${3:min}, ${4:max})",
            "kind": "function",
            "details": "Returns a list of primitives potentially intersecting a given bounding box"
        },
        {
            "trigger": "primhedge(geometry, prim)",
            "contents": "primhedge(${1:geometry}, ${2:prim})",
            "kind": "function",
            "details": "Returns one of the half-edges contained in a primitive"
        },
        {
            "trigger": "priminteriorweights(geometry, prim_num, uvw, verts, weights)",
            "contents": "priminteriorweights(${1:geometry}, ${2:prim_num}, ${3:uvw}, ${4:verts}, ${5:weights})",
            "kind": "function",
            "details": "Finds the indices and weightings of the vertices that will compute an interior point given the UVW coordinates"
        },
        {
            "trigger": "primintrinsic(geometry, intrinsic_name, prim_num)",
            "contents": "primintrinsic(${1:geometry}, ${2:intrinsic_name}, ${3:prim_num})",
            "kind": "function",
            "details": "Reads a primitive intrinsic from a geometry"
        },
        {
            "trigger": "primpoint(geometry, primnum, vertex)",
            "contents": "primpoint(${1:geometry}, ${2:primnum}, ${3:vertex})",
            "kind": "function",
            "details": "Converts a primitive/vertex pair into a point number"
        },
        {
            "trigger": "primpoints(geometry, primnum)",
            "contents": "primpoints(${1:geometry}, ${2:primnum})",
            "kind": "function",
            "details": "Returns the list of points on a primitive"
        },
        {
            "trigger": "primuv(geometry, attribute_name, prim_num, uvw)",
            "contents": "primuv(${1:geometry}, ${2:attribute_name}, ${3:prim_num}, ${4:uvw})",
            "kind": "function",
            "details": "Interpolates the value of an attribute at a certain parametric (uvw) position"
        },
        {
            "trigger": "primuvconvert(geometry, uv, prim_num, mode)",
            "contents": "primuvconvert(${1:geometry}, ${2:uv}, ${3:prim_num}, ${4:mode})",
            "kind": "function",
            "details": "Convert parametric UV locations on curve primitives between different spaces"
        },
        {
            "trigger": "primuvconvert(geometry, uv, prim_num, mode, tolerance)",
            "contents": "primuvconvert(${1:geometry}, ${2:uv}, ${3:prim_num}, ${4:mode}, ${5:tolerance})",
            "kind": "function",
            "details": "Convert parametric UV locations on curve primitives between different spaces"
        },
        {
            "trigger": "primvertex(geometry, primnum, vertex)",
            "contents": "primvertex(${1:geometry}, ${2:primnum}, ${3:vertex})",
            "kind": "function",
            "details": "Converts a primitive/vertex pair into a linear vertex"
        },
        {
            "trigger": "primvertexcount(geometry, prim_num)",
            "contents": "primvertexcount(${1:geometry}, ${2:prim_num})",
            "kind": "function",
            "details": "Returns number of vertices in a primitive in a geometry"
        },
        {
            "trigger": "primvertices(geometry, primnum)",
            "contents": "primvertices(${1:geometry}, ${2:primnum})",
            "kind": "function",
            "details": "Returns the list of vertices on a primitive"
        },
        {
            "trigger": "prim_attribute(geometry, value, attribute_name, prim_number, u, v)",
            "contents": "prim_attribute(${1:geometry}, ${2:value}, ${3:attribute_name}, ${4:prim_number}, ${5:u}, ${6:v})",
            "kind": "function",
            "details": "Interpolates the value of an attribute at a certain parametric (u, v) position and copies it into a variable"
        },
        {
            "trigger": "prim_attribute(geometry, value, attribute_name, prim_number, uvw)",
            "contents": "prim_attribute(${1:geometry}, ${2:value}, ${3:attribute_name}, ${4:prim_number}, ${5:uvw})",
            "kind": "function",
            "details": "Interpolates the value of an attribute at a certain parametric (u, v) position and copies it into a variable"
        },
        {
            "trigger": "prim_normal(geometry, prim_number, uvw)",
            "contents": "prim_normal(${1:geometry}, ${2:prim_number}, ${3:uvw})",
            "kind": "function",
            "details": "Returns the normal of the primitive (prim_number) at parametric location u, v"
        },
        {
            "trigger": "prim_normal(geometry, prim_number, u, v)",
            "contents": "prim_normal(${1:geometry}, ${2:prim_number}, ${3:u}, ${4:v})",
            "kind": "function",
            "details": "Returns the normal of the primitive (prim_number) at parametric location u, v"
        },
        {
            "trigger": "prim_normal(geometry, prim_number, u, v, w)",
            "contents": "prim_normal(${1:geometry}, ${2:prim_number}, ${3:u}, ${4:v}, ${5:w})",
            "kind": "function",
            "details": "Returns the normal of the primitive (prim_number) at parametric location u, v"
        },
        {
            "trigger": "printf(format, ...)",
            "contents": "printf(${1:format}, ${2:...})",
            "kind": "function",
            "details": "Prints values to the console which started the VEX program"
        },
        {
            "trigger": "print_once(msg, ...)",
            "contents": "print_once(${1:msg}, ${2:...})",
            "kind": "function",
            "details": "Prints a message only once, even in a loop"
        },
        {
            "trigger": "product(n)",
            "contents": "product(${1:n})",
            "kind": "function",
            "details": "Returns the product of a list of numbers"
        },
        {
            "trigger": "product(v)",
            "contents": "product(${1:v})",
            "kind": "function",
            "details": "Returns the product of a list of numbers"
        },
        {
            "trigger": "product(arr)",
            "contents": "product(${1:arr})",
            "kind": "function",
            "details": "Returns the product of a list of numbers"
        },
        {
            "trigger": "ptexture(map, face_id, ...)",
            "contents": "ptexture(${1:map}, ${2:face_id}, ${3:...})",
            "kind": "function",
            "details": "Computes a filtered sample from a ptex texture map. Use texture instead"
        },
        {
            "trigger": "ptexture(map, face_id, s, t, ...)",
            "contents": "ptexture(${1:map}, ${2:face_id}, ${3:s}, ${4:t}, ${5:...})",
            "kind": "function",
            "details": "Computes a filtered sample from a ptex texture map. Use texture instead"
        },
        {
            "trigger": "ptlined(P0, P1, Q)",
            "contents": "ptlined(${1:P0}, ${2:P1}, ${3:Q})",
            "kind": "function",
            "details": "This function returns the closest distance between the point Q and a finite line segment between points P0 and P1"
        },
        {
            "trigger": "ptransform(vec, transform)",
            "contents": "ptransform(${1:vec}, ${2:transform})",
            "kind": "function",
            "details": "Transforms a vector from one space to another"
        },
        {
            "trigger": "ptransform(tospace, vec)",
            "contents": "ptransform(${1:tospace}, ${2:vec})",
            "kind": "function",
            "details": "Transforms a vector from one space to another"
        },
        {
            "trigger": "ptransform(fromspace, tospace, vec)",
            "contents": "ptransform(${1:fromspace}, ${2:tospace}, ${3:vec})",
            "kind": "function",
            "details": "Transforms a vector from one space to another"
        },
        {
            "trigger": "push(array, value)",
            "contents": "push(${1:array}, ${2:value})",
            "kind": "function",
            "details": "Adds an item to an array"
        },
        {
            "trigger": "push(array, values)",
            "contents": "push(${1:array}, ${2:values})",
            "kind": "function",
            "details": "Adds an item to an array"
        },
        {
            "trigger": "pxnoise(x, xp)",
            "contents": "pxnoise(${1:x}, ${2:xp})",
            "kind": "function",
            "details": "Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid. This results in less grid artifacts. It also uses a higher order bspline to provide better derivatives. This is the periodic simplex noise"
        },
        {
            "trigger": "pxnoise(x, y, xp, yp)",
            "contents": "pxnoise(${1:x}, ${2:y}, ${3:xp}, ${4:yp})",
            "kind": "function",
            "details": "Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid. This results in less grid artifacts. It also uses a higher order bspline to provide better derivatives. This is the periodic simplex noise"
        },
        {
            "trigger": "pxnoise(xyz, xp, yp, zp)",
            "contents": "pxnoise(${1:xyz}, ${2:xp}, ${3:yp}, ${4:zp})",
            "kind": "function",
            "details": "Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid. This results in less grid artifacts. It also uses a higher order bspline to provide better derivatives. This is the periodic simplex noise"
        },
        {
            "trigger": "pxnoise(xyzt, xp, yp, zp, wp)",
            "contents": "pxnoise(${1:xyzt}, ${2:xp}, ${3:yp}, ${4:zp}, ${5:wp})",
            "kind": "function",
            "details": "Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid. This results in less grid artifacts. It also uses a higher order bspline to provide better derivatives. This is the periodic simplex noise"
        },
        {
            "trigger": "pxnoised(x, px, v, dvdx)",
            "contents": "pxnoised(${1:x}, ${2:px}, ${3:v}, ${4:dvdx})",
            "kind": "function",
            "details": "Periodic derivatives of Simplex Noise"
        },
        {
            "trigger": "pxnoised(x, y, px, py, v, dvdx, dvdy)",
            "contents": "pxnoised(${1:x}, ${2:y}, ${3:px}, ${4:py}, ${5:v}, ${6:dvdx}, ${7:dvdy})",
            "kind": "function",
            "details": "Periodic derivatives of Simplex Noise"
        },
        {
            "trigger": "pxnoised(xyz, px, py, pz, v, dvdx, dvdy, dvdz)",
            "contents": "pxnoised(${1:xyz}, ${2:px}, ${3:py}, ${4:pz}, ${5:v}, ${6:dvdx}, ${7:dvdy}, ${8:dvdz})",
            "kind": "function",
            "details": "Periodic derivatives of Simplex Noise"
        },
        {
            "trigger": "pxnoised(xyzw, px, py, pz, pw, v, dvdx, dvdy, dvdz, dvdw)",
            "contents": "pxnoised(${1:xyzw}, ${2:px}, ${3:py}, ${4:pz}, ${5:pw}, ${6:v}, ${7:dvdx}, ${8:dvdy}, ${9:dvdz}, ${10:dvdw})",
            "kind": "function",
            "details": "Periodic derivatives of Simplex Noise"
        },
        {
            "trigger": "qconvert(quaternion)",
            "contents": "qconvert(${1:quaternion})",
            "kind": "function",
            "details": "Converts a quaternion represented by a vector4 to a matrix3 representation"
        },
        {
            "trigger": "qconvert(quaternion, offset)",
            "contents": "qconvert(${1:quaternion}, ${2:offset})",
            "kind": "function",
            "details": "Converts a quaternion represented by a vector4 to a matrix3 representation"
        },
        {
            "trigger": "qdistance(q1, q2)",
            "contents": "qdistance(${1:q1}, ${2:q2})",
            "kind": "function",
            "details": "Finds distance between two quaternions"
        },
        {
            "trigger": "qinvert(quaternion)",
            "contents": "qinvert(${1:quaternion})",
            "kind": "function",
            "details": "Inverts a quaternion rotation"
        },
        {
            "trigger": "qmultiply(q1, q2)",
            "contents": "qmultiply(${1:q1}, ${2:q2})",
            "kind": "function",
            "details": "Multiplies two quaternions and returns the result"
        },
        {
            "trigger": "qrotate(quaternion, v)",
            "contents": "qrotate(${1:quaternion}, ${2:v})",
            "kind": "function",
            "details": "Rotates a vector by a quaternion"
        },
        {
            "trigger": "quaternion(rotations)",
            "contents": "quaternion(${1:rotations})",
            "kind": "function",
            "details": "Creates a vector4 representing a quaternion"
        },
        {
            "trigger": "quaternion(angle, axis)",
            "contents": "quaternion(${1:angle}, ${2:axis})",
            "kind": "function",
            "details": "Creates a vector4 representing a quaternion"
        },
        {
            "trigger": "quaternion(angleaxis)",
            "contents": "quaternion(${1:angleaxis})",
            "kind": "function",
            "details": "Creates a vector4 representing a quaternion"
        },
        {
            "trigger": "quaterniontoeuler(orient, order)",
            "contents": "quaterniontoeuler(${1:orient}, ${2:order})",
            "kind": "function",
            "details": "Creates a euler angle representing a quaternion"
        },
        {
            "trigger": "radians(angle_in_degrees)",
            "contents": "radians(${1:angle_in_degrees})",
            "kind": "function",
            "details": "Converts the argument from degrees into radians"
        },
        {
            "trigger": "radians(nums_in_degs)",
            "contents": "radians(${1:nums_in_degs})",
            "kind": "function",
            "details": "Converts the argument from degrees into radians"
        },
        {
            "trigger": "ramp_lookup(pos, ramp)",
            "contents": "ramp_lookup(${1:pos}, ${2:ramp})",
            "kind": "function",
            "details": "Evaluates a Houdini-style ramp at a specific location"
        },
        {
            "trigger": "ramp_lookup(pos, basis, key, val)",
            "contents": "ramp_lookup(${1:pos}, ${2:basis}, ${3:key}, ${4:val})",
            "kind": "function",
            "details": "Evaluates a Houdini-style ramp at a specific location"
        },
        {
            "trigger": "ramp_pack(basis, pos, value)",
            "contents": "ramp_pack(${1:basis}, ${2:pos}, ${3:value})",
            "kind": "function",
            "details": "Packs a set of arrays into a string-encoded ramp"
        },
        {
            "trigger": "ramp_unpack(ramp, basis, pos, value)",
            "contents": "ramp_unpack(${1:ramp}, ${2:basis}, ${3:pos}, ${4:value})",
            "kind": "function",
            "details": "Unpacks a string-encoded ramp into a set of arrays"
        },
        {
            "trigger": "rand(seed)",
            "contents": "rand(${1:seed})",
            "kind": "function",
            "details": "Creates a random number between 0 and 1 from a seed"
        },
        {
            "trigger": "rand(seed, seed2)",
            "contents": "rand(${1:seed}, ${2:seed2})",
            "kind": "function",
            "details": "Creates a random number between 0 and 1 from a seed"
        },
        {
            "trigger": "random(position)",
            "contents": "random(${1:position})",
            "kind": "function",
            "details": "Generate a random number based on the integer position in 1-4D space"
        },
        {
            "trigger": "random(xpos, ypos)",
            "contents": "random(${1:xpos}, ${2:ypos})",
            "kind": "function",
            "details": "Generate a random number based on the integer position in 1-4D space"
        },
        {
            "trigger": "random_brj(seed, offset)",
            "contents": "random_brj(${1:seed}, ${2:offset})",
            "kind": "function",
            "details": "Generate a uniformly distributed random number"
        },
        {
            "trigger": "random_fhash(seed)",
            "contents": "random_fhash(${1:seed})",
            "kind": "function",
            "details": "Hashes floating point numbers to integers"
        },
        {
            "trigger": "random_fhash(seed, seed2)",
            "contents": "random_fhash(${1:seed}, ${2:seed2})",
            "kind": "function",
            "details": "Hashes floating point numbers to integers"
        },
        {
            "trigger": "random_ihash(seed)",
            "contents": "random_ihash(${1:seed})",
            "kind": "function",
            "details": "Hashes integer numbers to integers"
        },
        {
            "trigger": "random_poisson(seed, mean)",
            "contents": "random_poisson(${1:seed}, ${2:mean})",
            "kind": "function",
            "details": "Generates a random Poisson variable given the mean to the distribution and a seed"
        },
        {
            "trigger": "random_poisson(seed, mean, minvalue, maxvalue)",
            "contents": "random_poisson(${1:seed}, ${2:mean}, ${3:minvalue}, ${4:maxvalue})",
            "kind": "function",
            "details": "Generates a random Poisson variable given the mean to the distribution and a seed"
        },
        {
            "trigger": "random_shash(seed)",
            "contents": "random_shash(${1:seed})",
            "kind": "function",
            "details": "Hashes a string to an integer"
        },
        {
            "trigger": "random_sobol(seed, offset)",
            "contents": "random_sobol(${1:seed}, ${2:offset})",
            "kind": "function",
            "details": "Generate a uniformly distributed random number"
        },
        {
            "trigger": "rawcolormap(filename, uvw, ...)",
            "contents": "rawcolormap(${1:filename}, ${2:uvw}, ${3:...})",
            "kind": "function",
            "details": "Looks up an unfiltered color from a texture file"
        },
        {
            "trigger": "rawcolormap(filename, u, v, ...)",
            "contents": "rawcolormap(${1:filename}, ${2:u}, ${3:v}, ${4:...})",
            "kind": "function",
            "details": "Looks up an unfiltered color from a texture file"
        },
        {
            "trigger": "rawcolormap(filename, uv, du, dv, samples, ...)",
            "contents": "rawcolormap(${1:filename}, ${2:uv}, ${3:du}, ${4:dv}, ${5:samples}, ${6:...})",
            "kind": "function",
            "details": "Looks up an unfiltered color from a texture file"
        },
        {
            "trigger": "rawcolormap(filename, uv0, uv1, uv2, uv3, ...)",
            "contents": "rawcolormap(${1:filename}, ${2:uv0}, ${3:uv1}, ${4:uv2}, ${5:uv3}, ${6:...})",
            "kind": "function",
            "details": "Looks up an unfiltered color from a texture file"
        },
        {
            "trigger": "rawcolormap(filename, uv0, uv1, uv2, uv3, samples, ...)",
            "contents": "rawcolormap(${1:filename}, ${2:uv0}, ${3:uv1}, ${4:uv2}, ${5:uv3}, ${6:samples}, ${7:...})",
            "kind": "function",
            "details": "Looks up an unfiltered color from a texture file"
        },
        {
            "trigger": "rawcolormap(filename, u0, v0, u1, v1, u2, v2, u3, v3, samples, ...)",
            "contents": "rawcolormap(${1:filename}, ${2:u0}, ${3:v0}, ${4:u1}, ${5:v1}, ${6:u2}, ${7:v2}, ${8:u3}, ${9:v3}, ${10:samples}, ${11:...})",
            "kind": "function",
            "details": "Looks up an unfiltered color from a texture file"
        },
        {
            "trigger": "rayhittest(P, D, bias, ...)",
            "contents": "rayhittest(${1:P}, ${2:D}, ${3:bias}, ${4:...})",
            "kind": "function",
            "details": "Sends a ray from the position P along the direction D"
        },
        {
            "trigger": "rayhittest(P, D, pHit, nHit, bias, ...)",
            "contents": "rayhittest(${1:P}, ${2:D}, ${3:pHit}, ${4:nHit}, ${5:bias}, ${6:...})",
            "kind": "function",
            "details": "Sends a ray from the position P along the direction D"
        },
        {
            "trigger": "rayimport(name, value)",
            "contents": "rayimport(${1:name}, ${2:value})",
            "kind": "function",
            "details": "Imports a value sent by a shader in a gather loop"
        },
        {
            "trigger": "reflect(direction, normal)",
            "contents": "reflect(${1:direction}, ${2:normal})",
            "kind": "function",
            "details": "Returns the vector representing the reflection of the direction against the normal"
        },
        {
            "trigger": "reflectlight(bias, max_contrib, ...)",
            "contents": "reflectlight(${1:bias}, ${2:max_contrib}, ${3:...})",
            "kind": "function",
            "details": "Computes the amount of reflected light which hits the surface"
        },
        {
            "trigger": "reflectlight(P, D, bias, max_contrib, ...)",
            "contents": "reflectlight(${1:P}, ${2:D}, ${3:bias}, ${4:max_contrib}, ${5:...})",
            "kind": "function",
            "details": "Computes the amount of reflected light which hits the surface"
        },
        {
            "trigger": "reflectlight(P, N, I, bias, max_contrib, ...)",
            "contents": "reflectlight(${1:P}, ${2:N}, ${3:I}, ${4:bias}, ${5:max_contrib}, ${6:...})",
            "kind": "function",
            "details": "Computes the amount of reflected light which hits the surface"
        },
        {
            "trigger": "refract(direction, normal, index)",
            "contents": "refract(${1:direction}, ${2:normal}, ${3:index})",
            "kind": "function",
            "details": "Returns the refraction ray given an incoming direction, the normalized normal and an index of refraction"
        },
        {
            "trigger": "refractlight(cf, of, af, P, D, bias, max_contrib, ...)",
            "contents": "refractlight(${1:cf}, ${2:of}, ${3:af}, ${4:P}, ${5:D}, ${6:bias}, ${7:max_contrib}, ${8:...})",
            "kind": "function",
            "details": "Computes the illumination of surfaces refracted by the current surface"
        },
        {
            "trigger": "refractlight(cf, of, af, P, N, I, eta, bias, max_contrib, ...)",
            "contents": "refractlight(${1:cf}, ${2:of}, ${3:af}, ${4:P}, ${5:N}, ${6:I}, ${7:eta}, ${8:bias}, ${9:max_contrib}, ${10:...})",
            "kind": "function",
            "details": "Computes the illumination of surfaces refracted by the current surface"
        },
        {
            "trigger": "relativepath(src, dest)",
            "contents": "relativepath(${1:src}, ${2:dest})",
            "kind": "function",
            "details": "Computes the relative path for two full paths"
        },
        {
            "trigger": "relbbox(geometry, position)",
            "contents": "relbbox(${1:geometry}, ${2:position})",
            "kind": "function",
            "details": "Returns the relative position of the point given with respect to the bounding box of the geometry"
        },
        {
            "trigger": "relbbox(geometry, primgroup, position)",
            "contents": "relbbox(${1:geometry}, ${2:primgroup}, ${3:position})",
            "kind": "function",
            "details": "Returns the relative position of the point given with respect to the bounding box of the geometry"
        },
        {
            "trigger": "relbbox(position)",
            "contents": "relbbox(${1:position})",
            "kind": "function",
            "details": "Returns the relative position of the point given with respect to the bounding box of the geometry"
        },
        {
            "trigger": "relpath(abspath)",
            "contents": "relpath(${1:abspath})",
            "kind": "function",
            "details": "Returns the relative path to a file"
        },
        {
            "trigger": "relpointbbox(geometry, position)",
            "contents": "relpointbbox(${1:geometry}, ${2:position})",
            "kind": "function",
            "details": "Returns the relative position of the point given with respect to the bounding box of the geometry"
        },
        {
            "trigger": "relpointbbox(geometry, pointgroup, position)",
            "contents": "relpointbbox(${1:geometry}, ${2:pointgroup}, ${3:position})",
            "kind": "function",
            "details": "Returns the relative position of the point given with respect to the bounding box of the geometry"
        },
        {
            "trigger": "removeattrib(geohandle, attribclass, name)",
            "contents": "removeattrib(${1:geohandle}, ${2:attribclass}, ${3:name})",
            "kind": "function",
            "details": "Removes an attribute or group from the geometry"
        },
        {
            "trigger": "removedetailattrib(geohandle, name)",
            "contents": "removedetailattrib(${1:geohandle}, ${2:name})",
            "kind": "function",
            "details": "Removes a detail attribute from a geometry"
        },
        {
            "trigger": "removeindex(array, index)",
            "contents": "removeindex(${1:array}, ${2:index})",
            "kind": "function",
            "details": "Removes an item at the given index from an array"
        },
        {
            "trigger": "removeindex(dictionary, index)",
            "contents": "removeindex(${1:dictionary}, ${2:index})",
            "kind": "function",
            "details": "Removes an item at the given index from an array"
        },
        {
            "trigger": "removepoint(geohandle, point_number)",
            "contents": "removepoint(${1:geohandle}, ${2:point_number})",
            "kind": "function",
            "details": "Removes a point from the geometry"
        },
        {
            "trigger": "removepoint(geohandle, point_number, and_prims)",
            "contents": "removepoint(${1:geohandle}, ${2:point_number}, ${3:and_prims})",
            "kind": "function",
            "details": "Removes a point from the geometry"
        },
        {
            "trigger": "removepointattrib(geohandle, name)",
            "contents": "removepointattrib(${1:geohandle}, ${2:name})",
            "kind": "function",
            "details": "Removes a point attribute from a geometry"
        },
        {
            "trigger": "removepointgroup(geohandle, name)",
            "contents": "removepointgroup(${1:geohandle}, ${2:name})",
            "kind": "function",
            "details": "Removes a point group from a geometry"
        },
        {
            "trigger": "removeprim(geohandle, prim_number, andpoints)",
            "contents": "removeprim(${1:geohandle}, ${2:prim_number}, ${3:andpoints})",
            "kind": "function",
            "details": "Removes a primitive from the geometry"
        },
        {
            "trigger": "removeprimattrib(geohandle, name)",
            "contents": "removeprimattrib(${1:geohandle}, ${2:name})",
            "kind": "function",
            "details": "Removes a primitive attribute from a geometry"
        },
        {
            "trigger": "removeprimgroup(geohandle, name)",
            "contents": "removeprimgroup(${1:geohandle}, ${2:name})",
            "kind": "function",
            "details": "Removes a primitive group from a geometry"
        },
        {
            "trigger": "removevalue(array, value)",
            "contents": "removevalue(${1:array}, ${2:value})",
            "kind": "function",
            "details": "Removes an item from an array"
        },
        {
            "trigger": "removevertex(geohandle, linear_vertex_index)",
            "contents": "removevertex(${1:geohandle}, ${2:linear_vertex_index})",
            "kind": "function",
            "details": "Removes a vertex from the geometry"
        },
        {
            "trigger": "removevertexattrib(geohandle, name)",
            "contents": "removevertexattrib(${1:geohandle}, ${2:name})",
            "kind": "function",
            "details": "Removes a vertex attribute from a geometry"
        },
        {
            "trigger": "removevertexgroup(geohandle, name)",
            "contents": "removevertexgroup(${1:geohandle}, ${2:name})",
            "kind": "function",
            "details": "Removes a vertex group from a geometry"
        },
        {
            "trigger": "renderstate(query, value)",
            "contents": "renderstate(${1:query}, ${2:value})",
            "kind": "function",
            "details": "Queries the renderer for a named property"
        },
        {
            "trigger": "renderstate(mat, query, value)",
            "contents": "renderstate(${1:mat}, ${2:query}, ${3:value})",
            "kind": "function",
            "details": "Queries the renderer for a named property"
        },
        {
            "trigger": "reorder(value, indices)",
            "contents": "reorder(${1:value}, ${2:indices})",
            "kind": "function",
            "details": "Reorders items in an array or string"
        },
        {
            "trigger": "reorder(values, indices)",
            "contents": "reorder(${1:values}, ${2:indices})",
            "kind": "function",
            "details": "Reorders items in an array or string"
        },
        {
            "trigger": "replace(str, old, new)",
            "contents": "replace(${1:str}, ${2:old}, ${3:new})",
            "kind": "function",
            "details": "Replaces occurrences of a substring"
        },
        {
            "trigger": "replace(str, old, new, count)",
            "contents": "replace(${1:str}, ${2:old}, ${3:new}, ${4:count})",
            "kind": "function",
            "details": "Replaces occurrences of a substring"
        },
        {
            "trigger": "replace_match(str, pattern_from, pattern_to)",
            "contents": "replace_match(${1:str}, ${2:pattern_from}, ${3:pattern_to})",
            "kind": "function",
            "details": "Replaces the matched string pattern with another pattern"
        },
        {
            "trigger": "resample_linear(input, new_length)",
            "contents": "resample_linear(${1:input}, ${2:new_length})",
            "kind": "function"
        },
        {
            "trigger": "resize(array, size)",
            "contents": "resize(${1:array}, ${2:size})",
            "kind": "function",
            "details": "Sets the length of an array"
        },
        {
            "trigger": "resize(array, size, val)",
            "contents": "resize(${1:array}, ${2:size}, ${3:val})",
            "kind": "function",
            "details": "Sets the length of an array"
        },
        {
            "trigger": "resolvemissedray(dir, time, mask, ...)",
            "contents": "resolvemissedray(${1:dir}, ${2:time}, ${3:mask}, ${4:...})",
            "kind": "function",
            "details": "Returns the background color for rays that exit the scene"
        },
        {
            "trigger": "reverse(str)",
            "contents": "reverse(${1:str})",
            "kind": "function",
            "details": "Returns an array or string in reverse order"
        },
        {
            "trigger": "reverse(values)",
            "contents": "reverse(${1:values})",
            "kind": "function",
            "details": "Returns an array or string in reverse order"
        },
        {
            "trigger": "re_find(regex, input)",
            "contents": "re_find(${1:regex}, ${2:input})",
            "kind": "function",
            "details": "Matches a regular expression in a string"
        },
        {
            "trigger": "re_find(regex, input, start)",
            "contents": "re_find(${1:regex}, ${2:input}, ${3:start})",
            "kind": "function",
            "details": "Matches a regular expression in a string"
        },
        {
            "trigger": "re_find(regex, input, start, end)",
            "contents": "re_find(${1:regex}, ${2:input}, ${3:start}, ${4:end})",
            "kind": "function",
            "details": "Matches a regular expression in a string"
        },
        {
            "trigger": "re_find(start_pos, end_pos, regex, input)",
            "contents": "re_find(${1:start_pos}, ${2:end_pos}, ${3:regex}, ${4:input})",
            "kind": "function",
            "details": "Matches a regular expression in a string"
        },
        {
            "trigger": "re_find(start_pos, end_pos, regex, input, start)",
            "contents": "re_find(${1:start_pos}, ${2:end_pos}, ${3:regex}, ${4:input}, ${5:start})",
            "kind": "function",
            "details": "Matches a regular expression in a string"
        },
        {
            "trigger": "re_find(start_pos, end_pos, regex, input, start, end)",
            "contents": "re_find(${1:start_pos}, ${2:end_pos}, ${3:regex}, ${4:input}, ${5:start}, ${6:end})",
            "kind": "function",
            "details": "Matches a regular expression in a string"
        },
        {
            "trigger": "re_findall(regex, input)",
            "contents": "re_findall(${1:regex}, ${2:input})",
            "kind": "function",
            "details": "Finds all instances of the given regular expression in the string"
        },
        {
            "trigger": "re_findall(regex, input, start)",
            "contents": "re_findall(${1:regex}, ${2:input}, ${3:start})",
            "kind": "function",
            "details": "Finds all instances of the given regular expression in the string"
        },
        {
            "trigger": "re_findall(regex, input, start, end)",
            "contents": "re_findall(${1:regex}, ${2:input}, ${3:start}, ${4:end})",
            "kind": "function",
            "details": "Finds all instances of the given regular expression in the string"
        },
        {
            "trigger": "re_match(regex, input)",
            "contents": "re_match(${1:regex}, ${2:input})",
            "kind": "function",
            "details": "Returns 1 if the entire input string matches the expression"
        },
        {
            "trigger": "re_replace(regex, replacement, input, maxreplace)",
            "contents": "re_replace(${1:regex}, ${2:replacement}, ${3:input}, ${4:maxreplace})",
            "kind": "function",
            "details": "Replaces instances of regex_find with regex_replace"
        },
        {
            "trigger": "re_split(regex, input, maxsplits)",
            "contents": "re_split(${1:regex}, ${2:input}, ${3:maxsplits})",
            "kind": "function",
            "details": "Splits the given string based on regex match"
        },
        {
            "trigger": "rgbtohsv(rgb)",
            "contents": "rgbtohsv(${1:rgb})",
            "kind": "function",
            "details": "Convert RGB color space to HSV color space"
        },
        {
            "trigger": "rgbtohsv(r, g, b)",
            "contents": "rgbtohsv(${1:r}, ${2:g}, ${3:b})",
            "kind": "function",
            "details": "Convert RGB color space to HSV color space"
        },
        {
            "trigger": "rgbtoxyz(rgb)",
            "contents": "rgbtoxyz(${1:rgb})",
            "kind": "function",
            "details": "Convert a linear sRGB triplet to CIE XYZ tristimulus values"
        },
        {
            "trigger": "rint(n)",
            "contents": "rint(${1:n})",
            "kind": "function",
            "details": "Rounds the number to the closest whole number"
        },
        {
            "trigger": "rint(v)",
            "contents": "rint(${1:v})",
            "kind": "function",
            "details": "Rounds the number to the closest whole number"
        },
        {
            "trigger": "rotate(m, amount)",
            "contents": "rotate(${1:m}, ${2:amount})",
            "kind": "function",
            "details": "Applies a rotation to the given matrix"
        },
        {
            "trigger": "rotate(m, amount, axis)",
            "contents": "rotate(${1:m}, ${2:amount}, ${3:axis})",
            "kind": "function",
            "details": "Applies a rotation to the given matrix"
        },
        {
            "trigger": "rotate(m, angles, xyz)",
            "contents": "rotate(${1:m}, ${2:angles}, ${3:xyz})",
            "kind": "function",
            "details": "Applies a rotation to the given matrix"
        },
        {
            "trigger": "rotate(m, angle, axis)",
            "contents": "rotate(${1:m}, ${2:angle}, ${3:axis})",
            "kind": "function",
            "details": "Applies a rotation to the given matrix"
        },
        {
            "trigger": "rotate_x_to(direction, v)",
            "contents": "rotate_x_to(${1:direction}, ${2:v})",
            "kind": "function",
            "details": "Rotates a vector by a rotation that would bring the x-axis to a given direction"
        },
        {
            "trigger": "rstrip(value)",
            "contents": "rstrip(${1:value})",
            "kind": "function",
            "details": "Strips trailing whitespace from a string"
        },
        {
            "trigger": "rstrip(value, whitespace)",
            "contents": "rstrip(${1:value}, ${2:whitespace})",
            "kind": "function",
            "details": "Strips trailing whitespace from a string"
        },
        {
            "trigger": "sampledisk(x, y, sx, sy)",
            "contents": "sampledisk(${1:x}, ${2:y}, ${3:sx}, ${4:sy})",
            "kind": "function",
            "details": "Warps uniform random samples to a disk"
        },
        {
            "trigger": "sample_bsdf(F, viewer_u, dir, eval, type, sx, sy, ...)",
            "contents": "sample_bsdf(${1:F}, ${2:viewer_u}, ${3:dir}, ${4:eval}, ${5:type}, ${6:sx}, ${7:sy}, ${8:...})",
            "kind": "function",
            "details": "Samples a BSDF"
        },
        {
            "trigger": "sample_bsdf(F, viewer_u, dir, eval, type, sx, sy, mask, ...)",
            "contents": "sample_bsdf(${1:F}, ${2:viewer_u}, ${3:dir}, ${4:eval}, ${5:type}, ${6:sx}, ${7:sy}, ${8:mask}, ${9:...})",
            "kind": "function",
            "details": "Samples a BSDF"
        },
        {
            "trigger": "sample_bsdf(F, viewer_u, dir, eval, pdf, type, sx, sy, ...)",
            "contents": "sample_bsdf(${1:F}, ${2:viewer_u}, ${3:dir}, ${4:eval}, ${5:pdf}, ${6:type}, ${7:sx}, ${8:sy}, ${9:...})",
            "kind": "function",
            "details": "Samples a BSDF"
        },
        {
            "trigger": "sample_bsdf(F, viewer_u, dir, eval, pdf, type, sx, sy, mask, ...)",
            "contents": "sample_bsdf(${1:F}, ${2:viewer_u}, ${3:dir}, ${4:eval}, ${5:pdf}, ${6:type}, ${7:sx}, ${8:sy}, ${9:mask}, ${10:...})",
            "kind": "function",
            "details": "Samples a BSDF"
        },
        {
            "trigger": "sample_bsdf(b, viewer_u, normal_v, flags, dir, eval, pdf, type, sx, sy, mask, ...)",
            "contents": "sample_bsdf(${1:b}, ${2:viewer_u}, ${3:normal_v}, ${4:flags}, ${5:dir}, ${6:eval}, ${7:pdf}, ${8:type}, ${9:sx}, ${10:sy}, ${11:mask}, ${12:...})",
            "kind": "function",
            "details": "Samples a BSDF"
        },
        {
            "trigger": "sample_cauchy(u)",
            "contents": "sample_cauchy(${1:u})",
            "kind": "function",
            "details": "Samples the Cauchy (Lorentz) distribution"
        },
        {
            "trigger": "sample_cauchy(scale, u)",
            "contents": "sample_cauchy(${1:scale}, ${2:u})",
            "kind": "function",
            "details": "Samples the Cauchy (Lorentz) distribution"
        },
        {
            "trigger": "sample_cauchy(origscale, minvalue, maxvalue, u)",
            "contents": "sample_cauchy(${1:origscale}, ${2:minvalue}, ${3:maxvalue}, ${4:u})",
            "kind": "function",
            "details": "Samples the Cauchy (Lorentz) distribution"
        },
        {
            "trigger": "sample_cdf(cdf, uniform_rand)",
            "contents": "sample_cdf(${1:cdf}, ${2:uniform_rand})",
            "kind": "function",
            "details": "Samples a cumulative distribution function (CDF)"
        },
        {
            "trigger": "sample_cdf(cdf, uniform_rand, index, x)",
            "contents": "sample_cdf(${1:cdf}, ${2:uniform_rand}, ${3:index}, ${4:x})",
            "kind": "function",
            "details": "Samples a cumulative distribution function (CDF)"
        },
        {
            "trigger": "sample_cdf(cdf, uniform_rand, index, x, pdf)",
            "contents": "sample_cdf(${1:cdf}, ${2:uniform_rand}, ${3:index}, ${4:x}, ${5:pdf})",
            "kind": "function",
            "details": "Samples a cumulative distribution function (CDF)"
        },
        {
            "trigger": "sample_circle_arc(center, maxangle, u)",
            "contents": "sample_circle_arc(${1:center}, ${2:maxangle}, ${3:u})",
            "kind": "function",
            "details": "Generates a uniform unit vector2, within maxangle of center, given a uniform number between 0 and 1"
        },
        {
            "trigger": "sample_circle_edge_uniform(u)",
            "contents": "sample_circle_edge_uniform(${1:u})",
            "kind": "function",
            "details": "Generates a uniform unit vector2, given a uniform number between 0 and 1"
        },
        {
            "trigger": "sample_circle_ring_uniform(u, alpha)",
            "contents": "sample_circle_ring_uniform(${1:u}, ${2:alpha})",
            "kind": "function",
            "details": "Generates a uniform vector2 with alpha < length < 1, where 0 < alpha < 1, given a vector2 of uniform numbers between 0 and 1"
        },
        {
            "trigger": "sample_circle_slice(center, maxangle, u)",
            "contents": "sample_circle_slice(${1:center}, ${2:maxangle}, ${3:u})",
            "kind": "function",
            "details": "Generates a uniform vector2 with length < 1, within maxangle of center, given a vector2 of uniform numbers between 0 and 1"
        },
        {
            "trigger": "sample_circle_uniform(u)",
            "contents": "sample_circle_uniform(${1:u})",
            "kind": "function",
            "details": "Generates a uniform vector2 with length < 1, given a vector2 of uniform numbers between 0 and 1"
        },
        {
            "trigger": "sample_direction_cone(center, maxangle, u)",
            "contents": "sample_direction_cone(${1:center}, ${2:maxangle}, ${3:u})",
            "kind": "function",
            "details": "Generates a uniform unit vector, within maxangle of center, given a vector2 of uniform numbers between 0 and 1"
        },
        {
            "trigger": "sample_direction_uniform(u)",
            "contents": "sample_direction_uniform(${1:u})",
            "kind": "function",
            "details": "Generates a uniform unit vector, given a vector2 of uniform numbers between 0 and 1"
        },
        {
            "trigger": "sample_discrete(nvalues, u)",
            "contents": "sample_discrete(${1:nvalues}, ${2:u})",
            "kind": "function",
            "details": "Returns an integer, either uniform or weighted, given a uniform number between 0 and 1"
        },
        {
            "trigger": "sample_discrete(weights, u)",
            "contents": "sample_discrete(${1:weights}, ${2:u})",
            "kind": "function",
            "details": "Returns an integer, either uniform or weighted, given a uniform number between 0 and 1"
        },
        {
            "trigger": "sample_exponential(u)",
            "contents": "sample_exponential(${1:u})",
            "kind": "function",
            "details": "Samples the exponential distribution"
        },
        {
            "trigger": "sample_exponential(mean, u)",
            "contents": "sample_exponential(${1:mean}, ${2:u})",
            "kind": "function",
            "details": "Samples the exponential distribution"
        },
        {
            "trigger": "sample_exponential(origmean, maxvalue, u)",
            "contents": "sample_exponential(${1:origmean}, ${2:maxvalue}, ${3:u})",
            "kind": "function",
            "details": "Samples the exponential distribution"
        },
        {
            "trigger": "sample_geometry(origin, sample, time, ...)",
            "contents": "sample_geometry(${1:origin}, ${2:sample}, ${3:time}, ${4:...})",
            "kind": "function",
            "details": "Samples geometry in the scene and returns information from the shaders of surfaces that were sampled"
        },
        {
            "trigger": "sample_hemisphere(u)",
            "contents": "sample_hemisphere(${1:u})",
            "kind": "function",
            "details": "Generates a unit vector, optionally biased, within a hemisphere, given a vector2 of uniform numbers between 0 and 1"
        },
        {
            "trigger": "sample_hemisphere(center, u)",
            "contents": "sample_hemisphere(${1:center}, ${2:u})",
            "kind": "function",
            "details": "Generates a unit vector, optionally biased, within a hemisphere, given a vector2 of uniform numbers between 0 and 1"
        },
        {
            "trigger": "sample_hemisphere(bias, u)",
            "contents": "sample_hemisphere(${1:bias}, ${2:u})",
            "kind": "function",
            "details": "Generates a unit vector, optionally biased, within a hemisphere, given a vector2 of uniform numbers between 0 and 1"
        },
        {
            "trigger": "sample_hemisphere(center, bias, u)",
            "contents": "sample_hemisphere(${1:center}, ${2:bias}, ${3:u})",
            "kind": "function",
            "details": "Generates a unit vector, optionally biased, within a hemisphere, given a vector2 of uniform numbers between 0 and 1"
        },
        {
            "trigger": "sample_hypersphere_cone(center, maxangle, u)",
            "contents": "sample_hypersphere_cone(${1:center}, ${2:maxangle}, ${3:u})",
            "kind": "function",
            "details": "Generates a uniform vector4 with length < 1, within maxangle of center, given a vector4 of uniform numbers between 0 and 1"
        },
        {
            "trigger": "sample_hypersphere_uniform(u)",
            "contents": "sample_hypersphere_uniform(${1:u})",
            "kind": "function",
            "details": "Generates a uniform vector4 with length < 1, given a vector4 of uniform numbers between 0 and 1"
        },
        {
            "trigger": "sample_light(lightid, pos, sam, time, pos, clr, scale, ...)",
            "contents": "sample_light(${1:lightid}, ${2:pos}, ${3:sam}, ${4:time}, ${5:pos}, ${6:clr}, ${7:scale}, ${8:...})",
            "kind": "function",
            "details": "Samples a 3D position on a light source and runs the light shader at that point"
        },
        {
            "trigger": "sample_lognormal(mu, sigma, u)",
            "contents": "sample_lognormal(${1:mu}, ${2:sigma}, ${3:u})",
            "kind": "function",
            "details": "Samples the log-normal distribution based on parameters of the underlying normal distribution"
        },
        {
            "trigger": "sample_lognormal(mu, sigma, minvalue, maxvalue, u)",
            "contents": "sample_lognormal(${1:mu}, ${2:sigma}, ${3:minvalue}, ${4:maxvalue}, ${5:u})",
            "kind": "function",
            "details": "Samples the log-normal distribution based on parameters of the underlying normal distribution"
        },
        {
            "trigger": "sample_lognormal_by_median(median, stddev, u)",
            "contents": "sample_lognormal_by_median(${1:median}, ${2:stddev}, ${3:u})",
            "kind": "function",
            "details": "Samples the log-normal distribution based on median and standard deviation"
        },
        {
            "trigger": "sample_lognormal_by_median(origmedian, origstddev, minvalue, maxvalue, u)",
            "contents": "sample_lognormal_by_median(${1:origmedian}, ${2:origstddev}, ${3:minvalue}, ${4:maxvalue}, ${5:u})",
            "kind": "function",
            "details": "Samples the log-normal distribution based on median and standard deviation"
        },
        {
            "trigger": "sample_normal(u)",
            "contents": "sample_normal(${1:u})",
            "kind": "function",
            "details": "Samples the normal (Gaussian) distribution"
        },
        {
            "trigger": "sample_normal(mean, stddev, u)",
            "contents": "sample_normal(${1:mean}, ${2:stddev}, ${3:u})",
            "kind": "function",
            "details": "Samples the normal (Gaussian) distribution"
        },
        {
            "trigger": "sample_normal(origmean, origstddev, minvalue, maxvalue, u)",
            "contents": "sample_normal(${1:origmean}, ${2:origstddev}, ${3:minvalue}, ${4:maxvalue}, ${5:u})",
            "kind": "function",
            "details": "Samples the normal (Gaussian) distribution"
        },
        {
            "trigger": "sample_orientation_cone(center, maxangle, u)",
            "contents": "sample_orientation_cone(${1:center}, ${2:maxangle}, ${3:u})",
            "kind": "function",
            "details": "Generates a uniform unit vector4, within maxangle of center, given a vector of uniform numbers between 0 and 1"
        },
        {
            "trigger": "sample_orientation_uniform(u)",
            "contents": "sample_orientation_uniform(${1:u})",
            "kind": "function",
            "details": "Generates a uniform unit vector4, given a vector of uniform numbers between 0 and 1"
        },
        {
            "trigger": "sample_photon(lp, pos, dir, scale, time)",
            "contents": "sample_photon(${1:lp}, ${2:pos}, ${3:dir}, ${4:scale}, ${5:time})",
            "kind": "function",
            "details": "Samples a 3D position on a light source and runs the light shader at that point"
        },
        {
            "trigger": "sample_sphere_cone(center, maxangle, u)",
            "contents": "sample_sphere_cone(${1:center}, ${2:maxangle}, ${3:u})",
            "kind": "function",
            "details": "Generates a uniform vector with length < 1, within maxangle of center, given a vector of uniform numbers between 0 and 1"
        },
        {
            "trigger": "sample_sphere_shell_uniform(u, alpha)",
            "contents": "sample_sphere_shell_uniform(${1:u}, ${2:alpha})",
            "kind": "function",
            "details": "Generates a uniform vector with alpha < length < 1, where 0 < alpha < 1, given a vector of uniform numbers between 0 and 1"
        },
        {
            "trigger": "sample_sphere_uniform(u)",
            "contents": "sample_sphere_uniform(${1:u})",
            "kind": "function",
            "details": "Generates a uniform vector with length < 1, given a vector of uniform numbers between 0 and 1"
        },
        {
            "trigger": "scale(m, scale_vector)",
            "contents": "scale(${1:m}, ${2:scale_vector})",
            "kind": "function",
            "details": "Scales the given matrix in three directions simultaneously (X, Y, Z - given by the components of the scale_vector)"
        },
        {
            "trigger": "scatter(ipoint, inormal, idirection, idistribution, time, maxdist, opoint, onormal, odirection)",
            "contents": "scatter(${1:ipoint}, ${2:inormal}, ${3:idirection}, ${4:idistribution}, ${5:time}, ${6:maxdist}, ${7:opoint}, ${8:onormal}, ${9:odirection})",
            "kind": "function",
            "details": "Evaluates a scattering event through the domain of a geometric object"
        },
        {
            "trigger": "select(conditional, a, b)",
            "contents": "select(${1:conditional}, ${2:a}, ${3:b})",
            "kind": "function",
            "details": "Returns one of two parameters based on a conditional"
        },
        {
            "trigger": "sensor_panorama_create(time, pos, size, near, far, candidateobj, includeobj, excludeobj, uselit)",
            "contents": "sensor_panorama_create(${1:time}, ${2:pos}, ${3:size}, ${4:near}, ${5:far}, ${6:candidateobj}, ${7:includeobj}, ${8:excludeobj}, ${9:uselit})",
            "kind": "function",
            "details": "Sensor function to render GL scene and query the result"
        },
        {
            "trigger": "sensor_panorama_getcolor(handle, dir)",
            "contents": "sensor_panorama_getcolor(${1:handle}, ${2:dir})",
            "kind": "function",
            "details": "Sensor function query a rendered GL scene"
        },
        {
            "trigger": "sensor_panorama_getcone(handle, lookodir, angle, colormin, colormax, depthmin, depthmax, strength, dir, color, depth)",
            "contents": "sensor_panorama_getcone(${1:handle}, ${2:lookodir}, ${3:angle}, ${4:colormin}, ${5:colormax}, ${6:depthmin}, ${7:depthmax}, ${8:strength}, ${9:dir}, ${10:color}, ${11:depth})",
            "kind": "function",
            "details": "Sensor function to query average values from rendered GL scene"
        },
        {
            "trigger": "sensor_panorama_getdepth(handle, dir)",
            "contents": "sensor_panorama_getdepth(${1:handle}, ${2:dir})",
            "kind": "function",
            "details": "Sensor function query a rendered GL scene"
        },
        {
            "trigger": "sensor_save(handle, colorfile, depthfile)",
            "contents": "sensor_save(${1:handle}, ${2:colorfile}, ${3:depthfile})",
            "kind": "function",
            "details": "Sensor function to save a rendered GL scene"
        },
        {
            "trigger": "serialize(vectors)",
            "contents": "serialize(${1:vectors})",
            "kind": "function",
            "details": "Flattens an array of vector or matrix types into an array of floats"
        },
        {
            "trigger": "serialize(matrices)",
            "contents": "serialize(${1:matrices})",
            "kind": "function",
            "details": "Flattens an array of vector or matrix types into an array of floats"
        },
        {
            "trigger": "set(v1, v2)",
            "contents": "set(${1:v1}, ${2:v2})",
            "kind": "function",
            "details": "Creates a new value based on its arguments, such as creating a vector from its components"
        },
        {
            "trigger": "set(v1, v2, v3)",
            "contents": "set(${1:v1}, ${2:v2}, ${3:v3})",
            "kind": "function",
            "details": "Creates a new value based on its arguments, such as creating a vector from its components"
        },
        {
            "trigger": "set(v1, v2, v3, v4)",
            "contents": "set(${1:v1}, ${2:v2}, ${3:v3}, ${4:v4})",
            "kind": "function",
            "details": "Creates a new value based on its arguments, such as creating a vector from its components"
        },
        {
            "trigger": "set(v1, v2, v4, v4, v5, v6, v7, v8, v9)",
            "contents": "set(${1:v1}, ${2:v2}, ${3:v4}, ${4:v4}, ${5:v5}, ${6:v6}, ${7:v7}, ${8:v8}, ${9:v9})",
            "kind": "function",
            "details": "Creates a new value based on its arguments, such as creating a vector from its components"
        },
        {
            "trigger": "set(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16)",
            "contents": "set(${1:v1}, ${2:v2}, ${3:v3}, ${4:v4}, ${5:v5}, ${6:v6}, ${7:v7}, ${8:v8}, ${9:v9}, ${10:v10}, ${11:v11}, ${12:v12}, ${13:v13}, ${14:v14}, ${15:v15}, ${16:v16})",
            "kind": "function",
            "details": "Creates a new value based on its arguments, such as creating a vector from its components"
        },
        {
            "trigger": "set(nums)",
            "contents": "set(${1:nums})",
            "kind": "function",
            "details": "Creates a new value based on its arguments, such as creating a vector from its components"
        },
        {
            "trigger": "set(v)",
            "contents": "set(${1:v})",
            "kind": "function",
            "details": "Creates a new value based on its arguments, such as creating a vector from its components"
        },
        {
            "trigger": "set(row1, row2)",
            "contents": "set(${1:row1}, ${2:row2})",
            "kind": "function",
            "details": "Creates a new value based on its arguments, such as creating a vector from its components"
        },
        {
            "trigger": "set(row1, row2, row3)",
            "contents": "set(${1:row1}, ${2:row2}, ${3:row3})",
            "kind": "function",
            "details": "Creates a new value based on its arguments, such as creating a vector from its components"
        },
        {
            "trigger": "set(row1, row2, row3, row4)",
            "contents": "set(${1:row1}, ${2:row2}, ${3:row3}, ${4:row4})",
            "kind": "function",
            "details": "Creates a new value based on its arguments, such as creating a vector from its components"
        },
        {
            "trigger": "set(rows)",
            "contents": "set(${1:rows})",
            "kind": "function",
            "details": "Creates a new value based on its arguments, such as creating a vector from its components"
        },
        {
            "trigger": "set(m)",
            "contents": "set(${1:m})",
            "kind": "function",
            "details": "Creates a new value based on its arguments, such as creating a vector from its components"
        },
        {
            "trigger": "set(vs)",
            "contents": "set(${1:vs})",
            "kind": "function",
            "details": "Creates a new value based on its arguments, such as creating a vector from its components"
        },
        {
            "trigger": "set(num)",
            "contents": "set(${1:num})",
            "kind": "function",
            "details": "Creates a new value based on its arguments, such as creating a vector from its components"
        },
        {
            "trigger": "set(key, ...)",
            "contents": "set(${1:key}, ${2:...})",
            "kind": "function",
            "details": "Creates a new value based on its arguments, such as creating a vector from its components"
        },
        {
            "trigger": "setagentchannelvalue(geohandle, prim, value, channel)",
            "contents": "setagentchannelvalue(${1:geohandle}, ${2:prim}, ${3:value}, ${4:channel})",
            "kind": "function",
            "details": "Overrides the value of an agent primitive\u2019s channel"
        },
        {
            "trigger": "setagentchannelvalues(geohandle, prim, values)",
            "contents": "setagentchannelvalues(${1:geohandle}, ${2:prim}, ${3:values})",
            "kind": "function",
            "details": "Overrides the values of an agent primitive\u2019s channels"
        },
        {
            "trigger": "setagentclipnames(geohandle, prim, clipnames)",
            "contents": "setagentclipnames(${1:geohandle}, ${2:prim}, ${3:clipnames})",
            "kind": "function",
            "details": "Sets the current animation clips for an agent primitive"
        },
        {
            "trigger": "setagentclips(geohandle, prim, clip_names, clip_times, clip_weights, clip_transform_groups, clip_layer_ids, layer_blend_modes, layer_weights, layer_parent_ids)",
            "contents": "setagentclips(${1:geohandle}, ${2:prim}, ${3:clip_names}, ${4:clip_times}, ${5:clip_weights}, ${6:clip_transform_groups}, ${7:clip_layer_ids}, ${8:layer_blend_modes}, ${9:layer_weights}, ${10:layer_parent_ids})",
            "kind": "function",
            "details": "Sets the animation clips that an agent should use to compute its transforms"
        },
        {
            "trigger": "setagentclips(geohandle, prim, clip_ids, clip_times, clip_weights, clip_transform_group_ids, clip_layer_ids, layer_blend_modes, layer_weights, layer_parent_ids)",
            "contents": "setagentclips(${1:geohandle}, ${2:prim}, ${3:clip_ids}, ${4:clip_times}, ${5:clip_weights}, ${6:clip_transform_group_ids}, ${7:clip_layer_ids}, ${8:layer_blend_modes}, ${9:layer_weights}, ${10:layer_parent_ids})",
            "kind": "function",
            "details": "Sets the animation clips that an agent should use to compute its transforms"
        },
        {
            "trigger": "setagentcliptimes(geohandle, prim, cliptimes)",
            "contents": "setagentcliptimes(${1:geohandle}, ${2:prim}, ${3:cliptimes})",
            "kind": "function",
            "details": "Sets the current times for an agent primitive\u2019s animation clips"
        },
        {
            "trigger": "setagentclipweights(geohandle, prim, clipweights)",
            "contents": "setagentclipweights(${1:geohandle}, ${2:prim}, ${3:clipweights})",
            "kind": "function",
            "details": "Sets the blend weights for an agent primitive\u2019s animation clips"
        },
        {
            "trigger": "setagentcollisionlayer(geohandle, prim, layername)",
            "contents": "setagentcollisionlayer(${1:geohandle}, ${2:prim}, ${3:layername})",
            "kind": "function",
            "details": "Sets the collision layer of an agent primitive"
        },
        {
            "trigger": "setagentcollisionlayers(geohandle, prim, layernames)",
            "contents": "setagentcollisionlayers(${1:geohandle}, ${2:prim}, ${3:layernames})",
            "kind": "function",
            "details": "Sets the collision layers of an agent primitive"
        },
        {
            "trigger": "setagentcollisionlayers(geohandle, prim, layer_ids)",
            "contents": "setagentcollisionlayers(${1:geohandle}, ${2:prim}, ${3:layer_ids})",
            "kind": "function",
            "details": "Sets the collision layers of an agent primitive"
        },
        {
            "trigger": "setagentcurrentlayer(geohandle, prim, layername)",
            "contents": "setagentcurrentlayer(${1:geohandle}, ${2:prim}, ${3:layername})",
            "kind": "function",
            "details": "Sets the current layer of an agent primitive"
        },
        {
            "trigger": "setagentcurrentlayers(geohandle, prim, layernames)",
            "contents": "setagentcurrentlayers(${1:geohandle}, ${2:prim}, ${3:layernames})",
            "kind": "function",
            "details": "Sets the current display layers of an agent primitive"
        },
        {
            "trigger": "setagentcurrentlayers(geohandle, prim, layer_ids)",
            "contents": "setagentcurrentlayers(${1:geohandle}, ${2:prim}, ${3:layer_ids})",
            "kind": "function",
            "details": "Sets the current display layers of an agent primitive"
        },
        {
            "trigger": "setagentlocaltransform(geohandle, prim, transform, index)",
            "contents": "setagentlocaltransform(${1:geohandle}, ${2:prim}, ${3:transform}, ${4:index})",
            "kind": "function",
            "details": "Overrides the local space transform of an agent primitive\u2019s bone"
        },
        {
            "trigger": "setagentlocaltransforms(geohandle, prim, transforms)",
            "contents": "setagentlocaltransforms(${1:geohandle}, ${2:prim}, ${3:transforms})",
            "kind": "function",
            "details": "Overrides the local space transforms of an agent primitive"
        },
        {
            "trigger": "setagentworldtransform(geohandle, prim, transform, index)",
            "contents": "setagentworldtransform(${1:geohandle}, ${2:prim}, ${3:transform}, ${4:index})",
            "kind": "function",
            "details": "Overrides the world space transform of an agent primitive\u2019s bone"
        },
        {
            "trigger": "setagentworldtransforms(geohandle, prim, transforms)",
            "contents": "setagentworldtransforms(${1:geohandle}, ${2:prim}, ${3:transforms})",
            "kind": "function",
            "details": "Overrides the world space transforms of an agent primitive"
        },
        {
            "trigger": "setattrib(geohandle, attribclass, attribute_name, element_num, vertex_num, value, mode)",
            "contents": "setattrib(${1:geohandle}, ${2:attribclass}, ${3:attribute_name}, ${4:element_num}, ${5:vertex_num}, ${6:value}, ${7:mode})",
            "kind": "function",
            "details": "Writes an attribute value to geometry"
        },
        {
            "trigger": "setattribtypeinfo(geohandle, attribclass, name, typeinfo)",
            "contents": "setattribtypeinfo(${1:geohandle}, ${2:attribclass}, ${3:name}, ${4:typeinfo})",
            "kind": "function",
            "details": "Sets the meaning of an attribute in geometry"
        },
        {
            "trigger": "setcomp(target, value, index)",
            "contents": "setcomp(${1:target}, ${2:value}, ${3:index})",
            "kind": "function",
            "details": "Sets a single component of a vector or matrix type, or an item in an array"
        },
        {
            "trigger": "setcomp(target, value, row, column)",
            "contents": "setcomp(${1:target}, ${2:value}, ${3:row}, ${4:column})",
            "kind": "function",
            "details": "Sets a single component of a vector or matrix type, or an item in an array"
        },
        {
            "trigger": "setcomp(array, value, index)",
            "contents": "setcomp(${1:array}, ${2:value}, ${3:index})",
            "kind": "function",
            "details": "Sets a single component of a vector or matrix type, or an item in an array"
        },
        {
            "trigger": "setcomp(array, value, i, j)",
            "contents": "setcomp(${1:array}, ${2:value}, ${3:i}, ${4:j})",
            "kind": "function",
            "details": "Sets a single component of a vector or matrix type, or an item in an array"
        },
        {
            "trigger": "setcomp(array, value, i, j, k)",
            "contents": "setcomp(${1:array}, ${2:value}, ${3:i}, ${4:j}, ${5:k})",
            "kind": "function",
            "details": "Sets a single component of a vector or matrix type, or an item in an array"
        },
        {
            "trigger": "setcomp(d, value, index)",
            "contents": "setcomp(${1:d}, ${2:value}, ${3:index})",
            "kind": "function",
            "details": "Sets a single component of a vector or matrix type, or an item in an array"
        },
        {
            "trigger": "setcurrentlight(lightid)",
            "contents": "setcurrentlight(${1:lightid})",
            "kind": "function",
            "details": "Sets the current light"
        },
        {
            "trigger": "setdetailattrib(geohandle, name, value, mode)",
            "contents": "setdetailattrib(${1:geohandle}, ${2:name}, ${3:value}, ${4:mode})",
            "kind": "function",
            "details": "Sets a detail attribute in a geometry"
        },
        {
            "trigger": "setdetailintrinsic(geohandle, name, value, mode)",
            "contents": "setdetailintrinsic(${1:geohandle}, ${2:name}, ${3:value}, ${4:mode})",
            "kind": "function",
            "details": "Sets the value of a writeable detail intrinsic attribute"
        },
        {
            "trigger": "setedgegroup(geohandle, name, pt0, pt1, value)",
            "contents": "setedgegroup(${1:geohandle}, ${2:name}, ${3:pt0}, ${4:pt1}, ${5:value})",
            "kind": "function",
            "details": "Sets edge group membership in a geometry"
        },
        {
            "trigger": "setpackedtransform(input, primnum, transform)",
            "contents": "setpackedtransform(${1:input}, ${2:primnum}, ${3:transform})",
            "kind": "function",
            "details": "Sets the transform of a packed primitive"
        },
        {
            "trigger": "setpointattrib(geohandle, name, point_num, value, mode)",
            "contents": "setpointattrib(${1:geohandle}, ${2:name}, ${3:point_num}, ${4:value}, ${5:mode})",
            "kind": "function",
            "details": "Sets a point attribute in a geometry"
        },
        {
            "trigger": "setpointgroup(geohandle, name, point_num, value, mode)",
            "contents": "setpointgroup(${1:geohandle}, ${2:name}, ${3:point_num}, ${4:value}, ${5:mode})",
            "kind": "function",
            "details": "Adds or removes a point to/from a group in a geometry"
        },
        {
            "trigger": "setpointlocaltransforms(geohandle, pnts, transforms)",
            "contents": "setpointlocaltransforms(${1:geohandle}, ${2:pnts}, ${3:transforms})",
            "kind": "function",
            "details": "Sets an array of point local transforms at the given point indices"
        },
        {
            "trigger": "setpointtransform(geohandle, pt, transform)",
            "contents": "setpointtransform(${1:geohandle}, ${2:pt}, ${3:transform})",
            "kind": "function",
            "details": "Sets the world space transform of a given point"
        },
        {
            "trigger": "setpointtransform(geohandle, pt, transform, constrain)",
            "contents": "setpointtransform(${1:geohandle}, ${2:pt}, ${3:transform}, ${4:constrain})",
            "kind": "function",
            "details": "Sets the world space transform of a given point"
        },
        {
            "trigger": "setpointtransforms(geohandle, pnts, transforms)",
            "contents": "setpointtransforms(${1:geohandle}, ${2:pnts}, ${3:transforms})",
            "kind": "function",
            "details": "Sets an array of point transforms at the given point indices"
        },
        {
            "trigger": "setpointtransforms(geohandle, pnts, transforms, constrain)",
            "contents": "setpointtransforms(${1:geohandle}, ${2:pnts}, ${3:transforms}, ${4:constrain})",
            "kind": "function",
            "details": "Sets an array of point transforms at the given point indices"
        },
        {
            "trigger": "setprimattrib(geohandle, name, prim_num, value, mode)",
            "contents": "setprimattrib(${1:geohandle}, ${2:name}, ${3:prim_num}, ${4:value}, ${5:mode})",
            "kind": "function",
            "details": "Sets a primitive attribute in a geometry"
        },
        {
            "trigger": "setprimgroup(geohandle, name, prim_num, value, mode)",
            "contents": "setprimgroup(${1:geohandle}, ${2:name}, ${3:prim_num}, ${4:value}, ${5:mode})",
            "kind": "function",
            "details": "Adds or removes a primitive to/from a group in a geometry"
        },
        {
            "trigger": "setprimintrinsic(geohandle, name, prim_num, value, mode)",
            "contents": "setprimintrinsic(${1:geohandle}, ${2:name}, ${3:prim_num}, ${4:value}, ${5:mode})",
            "kind": "function",
            "details": "Sets the value of a writeable primitive intrinsic attribute"
        },
        {
            "trigger": "setprimvertex(geohandle, prim, vtxofprim, pt)",
            "contents": "setprimvertex(${1:geohandle}, ${2:prim}, ${3:vtxofprim}, ${4:pt})",
            "kind": "function",
            "details": "Rewires a vertex in the geometry to a different point"
        },
        {
            "trigger": "setsamplestore(channel, P, value)",
            "contents": "setsamplestore(${1:channel}, ${2:P}, ${3:value})",
            "kind": "function",
            "details": "Stores sample data in a channel, referenced by a point"
        },
        {
            "trigger": "setvertexattrib(geohandle, name, prim_num, vertex_num, value, mode)",
            "contents": "setvertexattrib(${1:geohandle}, ${2:name}, ${3:prim_num}, ${4:vertex_num}, ${5:value}, ${6:mode})",
            "kind": "function",
            "details": "Sets a vertex attribute in a geometry"
        },
        {
            "trigger": "setvertexgroup(geohandle, name, prim_num, vertex_num, value, mode)",
            "contents": "setvertexgroup(${1:geohandle}, ${2:name}, ${3:prim_num}, ${4:vertex_num}, ${5:value}, ${6:mode})",
            "kind": "function",
            "details": "Adds or removes a vertex to/from a group in a geometry"
        },
        {
            "trigger": "setvertexpoint(geohandle, prim, vtxofprim, pt)",
            "contents": "setvertexpoint(${1:geohandle}, ${2:prim}, ${3:vtxofprim}, ${4:pt})",
            "kind": "function",
            "details": "Rewires a vertex in the geometry to a different point"
        },
        {
            "trigger": "shadow(Cl)",
            "contents": "shadow(${1:Cl})",
            "kind": "function",
            "details": "Calls shadow shaders for the current light source"
        },
        {
            "trigger": "shadow(Cl, P, L)",
            "contents": "shadow(${1:Cl}, ${2:P}, ${3:L})",
            "kind": "function",
            "details": "Calls shadow shaders for the current light source"
        },
        {
            "trigger": "shadowmap(filename, Pndc, spread, bias, quality, ...)",
            "contents": "shadowmap(${1:filename}, ${2:Pndc}, ${3:spread}, ${4:bias}, ${5:quality}, ${6:...})",
            "kind": "function",
            "details": "The shadowmap function will treat the shadow map as if the image were rendered from a light source"
        },
        {
            "trigger": "shadowmap(filename, Pndc1, Pndc2, Pndc3, Pndc4, spread, bias, quality, ...)",
            "contents": "shadowmap(${1:filename}, ${2:Pndc1}, ${3:Pndc2}, ${4:Pndc3}, ${5:Pndc4}, ${6:spread}, ${7:bias}, ${8:quality}, ${9:...})",
            "kind": "function",
            "details": "The shadowmap function will treat the shadow map as if the image were rendered from a light source"
        },
        {
            "trigger": "shadow_light(lightid, pos, dir, time, ...)",
            "contents": "shadow_light(${1:lightid}, ${2:pos}, ${3:dir}, ${4:time}, ${5:...})",
            "kind": "function",
            "details": "Executes the shadow shader for a given light and returns the amount of shadowing as a multiplier of the shaded color"
        },
        {
            "trigger": "shimport(variable_name, value)",
            "contents": "shimport(${1:variable_name}, ${2:value})",
            "kind": "function",
            "details": "Imports a variable from the shadow shader for the surface"
        },
        {
            "trigger": "shl(a, bits)",
            "contents": "shl(${1:a}, ${2:bits})",
            "kind": "function",
            "details": "Bit-shifts an integer left"
        },
        {
            "trigger": "shr(a, bits)",
            "contents": "shr(${1:a}, ${2:bits})",
            "kind": "function",
            "details": "Bit-shifts an integer right"
        },
        {
            "trigger": "shrz(a, bits)",
            "contents": "shrz(${1:a}, ${2:bits})",
            "kind": "function",
            "details": "Bit-shifts an integer right"
        },
        {
            "trigger": "sign(n)",
            "contents": "sign(${1:n})",
            "kind": "function",
            "details": "Returns -1, 0, or 1 depending on the sign of the argument"
        },
        {
            "trigger": "sign(v)",
            "contents": "sign(${1:v})",
            "kind": "function",
            "details": "Returns -1, 0, or 1 depending on the sign of the argument"
        },
        {
            "trigger": "simport(name, value)",
            "contents": "simport(${1:name}, ${2:value})",
            "kind": "function",
            "details": "Imports a variable sent by a surface shader in an illuminance loop"
        },
        {
            "trigger": "sin(n)",
            "contents": "sin(${1:n})",
            "kind": "function",
            "details": "Returns the sine of the argument"
        },
        {
            "trigger": "sinh(n)",
            "contents": "sinh(${1:n})",
            "kind": "function",
            "details": "Returns the hyperbolic sine of the argument"
        },
        {
            "trigger": "sinh(v)",
            "contents": "sinh(${1:v})",
            "kind": "function",
            "details": "Returns the hyperbolic sine of the argument"
        },
        {
            "trigger": "sleep(milliseconds)",
            "contents": "sleep(${1:milliseconds})",
            "kind": "function",
            "details": "Yields processing for a certain number of milliseconds"
        },
        {
            "trigger": "slerp(q1, q2, bias)",
            "contents": "slerp(${1:q1}, ${2:q2}, ${3:bias})",
            "kind": "function",
            "details": "Quaternion blend between q1 and q2 based on the bias"
        },
        {
            "trigger": "slerp(qs, weights, normalize)",
            "contents": "slerp(${1:qs}, ${2:weights}, ${3:normalize})",
            "kind": "function",
            "details": "Quaternion blend between q1 and q2 based on the bias"
        },
        {
            "trigger": "slerp(m1, m2, bias)",
            "contents": "slerp(${1:m1}, ${2:m2}, ${3:bias})",
            "kind": "function",
            "details": "Quaternion blend between q1 and q2 based on the bias"
        },
        {
            "trigger": "slerp(ms, weights, normalize)",
            "contents": "slerp(${1:ms}, ${2:weights}, ${3:normalize})",
            "kind": "function",
            "details": "Quaternion blend between q1 and q2 based on the bias"
        },
        {
            "trigger": "slerpv(v1, v2, bias)",
            "contents": "slerpv(${1:v1}, ${2:v2}, ${3:bias})",
            "kind": "function",
            "details": "Spherical blends between two vectors based on the bias"
        },
        {
            "trigger": "slice(s, start, end)",
            "contents": "slice(${1:s}, ${2:start}, ${3:end})",
            "kind": "function",
            "details": "Slices a sub-string or sub-array of a string or array"
        },
        {
            "trigger": "slice(s, start, end, step)",
            "contents": "slice(${1:s}, ${2:start}, ${3:end}, ${4:step})",
            "kind": "function",
            "details": "Slices a sub-string or sub-array of a string or array"
        },
        {
            "trigger": "slice(s, hasstart, start, hasend, end, hasstep, step)",
            "contents": "slice(${1:s}, ${2:hasstart}, ${3:start}, ${4:hasend}, ${5:end}, ${6:hasstep}, ${7:step})",
            "kind": "function",
            "details": "Slices a sub-string or sub-array of a string or array"
        },
        {
            "trigger": "slice(array, hasstart, start, hasend, end, hasstep, step)",
            "contents": "slice(${1:array}, ${2:hasstart}, ${3:start}, ${4:hasend}, ${5:end}, ${6:hasstep}, ${7:step})",
            "kind": "function",
            "details": "Slices a sub-string or sub-array of a string or array"
        },
        {
            "trigger": "slideframe(t0, t1, v0)",
            "contents": "slideframe(${1:t0}, ${2:t1}, ${3:v0})",
            "kind": "function",
            "details": "Finds the normal component of frame slid along a curve"
        },
        {
            "trigger": "slideframe(x0, t0, v0, x1, t1)",
            "contents": "slideframe(${1:x0}, ${2:t0}, ${3:v0}, ${4:x1}, ${5:t1})",
            "kind": "function",
            "details": "Finds the normal component of frame slid along a curve"
        },
        {
            "trigger": "smooth(value1, value2, amount)",
            "contents": "smooth(${1:value1}, ${2:value2}, ${3:amount})",
            "kind": "function",
            "details": "Computes ease in/out interpolation between values"
        },
        {
            "trigger": "smooth(value1, value2, amount, rolloff)",
            "contents": "smooth(${1:value1}, ${2:value2}, ${3:amount}, ${4:rolloff})",
            "kind": "function",
            "details": "Computes ease in/out interpolation between values"
        },
        {
            "trigger": "smoothrotation(order, r, r_reference)",
            "contents": "smoothrotation(${1:order}, ${2:r}, ${3:r_reference})",
            "kind": "function",
            "details": "Returns the closest equivalent Euler rotations to a reference rotation"
        },
        {
            "trigger": "snoise(pos)",
            "contents": "snoise(${1:pos})",
            "kind": "function",
            "details": "These functions are similar to wnoise"
        },
        {
            "trigger": "snoise(pos, turbulence, rough, atten)",
            "contents": "snoise(${1:pos}, ${2:turbulence}, ${3:rough}, ${4:atten})",
            "kind": "function",
            "details": "These functions are similar to wnoise"
        },
        {
            "trigger": "snoise(pos, periodX, periodY, periodZ)",
            "contents": "snoise(${1:pos}, ${2:periodX}, ${3:periodY}, ${4:periodZ})",
            "kind": "function",
            "details": "These functions are similar to wnoise"
        },
        {
            "trigger": "snoise(pos, periodX, periodY, periodZ, turbulence, rough, atten)",
            "contents": "snoise(${1:pos}, ${2:periodX}, ${3:periodY}, ${4:periodZ}, ${5:turbulence}, ${6:rough}, ${7:atten})",
            "kind": "function",
            "details": "These functions are similar to wnoise"
        },
        {
            "trigger": "solid_angle(b, mask)",
            "contents": "solid_angle(${1:b}, ${2:mask})",
            "kind": "function",
            "details": "Computes the solid angle (in steradians) a BSDF function subtends"
        },
        {
            "trigger": "solveconstraint(lengths, targetpos, tolerance, relmat, constraints)",
            "contents": "solveconstraint(${1:lengths}, ${2:targetpos}, ${3:tolerance}, ${4:relmat}, ${5:constraints})",
            "kind": "function",
            "details": "Applies an inverse kinematics algorithm to a skeleton"
        },
        {
            "trigger": "solvecubic(a, b, c, d, t1, t2, t3)",
            "contents": "solvecubic(${1:a}, ${2:b}, ${3:c}, ${4:d}, ${5:t1}, ${6:t2}, ${7:t3})",
            "kind": "function",
            "details": "Solves a cubic function returning the number of real roots"
        },
        {
            "trigger": "solvecurve(lengths, closed, orienttonormal, tangent, points, normals)",
            "contents": "solvecurve(${1:lengths}, ${2:closed}, ${3:orienttonormal}, ${4:tangent}, ${5:points}, ${6:normals})",
            "kind": "function",
            "details": "Applies a curve inverse kinematics algorithm to a skeleton"
        },
        {
            "trigger": "solvecurve(outlength, outpos, lengths, closed, orienttonormal, normalmode, tangent, points, normals)",
            "contents": "solvecurve(${1:outlength}, ${2:outpos}, ${3:lengths}, ${4:closed}, ${5:orienttonormal}, ${6:normalmode}, ${7:tangent}, ${8:points}, ${9:normals})",
            "kind": "function",
            "details": "Applies a curve inverse kinematics algorithm to a skeleton"
        },
        {
            "trigger": "solvecurve(outlength, outpos, lengths, closed, orienttonormal, normalmode, tangent, points, normals, twists, initialtwists, fmt, order, lod)",
            "contents": "solvecurve(${1:outlength}, ${2:outpos}, ${3:lengths}, ${4:closed}, ${5:orienttonormal}, ${6:normalmode}, ${7:tangent}, ${8:points}, ${9:normals}, ${10:twists}, ${11:initialtwists}, ${12:fmt}, ${13:order}, ${14:lod})",
            "kind": "function",
            "details": "Applies a curve inverse kinematics algorithm to a skeleton"
        },
        {
            "trigger": "solvecurve(op, lengths, closed, orienttonormal, tangent, normalcalcmethod, relmat)",
            "contents": "solvecurve(${1:op}, ${2:lengths}, ${3:closed}, ${4:orienttonormal}, ${5:tangent}, ${6:normalcalcmethod}, ${7:relmat})",
            "kind": "function",
            "details": "Applies a curve inverse kinematics algorithm to a skeleton"
        },
        {
            "trigger": "solvecurve(op, lengths, closed, orienttonormal, tangent, normalcalcmethod, relmat, primnum, lod)",
            "contents": "solvecurve(${1:op}, ${2:lengths}, ${3:closed}, ${4:orienttonormal}, ${5:tangent}, ${6:normalcalcmethod}, ${7:relmat}, ${8:primnum}, ${9:lod})",
            "kind": "function",
            "details": "Applies a curve inverse kinematics algorithm to a skeleton"
        },
        {
            "trigger": "solvefbik(xforms, parents, jointoptions, targetxforms, targets, targetoptions, iters, tolerance, pinroot)",
            "contents": "solvefbik(${1:xforms}, ${2:parents}, ${3:jointoptions}, ${4:targetxforms}, ${5:targets}, ${6:targetoptions}, ${7:iters}, ${8:tolerance}, ${9:pinroot})",
            "kind": "function",
            "details": "Applies a full-body inverse kinematics algorithm to a skeleton"
        },
        {
            "trigger": "solvefbik(xforms, parents, targets, targetxforms, iters)",
            "contents": "solvefbik(${1:xforms}, ${2:parents}, ${3:targets}, ${4:targetxforms}, ${5:iters})",
            "kind": "function",
            "details": "Applies a full-body inverse kinematics algorithm to a skeleton"
        },
        {
            "trigger": "solvefbik(xforms, parents, targets, targetxforms, iters, tolerance, pinroot)",
            "contents": "solvefbik(${1:xforms}, ${2:parents}, ${3:targets}, ${4:targetxforms}, ${5:iters}, ${6:tolerance}, ${7:pinroot})",
            "kind": "function",
            "details": "Applies a full-body inverse kinematics algorithm to a skeleton"
        },
        {
            "trigger": "solvefbik(xforms, parents, targets, targetxforms, iters, tolerance, pinroot, targetweights, targetpriorities, targetdepths)",
            "contents": "solvefbik(${1:xforms}, ${2:parents}, ${3:targets}, ${4:targetxforms}, ${5:iters}, ${6:tolerance}, ${7:pinroot}, ${8:targetweights}, ${9:targetpriorities}, ${10:targetdepths})",
            "kind": "function",
            "details": "Applies a full-body inverse kinematics algorithm to a skeleton"
        },
        {
            "trigger": "solvefbik(xforms, parents, targets, targetxforms, iters, tolerance, pinroot, targetweights, targetpriorities, targetdepths, targettypes, targetoffsets)",
            "contents": "solvefbik(${1:xforms}, ${2:parents}, ${3:targets}, ${4:targetxforms}, ${5:iters}, ${6:tolerance}, ${7:pinroot}, ${8:targetweights}, ${9:targetpriorities}, ${10:targetdepths}, ${11:targettypes}, ${12:targetoffsets})",
            "kind": "function",
            "details": "Applies a full-body inverse kinematics algorithm to a skeleton"
        },
        {
            "trigger": "solvefbik(xforms, parents, targets, targetxforms, iters, tolerance, pinroot, targetweights, targetpriorities, targetdepths, goalxforms, constrainedxforms, jointlimits)",
            "contents": "solvefbik(${1:xforms}, ${2:parents}, ${3:targets}, ${4:targetxforms}, ${5:iters}, ${6:tolerance}, ${7:pinroot}, ${8:targetweights}, ${9:targetpriorities}, ${10:targetdepths}, ${11:goalxforms}, ${12:constrainedxforms}, ${13:jointlimits})",
            "kind": "function",
            "details": "Applies a full-body inverse kinematics algorithm to a skeleton"
        },
        {
            "trigger": "solvefbik(xforms, parents, targets, targetxforms, iters, tolerance, pinroot, targetweights, targetpriorities, targetdepths, targettypes, targetoffsets, goalxforms, constrainedxforms, jointlimits)",
            "contents": "solvefbik(${1:xforms}, ${2:parents}, ${3:targets}, ${4:targetxforms}, ${5:iters}, ${6:tolerance}, ${7:pinroot}, ${8:targetweights}, ${9:targetpriorities}, ${10:targetdepths}, ${11:targettypes}, ${12:targetoffsets}, ${13:goalxforms}, ${14:constrainedxforms}, ${15:jointlimits})",
            "kind": "function",
            "details": "Applies a full-body inverse kinematics algorithm to a skeleton"
        },
        {
            "trigger": "solveik(lengths, targetpos, twistpos, twist, twistflag, dampen, resiststraight, trackingthres, relmat, constraints)",
            "contents": "solveik(${1:lengths}, ${2:targetpos}, ${3:twistpos}, ${4:twist}, ${5:twistflag}, ${6:dampen}, ${7:resiststraight}, ${8:trackingthres}, ${9:relmat}, ${10:constraints})",
            "kind": "function",
            "details": "Applies an inverse kinematics algorithm to a skeleton"
        },
        {
            "trigger": "solvephysfbik(xforms, parents, jointoptions, targetxforms, targets, targetoptions, iters, damping, tolerance)",
            "contents": "solvephysfbik(${1:xforms}, ${2:parents}, ${3:jointoptions}, ${4:targetxforms}, ${5:targets}, ${6:targetoptions}, ${7:iters}, ${8:damping}, ${9:tolerance})",
            "kind": "function",
            "details": "Applies a full-body inverse kinematics algorithm to a skeleton, with optional control over the center of mass"
        },
        {
            "trigger": "solvepoly(coef, roots, maxiter)",
            "contents": "solvepoly(${1:coef}, ${2:roots}, ${3:maxiter})",
            "kind": "function",
            "details": "Finds the real roots of a polynomial"
        },
        {
            "trigger": "solvequadratic(a, b, c, t1, t2)",
            "contents": "solvequadratic(${1:a}, ${2:b}, ${3:c}, ${4:t1}, ${5:t2})",
            "kind": "function",
            "details": "Solves a quadratic function returning the number of real roots"
        },
        {
            "trigger": "solvetriangleSSS(sides)",
            "contents": "solvetriangleSSS(${1:sides})",
            "kind": "function",
            "details": "Finds the angles of a triangle from its sides"
        },
        {
            "trigger": "solvetriangleSSS(a, b, c)",
            "contents": "solvetriangleSSS(${1:a}, ${2:b}, ${3:c})",
            "kind": "function",
            "details": "Finds the angles of a triangle from its sides"
        },
        {
            "trigger": "sort(values)",
            "contents": "sort(${1:values})",
            "kind": "function",
            "details": "Returns the array sorted in increasing order"
        },
        {
            "trigger": "specular(dir, ...)",
            "contents": "specular(${1:dir}, ${2:...})",
            "kind": "function",
            "details": "Returns a specular BSDF or computes specular shading"
        },
        {
            "trigger": "specular(nml, V, roughness, ...)",
            "contents": "specular(${1:nml}, ${2:V}, ${3:roughness}, ${4:...})",
            "kind": "function",
            "details": "Returns a specular BSDF or computes specular shading"
        },
        {
            "trigger": "specularBRDF(L, N, V, rough)",
            "contents": "specularBRDF(${1:L}, ${2:N}, ${3:V}, ${4:rough})",
            "kind": "function",
            "details": "Returns the computed BRDFs for the different lighting models used in VEX shading"
        },
        {
            "trigger": "spline(basis, sample_pos, value1, ...)",
            "contents": "spline(${1:basis}, ${2:sample_pos}, ${3:value1}, ${4:...})",
            "kind": "function",
            "details": "Samples a value along a polyline or spline curve"
        },
        {
            "trigger": "spline(basis, sample_pos, values, ...)",
            "contents": "spline(${1:basis}, ${2:sample_pos}, ${3:values}, ${4:...})",
            "kind": "function",
            "details": "Samples a value along a polyline or spline curve"
        },
        {
            "trigger": "spline(bases, sample_pos, values, ...)",
            "contents": "spline(${1:bases}, ${2:sample_pos}, ${3:values}, ${4:...})",
            "kind": "function",
            "details": "Samples a value along a polyline or spline curve"
        },
        {
            "trigger": "spline(bases, sample_pos, values, positions, ...)",
            "contents": "spline(${1:bases}, ${2:sample_pos}, ${3:values}, ${4:positions}, ${5:...})",
            "kind": "function",
            "details": "Samples a value along a polyline or spline curve"
        },
        {
            "trigger": "spline_cdf(bases, values, positions, ...)",
            "contents": "spline_cdf(${1:bases}, ${2:values}, ${3:positions}, ${4:...})",
            "kind": "function",
            "details": "Generate a cumulative distribution function (CDF) by sampling a spline curve"
        },
        {
            "trigger": "split(s)",
            "contents": "split(${1:s})",
            "kind": "function",
            "details": "Splits a string into tokens"
        },
        {
            "trigger": "split(s, separators)",
            "contents": "split(${1:s}, ${2:separators})",
            "kind": "function",
            "details": "Splits a string into tokens"
        },
        {
            "trigger": "split(s, separators, maxsplits)",
            "contents": "split(${1:s}, ${2:separators}, ${3:maxsplits})",
            "kind": "function",
            "details": "Splits a string into tokens"
        },
        {
            "trigger": "splitpath(fullpath, dir, name)",
            "contents": "splitpath(${1:fullpath}, ${2:dir}, ${3:name})",
            "kind": "function",
            "details": "Splits a file path into the directory and name parts"
        },
        {
            "trigger": "split_bsdf(lobes, source, weights)",
            "contents": "split_bsdf(${1:lobes}, ${2:source}, ${3:weights})",
            "kind": "function",
            "details": "Splits a bsdf into its component lobes"
        },
        {
            "trigger": "split_bsdf(lobes, source, weights, mask)",
            "contents": "split_bsdf(${1:lobes}, ${2:source}, ${3:weights}, ${4:mask})",
            "kind": "function",
            "details": "Splits a bsdf into its component lobes"
        },
        {
            "trigger": "split_bsdf(lobes, source, weights, mask, type)",
            "contents": "split_bsdf(${1:lobes}, ${2:source}, ${3:weights}, ${4:mask}, ${5:type})",
            "kind": "function",
            "details": "Splits a bsdf into its component lobes"
        },
        {
            "trigger": "split_bsdf(lobes, source, weights, mask, type, u)",
            "contents": "split_bsdf(${1:lobes}, ${2:source}, ${3:weights}, ${4:mask}, ${5:type}, ${6:u})",
            "kind": "function",
            "details": "Splits a bsdf into its component lobes"
        },
        {
            "trigger": "split_bsdf(lobes, source, weights, mask, type, u, cdf)",
            "contents": "split_bsdf(${1:lobes}, ${2:source}, ${3:weights}, ${4:mask}, ${5:type}, ${6:u}, ${7:cdf})",
            "kind": "function",
            "details": "Splits a bsdf into its component lobes"
        },
        {
            "trigger": "sprintf(format, ...)",
            "contents": "sprintf(${1:format}, ${2:...})",
            "kind": "function",
            "details": "Formats a string like printf but returns the result as a string instead of printing it"
        },
        {
            "trigger": "sqrt(value)",
            "contents": "sqrt(${1:value})",
            "kind": "function",
            "details": "Returns the square root of the argument"
        },
        {
            "trigger": "sssapprox(albedo, meanFreePath, roughness, scale, ...)",
            "contents": "sssapprox(${1:albedo}, ${2:meanFreePath}, ${3:roughness}, ${4:scale}, ${5:...})",
            "kind": "function",
            "details": "Creates an approximate SSS BSDF"
        },
        {
            "trigger": "startswith(str, startswith)",
            "contents": "startswith(${1:str}, ${2:startswith})",
            "kind": "function",
            "details": "Returns 1 if the string starts with the specified string"
        },
        {
            "trigger": "storelightexport(lightname, exportname, value)",
            "contents": "storelightexport(${1:lightname}, ${2:exportname}, ${3:value})",
            "kind": "function",
            "details": "Stores exported data for a light"
        },
        {
            "trigger": "strip(value)",
            "contents": "strip(${1:value})",
            "kind": "function",
            "details": "Strips leading and trailing whitespace from a string"
        },
        {
            "trigger": "strip(value, whitespace)",
            "contents": "strip(${1:value}, ${2:whitespace})",
            "kind": "function",
            "details": "Strips leading and trailing whitespace from a string"
        },
        {
            "trigger": "strlen(string)",
            "contents": "strlen(${1:string})",
            "kind": "function",
            "details": "Returns the length of the string"
        },
        {
            "trigger": "sum(n)",
            "contents": "sum(${1:n})",
            "kind": "function",
            "details": "Returns the sum of a list of numbers"
        },
        {
            "trigger": "sum(v)",
            "contents": "sum(${1:v})",
            "kind": "function",
            "details": "Returns the sum of a list of numbers"
        },
        {
            "trigger": "sum(m)",
            "contents": "sum(${1:m})",
            "kind": "function",
            "details": "Returns the sum of a list of numbers"
        },
        {
            "trigger": "sum(nums)",
            "contents": "sum(${1:nums})",
            "kind": "function",
            "details": "Returns the sum of a list of numbers"
        },
        {
            "trigger": "sum(arr)",
            "contents": "sum(${1:arr})",
            "kind": "function",
            "details": "Returns the sum of a list of numbers"
        },
        {
            "trigger": "surfacedist(geometry, ptgroup, P_attribute, search_pt, closest_pt, distance_metric)",
            "contents": "surfacedist(${1:geometry}, ${2:ptgroup}, ${3:P_attribute}, ${4:search_pt}, ${5:closest_pt}, ${6:distance_metric})",
            "kind": "function",
            "details": "Finds the distance of a point to a group of points along the surface of a geometry"
        },
        {
            "trigger": "surfacedist(geometry, ptgroup, P_attribute, search_pt, max_radius, closest_pt, distance_metric)",
            "contents": "surfacedist(${1:geometry}, ${2:ptgroup}, ${3:P_attribute}, ${4:search_pt}, ${5:max_radius}, ${6:closest_pt}, ${7:distance_metric})",
            "kind": "function",
            "details": "Finds the distance of a point to a group of points along the surface of a geometry"
        },
        {
            "trigger": "svddecomp(input_M, output_U, output_S, output_V)",
            "contents": "svddecomp(${1:input_M}, ${2:output_U}, ${3:output_S}, ${4:output_V})",
            "kind": "function",
            "details": "Computes the singular value decomposition of a 3\u00d73 matrix"
        },
        {
            "trigger": "svddecomp(input_M)",
            "contents": "svddecomp(${1:input_M})",
            "kind": "function",
            "details": "Computes the singular value decomposition of a 3\u00d73 matrix"
        },
        {
            "trigger": "switch(direct, indirect)",
            "contents": "switch(${1:direct}, ${2:indirect})",
            "kind": "function",
            "details": "Use a different bsdf for direct or indirect lighting"
        },
        {
            "trigger": "swizzle(v, i0, i1)",
            "contents": "swizzle(${1:v}, ${2:i0}, ${3:i1})",
            "kind": "function",
            "details": "Rearranges the components of a vector"
        },
        {
            "trigger": "swizzle(v, i0, i1, i2)",
            "contents": "swizzle(${1:v}, ${2:i0}, ${3:i1}, ${4:i2})",
            "kind": "function",
            "details": "Rearranges the components of a vector"
        },
        {
            "trigger": "swizzle(v, i0, i1, i2, i3)",
            "contents": "swizzle(${1:v}, ${2:i0}, ${3:i1}, ${4:i2}, ${5:i3})",
            "kind": "function",
            "details": "Rearranges the components of a vector"
        },
        {
            "trigger": "tan(n)",
            "contents": "tan(${1:n})",
            "kind": "function",
            "details": "Returns the trigonometric tangent of the argument"
        },
        {
            "trigger": "tan(v)",
            "contents": "tan(${1:v})",
            "kind": "function",
            "details": "Returns the trigonometric tangent of the argument"
        },
        {
            "trigger": "tanh(n)",
            "contents": "tanh(${1:n})",
            "kind": "function",
            "details": "Returns the hyperbolic tangent of the argument"
        },
        {
            "trigger": "tet_adjacent(geometry, primindex, faceno)",
            "contents": "tet_adjacent(${1:geometry}, ${2:primindex}, ${3:faceno})",
            "kind": "function",
            "details": "Returns primitive number of an adjacent tetrahedron"
        },
        {
            "trigger": "tet_faceindex(faceno, vtxno)",
            "contents": "tet_faceindex(${1:faceno}, ${2:vtxno})",
            "kind": "function",
            "details": "Returns vertex indices of each face of a tetrahedron"
        },
        {
            "trigger": "teximport(map, attribute, value)",
            "contents": "teximport(${1:map}, ${2:attribute}, ${3:value})",
            "kind": "function",
            "details": "Imports attributes from texture files"
        },
        {
            "trigger": "teximport(map, token, values)",
            "contents": "teximport(${1:map}, ${2:token}, ${3:values})",
            "kind": "function",
            "details": "Imports attributes from texture files"
        },
        {
            "trigger": "texprintf(u, v, format, ...)",
            "contents": "texprintf(${1:u}, ${2:v}, ${3:format}, ${4:...})",
            "kind": "function",
            "details": "Similar to sprintf, but does expansion of UDIM or UVTILE texture filename expansion"
        },
        {
            "trigger": "texture(map, ...)",
            "contents": "texture(${1:map}, ${2:...})",
            "kind": "function",
            "details": "Computes a filtered sample of the texture map specified"
        },
        {
            "trigger": "texture(map, ss, tt, ...)",
            "contents": "texture(${1:map}, ${2:ss}, ${3:tt}, ${4:...})",
            "kind": "function",
            "details": "Computes a filtered sample of the texture map specified"
        },
        {
            "trigger": "texture(map, s0, t0, s1, t1, s2, t2, s3, t3, ...)",
            "contents": "texture(${1:map}, ${2:s0}, ${3:t0}, ${4:s1}, ${5:t1}, ${6:s2}, ${7:t2}, ${8:s3}, ${9:t3}, ${10:...})",
            "kind": "function",
            "details": "Computes a filtered sample of the texture map specified"
        },
        {
            "trigger": "texture3d(filename, channel, P, ...)",
            "contents": "texture3d(${1:filename}, ${2:channel}, ${3:P}, ${4:...})",
            "kind": "function",
            "details": "Returns the value of the 3d image at the position specified by P"
        },
        {
            "trigger": "texture3dBox(filename, channel, min, max, ...)",
            "contents": "texture3dBox(${1:filename}, ${2:channel}, ${3:min}, ${4:max}, ${5:...})",
            "kind": "function",
            "details": "This function queries the 3D texture map specified and returns the bounding box information of the file"
        },
        {
            "trigger": "titlecase(str)",
            "contents": "titlecase(${1:str})",
            "kind": "function",
            "details": "Returns a string that is the titlecase version of the input string"
        },
        {
            "trigger": "tolower(str)",
            "contents": "tolower(${1:str})",
            "kind": "function",
            "details": "Converts all characters in string to lower case"
        },
        {
            "trigger": "toNDC(point)",
            "contents": "toNDC(${1:point})",
            "kind": "function",
            "details": "Transforms a position into normal device coordinates"
        },
        {
            "trigger": "toNDC(camera_name, point)",
            "contents": "toNDC(${1:camera_name}, ${2:point})",
            "kind": "function",
            "details": "Transforms a position into normal device coordinates"
        },
        {
            "trigger": "toupper(str)",
            "contents": "toupper(${1:str})",
            "kind": "function",
            "details": "Converts all characters in string to upper case"
        },
        {
            "trigger": "tr(m)",
            "contents": "tr(${1:m})",
            "kind": "function",
            "details": "Returns the trace of the given matrix"
        },
        {
            "trigger": "trace(cv, of, af, P, D, shadow_bias, max_contrib, ...)",
            "contents": "trace(${1:cv}, ${2:of}, ${3:af}, ${4:P}, ${5:D}, ${6:shadow_bias}, ${7:max_contrib}, ${8:...})",
            "kind": "function",
            "details": "Sends a ray from P along the normalized vector D"
        },
        {
            "trigger": "trace(pos, dir, time, ...)",
            "contents": "trace(${1:pos}, ${2:dir}, ${3:time}, ${4:...})",
            "kind": "function",
            "details": "Sends a ray from P along the normalized vector D"
        },
        {
            "trigger": "translate(m, amount)",
            "contents": "translate(${1:m}, ${2:amount})",
            "kind": "function",
            "details": "Translates a matrix by a vector"
        },
        {
            "trigger": "translucent(nml, ng, ...)",
            "contents": "translucent(${1:nml}, ${2:ng}, ${3:...})",
            "kind": "function",
            "details": "Returns a Lambertian translucence BSDF"
        },
        {
            "trigger": "transpose(m)",
            "contents": "transpose(${1:m})",
            "kind": "function",
            "details": "Transposes the given matrix"
        },
        {
            "trigger": "trunc(x)",
            "contents": "trunc(${1:x})",
            "kind": "function",
            "details": "Removes the fractional part of a floating point number"
        },
        {
            "trigger": "tw_nspace(v)",
            "contents": "tw_nspace(${1:v})",
            "kind": "function",
            "details": "Transforms a normal vector from Texture to World space"
        },
        {
            "trigger": "tw_space()",
            "contents": "tw_space()",
            "kind": "function",
            "details": "Transforms a position value from Texture to World space"
        },
        {
            "trigger": "tw_space(v)",
            "contents": "tw_space(${1:v})",
            "kind": "function",
            "details": "Transforms a position value from Texture to World space"
        },
        {
            "trigger": "tw_vspace(v)",
            "contents": "tw_vspace(${1:v})",
            "kind": "function",
            "details": "Transforms a direction vector from Texture to World space"
        },
        {
            "trigger": "typeid(value)",
            "contents": "typeid(${1:value})",
            "kind": "function",
            "details": "Returns a numeric code identifying a VEX data type"
        },
        {
            "trigger": "typeid(dictionary, key)",
            "contents": "typeid(${1:dictionary}, ${2:key})",
            "kind": "function",
            "details": "Returns a numeric code identifying a VEX data type"
        },
        {
            "trigger": "uniqueval(geometry, attribclass, attribute_name, which)",
            "contents": "uniqueval(${1:geometry}, ${2:attribclass}, ${3:attribute_name}, ${4:which})",
            "kind": "function",
            "details": "Returns one of the set of unique values across all values for an int or string attribute"
        },
        {
            "trigger": "uniquevals(geometry, attribclass, attribute_name)",
            "contents": "uniquevals(${1:geometry}, ${2:attribclass}, ${3:attribute_name})",
            "kind": "function",
            "details": "Returns the set of unique values across all values for an int or string attribute"
        },
        {
            "trigger": "unpack_intfromsafefloat(f)",
            "contents": "unpack_intfromsafefloat(${1:f})",
            "kind": "function",
            "details": "Reverses the packing of pack_inttosafefloat to get back the original integer"
        },
        {
            "trigger": "unserialize(values)",
            "contents": "unserialize(${1:values})",
            "kind": "function",
            "details": "Turns a flat array of floats into an array of vectors or matrices"
        },
        {
            "trigger": "upush(array, value)",
            "contents": "upush(${1:array}, ${2:value})",
            "kind": "function",
            "details": "Adds a uniform item to an array"
        },
        {
            "trigger": "usd_addattrib(stagehandle, primpath, name, typename)",
            "contents": "usd_addattrib(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:typename})",
            "kind": "function",
            "details": "Creates an attribute of a given type on a primitive"
        },
        {
            "trigger": "usd_addcollectionexclude(stagehandle, collectionpath, path)",
            "contents": "usd_addcollectionexclude(${1:stagehandle}, ${2:collectionpath}, ${3:path})",
            "kind": "function",
            "details": "Excludes an object from the collection"
        },
        {
            "trigger": "usd_addcollectioninclude(stagehandle, collectionpath, path)",
            "contents": "usd_addcollectioninclude(${1:stagehandle}, ${2:collectionpath}, ${3:path})",
            "kind": "function",
            "details": "Includes an object in the collection"
        },
        {
            "trigger": "usd_addinversetotransformorder(stagehandle, primpath, name)",
            "contents": "usd_addinversetotransformorder(${1:stagehandle}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Appends an inversed transform operation to the primitive\u2019s transform order"
        },
        {
            "trigger": "usd_addorient(stagehandle, primpath, suffix, orient)",
            "contents": "usd_addorient(${1:stagehandle}, ${2:primpath}, ${3:suffix}, ${4:orient})",
            "kind": "function",
            "details": "Applies a quaternion orientation to the primitive"
        },
        {
            "trigger": "usd_addprim(stagehandle, primpath, typename)",
            "contents": "usd_addprim(${1:stagehandle}, ${2:primpath}, ${3:typename})",
            "kind": "function",
            "details": "Creates a primitive of a given type"
        },
        {
            "trigger": "usd_addprimvar(stagehandle, primpath, name, typename)",
            "contents": "usd_addprimvar(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:typename})",
            "kind": "function",
            "details": "Creates a primvar of a given type on a primitive"
        },
        {
            "trigger": "usd_addprimvar(stagehandle, primpath, name, typename, interpolation)",
            "contents": "usd_addprimvar(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:typename}, ${5:interpolation})",
            "kind": "function",
            "details": "Creates a primvar of a given type on a primitive"
        },
        {
            "trigger": "usd_addrelationshiptarget(stagehandle, primpath, name, target)",
            "contents": "usd_addrelationshiptarget(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:target})",
            "kind": "function",
            "details": "Adds a target to the primitive\u2019s relationship"
        },
        {
            "trigger": "usd_addrotate(stagehandle, primpath, suffix, axis, angle)",
            "contents": "usd_addrotate(${1:stagehandle}, ${2:primpath}, ${3:suffix}, ${4:axis}, ${5:angle})",
            "kind": "function",
            "details": "Applies a rotation to the primitive"
        },
        {
            "trigger": "usd_addrotate(stagehandle, primpath, suffix, xyz, angles)",
            "contents": "usd_addrotate(${1:stagehandle}, ${2:primpath}, ${3:suffix}, ${4:xyz}, ${5:angles})",
            "kind": "function",
            "details": "Applies a rotation to the primitive"
        },
        {
            "trigger": "usd_addscale(stagehandle, primpath, suffix, scale)",
            "contents": "usd_addscale(${1:stagehandle}, ${2:primpath}, ${3:suffix}, ${4:scale})",
            "kind": "function",
            "details": "Applies a scale to the primitive"
        },
        {
            "trigger": "usd_addschemaattrib(stagehandle, primpath, name, typename)",
            "contents": "usd_addschemaattrib(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:typename})",
            "kind": "function",
            "details": "Creates an attribute of a given type on a primitive, and sets the custom metadata flag to False"
        },
        {
            "trigger": "usd_addtotransformorder(stagehandle, primpath, name)",
            "contents": "usd_addtotransformorder(${1:stagehandle}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Appends a transform operation to the primitive\u2019s transform order"
        },
        {
            "trigger": "usd_addtransform(stagehandle, primpath, suffix, xform)",
            "contents": "usd_addtransform(${1:stagehandle}, ${2:primpath}, ${3:suffix}, ${4:xform})",
            "kind": "function",
            "details": "Applies a transformation to the primitive"
        },
        {
            "trigger": "usd_addtranslate(stagehandle, primpath, suffix, amount)",
            "contents": "usd_addtranslate(${1:stagehandle}, ${2:primpath}, ${3:suffix}, ${4:amount})",
            "kind": "function",
            "details": "Applies a translation to the primitive"
        },
        {
            "trigger": "usd_applyapi(stagehandle, primpath, apischemaname)",
            "contents": "usd_applyapi(${1:stagehandle}, ${2:primpath}, ${3:apischemaname})",
            "kind": "function",
            "details": "Apply an API schema to a primitive"
        },
        {
            "trigger": "usd_attrib(stage, primpath, name)",
            "contents": "usd_attrib(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Reads the value of an attribute from the USD primitive"
        },
        {
            "trigger": "usd_attrib(stage, primpath, name, timecode)",
            "contents": "usd_attrib(${1:stage}, ${2:primpath}, ${3:name}, ${4:timecode})",
            "kind": "function",
            "details": "Reads the value of an attribute from the USD primitive"
        },
        {
            "trigger": "usd_attribelement(stage, primpath, name, index)",
            "contents": "usd_attribelement(${1:stage}, ${2:primpath}, ${3:name}, ${4:index})",
            "kind": "function",
            "details": "Reads the value of an element from an array attribute"
        },
        {
            "trigger": "usd_attribelement(stage, primpath, name, index, timecode)",
            "contents": "usd_attribelement(${1:stage}, ${2:primpath}, ${3:name}, ${4:index}, ${5:timecode})",
            "kind": "function",
            "details": "Reads the value of an element from an array attribute"
        },
        {
            "trigger": "usd_attriblen(stage, primpath, name)",
            "contents": "usd_attriblen(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the length of the array attribute"
        },
        {
            "trigger": "usd_attriblen(stage, primpath, name, timecode)",
            "contents": "usd_attriblen(${1:stage}, ${2:primpath}, ${3:name}, ${4:timecode})",
            "kind": "function",
            "details": "Returns the length of the array attribute"
        },
        {
            "trigger": "usd_attribnames(stage, primpath)",
            "contents": "usd_attribnames(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Returns the names of the attributes available on the primitive"
        },
        {
            "trigger": "usd_attribsize(stage, primpath, name)",
            "contents": "usd_attribsize(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the tuple size of the attribute"
        },
        {
            "trigger": "usd_attribtimesamples(stage, primpath, name)",
            "contents": "usd_attribtimesamples(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the time codes at which the attribute values are authored"
        },
        {
            "trigger": "usd_attribtypename(stage, primpath, name)",
            "contents": "usd_attribtypename(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the name of the attribute type"
        },
        {
            "trigger": "usd_blockattrib(stagehandle, primpath, name)",
            "contents": "usd_blockattrib(${1:stagehandle}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Blocks the attribute"
        },
        {
            "trigger": "usd_blockprimvar(stagehandle, primpath, name)",
            "contents": "usd_blockprimvar(${1:stagehandle}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Blocks the primvar"
        },
        {
            "trigger": "usd_blockprimvarindices(stagehandle, primpath, name)",
            "contents": "usd_blockprimvarindices(${1:stagehandle}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Blocks the primvar"
        },
        {
            "trigger": "usd_blockrelationship(stagehandle, primpath, name)",
            "contents": "usd_blockrelationship(${1:stagehandle}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Blocks the primitive\u2019s relationship"
        },
        {
            "trigger": "usd_boundmaterialpath(stage, primpath)",
            "contents": "usd_boundmaterialpath(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Returns the material path bound to a given primitive"
        },
        {
            "trigger": "usd_childnames(stage, primpath)",
            "contents": "usd_childnames(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Returns the names of the primitive\u2019s children"
        },
        {
            "trigger": "usd_clearmetadata(stagehandle, path, name)",
            "contents": "usd_clearmetadata(${1:stagehandle}, ${2:path}, ${3:name})",
            "kind": "function",
            "details": "Clears the value of the metadata"
        },
        {
            "trigger": "usd_cleartransformorder(stagehandle, primpath)",
            "contents": "usd_cleartransformorder(${1:stagehandle}, ${2:primpath})",
            "kind": "function",
            "details": "Clears the primitive\u2019s transform order"
        },
        {
            "trigger": "usd_collectioncomputedpaths(stage, collectionpath)",
            "contents": "usd_collectioncomputedpaths(${1:stage}, ${2:collectionpath})",
            "kind": "function",
            "details": "Obtains the list of all objects that belong to the collection"
        },
        {
            "trigger": "usd_collectioncontains(stage, collectionpath, path)",
            "contents": "usd_collectioncontains(${1:stage}, ${2:collectionpath}, ${3:path})",
            "kind": "function",
            "details": "Checks if an object path belongs to the collection"
        },
        {
            "trigger": "usd_collectionexcludes(stage, collectionpath)",
            "contents": "usd_collectionexcludes(${1:stage}, ${2:collectionpath})",
            "kind": "function",
            "details": "Obtains the object paths that are in the collection\u2019s exclude list"
        },
        {
            "trigger": "usd_collectionexpansionrule(stage, collectionpath)",
            "contents": "usd_collectionexpansionrule(${1:stage}, ${2:collectionpath})",
            "kind": "function",
            "details": "Obtains the collection\u2019s expansion rule"
        },
        {
            "trigger": "usd_collectionincludes(stage, collectionpath)",
            "contents": "usd_collectionincludes(${1:stage}, ${2:collectionpath})",
            "kind": "function",
            "details": "Obtains the object paths that are in the collection\u2019s include list"
        },
        {
            "trigger": "usd_drawmode(stage, primpath)",
            "contents": "usd_drawmode(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Returns the primitive\u2019s draw mode"
        },
        {
            "trigger": "usd_findtransformname(stage, primpath, suffix)",
            "contents": "usd_findtransformname(${1:stage}, ${2:primpath}, ${3:suffix})",
            "kind": "function",
            "details": "Retrurns primitive\u2019s transform operation full name for given the transform operation suffix"
        },
        {
            "trigger": "usd_flattenediprimvar(stage, primpath, name)",
            "contents": "usd_flattenediprimvar(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Reads the value of a flattened primvar directly from the USD primitive or from USD primitive\u2019s ancestor"
        },
        {
            "trigger": "usd_flattenediprimvar(stage, primpath, name, timecode)",
            "contents": "usd_flattenediprimvar(${1:stage}, ${2:primpath}, ${3:name}, ${4:timecode})",
            "kind": "function",
            "details": "Reads the value of a flattened primvar directly from the USD primitive or from USD primitive\u2019s ancestor"
        },
        {
            "trigger": "usd_flattenediprimvarelement(stage, primpath, name, index)",
            "contents": "usd_flattenediprimvarelement(${1:stage}, ${2:primpath}, ${3:name}, ${4:index})",
            "kind": "function",
            "details": "Reads an element value of a flattened array primvar directly from the USD primitive or from its ancestor"
        },
        {
            "trigger": "usd_flattenediprimvarelement(stage, primpath, name, index, timecode)",
            "contents": "usd_flattenediprimvarelement(${1:stage}, ${2:primpath}, ${3:name}, ${4:index}, ${5:timecode})",
            "kind": "function",
            "details": "Reads an element value of a flattened array primvar directly from the USD primitive or from its ancestor"
        },
        {
            "trigger": "usd_flattenedprimvar(stage, primpath, name)",
            "contents": "usd_flattenedprimvar(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Reads the value of an flattened primvar directly from the USD primitive"
        },
        {
            "trigger": "usd_flattenedprimvar(stage, primpath, name, timecode)",
            "contents": "usd_flattenedprimvar(${1:stage}, ${2:primpath}, ${3:name}, ${4:timecode})",
            "kind": "function",
            "details": "Reads the value of an flattened primvar directly from the USD primitive"
        },
        {
            "trigger": "usd_flattenedprimvarelement(stage, primpath, name, index)",
            "contents": "usd_flattenedprimvarelement(${1:stage}, ${2:primpath}, ${3:name}, ${4:index})",
            "kind": "function",
            "details": "Reads an element value of a flattened array primvar directly from a USD primitive"
        },
        {
            "trigger": "usd_flattenedprimvarelement(stage, primpath, name, index, timecode)",
            "contents": "usd_flattenedprimvarelement(${1:stage}, ${2:primpath}, ${3:name}, ${4:index}, ${5:timecode})",
            "kind": "function",
            "details": "Reads an element value of a flattened array primvar directly from a USD primitive"
        },
        {
            "trigger": "usd_getbbox(stage, primpath, purpose, min, max)",
            "contents": "usd_getbbox(${1:stage}, ${2:primpath}, ${3:purpose}, ${4:min}, ${5:max})",
            "kind": "function",
            "details": "Sets two vectors to the minimum and maximum corners of the bounding box for the primitive"
        },
        {
            "trigger": "usd_getbbox_center(stage, primpath, purpose)",
            "contents": "usd_getbbox_center(${1:stage}, ${2:primpath}, ${3:purpose})",
            "kind": "function",
            "details": "Returns the center of the bounding box for the primitive"
        },
        {
            "trigger": "usd_getbbox_max(stage, primpath, purpose)",
            "contents": "usd_getbbox_max(${1:stage}, ${2:primpath}, ${3:purpose})",
            "kind": "function",
            "details": "Returns the maximum of the bounding box for the primitive"
        },
        {
            "trigger": "usd_getbbox_min(stage, primpath, purpose)",
            "contents": "usd_getbbox_min(${1:stage}, ${2:primpath}, ${3:purpose})",
            "kind": "function",
            "details": "Returns the minimum of the bounding box for the primitive"
        },
        {
            "trigger": "usd_getbbox_size(stage, primpath, purpose)",
            "contents": "usd_getbbox_size(${1:stage}, ${2:primpath}, ${3:purpose})",
            "kind": "function",
            "details": "Returns the size of the bounding box for the primitive"
        },
        {
            "trigger": "usd_getbounds(stage, primpath, purpose, min, max)",
            "contents": "usd_getbounds(${1:stage}, ${2:primpath}, ${3:purpose}, ${4:min}, ${5:max})",
            "kind": "function",
            "details": "Obtains the primitive\u2019s bounds"
        },
        {
            "trigger": "usd_getbounds(stage, primpath, purpose, timecode, min, max)",
            "contents": "usd_getbounds(${1:stage}, ${2:primpath}, ${3:purpose}, ${4:timecode}, ${5:min}, ${6:max})",
            "kind": "function",
            "details": "Obtains the primitive\u2019s bounds"
        },
        {
            "trigger": "usd_getpointinstancebounds(stage, primpath, instance_index, purpose, min, max)",
            "contents": "usd_getpointinstancebounds(${1:stage}, ${2:primpath}, ${3:instance_index}, ${4:purpose}, ${5:min}, ${6:max})",
            "kind": "function",
            "details": "Obtains the primitive\u2019s bounds"
        },
        {
            "trigger": "usd_getpointinstancebounds(stage, primpath, instance_index, purpose, timecode, min, max)",
            "contents": "usd_getpointinstancebounds(${1:stage}, ${2:primpath}, ${3:instance_index}, ${4:purpose}, ${5:timecode}, ${6:min}, ${7:max})",
            "kind": "function",
            "details": "Obtains the primitive\u2019s bounds"
        },
        {
            "trigger": "usd_hasapi(stage, primpath, api)",
            "contents": "usd_hasapi(${1:stage}, ${2:primpath}, ${3:api})",
            "kind": "function",
            "details": "Checks if the primitive adheres to the given API"
        },
        {
            "trigger": "usd_haspayload(stage, primpath)",
            "contents": "usd_haspayload(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Checks if the primitive adheres to the given API"
        },
        {
            "trigger": "usd_iprimvar(stage, primpath, name)",
            "contents": "usd_iprimvar(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Reads the value of a primvar directly from the USD primitive or from USD primitive\u2019s ancestor"
        },
        {
            "trigger": "usd_iprimvar(stage, primpath, name, timecode)",
            "contents": "usd_iprimvar(${1:stage}, ${2:primpath}, ${3:name}, ${4:timecode})",
            "kind": "function",
            "details": "Reads the value of a primvar directly from the USD primitive or from USD primitive\u2019s ancestor"
        },
        {
            "trigger": "usd_iprimvarelement(stage, primpath, name, index)",
            "contents": "usd_iprimvarelement(${1:stage}, ${2:primpath}, ${3:name}, ${4:index})",
            "kind": "function",
            "details": "Reads the value of an element from the array primvar directly from the USD primitive or from USD primitive\u2019s ancestor"
        },
        {
            "trigger": "usd_iprimvarelement(stage, primpath, name, index, timecode)",
            "contents": "usd_iprimvarelement(${1:stage}, ${2:primpath}, ${3:name}, ${4:index}, ${5:timecode})",
            "kind": "function",
            "details": "Reads the value of an element from the array primvar directly from the USD primitive or from USD primitive\u2019s ancestor"
        },
        {
            "trigger": "usd_iprimvarelementsize(stage, primpath, name)",
            "contents": "usd_iprimvarelementsize(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the element size of the primvar directly from the USD primitive or from USD primitive\u2019s ancestor"
        },
        {
            "trigger": "usd_iprimvarindices(stage, primpath, name)",
            "contents": "usd_iprimvarindices(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the index array of an indexed primvar directly on the USD primitive or on USD primitive\u2019s ancestor"
        },
        {
            "trigger": "usd_iprimvarindices(stage, primpath, name, timecode)",
            "contents": "usd_iprimvarindices(${1:stage}, ${2:primpath}, ${3:name}, ${4:timecode})",
            "kind": "function",
            "details": "Returns the index array of an indexed primvar directly on the USD primitive or on USD primitive\u2019s ancestor"
        },
        {
            "trigger": "usd_iprimvarinterpolation(stage, primpath, name)",
            "contents": "usd_iprimvarinterpolation(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the element size of the primvar directly on the USD primitive or on USD primitive\u2019s ancestor"
        },
        {
            "trigger": "usd_iprimvarlen(stage, primpath, name)",
            "contents": "usd_iprimvarlen(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the length of the array primvar directly on the USD primitive or on USD primitive\u2019s ancestor"
        },
        {
            "trigger": "usd_iprimvarlen(stage, primpath, name, timecode)",
            "contents": "usd_iprimvarlen(${1:stage}, ${2:primpath}, ${3:name}, ${4:timecode})",
            "kind": "function",
            "details": "Returns the length of the array primvar directly on the USD primitive or on USD primitive\u2019s ancestor"
        },
        {
            "trigger": "usd_iprimvarnames(stage, primpath)",
            "contents": "usd_iprimvarnames(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Returns the names of the primvars available directly on the given USD primitive or on USD primitive\u2019s ancestor"
        },
        {
            "trigger": "usd_iprimvarsize(stage, primpath, name)",
            "contents": "usd_iprimvarsize(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the tuple size of the primvar directly on the USD primitive or on USD primitive\u2019s ancestor"
        },
        {
            "trigger": "usd_iprimvartimesamples(stage, primpath, name)",
            "contents": "usd_iprimvartimesamples(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the time codes at which the primvar values are authored directly on the given primitive or on its ancestor"
        },
        {
            "trigger": "usd_iprimvartypename(stage, primpath, name)",
            "contents": "usd_iprimvartypename(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the name of the primvar type found on the given primitive or its ancestor"
        },
        {
            "trigger": "usd_isabstract(stage, primpath)",
            "contents": "usd_isabstract(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Checks if the primitive is abstract"
        },
        {
            "trigger": "usd_isactive(stage, primpath)",
            "contents": "usd_isactive(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Checks if the primitive is active"
        },
        {
            "trigger": "usd_isarray(stage, primpath, name)",
            "contents": "usd_isarray(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Checks if the attribute is an array"
        },
        {
            "trigger": "usd_isarrayiprimvar(stage, primpath, name)",
            "contents": "usd_isarrayiprimvar(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Checks if there is an array primvar directly on the USD primitive or on USD primitive\u2019s ancestor"
        },
        {
            "trigger": "usd_isarraymetadata(stage, path, name)",
            "contents": "usd_isarraymetadata(${1:stage}, ${2:path}, ${3:name})",
            "kind": "function",
            "details": "Checks if the given metadata is an array"
        },
        {
            "trigger": "usd_isarrayprimvar(stage, primpath, name)",
            "contents": "usd_isarrayprimvar(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Checks if there is an array primvar directly on the USD primitive"
        },
        {
            "trigger": "usd_isattrib(stage, primpath, name)",
            "contents": "usd_isattrib(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Checks if the primitive has an attribute by the given name"
        },
        {
            "trigger": "usd_iscollection(stage, collectionpath)",
            "contents": "usd_iscollection(${1:stage}, ${2:collectionpath})",
            "kind": "function",
            "details": "Checks if the collection exists"
        },
        {
            "trigger": "usd_iscollectionpath(stage, collectionpath)",
            "contents": "usd_iscollectionpath(${1:stage}, ${2:collectionpath})",
            "kind": "function",
            "details": "Checks if the path is a valid collection path"
        },
        {
            "trigger": "usd_isindexediprimvar(stage, primpath, name)",
            "contents": "usd_isindexediprimvar(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Checks if there is an indexed primvar directly on the USD primitive or on USD primitive\u2019s ancestor"
        },
        {
            "trigger": "usd_isindexedprimvar(stage, primpath, name)",
            "contents": "usd_isindexedprimvar(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Checks if there is an indexed primvar directly on the USD primitive"
        },
        {
            "trigger": "usd_isinstance(stage, primpath)",
            "contents": "usd_isinstance(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Checks if the primitive is an instance"
        },
        {
            "trigger": "usd_isiprimvar(stage, primpath, name)",
            "contents": "usd_isiprimvar(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Checks if the primitive or its ancestor has a primvar of the given name"
        },
        {
            "trigger": "usd_iskind(stage, primpath, kind)",
            "contents": "usd_iskind(${1:stage}, ${2:primpath}, ${3:kind})",
            "kind": "function",
            "details": "Checks if the primitive is of a given kind"
        },
        {
            "trigger": "usd_ismetadata(stage, path, name)",
            "contents": "usd_ismetadata(${1:stage}, ${2:path}, ${3:name})",
            "kind": "function",
            "details": "Checks if the primitive has metadata by the given name"
        },
        {
            "trigger": "usd_ismodel(stage, primpath)",
            "contents": "usd_ismodel(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Checks if the primitive is a model"
        },
        {
            "trigger": "usd_isprim(stage, primpath)",
            "contents": "usd_isprim(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Checks if the path refers to a valid primitive"
        },
        {
            "trigger": "usd_isprimvar(stage, primpath, name)",
            "contents": "usd_isprimvar(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Checks if the primitive has a primvar of the given name"
        },
        {
            "trigger": "usd_isrelationship(stage, primpath, name)",
            "contents": "usd_isrelationship(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Checks if the primitive has a relationship by the given name"
        },
        {
            "trigger": "usd_isstage(stage)",
            "contents": "usd_isstage(${1:stage})",
            "kind": "function",
            "details": "Checks if the stage is valid"
        },
        {
            "trigger": "usd_istransformreset(stage, primpath)",
            "contents": "usd_istransformreset(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Checks if the primitive transform is reset"
        },
        {
            "trigger": "usd_istype(stage, primpath, type)",
            "contents": "usd_istype(${1:stage}, ${2:primpath}, ${3:type})",
            "kind": "function",
            "details": "Checks if the primitive is of a given type"
        },
        {
            "trigger": "usd_isvisible(stage, primpath)",
            "contents": "usd_isvisible(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Checks if the primitive is visible"
        },
        {
            "trigger": "usd_isvisible(stage, primpath, timecode)",
            "contents": "usd_isvisible(${1:stage}, ${2:primpath}, ${3:timecode})",
            "kind": "function",
            "details": "Checks if the primitive is visible"
        },
        {
            "trigger": "usd_kind(stage, primpath)",
            "contents": "usd_kind(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Returns the primitive\u2019s kind"
        },
        {
            "trigger": "usd_localtransform(stage, primpath)",
            "contents": "usd_localtransform(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Obtains the primitive\u2019s local transform"
        },
        {
            "trigger": "usd_localtransform(stage, primpath, timecode)",
            "contents": "usd_localtransform(${1:stage}, ${2:primpath}, ${3:timecode})",
            "kind": "function",
            "details": "Obtains the primitive\u2019s local transform"
        },
        {
            "trigger": "usd_makeattribpath(stage, primpath, name)",
            "contents": "usd_makeattribpath(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Constructs an attribute path from a primitive path and an attribute name"
        },
        {
            "trigger": "usd_makecollectionpath(stage, primpath, name)",
            "contents": "usd_makecollectionpath(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Constructs a collection path from a primitive path and a collection name"
        },
        {
            "trigger": "usd_makepropertypath(stage, primpath, name)",
            "contents": "usd_makepropertypath(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Constructs an property path from a primitive path and an property name"
        },
        {
            "trigger": "usd_makerelationshippath(stage, primpath, name)",
            "contents": "usd_makerelationshippath(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Constructs an relationship path from a primitive path and a relationship name"
        },
        {
            "trigger": "usd_makevalidprimname(name)",
            "contents": "usd_makevalidprimname(${1:name})",
            "kind": "function",
            "details": "Forces a string to conform to the rules for naming USD primitives"
        },
        {
            "trigger": "usd_makevalidprimpath(path, allow_relative)",
            "contents": "usd_makevalidprimpath(${1:path}, ${2:allow_relative})",
            "kind": "function",
            "details": "Forces a string to conform to the rules for paths to USD primitives"
        },
        {
            "trigger": "usd_metadata(stage, path, name)",
            "contents": "usd_metadata(${1:stage}, ${2:path}, ${3:name})",
            "kind": "function",
            "details": "Reads the value of metadata from the USD object"
        },
        {
            "trigger": "usd_metadataelement(stage, path, name, index)",
            "contents": "usd_metadataelement(${1:stage}, ${2:path}, ${3:name}, ${4:index})",
            "kind": "function",
            "details": "Reads the value of an element from the array metadata"
        },
        {
            "trigger": "usd_metadatalen(stage, path, name)",
            "contents": "usd_metadatalen(${1:stage}, ${2:path}, ${3:name})",
            "kind": "function",
            "details": "Returns the length of the array metadata"
        },
        {
            "trigger": "usd_metadatanames(stage, path)",
            "contents": "usd_metadatanames(${1:stage}, ${2:path})",
            "kind": "function",
            "details": "Returns the names of the metadata available on the object"
        },
        {
            "trigger": "usd_name(stage, primpath)",
            "contents": "usd_name(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Returns the name of the primitive"
        },
        {
            "trigger": "usd_parentpath(stage, primpath)",
            "contents": "usd_parentpath(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Returns the path of the primitive\u2019s parent"
        },
        {
            "trigger": "usd_pointinstancetransform(stage, primpath, index)",
            "contents": "usd_pointinstancetransform(${1:stage}, ${2:primpath}, ${3:index})",
            "kind": "function",
            "details": "Obtains the transform for the given point instance"
        },
        {
            "trigger": "usd_pointinstancetransform(stage, primpath, index, timecode)",
            "contents": "usd_pointinstancetransform(${1:stage}, ${2:primpath}, ${3:index}, ${4:timecode})",
            "kind": "function",
            "details": "Obtains the transform for the given point instance"
        },
        {
            "trigger": "usd_pointinstance_getbbox(stage, primpath, instance_index, purpose, min, max)",
            "contents": "usd_pointinstance_getbbox(${1:stage}, ${2:primpath}, ${3:instance_index}, ${4:purpose}, ${5:min}, ${6:max})",
            "kind": "function",
            "details": "Sets two vectors to the minimum and maximum corners of the bounding box for the given instance inside point instancer"
        },
        {
            "trigger": "usd_pointinstance_getbbox_center(stage, primpath, instance_index, purpose)",
            "contents": "usd_pointinstance_getbbox_center(${1:stage}, ${2:primpath}, ${3:instance_index}, ${4:purpose})",
            "kind": "function",
            "details": "Returns the center of the bounding box for the instance inside a point instancer primitive"
        },
        {
            "trigger": "usd_pointinstance_getbbox_max(stage, primpath, instance_index, purpose)",
            "contents": "usd_pointinstance_getbbox_max(${1:stage}, ${2:primpath}, ${3:instance_index}, ${4:purpose})",
            "kind": "function",
            "details": "Returns the maximum position of the bounding box for the instance inside a point instancer primitive"
        },
        {
            "trigger": "usd_pointinstance_getbbox_min(stage, primpath, instance_index, purpose)",
            "contents": "usd_pointinstance_getbbox_min(${1:stage}, ${2:primpath}, ${3:instance_index}, ${4:purpose})",
            "kind": "function",
            "details": "Returns the minimum position of the bounding box for the instance inside a point instancer primitive"
        },
        {
            "trigger": "usd_pointinstance_getbbox_size(stage, primpath, instance_index, purpose)",
            "contents": "usd_pointinstance_getbbox_size(${1:stage}, ${2:primpath}, ${3:instance_index}, ${4:purpose})",
            "kind": "function",
            "details": "Returns the size of the bounding box for the instance inside a point instancer primitive"
        },
        {
            "trigger": "usd_pointinstance_relbbox(stage, primpath, instance_index, purpose, position)",
            "contents": "usd_pointinstance_relbbox(${1:stage}, ${2:primpath}, ${3:instance_index}, ${4:purpose}, ${5:position})",
            "kind": "function",
            "details": "Returns the relative position of the point given with respect to the bounding box of the geometry"
        },
        {
            "trigger": "usd_primvar(stage, primpath, name)",
            "contents": "usd_primvar(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Reads the value of a primvar directly from the USD primitive"
        },
        {
            "trigger": "usd_primvar(stage, primpath, name, timecode)",
            "contents": "usd_primvar(${1:stage}, ${2:primpath}, ${3:name}, ${4:timecode})",
            "kind": "function",
            "details": "Reads the value of a primvar directly from the USD primitive"
        },
        {
            "trigger": "usd_primvarattribname(stage, name)",
            "contents": "usd_primvarattribname(${1:stage}, ${2:name})",
            "kind": "function",
            "details": "Returns the namespaced attribute name for the given primvar"
        },
        {
            "trigger": "usd_primvarelement(stage, primpath, name, index)",
            "contents": "usd_primvarelement(${1:stage}, ${2:primpath}, ${3:name}, ${4:index})",
            "kind": "function",
            "details": "Reads the value of an element from the array primvar directly from the USD primitive"
        },
        {
            "trigger": "usd_primvarelement(stage, primpath, name, index, timecode)",
            "contents": "usd_primvarelement(${1:stage}, ${2:primpath}, ${3:name}, ${4:index}, ${5:timecode})",
            "kind": "function",
            "details": "Reads the value of an element from the array primvar directly from the USD primitive"
        },
        {
            "trigger": "usd_primvarelementsize(stage, primpath, name)",
            "contents": "usd_primvarelementsize(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the element size of the primvar directly from the USD primitive"
        },
        {
            "trigger": "usd_primvarindices(stage, primpath, name)",
            "contents": "usd_primvarindices(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the index array of an indexed primvar directly on the USD primitive"
        },
        {
            "trigger": "usd_primvarindices(stage, primpath, name, timecode)",
            "contents": "usd_primvarindices(${1:stage}, ${2:primpath}, ${3:name}, ${4:timecode})",
            "kind": "function",
            "details": "Returns the index array of an indexed primvar directly on the USD primitive"
        },
        {
            "trigger": "usd_primvarinterpolation(stage, primpath, name)",
            "contents": "usd_primvarinterpolation(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the element size of the primvar directly on the USD primitive"
        },
        {
            "trigger": "usd_primvarlen(stage, primpath, name)",
            "contents": "usd_primvarlen(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the length of the array primvar directly on the USD primitive"
        },
        {
            "trigger": "usd_primvarlen(stage, primpath, name, timecode)",
            "contents": "usd_primvarlen(${1:stage}, ${2:primpath}, ${3:name}, ${4:timecode})",
            "kind": "function",
            "details": "Returns the length of the array primvar directly on the USD primitive"
        },
        {
            "trigger": "usd_primvarnames(stage, primpath)",
            "contents": "usd_primvarnames(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Returns the names of the primvars available on the given USD primitive"
        },
        {
            "trigger": "usd_primvarsize(stage, primpath, name)",
            "contents": "usd_primvarsize(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the tuple size of the primvar directly on the USD primitive"
        },
        {
            "trigger": "usd_primvartimesamples(stage, primpath, name)",
            "contents": "usd_primvartimesamples(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the time codes at which the primvar values are authored directly on the given primitive"
        },
        {
            "trigger": "usd_primvartypename(stage, primpath, name)",
            "contents": "usd_primvartypename(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Returns the name of the primvar type found on the given primitive"
        },
        {
            "trigger": "usd_purpose(stage, primpath)",
            "contents": "usd_purpose(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Returns the primitive\u2019s purpose"
        },
        {
            "trigger": "usd_relationshipforwardedtargets(stage, primpath, name)",
            "contents": "usd_relationshipforwardedtargets(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Obtains the relationship forwarded targets"
        },
        {
            "trigger": "usd_relationshipnames(stage, primpath)",
            "contents": "usd_relationshipnames(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Returns the names of the relationships available on the primitive"
        },
        {
            "trigger": "usd_relationshiptargets(stage, primpath, name)",
            "contents": "usd_relationshiptargets(${1:stage}, ${2:primpath}, ${3:name})",
            "kind": "function",
            "details": "Obtains the relationship targets"
        },
        {
            "trigger": "usd_relbbox(stage, primpath, purpose, position)",
            "contents": "usd_relbbox(${1:stage}, ${2:primpath}, ${3:purpose}, ${4:position})",
            "kind": "function",
            "details": "Returns the relative position of the point given with respect to the bounding box of the geometry"
        },
        {
            "trigger": "usd_removerelationshiptarget(stagehandle, primpath, name, target)",
            "contents": "usd_removerelationshiptarget(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:target})",
            "kind": "function",
            "details": "Remove a target from the primitive\u2019s relationship"
        },
        {
            "trigger": "usd_setactive(stagehandle, primpath, flag)",
            "contents": "usd_setactive(${1:stagehandle}, ${2:primpath}, ${3:flag})",
            "kind": "function",
            "details": "Sets the primitive active state"
        },
        {
            "trigger": "usd_setattrib(stagehandle, primpath, name, value)",
            "contents": "usd_setattrib(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:value})",
            "kind": "function",
            "details": "Sets the value of an attribute"
        },
        {
            "trigger": "usd_setattribelement(stagehandle, primpath, name, index, value)",
            "contents": "usd_setattribelement(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:index}, ${5:value})",
            "kind": "function",
            "details": "Sets the value of an element in an array attribute"
        },
        {
            "trigger": "usd_setcollectionexcludes(stagehandle, collectionpath, excludes)",
            "contents": "usd_setcollectionexcludes(${1:stagehandle}, ${2:collectionpath}, ${3:excludes})",
            "kind": "function",
            "details": "Sets the excludes list on the collection"
        },
        {
            "trigger": "usd_setcollectionexpansionrule(stagehandle, collectionpath, rule)",
            "contents": "usd_setcollectionexpansionrule(${1:stagehandle}, ${2:collectionpath}, ${3:rule})",
            "kind": "function",
            "details": "Sets the expansion rule on the collection"
        },
        {
            "trigger": "usd_setcollectionincludes(stagehandle, collectionpath, includes)",
            "contents": "usd_setcollectionincludes(${1:stagehandle}, ${2:collectionpath}, ${3:includes})",
            "kind": "function",
            "details": "Sets the includes list on the collection"
        },
        {
            "trigger": "usd_setdrawmode(stagehandle, primpath, mode)",
            "contents": "usd_setdrawmode(${1:stagehandle}, ${2:primpath}, ${3:mode})",
            "kind": "function",
            "details": "Sets the primitive\u2019s draw mode"
        },
        {
            "trigger": "usd_setkind(stagehandle, primpath, kind)",
            "contents": "usd_setkind(${1:stagehandle}, ${2:primpath}, ${3:kind})",
            "kind": "function",
            "details": "Sets the primitive\u2019s kind"
        },
        {
            "trigger": "usd_setmetadata(stagehandle, path, name, value)",
            "contents": "usd_setmetadata(${1:stagehandle}, ${2:path}, ${3:name}, ${4:value})",
            "kind": "function",
            "details": "Sets the value of an metadata"
        },
        {
            "trigger": "usd_setmetadataelement(stagehandle, path, name, index, value)",
            "contents": "usd_setmetadataelement(${1:stagehandle}, ${2:path}, ${3:name}, ${4:index}, ${5:value})",
            "kind": "function",
            "details": "Sets the value of an element in an array metadata"
        },
        {
            "trigger": "usd_setprimvar(stagehandle, primpath, name, value)",
            "contents": "usd_setprimvar(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:value})",
            "kind": "function",
            "details": "Sets the value of a primvar"
        },
        {
            "trigger": "usd_setprimvarelement(stagehandle, primpath, name, index, value)",
            "contents": "usd_setprimvarelement(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:index}, ${5:value})",
            "kind": "function",
            "details": "Sets the value of an element in an array primvar"
        },
        {
            "trigger": "usd_setprimvarelementsize(stagehandle, primpath, name, size)",
            "contents": "usd_setprimvarelementsize(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:size})",
            "kind": "function",
            "details": "Sets the element size of a primvar"
        },
        {
            "trigger": "usd_setprimvarindices(stagehandle, primpath, name, indices)",
            "contents": "usd_setprimvarindices(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:indices})",
            "kind": "function",
            "details": "Sets the indices for the given primvar"
        },
        {
            "trigger": "usd_setprimvarinterpolation(stagehandle, primpath, name, interpolation)",
            "contents": "usd_setprimvarinterpolation(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:interpolation})",
            "kind": "function",
            "details": "Sets the interpolation of a primvar"
        },
        {
            "trigger": "usd_setpurpose(stagehandle, primpath, purpose)",
            "contents": "usd_setpurpose(${1:stagehandle}, ${2:primpath}, ${3:purpose})",
            "kind": "function",
            "details": "Sets the primitive\u2019s purpose"
        },
        {
            "trigger": "usd_setrelationshiptargets(stagehandle, primpath, name, targets)",
            "contents": "usd_setrelationshiptargets(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:targets})",
            "kind": "function",
            "details": "Sets the targets in the primitive\u2019s relationship"
        },
        {
            "trigger": "usd_settransformorder(stagehandle, primpath, transformorder)",
            "contents": "usd_settransformorder(${1:stagehandle}, ${2:primpath}, ${3:transformorder})",
            "kind": "function",
            "details": "Sets the primitive\u2019s transform order"
        },
        {
            "trigger": "usd_settransformreset(stagehandle, primpath, flag)",
            "contents": "usd_settransformreset(${1:stagehandle}, ${2:primpath}, ${3:flag})",
            "kind": "function",
            "details": "Sets/clears the primitive\u2019s transform reset flag"
        },
        {
            "trigger": "usd_setvariantselection(stage, primpath, variantset, variant)",
            "contents": "usd_setvariantselection(${1:stage}, ${2:primpath}, ${3:variantset}, ${4:variant})",
            "kind": "function",
            "details": "Sets the selected variant in the given variant set"
        },
        {
            "trigger": "usd_setvisibility(stagehandle, primpath, code)",
            "contents": "usd_setvisibility(${1:stagehandle}, ${2:primpath}, ${3:code})",
            "kind": "function",
            "details": "Configures the primitive to be visible, invisible, or to inherit visibility from the parent"
        },
        {
            "trigger": "usd_setvisible(stagehandle, primpath, flag)",
            "contents": "usd_setvisible(${1:stagehandle}, ${2:primpath}, ${3:flag})",
            "kind": "function",
            "details": "Makes the primitive visible or invisible"
        },
        {
            "trigger": "usd_specifier(stage, primpath)",
            "contents": "usd_specifier(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Returns the primitive\u2019s specifier"
        },
        {
            "trigger": "usd_transformname(transformtype, suffix)",
            "contents": "usd_transformname(${1:transformtype}, ${2:suffix})",
            "kind": "function",
            "details": "Constructs a full name of a transform operation"
        },
        {
            "trigger": "usd_transformorder(stage, primpath)",
            "contents": "usd_transformorder(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Obtains the primitive\u2019s transform order"
        },
        {
            "trigger": "usd_transformsuffix(name)",
            "contents": "usd_transformsuffix(${1:name})",
            "kind": "function",
            "details": "Extracts the transform operation suffix from the full name"
        },
        {
            "trigger": "usd_transformtype(name)",
            "contents": "usd_transformtype(${1:name})",
            "kind": "function",
            "details": "Infers the transform operation type from the full name"
        },
        {
            "trigger": "usd_typename(stage, primpath)",
            "contents": "usd_typename(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Returns the name of the primitive\u2019s type"
        },
        {
            "trigger": "usd_uniquetransformname(stage, primpath, transformtype, suffix)",
            "contents": "usd_uniquetransformname(${1:stage}, ${2:primpath}, ${3:transformtype}, ${4:suffix})",
            "kind": "function",
            "details": "Constructs a unique full name of a transform operation"
        },
        {
            "trigger": "usd_variants(stage, primpath, variantset)",
            "contents": "usd_variants(${1:stage}, ${2:primpath}, ${3:variantset})",
            "kind": "function",
            "details": "Returns the variants belonging to the given variant set on a primitive"
        },
        {
            "trigger": "usd_variantselection(stage, primpath, variantset)",
            "contents": "usd_variantselection(${1:stage}, ${2:primpath}, ${3:variantset})",
            "kind": "function",
            "details": "Returns the currently selected variant in a given variant set"
        },
        {
            "trigger": "usd_variantsets(stage, primpath)",
            "contents": "usd_variantsets(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Returns the variant sets available on a primitive"
        },
        {
            "trigger": "usd_worldtransform(stage, primpath)",
            "contents": "usd_worldtransform(${1:stage}, ${2:primpath})",
            "kind": "function",
            "details": "Obtains the primitive\u2019s world transform"
        },
        {
            "trigger": "usd_worldtransform(stage, primpath, timecode)",
            "contents": "usd_worldtransform(${1:stage}, ${2:primpath}, ${3:timecode})",
            "kind": "function",
            "details": "Obtains the primitive\u2019s world transform"
        },
        {
            "trigger": "uvdist(geometry, uvname, uv, prim, primuv)",
            "contents": "uvdist(${1:geometry}, ${2:uvname}, ${3:uv}, ${4:prim}, ${5:primuv})",
            "kind": "function",
            "details": "Finds the distance of a uv coordinate to a geometry in uv space"
        },
        {
            "trigger": "uvdist(geometry, uvname, uv, prim, primuv, maxdist)",
            "contents": "uvdist(${1:geometry}, ${2:uvname}, ${3:uv}, ${4:prim}, ${5:primuv}, ${6:maxdist})",
            "kind": "function",
            "details": "Finds the distance of a uv coordinate to a geometry in uv space"
        },
        {
            "trigger": "uvdist(geometry, primgroup, uvname, uv, prim, primuv)",
            "contents": "uvdist(${1:geometry}, ${2:primgroup}, ${3:uvname}, ${4:uv}, ${5:prim}, ${6:primuv})",
            "kind": "function",
            "details": "Finds the distance of a uv coordinate to a geometry in uv space"
        },
        {
            "trigger": "uvdist(geometry, primgroup, uvname, uv, prim, primuv, maxdist)",
            "contents": "uvdist(${1:geometry}, ${2:primgroup}, ${3:uvname}, ${4:uv}, ${5:prim}, ${6:primuv}, ${7:maxdist})",
            "kind": "function",
            "details": "Finds the distance of a uv coordinate to a geometry in uv space"
        },
        {
            "trigger": "uvintersect(geometry, uvname, orig, dir, pos, primuv)",
            "contents": "uvintersect(${1:geometry}, ${2:uvname}, ${3:orig}, ${4:dir}, ${5:pos}, ${6:primuv})",
            "kind": "function",
            "details": "This function computes the intersection of the specified ray with the geometry in uv space"
        },
        {
            "trigger": "uvintersect(geometry, primgroup, uvname, orig, dir, pos, primuv)",
            "contents": "uvintersect(${1:geometry}, ${2:primgroup}, ${3:uvname}, ${4:orig}, ${5:dir}, ${6:pos}, ${7:primuv})",
            "kind": "function",
            "details": "This function computes the intersection of the specified ray with the geometry in uv space"
        },
        {
            "trigger": "uvsample(geometry, attr_name, uv_attr_name, uvw)",
            "contents": "uvsample(${1:geometry}, ${2:attr_name}, ${3:uv_attr_name}, ${4:uvw})",
            "kind": "function",
            "details": "Interpolates the value of an attribute at certain UV coordinates using a UV attribute"
        },
        {
            "trigger": "uvsample(geometry, primgroup, attr_name, uv_attr_name, uvw)",
            "contents": "uvsample(${1:geometry}, ${2:primgroup}, ${3:attr_name}, ${4:uv_attr_name}, ${5:uvw})",
            "kind": "function",
            "details": "Interpolates the value of an attribute at certain UV coordinates using a UV attribute"
        },
        {
            "trigger": "uvunwrap(object_path, u, v, time, P, I)",
            "contents": "uvunwrap(${1:object_path}, ${2:u}, ${3:v}, ${4:time}, ${5:P}, ${6:I})",
            "kind": "function",
            "details": "Computes the position and normal at given (u, v) coordinates, for use in a lens shader"
        },
        {
            "trigger": "uvunwrap(object_path, u, v, time, P, I, mikkelsenUtan, mikkelsenVtan)",
            "contents": "uvunwrap(${1:object_path}, ${2:u}, ${3:v}, ${4:time}, ${5:P}, ${6:I}, ${7:mikkelsenUtan}, ${8:mikkelsenVtan})",
            "kind": "function",
            "details": "Computes the position and normal at given (u, v) coordinates, for use in a lens shader"
        },
        {
            "trigger": "variance(variable, mean, sample_size)",
            "contents": "variance(${1:variable}, ${2:mean}, ${3:sample_size})",
            "kind": "function",
            "details": "Computes the mean value and variance for a value"
        },
        {
            "trigger": "velocityname()",
            "contents": "velocityname()",
            "kind": "function",
            "details": "Returns the default name of the velocity plane (as it appears in the compositor preferences)"
        },
        {
            "trigger": "vertex(geometry, attribute_name, linear_vertex_index)",
            "contents": "vertex(${1:geometry}, ${2:attribute_name}, ${3:linear_vertex_index})",
            "kind": "function",
            "details": "Reads a vertex attribute value from a geometry"
        },
        {
            "trigger": "vertex(geometry, attribute_name, prim_num, vertex_num)",
            "contents": "vertex(${1:geometry}, ${2:attribute_name}, ${3:prim_num}, ${4:vertex_num})",
            "kind": "function",
            "details": "Reads a vertex attribute value from a geometry"
        },
        {
            "trigger": "vertexattrib(geometry, attribute_name, linear_vertex_index, success)",
            "contents": "vertexattrib(${1:geometry}, ${2:attribute_name}, ${3:linear_vertex_index}, ${4:success})",
            "kind": "function",
            "details": "Reads a vertex attribute value from a geometry"
        },
        {
            "trigger": "vertexattribsize(geometry, attribute_name)",
            "contents": "vertexattribsize(${1:geometry}, ${2:attribute_name})",
            "kind": "function",
            "details": "Returns the size of a geometry vertex attribute"
        },
        {
            "trigger": "vertexattribtype(geometry, attribute_name)",
            "contents": "vertexattribtype(${1:geometry}, ${2:attribute_name})",
            "kind": "function",
            "details": "Returns the type of a geometry vertex attribute"
        },
        {
            "trigger": "vertexattribtypeinfo(geometry, attribute_name)",
            "contents": "vertexattribtypeinfo(${1:geometry}, ${2:attribute_name})",
            "kind": "function",
            "details": "Returns the type info of a geometry attribute"
        },
        {
            "trigger": "vertexcurveparam(geometry, linearindex)",
            "contents": "vertexcurveparam(${1:geometry}, ${2:linearindex})",
            "kind": "function",
            "details": "Returns the parametric coordinate of a vertex along the perimeter of its primitive"
        },
        {
            "trigger": "vertexhedge(geometry, vertex)",
            "contents": "vertexhedge(${1:geometry}, ${2:vertex})",
            "kind": "function",
            "details": "Returns the half-edge which has a vertex as source"
        },
        {
            "trigger": "vertexindex(geometry, primnum, vertex)",
            "contents": "vertexindex(${1:geometry}, ${2:primnum}, ${3:vertex})",
            "kind": "function",
            "details": "Converts a primitive/vertex pair into a linear vertex"
        },
        {
            "trigger": "vertexnext(geometry, linearvertex)",
            "contents": "vertexnext(${1:geometry}, ${2:linearvertex})",
            "kind": "function",
            "details": "Returns the linear vertex number of the next vertex sharing a point with a given vertex"
        },
        {
            "trigger": "vertexpoint(geometry, linearvertex)",
            "contents": "vertexpoint(${1:geometry}, ${2:linearvertex})",
            "kind": "function",
            "details": "Returns the point number of linear vertex in a geometry"
        },
        {
            "trigger": "vertexprev(geometry, linearvertex)",
            "contents": "vertexprev(${1:geometry}, ${2:linearvertex})",
            "kind": "function",
            "details": "Returns the linear vertex number of the previous vertex sharing a point with a given vertex"
        },
        {
            "trigger": "vertexprim(geometry, linearvertex)",
            "contents": "vertexprim(${1:geometry}, ${2:linearvertex})",
            "kind": "function",
            "details": "Returns the number of the primitive containing a given vertex"
        },
        {
            "trigger": "vertexprimindex(geometry, linearindex)",
            "contents": "vertexprimindex(${1:geometry}, ${2:linearindex})",
            "kind": "function",
            "details": "Converts a linear vertex index into a primitive vertex number"
        },
        {
            "trigger": "vnoise(position, jitter, seed, f1, f2, pos1, pos2)",
            "contents": "vnoise(${1:position}, ${2:jitter}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:pos1}, ${7:pos2})",
            "kind": "function",
            "details": "Generates Voronoi (cellular) noise"
        },
        {
            "trigger": "vnoise(position, jitter, seed, f1, f2, pos1, pos2, period)",
            "contents": "vnoise(${1:position}, ${2:jitter}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:pos1}, ${7:pos2}, ${8:period})",
            "kind": "function",
            "details": "Generates Voronoi (cellular) noise"
        },
        {
            "trigger": "vnoise(posx, posy, jittx, jitty, seed, f1, f2, pos1x, pos1y, pos2x, pos2y)",
            "contents": "vnoise(${1:posx}, ${2:posy}, ${3:jittx}, ${4:jitty}, ${5:seed}, ${6:f1}, ${7:f2}, ${8:pos1x}, ${9:pos1y}, ${10:pos2x}, ${11:pos2y})",
            "kind": "function",
            "details": "Generates Voronoi (cellular) noise"
        },
        {
            "trigger": "vnoise(posx, posy, jittx, jitty, seed, f1, f2, pos1x, pos1y, pos2x, pos2, periodx, periody)",
            "contents": "vnoise(${1:posx}, ${2:posy}, ${3:jittx}, ${4:jitty}, ${5:seed}, ${6:f1}, ${7:f2}, ${8:pos1x}, ${9:pos1y}, ${10:pos2x}, ${11:pos2}, ${12:periodx}, ${13:periody})",
            "kind": "function",
            "details": "Generates Voronoi (cellular) noise"
        },
        {
            "trigger": "vnoise(position, jitter, seed, f1, f2, pos1, pos2, periodx, periody, periodz)",
            "contents": "vnoise(${1:position}, ${2:jitter}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:pos1}, ${7:pos2}, ${8:periodx}, ${9:periody}, ${10:periodz})",
            "kind": "function",
            "details": "Generates Voronoi (cellular) noise"
        },
        {
            "trigger": "vnoise(position, jitter, seed, f1, f2, pos1, pos2, periodx, periody, periodz, periodw)",
            "contents": "vnoise(${1:position}, ${2:jitter}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:pos1}, ${7:pos2}, ${8:periodx}, ${9:periody}, ${10:periodz}, ${11:periodw})",
            "kind": "function",
            "details": "Generates Voronoi (cellular) noise"
        },
        {
            "trigger": "volume(pos, ...)",
            "contents": "volume(${1:pos}, ${2:...})",
            "kind": "function",
            "details": "Returns the volume of the microvoxel containing a variable such as P"
        },
        {
            "trigger": "volumecubicsample(geometry, primnum, pos)",
            "contents": "volumecubicsample(${1:geometry}, ${2:primnum}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumecubicsample(geometry, volumename, pos)",
            "contents": "volumecubicsample(${1:geometry}, ${2:volumename}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumecubicsample(geometry, primnum, pos, grad)",
            "contents": "volumecubicsample(${1:geometry}, ${2:primnum}, ${3:pos}, ${4:grad})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumecubicsample(geometry, volumename, pos, grad)",
            "contents": "volumecubicsample(${1:geometry}, ${2:volumename}, ${3:pos}, ${4:grad})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumecubicsample(geometry, primnum, pos, grad, hess)",
            "contents": "volumecubicsample(${1:geometry}, ${2:primnum}, ${3:pos}, ${4:grad}, ${5:hess})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumecubicsample(geometry, volumename, pos, grad, hess)",
            "contents": "volumecubicsample(${1:geometry}, ${2:volumename}, ${3:pos}, ${4:grad}, ${5:hess})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumecubicsamplev(geometry, primnum, pos)",
            "contents": "volumecubicsamplev(${1:geometry}, ${2:primnum}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumecubicsamplev(geometry, volumename, pos)",
            "contents": "volumecubicsamplev(${1:geometry}, ${2:volumename}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumecubicsamplev(geometry, primnum, pos, grad)",
            "contents": "volumecubicsamplev(${1:geometry}, ${2:primnum}, ${3:pos}, ${4:grad})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumecubicsamplev(geometry, volumename, pos, grad)",
            "contents": "volumecubicsamplev(${1:geometry}, ${2:volumename}, ${3:pos}, ${4:grad})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumecubicsamplev(geometry, primnum, pos, grad, hessX, hessY, hessZ)",
            "contents": "volumecubicsamplev(${1:geometry}, ${2:primnum}, ${3:pos}, ${4:grad}, ${5:hessX}, ${6:hessY}, ${7:hessZ})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumecubicsamplev(geometry, volumename, pos, grad, hessX, hessY, hessZ)",
            "contents": "volumecubicsamplev(${1:geometry}, ${2:volumename}, ${3:pos}, ${4:grad}, ${5:hessX}, ${6:hessY}, ${7:hessZ})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumegradient(geometry, primnum, pos)",
            "contents": "volumegradient(${1:geometry}, ${2:primnum}, ${3:pos})",
            "kind": "function",
            "details": "Calculates the volume primitive\u2019s gradient"
        },
        {
            "trigger": "volumegradient(geometry, volumename, pos)",
            "contents": "volumegradient(${1:geometry}, ${2:volumename}, ${3:pos})",
            "kind": "function",
            "details": "Calculates the volume primitive\u2019s gradient"
        },
        {
            "trigger": "volumeindex(geometry, primnum, voxel)",
            "contents": "volumeindex(${1:geometry}, ${2:primnum}, ${3:voxel})",
            "kind": "function",
            "details": "Gets the value of a specific voxel"
        },
        {
            "trigger": "volumeindex(geometry, volumename, voxel)",
            "contents": "volumeindex(${1:geometry}, ${2:volumename}, ${3:voxel})",
            "kind": "function",
            "details": "Gets the value of a specific voxel"
        },
        {
            "trigger": "volumeindexactive(geometry, primnum, voxel)",
            "contents": "volumeindexactive(${1:geometry}, ${2:primnum}, ${3:voxel})",
            "kind": "function",
            "details": "Gets the active setting of a specific voxel"
        },
        {
            "trigger": "volumeindexactive(geometry, volumename, voxel)",
            "contents": "volumeindexactive(${1:geometry}, ${2:volumename}, ${3:voxel})",
            "kind": "function",
            "details": "Gets the active setting of a specific voxel"
        },
        {
            "trigger": "volumeindexi(geometry, primnum, voxel)",
            "contents": "volumeindexi(${1:geometry}, ${2:primnum}, ${3:voxel})",
            "kind": "function",
            "details": "Gets the integer value of a specific voxel"
        },
        {
            "trigger": "volumeindexi(geometry, volumename, voxel)",
            "contents": "volumeindexi(${1:geometry}, ${2:volumename}, ${3:voxel})",
            "kind": "function",
            "details": "Gets the integer value of a specific voxel"
        },
        {
            "trigger": "volumeindexorigin(geometry, primnum)",
            "contents": "volumeindexorigin(${1:geometry}, ${2:primnum})",
            "kind": "function",
            "details": "Gets the index of the bottom left of a volume primitive"
        },
        {
            "trigger": "volumeindexorigin(geometry, volumename)",
            "contents": "volumeindexorigin(${1:geometry}, ${2:volumename})",
            "kind": "function",
            "details": "Gets the index of the bottom left of a volume primitive"
        },
        {
            "trigger": "volumeindexp(geometry, primnum, voxel)",
            "contents": "volumeindexp(${1:geometry}, ${2:primnum}, ${3:voxel})",
            "kind": "function",
            "details": "Gets the vector4 value of a specific voxel"
        },
        {
            "trigger": "volumeindexp(geometry, volumename, voxel)",
            "contents": "volumeindexp(${1:geometry}, ${2:volumename}, ${3:voxel})",
            "kind": "function",
            "details": "Gets the vector4 value of a specific voxel"
        },
        {
            "trigger": "volumeindextopos(geometry, primnum, voxel)",
            "contents": "volumeindextopos(${1:geometry}, ${2:primnum}, ${3:voxel})",
            "kind": "function",
            "details": "Converts a volume voxel index into a position"
        },
        {
            "trigger": "volumeindextopos(geometry, volumename, voxel)",
            "contents": "volumeindextopos(${1:geometry}, ${2:volumename}, ${3:voxel})",
            "kind": "function",
            "details": "Converts a volume voxel index into a position"
        },
        {
            "trigger": "volumeindexu(geometry, primnum, voxel)",
            "contents": "volumeindexu(${1:geometry}, ${2:primnum}, ${3:voxel})",
            "kind": "function",
            "details": "Gets the vector2 value of a specific voxel"
        },
        {
            "trigger": "volumeindexu(geometry, volumename, voxel)",
            "contents": "volumeindexu(${1:geometry}, ${2:volumename}, ${3:voxel})",
            "kind": "function",
            "details": "Gets the vector2 value of a specific voxel"
        },
        {
            "trigger": "volumeindexv(geometry, primnum, voxel)",
            "contents": "volumeindexv(${1:geometry}, ${2:primnum}, ${3:voxel})",
            "kind": "function",
            "details": "Gets the vector value of a specific voxel"
        },
        {
            "trigger": "volumeindexv(geometry, volumename, voxel)",
            "contents": "volumeindexv(${1:geometry}, ${2:volumename}, ${3:voxel})",
            "kind": "function",
            "details": "Gets the vector value of a specific voxel"
        },
        {
            "trigger": "volumepostoindex(geometry, primnum, position)",
            "contents": "volumepostoindex(${1:geometry}, ${2:primnum}, ${3:position})",
            "kind": "function",
            "details": "Converts a position into a volume voxel index"
        },
        {
            "trigger": "volumepostoindex(geometry, volumename, position)",
            "contents": "volumepostoindex(${1:geometry}, ${2:volumename}, ${3:position})",
            "kind": "function",
            "details": "Converts a position into a volume voxel index"
        },
        {
            "trigger": "volumeres(geometry, primnum)",
            "contents": "volumeres(${1:geometry}, ${2:primnum})",
            "kind": "function",
            "details": "Gets the resolution of a volume primitive"
        },
        {
            "trigger": "volumeres(geometry, volumename)",
            "contents": "volumeres(${1:geometry}, ${2:volumename})",
            "kind": "function",
            "details": "Gets the resolution of a volume primitive"
        },
        {
            "trigger": "volumesample(geometry, primnum, pos)",
            "contents": "volumesample(${1:geometry}, ${2:primnum}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s float value"
        },
        {
            "trigger": "volumesample(geometry, volumename, pos)",
            "contents": "volumesample(${1:geometry}, ${2:volumename}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s float value"
        },
        {
            "trigger": "volumesamplei(geometry, primnum, pos)",
            "contents": "volumesamplei(${1:geometry}, ${2:primnum}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s integer value"
        },
        {
            "trigger": "volumesamplei(geometry, volumename, pos)",
            "contents": "volumesamplei(${1:geometry}, ${2:volumename}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s integer value"
        },
        {
            "trigger": "volumesamplep(geometry, primnum, pos)",
            "contents": "volumesamplep(${1:geometry}, ${2:primnum}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s vector4 value"
        },
        {
            "trigger": "volumesamplep(geometry, volumename, pos)",
            "contents": "volumesamplep(${1:geometry}, ${2:volumename}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s vector4 value"
        },
        {
            "trigger": "volumesampleu(geometry, primnum, pos)",
            "contents": "volumesampleu(${1:geometry}, ${2:primnum}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s vector2 value"
        },
        {
            "trigger": "volumesampleu(geometry, volumename, pos)",
            "contents": "volumesampleu(${1:geometry}, ${2:volumename}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s vector2 value"
        },
        {
            "trigger": "volumesamplev(geometry, primnum, pos)",
            "contents": "volumesamplev(${1:geometry}, ${2:primnum}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s vector value"
        },
        {
            "trigger": "volumesamplev(geometry, volumename, pos)",
            "contents": "volumesamplev(${1:geometry}, ${2:volumename}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s vector value"
        },
        {
            "trigger": "volumesmoothsample(geometry, primnum, pos)",
            "contents": "volumesmoothsample(${1:geometry}, ${2:primnum}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumesmoothsample(geometry, volumename, pos)",
            "contents": "volumesmoothsample(${1:geometry}, ${2:volumename}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumesmoothsample(geometry, primnum, pos, grad)",
            "contents": "volumesmoothsample(${1:geometry}, ${2:primnum}, ${3:pos}, ${4:grad})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumesmoothsample(geometry, volumename, pos, grad)",
            "contents": "volumesmoothsample(${1:geometry}, ${2:volumename}, ${3:pos}, ${4:grad})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumesmoothsample(geometry, primnum, pos, grad, hess)",
            "contents": "volumesmoothsample(${1:geometry}, ${2:primnum}, ${3:pos}, ${4:grad}, ${5:hess})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumesmoothsample(geometry, volumename, pos, grad, hess)",
            "contents": "volumesmoothsample(${1:geometry}, ${2:volumename}, ${3:pos}, ${4:grad}, ${5:hess})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumesmoothsamplev(geometry, primnum, pos)",
            "contents": "volumesmoothsamplev(${1:geometry}, ${2:primnum}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumesmoothsamplev(geometry, volumename, pos)",
            "contents": "volumesmoothsamplev(${1:geometry}, ${2:volumename}, ${3:pos})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumesmoothsamplev(geometry, primnum, pos, grad)",
            "contents": "volumesmoothsamplev(${1:geometry}, ${2:primnum}, ${3:pos}, ${4:grad})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumesmoothsamplev(geometry, volumename, pos, grad)",
            "contents": "volumesmoothsamplev(${1:geometry}, ${2:volumename}, ${3:pos}, ${4:grad})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumesmoothsamplev(geometry, primnum, pos, grad, hessX, hessY, hessZ)",
            "contents": "volumesmoothsamplev(${1:geometry}, ${2:primnum}, ${3:pos}, ${4:grad}, ${5:hessX}, ${6:hessY}, ${7:hessZ})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumesmoothsamplev(geometry, volumename, pos, grad, hessX, hessY, hessZ)",
            "contents": "volumesmoothsamplev(${1:geometry}, ${2:volumename}, ${3:pos}, ${4:grad}, ${5:hessX}, ${6:hessY}, ${7:hessZ})",
            "kind": "function",
            "details": "Samples the volume primitive\u2019s value"
        },
        {
            "trigger": "volumetypeid(geometry, primnum)",
            "contents": "volumetypeid(${1:geometry}, ${2:primnum})",
            "kind": "function",
            "details": "Gets the typeid of the data of a volume or VDB primitive"
        },
        {
            "trigger": "volumetypeid(geometry, volumename)",
            "contents": "volumetypeid(${1:geometry}, ${2:volumename})",
            "kind": "function",
            "details": "Gets the typeid of the data of a volume or VDB primitive"
        },
        {
            "trigger": "volumevoxeldiameter(geometry, primnum)",
            "contents": "volumevoxeldiameter(${1:geometry}, ${2:primnum})",
            "kind": "function",
            "details": "Computes the approximate diameter of a voxel"
        },
        {
            "trigger": "volumevoxeldiameter(geometry, primname)",
            "contents": "volumevoxeldiameter(${1:geometry}, ${2:primname})",
            "kind": "function",
            "details": "Computes the approximate diameter of a voxel"
        },
        {
            "trigger": "vtransform(v, transform)",
            "contents": "vtransform(${1:v}, ${2:transform})",
            "kind": "function",
            "details": "Transforms a directional vector"
        },
        {
            "trigger": "vtransform(tospace, v)",
            "contents": "vtransform(${1:tospace}, ${2:v})",
            "kind": "function",
            "details": "Transforms a directional vector"
        },
        {
            "trigger": "vtransform(fromspace, tospace, v)",
            "contents": "vtransform(${1:fromspace}, ${2:tospace}, ${3:v})",
            "kind": "function",
            "details": "Transforms a directional vector"
        },
        {
            "trigger": "warning(format, ...)",
            "contents": "warning(${1:format}, ${2:...})",
            "kind": "function",
            "details": "Reports a custom runtime VEX warning"
        },
        {
            "trigger": "weightarrayblend(names, weights, newname, blend)",
            "contents": "weightarrayblend(${1:names}, ${2:weights}, ${3:newname}, ${4:blend})",
            "kind": "function",
            "details": "Blends an existing name/weight array pair with another array or named item"
        },
        {
            "trigger": "weightarrayblend(names, weights, newnames, newweights, blend)",
            "contents": "weightarrayblend(${1:names}, ${2:weights}, ${3:newnames}, ${4:newweights}, ${5:blend})",
            "kind": "function",
            "details": "Blends an existing name/weight array pair with another array or named item"
        },
        {
            "trigger": "weightarrayfromname(names, weights, name)",
            "contents": "weightarrayfromname(${1:names}, ${2:weights}, ${3:name})",
            "kind": "function",
            "details": "Initializes an index array and weight array pair with a single named entry"
        },
        {
            "trigger": "weightarraynormalize(weights)",
            "contents": "weightarraynormalize(${1:weights})",
            "kind": "function",
            "details": "Normalizes an array of floats so it sums to 1.0"
        },
        {
            "trigger": "weightarraythreshold(names, weights, threshold)",
            "contents": "weightarraythreshold(${1:names}, ${2:weights}, ${3:threshold})",
            "kind": "function",
            "details": "Discards any weights below a threshold from an name/weight array pair"
        },
        {
            "trigger": "windingnumber(geometry, origin)",
            "contents": "windingnumber(${1:geometry}, ${2:origin})",
            "kind": "function",
            "details": "Computes the winding number of a mesh around a point. Winding number indicates how many times a geometry wraps around a point. Useful for inside/outside test, the winding number is equal to one inside of the mesh and zero outside"
        },
        {
            "trigger": "windingnumber(geometry, origin, accuracy)",
            "contents": "windingnumber(${1:geometry}, ${2:origin}, ${3:accuracy})",
            "kind": "function",
            "details": "Computes the winding number of a mesh around a point. Winding number indicates how many times a geometry wraps around a point. Useful for inside/outside test, the winding number is equal to one inside of the mesh and zero outside"
        },
        {
            "trigger": "windingnumber(geometry, primgroup, origin)",
            "contents": "windingnumber(${1:geometry}, ${2:primgroup}, ${3:origin})",
            "kind": "function",
            "details": "Computes the winding number of a mesh around a point. Winding number indicates how many times a geometry wraps around a point. Useful for inside/outside test, the winding number is equal to one inside of the mesh and zero outside"
        },
        {
            "trigger": "windingnumber(geometry, primgroup, origin, accuracy)",
            "contents": "windingnumber(${1:geometry}, ${2:primgroup}, ${3:origin}, ${4:accuracy})",
            "kind": "function",
            "details": "Computes the winding number of a mesh around a point. Winding number indicates how many times a geometry wraps around a point. Useful for inside/outside test, the winding number is equal to one inside of the mesh and zero outside"
        },
        {
            "trigger": "windingnumber2d(geometry, origin)",
            "contents": "windingnumber2d(${1:geometry}, ${2:origin})",
            "kind": "function",
            "details": "Computes the winding number of a curve in XY plane around a point. Winding number indicates how many times a curve wraps around a point. Useful for inside/outside test, the winding number is equal to one inside of the curve and zero outside"
        },
        {
            "trigger": "windingnumber2d(geometry, origin, accuracy)",
            "contents": "windingnumber2d(${1:geometry}, ${2:origin}, ${3:accuracy})",
            "kind": "function",
            "details": "Computes the winding number of a curve in XY plane around a point. Winding number indicates how many times a curve wraps around a point. Useful for inside/outside test, the winding number is equal to one inside of the curve and zero outside"
        },
        {
            "trigger": "windingnumber2d(geometry, primgroup, origin)",
            "contents": "windingnumber2d(${1:geometry}, ${2:primgroup}, ${3:origin})",
            "kind": "function",
            "details": "Computes the winding number of a curve in XY plane around a point. Winding number indicates how many times a curve wraps around a point. Useful for inside/outside test, the winding number is equal to one inside of the curve and zero outside"
        },
        {
            "trigger": "windingnumber2d(geometry, primgroup, origin, accuracy)",
            "contents": "windingnumber2d(${1:geometry}, ${2:primgroup}, ${3:origin}, ${4:accuracy})",
            "kind": "function",
            "details": "Computes the winding number of a curve in XY plane around a point. Winding number indicates how many times a curve wraps around a point. Useful for inside/outside test, the winding number is equal to one inside of the curve and zero outside"
        },
        {
            "trigger": "wireblinn(tangent, exponent, ...)",
            "contents": "wireblinn(${1:tangent}, ${2:exponent}, ${3:...})",
            "kind": "function"
        },
        {
            "trigger": "wirediffuse(tangent, ...)",
            "contents": "wirediffuse(${1:tangent}, ${2:...})",
            "kind": "function"
        },
        {
            "trigger": "wnoise(position, seed, f1, f2)",
            "contents": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise"
        },
        {
            "trigger": "wnoise(position, seed, f1, f2, f3, f4)",
            "contents": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise"
        },
        {
            "trigger": "wnoise(position, seed, f1, f2, peiod)",
            "contents": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:peiod})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise"
        },
        {
            "trigger": "wnoise(position, seed, f1, f2, f4, f4, period)",
            "contents": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f4}, ${6:f4}, ${7:period})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise"
        },
        {
            "trigger": "wnoise(posx, posy, seed, f1, f2)",
            "contents": "wnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise"
        },
        {
            "trigger": "wnoise(posx, posy, seed, f1, f2, f3, f4)",
            "contents": "wnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:f3}, ${7:f4})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise"
        },
        {
            "trigger": "wnoise(posx, posy, seed, f1, f2, periodx, periody)",
            "contents": "wnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:periodx}, ${7:periody})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise"
        },
        {
            "trigger": "wnoise(posx, posy, seed, f1, f2, f3, f4, periodx, periody)",
            "contents": "wnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:f3}, ${7:f4}, ${8:periodx}, ${9:periody})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise"
        },
        {
            "trigger": "wnoise(position, seed, f1, f2, periodx, periody)",
            "contents": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise"
        },
        {
            "trigger": "wnoise(position, seed, f1, f2, f3, f4, periodx, periody)",
            "contents": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise"
        },
        {
            "trigger": "wnoise(position, seed, f1, f2, periodx, periody, periodx)",
            "contents": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody}, ${7:periodx})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise"
        },
        {
            "trigger": "wnoise(position, seed, f1, f2, f3, f4, periodx, periody, periodz)",
            "contents": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody}, ${9:periodz})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise"
        },
        {
            "trigger": "wnoise(position, seed, f1, f2, periodx, periody, periodz, periodw)",
            "contents": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody}, ${7:periodz}, ${8:periodw})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise"
        },
        {
            "trigger": "wnoise(position, seed, f1, f2, f3, f4, periodx, periody, periodz, periodw)",
            "contents": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody}, ${9:periodz}, ${10:periodw})",
            "kind": "function",
            "details": "Generates Worley (cellular) noise"
        },
        {
            "trigger": "wo_nspace(v)",
            "contents": "wo_nspace(${1:v})",
            "kind": "function",
            "details": "Transforms a normal vector from World to Object space"
        },
        {
            "trigger": "wo_space()",
            "contents": "wo_space()",
            "kind": "function",
            "details": "Transforms a position value from World to Object space"
        },
        {
            "trigger": "wo_space(pos)",
            "contents": "wo_space(${1:pos})",
            "kind": "function",
            "details": "Transforms a position value from World to Object space"
        },
        {
            "trigger": "wo_vspace(v)",
            "contents": "wo_vspace(${1:v})",
            "kind": "function",
            "details": "Transforms a direction vector from World to Object space"
        },
        {
            "trigger": "writepixel(channel, ndc_x, ndc_y, clr)",
            "contents": "writepixel(${1:channel}, ${2:ndc_x}, ${3:ndc_y}, ${4:clr})",
            "kind": "function",
            "details": "Writes color information to a pixel in the output image"
        },
        {
            "trigger": "wt_nspace(v)",
            "contents": "wt_nspace(${1:v})",
            "kind": "function",
            "details": "Transforms a normal vector from World to Texture space"
        },
        {
            "trigger": "wt_space()",
            "contents": "wt_space()",
            "kind": "function",
            "details": "Transforms a position value from World to Texture space"
        },
        {
            "trigger": "wt_space(v)",
            "contents": "wt_space(${1:v})",
            "kind": "function",
            "details": "Transforms a position value from World to Texture space"
        },
        {
            "trigger": "wt_vspace(v)",
            "contents": "wt_vspace(${1:v})",
            "kind": "function",
            "details": "Transforms a direction vector from World to Texture space"
        },
        {
            "trigger": "xnoise(x)",
            "contents": "xnoise(${1:x})",
            "kind": "function",
            "details": "Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid. This results in less grid artifacts. It also uses a higher order bspline to provide better derivatives"
        },
        {
            "trigger": "xnoise(x, y)",
            "contents": "xnoise(${1:x}, ${2:y})",
            "kind": "function",
            "details": "Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid. This results in less grid artifacts. It also uses a higher order bspline to provide better derivatives"
        },
        {
            "trigger": "xnoise(xyz)",
            "contents": "xnoise(${1:xyz})",
            "kind": "function",
            "details": "Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid. This results in less grid artifacts. It also uses a higher order bspline to provide better derivatives"
        },
        {
            "trigger": "xnoise(xyzt)",
            "contents": "xnoise(${1:xyzt})",
            "kind": "function",
            "details": "Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid. This results in less grid artifacts. It also uses a higher order bspline to provide better derivatives"
        },
        {
            "trigger": "xnoised(x, v, dvdx)",
            "contents": "xnoised(${1:x}, ${2:v}, ${3:dvdx})",
            "kind": "function",
            "details": "Derivatives of Simplex Noise"
        },
        {
            "trigger": "xnoised(x, y, v, dvdx, dvdy)",
            "contents": "xnoised(${1:x}, ${2:y}, ${3:v}, ${4:dvdx}, ${5:dvdy})",
            "kind": "function",
            "details": "Derivatives of Simplex Noise"
        },
        {
            "trigger": "xnoised(xyz, v, dvdx, dvdy, dvdz)",
            "contents": "xnoised(${1:xyz}, ${2:v}, ${3:dvdx}, ${4:dvdy}, ${5:dvdz})",
            "kind": "function",
            "details": "Derivatives of Simplex Noise"
        },
        {
            "trigger": "xnoised(xyzw, v, dvdx, dvdy, dvdz, dvdw)",
            "contents": "xnoised(${1:xyzw}, ${2:v}, ${3:dvdx}, ${4:dvdy}, ${5:dvdz}, ${6:dvdw})",
            "kind": "function",
            "details": "Derivatives of Simplex Noise"
        },
        {
            "trigger": "xyzdist(geometry, origin)",
            "contents": "xyzdist(${1:geometry}, ${2:origin})",
            "kind": "function",
            "details": "Finds the distance from a point to the closest location on surface geometry"
        },
        {
            "trigger": "xyzdist(geometry, origin, prim, uv)",
            "contents": "xyzdist(${1:geometry}, ${2:origin}, ${3:prim}, ${4:uv})",
            "kind": "function",
            "details": "Finds the distance from a point to the closest location on surface geometry"
        },
        {
            "trigger": "xyzdist(geometry, origin, prim, uv, maxdist)",
            "contents": "xyzdist(${1:geometry}, ${2:origin}, ${3:prim}, ${4:uv}, ${5:maxdist})",
            "kind": "function",
            "details": "Finds the distance from a point to the closest location on surface geometry"
        },
        {
            "trigger": "xyzdist(geometry, primgroup, origin)",
            "contents": "xyzdist(${1:geometry}, ${2:primgroup}, ${3:origin})",
            "kind": "function",
            "details": "Finds the distance from a point to the closest location on surface geometry"
        },
        {
            "trigger": "xyzdist(geometry, primgroup, origin, prim, uv)",
            "contents": "xyzdist(${1:geometry}, ${2:primgroup}, ${3:origin}, ${4:prim}, ${5:uv})",
            "kind": "function",
            "details": "Finds the distance from a point to the closest location on surface geometry"
        },
        {
            "trigger": "xyzdist(geometry, primgroup, origin, prim, uv, maxdist)",
            "contents": "xyzdist(${1:geometry}, ${2:primgroup}, ${3:origin}, ${4:prim}, ${5:uv}, ${6:maxdist})",
            "kind": "function",
            "details": "Finds the distance from a point to the closest location on surface geometry"
        },
        {
            "trigger": "xyztorgb(xyz)",
            "contents": "xyztorgb(${1:xyz})",
            "kind": "function",
            "details": "Convert CIE XYZ tristimulus values to a linear sRGB triplet"
        },
        {
            "trigger": "__uniform_mul(a, b)",
            "contents": "__uniform_mul(${1:a}, ${2:b})",
            "kind": "function",
            "details": "Multiply matrices"
        },
        {
            "trigger": "__uniform_mul(m, a, b)",
            "contents": "__uniform_mul(${1:m}, ${2:a}, ${3:b})",
            "kind": "function",
            "details": "Multiply matrices"
        },
        {
            "trigger": "__uniform_premul(a, b)",
            "contents": "__uniform_premul(${1:a}, ${2:b})",
            "kind": "function",
            "details": "Pre multiply matrices"
        },
        {
            "trigger": "__uniform_premul(m, a, b)",
            "contents": "__uniform_premul(${1:m}, ${2:a}, ${3:b})",
            "kind": "function",
            "details": "Pre multiply matrices"
        }
    ]
}